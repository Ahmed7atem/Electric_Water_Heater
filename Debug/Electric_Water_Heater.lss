
Electric_Water_Heater.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00006e6e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000015c  00800060  00006e6e  00006f02  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000578  008001bc  008001bc  0000705e  2**0
                  ALLOC
  3 .stab         000090b4  00000000  00000000  00007060  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00005056  00000000  00000000  00010114  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001a0  00000000  00000000  0001516a  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000001f2  00000000  00000000  0001530a  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000240b  00000000  00000000  000154fc  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001386  00000000  00000000  00017907  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000011d6  00000000  00000000  00018c8d  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000001c0  00000000  00000000  00019e64  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002f6  00000000  00000000  0001a024  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000096e  00000000  00000000  0001a31a  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  0001ac88  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 65 0e 	jmp	0x1cca	; 0x1cca <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	ee e6       	ldi	r30, 0x6E	; 110
      68:	fe e6       	ldi	r31, 0x6E	; 110
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	ac 3b       	cpi	r26, 0xBC	; 188
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	ac eb       	ldi	r26, 0xBC	; 188
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a4 33       	cpi	r26, 0x34	; 52
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 b8 21 	call	0x4370	; 0x4370 <main>
      8a:	0c 94 35 37 	jmp	0x6e6a	; 0x6e6a <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 3e 34 	jmp	0x687c	; 0x687c <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a7 e9       	ldi	r26, 0x97	; 151
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 5a 34 	jmp	0x68b4	; 0x68b4 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 4a 34 	jmp	0x6894	; 0x6894 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 66 34 	jmp	0x68cc	; 0x68cc <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 4a 34 	jmp	0x6894	; 0x6894 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 66 34 	jmp	0x68cc	; 0x68cc <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 3e 34 	jmp	0x687c	; 0x687c <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	87 e9       	ldi	r24, 0x97	; 151
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 5a 34 	jmp	0x68b4	; 0x68b4 <__epilogue_restores__>

00000632 <__divsf3>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 46 34 	jmp	0x688c	; 0x688c <__prologue_saves__+0x10>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	b9 e0       	ldi	r27, 0x09	; 9
     650:	eb 2e       	mov	r14, r27
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     672:	29 85       	ldd	r18, Y+9	; 0x09
     674:	22 30       	cpi	r18, 0x02	; 2
     676:	08 f4       	brcc	.+2      	; 0x67a <__divsf3+0x48>
     678:	7e c0       	rjmp	.+252    	; 0x776 <__divsf3+0x144>
     67a:	39 89       	ldd	r19, Y+17	; 0x11
     67c:	32 30       	cpi	r19, 0x02	; 2
     67e:	10 f4       	brcc	.+4      	; 0x684 <__divsf3+0x52>
     680:	b8 01       	movw	r22, r16
     682:	7c c0       	rjmp	.+248    	; 0x77c <__divsf3+0x14a>
     684:	8a 85       	ldd	r24, Y+10	; 0x0a
     686:	9a 89       	ldd	r25, Y+18	; 0x12
     688:	89 27       	eor	r24, r25
     68a:	8a 87       	std	Y+10, r24	; 0x0a
     68c:	24 30       	cpi	r18, 0x04	; 4
     68e:	11 f0       	breq	.+4      	; 0x694 <__divsf3+0x62>
     690:	22 30       	cpi	r18, 0x02	; 2
     692:	31 f4       	brne	.+12     	; 0x6a0 <__divsf3+0x6e>
     694:	23 17       	cp	r18, r19
     696:	09 f0       	breq	.+2      	; 0x69a <__divsf3+0x68>
     698:	6e c0       	rjmp	.+220    	; 0x776 <__divsf3+0x144>
     69a:	67 e9       	ldi	r22, 0x97	; 151
     69c:	70 e0       	ldi	r23, 0x00	; 0
     69e:	6e c0       	rjmp	.+220    	; 0x77c <__divsf3+0x14a>
     6a0:	34 30       	cpi	r19, 0x04	; 4
     6a2:	39 f4       	brne	.+14     	; 0x6b2 <__divsf3+0x80>
     6a4:	1d 86       	std	Y+13, r1	; 0x0d
     6a6:	1e 86       	std	Y+14, r1	; 0x0e
     6a8:	1f 86       	std	Y+15, r1	; 0x0f
     6aa:	18 8a       	std	Y+16, r1	; 0x10
     6ac:	1c 86       	std	Y+12, r1	; 0x0c
     6ae:	1b 86       	std	Y+11, r1	; 0x0b
     6b0:	04 c0       	rjmp	.+8      	; 0x6ba <__divsf3+0x88>
     6b2:	32 30       	cpi	r19, 0x02	; 2
     6b4:	21 f4       	brne	.+8      	; 0x6be <__divsf3+0x8c>
     6b6:	84 e0       	ldi	r24, 0x04	; 4
     6b8:	89 87       	std	Y+9, r24	; 0x09
     6ba:	b7 01       	movw	r22, r14
     6bc:	5f c0       	rjmp	.+190    	; 0x77c <__divsf3+0x14a>
     6be:	2b 85       	ldd	r18, Y+11	; 0x0b
     6c0:	3c 85       	ldd	r19, Y+12	; 0x0c
     6c2:	8b 89       	ldd	r24, Y+19	; 0x13
     6c4:	9c 89       	ldd	r25, Y+20	; 0x14
     6c6:	28 1b       	sub	r18, r24
     6c8:	39 0b       	sbc	r19, r25
     6ca:	3c 87       	std	Y+12, r19	; 0x0c
     6cc:	2b 87       	std	Y+11, r18	; 0x0b
     6ce:	ed 84       	ldd	r14, Y+13	; 0x0d
     6d0:	fe 84       	ldd	r15, Y+14	; 0x0e
     6d2:	0f 85       	ldd	r16, Y+15	; 0x0f
     6d4:	18 89       	ldd	r17, Y+16	; 0x10
     6d6:	ad 88       	ldd	r10, Y+21	; 0x15
     6d8:	be 88       	ldd	r11, Y+22	; 0x16
     6da:	cf 88       	ldd	r12, Y+23	; 0x17
     6dc:	d8 8c       	ldd	r13, Y+24	; 0x18
     6de:	ea 14       	cp	r14, r10
     6e0:	fb 04       	cpc	r15, r11
     6e2:	0c 05       	cpc	r16, r12
     6e4:	1d 05       	cpc	r17, r13
     6e6:	40 f4       	brcc	.+16     	; 0x6f8 <__divsf3+0xc6>
     6e8:	ee 0c       	add	r14, r14
     6ea:	ff 1c       	adc	r15, r15
     6ec:	00 1f       	adc	r16, r16
     6ee:	11 1f       	adc	r17, r17
     6f0:	21 50       	subi	r18, 0x01	; 1
     6f2:	30 40       	sbci	r19, 0x00	; 0
     6f4:	3c 87       	std	Y+12, r19	; 0x0c
     6f6:	2b 87       	std	Y+11, r18	; 0x0b
     6f8:	20 e0       	ldi	r18, 0x00	; 0
     6fa:	30 e0       	ldi	r19, 0x00	; 0
     6fc:	40 e0       	ldi	r20, 0x00	; 0
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	a0 e0       	ldi	r26, 0x00	; 0
     706:	b0 e4       	ldi	r27, 0x40	; 64
     708:	60 e0       	ldi	r22, 0x00	; 0
     70a:	70 e0       	ldi	r23, 0x00	; 0
     70c:	ea 14       	cp	r14, r10
     70e:	fb 04       	cpc	r15, r11
     710:	0c 05       	cpc	r16, r12
     712:	1d 05       	cpc	r17, r13
     714:	40 f0       	brcs	.+16     	; 0x726 <__divsf3+0xf4>
     716:	28 2b       	or	r18, r24
     718:	39 2b       	or	r19, r25
     71a:	4a 2b       	or	r20, r26
     71c:	5b 2b       	or	r21, r27
     71e:	ea 18       	sub	r14, r10
     720:	fb 08       	sbc	r15, r11
     722:	0c 09       	sbc	r16, r12
     724:	1d 09       	sbc	r17, r13
     726:	b6 95       	lsr	r27
     728:	a7 95       	ror	r26
     72a:	97 95       	ror	r25
     72c:	87 95       	ror	r24
     72e:	ee 0c       	add	r14, r14
     730:	ff 1c       	adc	r15, r15
     732:	00 1f       	adc	r16, r16
     734:	11 1f       	adc	r17, r17
     736:	6f 5f       	subi	r22, 0xFF	; 255
     738:	7f 4f       	sbci	r23, 0xFF	; 255
     73a:	6f 31       	cpi	r22, 0x1F	; 31
     73c:	71 05       	cpc	r23, r1
     73e:	31 f7       	brne	.-52     	; 0x70c <__divsf3+0xda>
     740:	da 01       	movw	r26, r20
     742:	c9 01       	movw	r24, r18
     744:	8f 77       	andi	r24, 0x7F	; 127
     746:	90 70       	andi	r25, 0x00	; 0
     748:	a0 70       	andi	r26, 0x00	; 0
     74a:	b0 70       	andi	r27, 0x00	; 0
     74c:	80 34       	cpi	r24, 0x40	; 64
     74e:	91 05       	cpc	r25, r1
     750:	a1 05       	cpc	r26, r1
     752:	b1 05       	cpc	r27, r1
     754:	61 f4       	brne	.+24     	; 0x76e <__divsf3+0x13c>
     756:	27 fd       	sbrc	r18, 7
     758:	0a c0       	rjmp	.+20     	; 0x76e <__divsf3+0x13c>
     75a:	e1 14       	cp	r14, r1
     75c:	f1 04       	cpc	r15, r1
     75e:	01 05       	cpc	r16, r1
     760:	11 05       	cpc	r17, r1
     762:	29 f0       	breq	.+10     	; 0x76e <__divsf3+0x13c>
     764:	20 5c       	subi	r18, 0xC0	; 192
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	4f 4f       	sbci	r20, 0xFF	; 255
     76a:	5f 4f       	sbci	r21, 0xFF	; 255
     76c:	20 78       	andi	r18, 0x80	; 128
     76e:	2d 87       	std	Y+13, r18	; 0x0d
     770:	3e 87       	std	Y+14, r19	; 0x0e
     772:	4f 87       	std	Y+15, r20	; 0x0f
     774:	58 8b       	std	Y+16, r21	; 0x10
     776:	be 01       	movw	r22, r28
     778:	67 5f       	subi	r22, 0xF7	; 247
     77a:	7f 4f       	sbci	r23, 0xFF	; 255
     77c:	cb 01       	movw	r24, r22
     77e:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     782:	68 96       	adiw	r28, 0x18	; 24
     784:	ea e0       	ldi	r30, 0x0A	; 10
     786:	0c 94 62 34 	jmp	0x68c4	; 0x68c4 <__epilogue_restores__+0x10>

0000078a <__gtsf2>:
     78a:	a8 e1       	ldi	r26, 0x18	; 24
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	eb ec       	ldi	r30, 0xCB	; 203
     790:	f3 e0       	ldi	r31, 0x03	; 3
     792:	0c 94 4a 34 	jmp	0x6894	; 0x6894 <__prologue_saves__+0x18>
     796:	69 83       	std	Y+1, r22	; 0x01
     798:	7a 83       	std	Y+2, r23	; 0x02
     79a:	8b 83       	std	Y+3, r24	; 0x03
     79c:	9c 83       	std	Y+4, r25	; 0x04
     79e:	2d 83       	std	Y+5, r18	; 0x05
     7a0:	3e 83       	std	Y+6, r19	; 0x06
     7a2:	4f 83       	std	Y+7, r20	; 0x07
     7a4:	58 87       	std	Y+8, r21	; 0x08
     7a6:	89 e0       	ldi	r24, 0x09	; 9
     7a8:	e8 2e       	mov	r14, r24
     7aa:	f1 2c       	mov	r15, r1
     7ac:	ec 0e       	add	r14, r28
     7ae:	fd 1e       	adc	r15, r29
     7b0:	ce 01       	movw	r24, r28
     7b2:	01 96       	adiw	r24, 0x01	; 1
     7b4:	b7 01       	movw	r22, r14
     7b6:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     7ba:	8e 01       	movw	r16, r28
     7bc:	0f 5e       	subi	r16, 0xEF	; 239
     7be:	1f 4f       	sbci	r17, 0xFF	; 255
     7c0:	ce 01       	movw	r24, r28
     7c2:	05 96       	adiw	r24, 0x05	; 5
     7c4:	b8 01       	movw	r22, r16
     7c6:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     7ca:	89 85       	ldd	r24, Y+9	; 0x09
     7cc:	82 30       	cpi	r24, 0x02	; 2
     7ce:	40 f0       	brcs	.+16     	; 0x7e0 <__gtsf2+0x56>
     7d0:	89 89       	ldd	r24, Y+17	; 0x11
     7d2:	82 30       	cpi	r24, 0x02	; 2
     7d4:	28 f0       	brcs	.+10     	; 0x7e0 <__gtsf2+0x56>
     7d6:	c7 01       	movw	r24, r14
     7d8:	b8 01       	movw	r22, r16
     7da:	0e 94 be 06 	call	0xd7c	; 0xd7c <__fpcmp_parts_f>
     7de:	01 c0       	rjmp	.+2      	; 0x7e2 <__gtsf2+0x58>
     7e0:	8f ef       	ldi	r24, 0xFF	; 255
     7e2:	68 96       	adiw	r28, 0x18	; 24
     7e4:	e6 e0       	ldi	r30, 0x06	; 6
     7e6:	0c 94 66 34 	jmp	0x68cc	; 0x68cc <__epilogue_restores__+0x18>

000007ea <__gesf2>:
     7ea:	a8 e1       	ldi	r26, 0x18	; 24
     7ec:	b0 e0       	ldi	r27, 0x00	; 0
     7ee:	eb ef       	ldi	r30, 0xFB	; 251
     7f0:	f3 e0       	ldi	r31, 0x03	; 3
     7f2:	0c 94 4a 34 	jmp	0x6894	; 0x6894 <__prologue_saves__+0x18>
     7f6:	69 83       	std	Y+1, r22	; 0x01
     7f8:	7a 83       	std	Y+2, r23	; 0x02
     7fa:	8b 83       	std	Y+3, r24	; 0x03
     7fc:	9c 83       	std	Y+4, r25	; 0x04
     7fe:	2d 83       	std	Y+5, r18	; 0x05
     800:	3e 83       	std	Y+6, r19	; 0x06
     802:	4f 83       	std	Y+7, r20	; 0x07
     804:	58 87       	std	Y+8, r21	; 0x08
     806:	89 e0       	ldi	r24, 0x09	; 9
     808:	e8 2e       	mov	r14, r24
     80a:	f1 2c       	mov	r15, r1
     80c:	ec 0e       	add	r14, r28
     80e:	fd 1e       	adc	r15, r29
     810:	ce 01       	movw	r24, r28
     812:	01 96       	adiw	r24, 0x01	; 1
     814:	b7 01       	movw	r22, r14
     816:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     81a:	8e 01       	movw	r16, r28
     81c:	0f 5e       	subi	r16, 0xEF	; 239
     81e:	1f 4f       	sbci	r17, 0xFF	; 255
     820:	ce 01       	movw	r24, r28
     822:	05 96       	adiw	r24, 0x05	; 5
     824:	b8 01       	movw	r22, r16
     826:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     82a:	89 85       	ldd	r24, Y+9	; 0x09
     82c:	82 30       	cpi	r24, 0x02	; 2
     82e:	40 f0       	brcs	.+16     	; 0x840 <__gesf2+0x56>
     830:	89 89       	ldd	r24, Y+17	; 0x11
     832:	82 30       	cpi	r24, 0x02	; 2
     834:	28 f0       	brcs	.+10     	; 0x840 <__gesf2+0x56>
     836:	c7 01       	movw	r24, r14
     838:	b8 01       	movw	r22, r16
     83a:	0e 94 be 06 	call	0xd7c	; 0xd7c <__fpcmp_parts_f>
     83e:	01 c0       	rjmp	.+2      	; 0x842 <__gesf2+0x58>
     840:	8f ef       	ldi	r24, 0xFF	; 255
     842:	68 96       	adiw	r28, 0x18	; 24
     844:	e6 e0       	ldi	r30, 0x06	; 6
     846:	0c 94 66 34 	jmp	0x68cc	; 0x68cc <__epilogue_restores__+0x18>

0000084a <__ltsf2>:
     84a:	a8 e1       	ldi	r26, 0x18	; 24
     84c:	b0 e0       	ldi	r27, 0x00	; 0
     84e:	eb e2       	ldi	r30, 0x2B	; 43
     850:	f4 e0       	ldi	r31, 0x04	; 4
     852:	0c 94 4a 34 	jmp	0x6894	; 0x6894 <__prologue_saves__+0x18>
     856:	69 83       	std	Y+1, r22	; 0x01
     858:	7a 83       	std	Y+2, r23	; 0x02
     85a:	8b 83       	std	Y+3, r24	; 0x03
     85c:	9c 83       	std	Y+4, r25	; 0x04
     85e:	2d 83       	std	Y+5, r18	; 0x05
     860:	3e 83       	std	Y+6, r19	; 0x06
     862:	4f 83       	std	Y+7, r20	; 0x07
     864:	58 87       	std	Y+8, r21	; 0x08
     866:	89 e0       	ldi	r24, 0x09	; 9
     868:	e8 2e       	mov	r14, r24
     86a:	f1 2c       	mov	r15, r1
     86c:	ec 0e       	add	r14, r28
     86e:	fd 1e       	adc	r15, r29
     870:	ce 01       	movw	r24, r28
     872:	01 96       	adiw	r24, 0x01	; 1
     874:	b7 01       	movw	r22, r14
     876:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     87a:	8e 01       	movw	r16, r28
     87c:	0f 5e       	subi	r16, 0xEF	; 239
     87e:	1f 4f       	sbci	r17, 0xFF	; 255
     880:	ce 01       	movw	r24, r28
     882:	05 96       	adiw	r24, 0x05	; 5
     884:	b8 01       	movw	r22, r16
     886:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     88a:	89 85       	ldd	r24, Y+9	; 0x09
     88c:	82 30       	cpi	r24, 0x02	; 2
     88e:	40 f0       	brcs	.+16     	; 0x8a0 <__stack+0x41>
     890:	89 89       	ldd	r24, Y+17	; 0x11
     892:	82 30       	cpi	r24, 0x02	; 2
     894:	28 f0       	brcs	.+10     	; 0x8a0 <__stack+0x41>
     896:	c7 01       	movw	r24, r14
     898:	b8 01       	movw	r22, r16
     89a:	0e 94 be 06 	call	0xd7c	; 0xd7c <__fpcmp_parts_f>
     89e:	01 c0       	rjmp	.+2      	; 0x8a2 <__stack+0x43>
     8a0:	81 e0       	ldi	r24, 0x01	; 1
     8a2:	68 96       	adiw	r28, 0x18	; 24
     8a4:	e6 e0       	ldi	r30, 0x06	; 6
     8a6:	0c 94 66 34 	jmp	0x68cc	; 0x68cc <__epilogue_restores__+0x18>

000008aa <__fixsfsi>:
     8aa:	ac e0       	ldi	r26, 0x0C	; 12
     8ac:	b0 e0       	ldi	r27, 0x00	; 0
     8ae:	eb e5       	ldi	r30, 0x5B	; 91
     8b0:	f4 e0       	ldi	r31, 0x04	; 4
     8b2:	0c 94 4e 34 	jmp	0x689c	; 0x689c <__prologue_saves__+0x20>
     8b6:	69 83       	std	Y+1, r22	; 0x01
     8b8:	7a 83       	std	Y+2, r23	; 0x02
     8ba:	8b 83       	std	Y+3, r24	; 0x03
     8bc:	9c 83       	std	Y+4, r25	; 0x04
     8be:	ce 01       	movw	r24, r28
     8c0:	01 96       	adiw	r24, 0x01	; 1
     8c2:	be 01       	movw	r22, r28
     8c4:	6b 5f       	subi	r22, 0xFB	; 251
     8c6:	7f 4f       	sbci	r23, 0xFF	; 255
     8c8:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     8cc:	8d 81       	ldd	r24, Y+5	; 0x05
     8ce:	82 30       	cpi	r24, 0x02	; 2
     8d0:	61 f1       	breq	.+88     	; 0x92a <__fixsfsi+0x80>
     8d2:	82 30       	cpi	r24, 0x02	; 2
     8d4:	50 f1       	brcs	.+84     	; 0x92a <__fixsfsi+0x80>
     8d6:	84 30       	cpi	r24, 0x04	; 4
     8d8:	21 f4       	brne	.+8      	; 0x8e2 <__fixsfsi+0x38>
     8da:	8e 81       	ldd	r24, Y+6	; 0x06
     8dc:	88 23       	and	r24, r24
     8de:	51 f1       	breq	.+84     	; 0x934 <__fixsfsi+0x8a>
     8e0:	2e c0       	rjmp	.+92     	; 0x93e <__fixsfsi+0x94>
     8e2:	2f 81       	ldd	r18, Y+7	; 0x07
     8e4:	38 85       	ldd	r19, Y+8	; 0x08
     8e6:	37 fd       	sbrc	r19, 7
     8e8:	20 c0       	rjmp	.+64     	; 0x92a <__fixsfsi+0x80>
     8ea:	6e 81       	ldd	r22, Y+6	; 0x06
     8ec:	2f 31       	cpi	r18, 0x1F	; 31
     8ee:	31 05       	cpc	r19, r1
     8f0:	1c f0       	brlt	.+6      	; 0x8f8 <__fixsfsi+0x4e>
     8f2:	66 23       	and	r22, r22
     8f4:	f9 f0       	breq	.+62     	; 0x934 <__fixsfsi+0x8a>
     8f6:	23 c0       	rjmp	.+70     	; 0x93e <__fixsfsi+0x94>
     8f8:	8e e1       	ldi	r24, 0x1E	; 30
     8fa:	90 e0       	ldi	r25, 0x00	; 0
     8fc:	82 1b       	sub	r24, r18
     8fe:	93 0b       	sbc	r25, r19
     900:	29 85       	ldd	r18, Y+9	; 0x09
     902:	3a 85       	ldd	r19, Y+10	; 0x0a
     904:	4b 85       	ldd	r20, Y+11	; 0x0b
     906:	5c 85       	ldd	r21, Y+12	; 0x0c
     908:	04 c0       	rjmp	.+8      	; 0x912 <__fixsfsi+0x68>
     90a:	56 95       	lsr	r21
     90c:	47 95       	ror	r20
     90e:	37 95       	ror	r19
     910:	27 95       	ror	r18
     912:	8a 95       	dec	r24
     914:	d2 f7       	brpl	.-12     	; 0x90a <__fixsfsi+0x60>
     916:	66 23       	and	r22, r22
     918:	b1 f0       	breq	.+44     	; 0x946 <__fixsfsi+0x9c>
     91a:	50 95       	com	r21
     91c:	40 95       	com	r20
     91e:	30 95       	com	r19
     920:	21 95       	neg	r18
     922:	3f 4f       	sbci	r19, 0xFF	; 255
     924:	4f 4f       	sbci	r20, 0xFF	; 255
     926:	5f 4f       	sbci	r21, 0xFF	; 255
     928:	0e c0       	rjmp	.+28     	; 0x946 <__fixsfsi+0x9c>
     92a:	20 e0       	ldi	r18, 0x00	; 0
     92c:	30 e0       	ldi	r19, 0x00	; 0
     92e:	40 e0       	ldi	r20, 0x00	; 0
     930:	50 e0       	ldi	r21, 0x00	; 0
     932:	09 c0       	rjmp	.+18     	; 0x946 <__fixsfsi+0x9c>
     934:	2f ef       	ldi	r18, 0xFF	; 255
     936:	3f ef       	ldi	r19, 0xFF	; 255
     938:	4f ef       	ldi	r20, 0xFF	; 255
     93a:	5f e7       	ldi	r21, 0x7F	; 127
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__fixsfsi+0x9c>
     93e:	20 e0       	ldi	r18, 0x00	; 0
     940:	30 e0       	ldi	r19, 0x00	; 0
     942:	40 e0       	ldi	r20, 0x00	; 0
     944:	50 e8       	ldi	r21, 0x80	; 128
     946:	b9 01       	movw	r22, r18
     948:	ca 01       	movw	r24, r20
     94a:	2c 96       	adiw	r28, 0x0c	; 12
     94c:	e2 e0       	ldi	r30, 0x02	; 2
     94e:	0c 94 6a 34 	jmp	0x68d4	; 0x68d4 <__epilogue_restores__+0x20>

00000952 <__floatunsisf>:
     952:	a8 e0       	ldi	r26, 0x08	; 8
     954:	b0 e0       	ldi	r27, 0x00	; 0
     956:	ef ea       	ldi	r30, 0xAF	; 175
     958:	f4 e0       	ldi	r31, 0x04	; 4
     95a:	0c 94 46 34 	jmp	0x688c	; 0x688c <__prologue_saves__+0x10>
     95e:	7b 01       	movw	r14, r22
     960:	8c 01       	movw	r16, r24
     962:	61 15       	cp	r22, r1
     964:	71 05       	cpc	r23, r1
     966:	81 05       	cpc	r24, r1
     968:	91 05       	cpc	r25, r1
     96a:	19 f4       	brne	.+6      	; 0x972 <__floatunsisf+0x20>
     96c:	82 e0       	ldi	r24, 0x02	; 2
     96e:	89 83       	std	Y+1, r24	; 0x01
     970:	60 c0       	rjmp	.+192    	; 0xa32 <__floatunsisf+0xe0>
     972:	83 e0       	ldi	r24, 0x03	; 3
     974:	89 83       	std	Y+1, r24	; 0x01
     976:	8e e1       	ldi	r24, 0x1E	; 30
     978:	c8 2e       	mov	r12, r24
     97a:	d1 2c       	mov	r13, r1
     97c:	dc 82       	std	Y+4, r13	; 0x04
     97e:	cb 82       	std	Y+3, r12	; 0x03
     980:	ed 82       	std	Y+5, r14	; 0x05
     982:	fe 82       	std	Y+6, r15	; 0x06
     984:	0f 83       	std	Y+7, r16	; 0x07
     986:	18 87       	std	Y+8, r17	; 0x08
     988:	c8 01       	movw	r24, r16
     98a:	b7 01       	movw	r22, r14
     98c:	0e 94 22 05 	call	0xa44	; 0xa44 <__clzsi2>
     990:	fc 01       	movw	r30, r24
     992:	31 97       	sbiw	r30, 0x01	; 1
     994:	f7 ff       	sbrs	r31, 7
     996:	3b c0       	rjmp	.+118    	; 0xa0e <__floatunsisf+0xbc>
     998:	22 27       	eor	r18, r18
     99a:	33 27       	eor	r19, r19
     99c:	2e 1b       	sub	r18, r30
     99e:	3f 0b       	sbc	r19, r31
     9a0:	57 01       	movw	r10, r14
     9a2:	68 01       	movw	r12, r16
     9a4:	02 2e       	mov	r0, r18
     9a6:	04 c0       	rjmp	.+8      	; 0x9b0 <__floatunsisf+0x5e>
     9a8:	d6 94       	lsr	r13
     9aa:	c7 94       	ror	r12
     9ac:	b7 94       	ror	r11
     9ae:	a7 94       	ror	r10
     9b0:	0a 94       	dec	r0
     9b2:	d2 f7       	brpl	.-12     	; 0x9a8 <__floatunsisf+0x56>
     9b4:	40 e0       	ldi	r20, 0x00	; 0
     9b6:	50 e0       	ldi	r21, 0x00	; 0
     9b8:	60 e0       	ldi	r22, 0x00	; 0
     9ba:	70 e0       	ldi	r23, 0x00	; 0
     9bc:	81 e0       	ldi	r24, 0x01	; 1
     9be:	90 e0       	ldi	r25, 0x00	; 0
     9c0:	a0 e0       	ldi	r26, 0x00	; 0
     9c2:	b0 e0       	ldi	r27, 0x00	; 0
     9c4:	04 c0       	rjmp	.+8      	; 0x9ce <__floatunsisf+0x7c>
     9c6:	88 0f       	add	r24, r24
     9c8:	99 1f       	adc	r25, r25
     9ca:	aa 1f       	adc	r26, r26
     9cc:	bb 1f       	adc	r27, r27
     9ce:	2a 95       	dec	r18
     9d0:	d2 f7       	brpl	.-12     	; 0x9c6 <__floatunsisf+0x74>
     9d2:	01 97       	sbiw	r24, 0x01	; 1
     9d4:	a1 09       	sbc	r26, r1
     9d6:	b1 09       	sbc	r27, r1
     9d8:	8e 21       	and	r24, r14
     9da:	9f 21       	and	r25, r15
     9dc:	a0 23       	and	r26, r16
     9de:	b1 23       	and	r27, r17
     9e0:	00 97       	sbiw	r24, 0x00	; 0
     9e2:	a1 05       	cpc	r26, r1
     9e4:	b1 05       	cpc	r27, r1
     9e6:	21 f0       	breq	.+8      	; 0x9f0 <__floatunsisf+0x9e>
     9e8:	41 e0       	ldi	r20, 0x01	; 1
     9ea:	50 e0       	ldi	r21, 0x00	; 0
     9ec:	60 e0       	ldi	r22, 0x00	; 0
     9ee:	70 e0       	ldi	r23, 0x00	; 0
     9f0:	4a 29       	or	r20, r10
     9f2:	5b 29       	or	r21, r11
     9f4:	6c 29       	or	r22, r12
     9f6:	7d 29       	or	r23, r13
     9f8:	4d 83       	std	Y+5, r20	; 0x05
     9fa:	5e 83       	std	Y+6, r21	; 0x06
     9fc:	6f 83       	std	Y+7, r22	; 0x07
     9fe:	78 87       	std	Y+8, r23	; 0x08
     a00:	8e e1       	ldi	r24, 0x1E	; 30
     a02:	90 e0       	ldi	r25, 0x00	; 0
     a04:	8e 1b       	sub	r24, r30
     a06:	9f 0b       	sbc	r25, r31
     a08:	9c 83       	std	Y+4, r25	; 0x04
     a0a:	8b 83       	std	Y+3, r24	; 0x03
     a0c:	12 c0       	rjmp	.+36     	; 0xa32 <__floatunsisf+0xe0>
     a0e:	30 97       	sbiw	r30, 0x00	; 0
     a10:	81 f0       	breq	.+32     	; 0xa32 <__floatunsisf+0xe0>
     a12:	0e 2e       	mov	r0, r30
     a14:	04 c0       	rjmp	.+8      	; 0xa1e <__floatunsisf+0xcc>
     a16:	ee 0c       	add	r14, r14
     a18:	ff 1c       	adc	r15, r15
     a1a:	00 1f       	adc	r16, r16
     a1c:	11 1f       	adc	r17, r17
     a1e:	0a 94       	dec	r0
     a20:	d2 f7       	brpl	.-12     	; 0xa16 <__floatunsisf+0xc4>
     a22:	ed 82       	std	Y+5, r14	; 0x05
     a24:	fe 82       	std	Y+6, r15	; 0x06
     a26:	0f 83       	std	Y+7, r16	; 0x07
     a28:	18 87       	std	Y+8, r17	; 0x08
     a2a:	ce 1a       	sub	r12, r30
     a2c:	df 0a       	sbc	r13, r31
     a2e:	dc 82       	std	Y+4, r13	; 0x04
     a30:	cb 82       	std	Y+3, r12	; 0x03
     a32:	1a 82       	std	Y+2, r1	; 0x02
     a34:	ce 01       	movw	r24, r28
     a36:	01 96       	adiw	r24, 0x01	; 1
     a38:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     a3c:	28 96       	adiw	r28, 0x08	; 8
     a3e:	ea e0       	ldi	r30, 0x0A	; 10
     a40:	0c 94 62 34 	jmp	0x68c4	; 0x68c4 <__epilogue_restores__+0x10>

00000a44 <__clzsi2>:
     a44:	ef 92       	push	r14
     a46:	ff 92       	push	r15
     a48:	0f 93       	push	r16
     a4a:	1f 93       	push	r17
     a4c:	7b 01       	movw	r14, r22
     a4e:	8c 01       	movw	r16, r24
     a50:	80 e0       	ldi	r24, 0x00	; 0
     a52:	e8 16       	cp	r14, r24
     a54:	80 e0       	ldi	r24, 0x00	; 0
     a56:	f8 06       	cpc	r15, r24
     a58:	81 e0       	ldi	r24, 0x01	; 1
     a5a:	08 07       	cpc	r16, r24
     a5c:	80 e0       	ldi	r24, 0x00	; 0
     a5e:	18 07       	cpc	r17, r24
     a60:	88 f4       	brcc	.+34     	; 0xa84 <__clzsi2+0x40>
     a62:	8f ef       	ldi	r24, 0xFF	; 255
     a64:	e8 16       	cp	r14, r24
     a66:	f1 04       	cpc	r15, r1
     a68:	01 05       	cpc	r16, r1
     a6a:	11 05       	cpc	r17, r1
     a6c:	31 f0       	breq	.+12     	; 0xa7a <__clzsi2+0x36>
     a6e:	28 f0       	brcs	.+10     	; 0xa7a <__clzsi2+0x36>
     a70:	88 e0       	ldi	r24, 0x08	; 8
     a72:	90 e0       	ldi	r25, 0x00	; 0
     a74:	a0 e0       	ldi	r26, 0x00	; 0
     a76:	b0 e0       	ldi	r27, 0x00	; 0
     a78:	17 c0       	rjmp	.+46     	; 0xaa8 <__clzsi2+0x64>
     a7a:	80 e0       	ldi	r24, 0x00	; 0
     a7c:	90 e0       	ldi	r25, 0x00	; 0
     a7e:	a0 e0       	ldi	r26, 0x00	; 0
     a80:	b0 e0       	ldi	r27, 0x00	; 0
     a82:	12 c0       	rjmp	.+36     	; 0xaa8 <__clzsi2+0x64>
     a84:	80 e0       	ldi	r24, 0x00	; 0
     a86:	e8 16       	cp	r14, r24
     a88:	80 e0       	ldi	r24, 0x00	; 0
     a8a:	f8 06       	cpc	r15, r24
     a8c:	80 e0       	ldi	r24, 0x00	; 0
     a8e:	08 07       	cpc	r16, r24
     a90:	81 e0       	ldi	r24, 0x01	; 1
     a92:	18 07       	cpc	r17, r24
     a94:	28 f0       	brcs	.+10     	; 0xaa0 <__clzsi2+0x5c>
     a96:	88 e1       	ldi	r24, 0x18	; 24
     a98:	90 e0       	ldi	r25, 0x00	; 0
     a9a:	a0 e0       	ldi	r26, 0x00	; 0
     a9c:	b0 e0       	ldi	r27, 0x00	; 0
     a9e:	04 c0       	rjmp	.+8      	; 0xaa8 <__clzsi2+0x64>
     aa0:	80 e1       	ldi	r24, 0x10	; 16
     aa2:	90 e0       	ldi	r25, 0x00	; 0
     aa4:	a0 e0       	ldi	r26, 0x00	; 0
     aa6:	b0 e0       	ldi	r27, 0x00	; 0
     aa8:	20 e2       	ldi	r18, 0x20	; 32
     aaa:	30 e0       	ldi	r19, 0x00	; 0
     aac:	40 e0       	ldi	r20, 0x00	; 0
     aae:	50 e0       	ldi	r21, 0x00	; 0
     ab0:	28 1b       	sub	r18, r24
     ab2:	39 0b       	sbc	r19, r25
     ab4:	4a 0b       	sbc	r20, r26
     ab6:	5b 0b       	sbc	r21, r27
     ab8:	04 c0       	rjmp	.+8      	; 0xac2 <__clzsi2+0x7e>
     aba:	16 95       	lsr	r17
     abc:	07 95       	ror	r16
     abe:	f7 94       	ror	r15
     ac0:	e7 94       	ror	r14
     ac2:	8a 95       	dec	r24
     ac4:	d2 f7       	brpl	.-12     	; 0xaba <__clzsi2+0x76>
     ac6:	f7 01       	movw	r30, r14
     ac8:	e1 56       	subi	r30, 0x61	; 97
     aca:	ff 4f       	sbci	r31, 0xFF	; 255
     acc:	80 81       	ld	r24, Z
     ace:	28 1b       	sub	r18, r24
     ad0:	31 09       	sbc	r19, r1
     ad2:	41 09       	sbc	r20, r1
     ad4:	51 09       	sbc	r21, r1
     ad6:	c9 01       	movw	r24, r18
     ad8:	1f 91       	pop	r17
     ada:	0f 91       	pop	r16
     adc:	ff 90       	pop	r15
     ade:	ef 90       	pop	r14
     ae0:	08 95       	ret

00000ae2 <__pack_f>:
     ae2:	df 92       	push	r13
     ae4:	ef 92       	push	r14
     ae6:	ff 92       	push	r15
     ae8:	0f 93       	push	r16
     aea:	1f 93       	push	r17
     aec:	fc 01       	movw	r30, r24
     aee:	e4 80       	ldd	r14, Z+4	; 0x04
     af0:	f5 80       	ldd	r15, Z+5	; 0x05
     af2:	06 81       	ldd	r16, Z+6	; 0x06
     af4:	17 81       	ldd	r17, Z+7	; 0x07
     af6:	d1 80       	ldd	r13, Z+1	; 0x01
     af8:	80 81       	ld	r24, Z
     afa:	82 30       	cpi	r24, 0x02	; 2
     afc:	48 f4       	brcc	.+18     	; 0xb10 <__pack_f+0x2e>
     afe:	80 e0       	ldi	r24, 0x00	; 0
     b00:	90 e0       	ldi	r25, 0x00	; 0
     b02:	a0 e1       	ldi	r26, 0x10	; 16
     b04:	b0 e0       	ldi	r27, 0x00	; 0
     b06:	e8 2a       	or	r14, r24
     b08:	f9 2a       	or	r15, r25
     b0a:	0a 2b       	or	r16, r26
     b0c:	1b 2b       	or	r17, r27
     b0e:	a5 c0       	rjmp	.+330    	; 0xc5a <__pack_f+0x178>
     b10:	84 30       	cpi	r24, 0x04	; 4
     b12:	09 f4       	brne	.+2      	; 0xb16 <__pack_f+0x34>
     b14:	9f c0       	rjmp	.+318    	; 0xc54 <__pack_f+0x172>
     b16:	82 30       	cpi	r24, 0x02	; 2
     b18:	21 f4       	brne	.+8      	; 0xb22 <__pack_f+0x40>
     b1a:	ee 24       	eor	r14, r14
     b1c:	ff 24       	eor	r15, r15
     b1e:	87 01       	movw	r16, r14
     b20:	05 c0       	rjmp	.+10     	; 0xb2c <__pack_f+0x4a>
     b22:	e1 14       	cp	r14, r1
     b24:	f1 04       	cpc	r15, r1
     b26:	01 05       	cpc	r16, r1
     b28:	11 05       	cpc	r17, r1
     b2a:	19 f4       	brne	.+6      	; 0xb32 <__pack_f+0x50>
     b2c:	e0 e0       	ldi	r30, 0x00	; 0
     b2e:	f0 e0       	ldi	r31, 0x00	; 0
     b30:	96 c0       	rjmp	.+300    	; 0xc5e <__pack_f+0x17c>
     b32:	62 81       	ldd	r22, Z+2	; 0x02
     b34:	73 81       	ldd	r23, Z+3	; 0x03
     b36:	9f ef       	ldi	r25, 0xFF	; 255
     b38:	62 38       	cpi	r22, 0x82	; 130
     b3a:	79 07       	cpc	r23, r25
     b3c:	0c f0       	brlt	.+2      	; 0xb40 <__pack_f+0x5e>
     b3e:	5b c0       	rjmp	.+182    	; 0xbf6 <__pack_f+0x114>
     b40:	22 e8       	ldi	r18, 0x82	; 130
     b42:	3f ef       	ldi	r19, 0xFF	; 255
     b44:	26 1b       	sub	r18, r22
     b46:	37 0b       	sbc	r19, r23
     b48:	2a 31       	cpi	r18, 0x1A	; 26
     b4a:	31 05       	cpc	r19, r1
     b4c:	2c f0       	brlt	.+10     	; 0xb58 <__pack_f+0x76>
     b4e:	20 e0       	ldi	r18, 0x00	; 0
     b50:	30 e0       	ldi	r19, 0x00	; 0
     b52:	40 e0       	ldi	r20, 0x00	; 0
     b54:	50 e0       	ldi	r21, 0x00	; 0
     b56:	2a c0       	rjmp	.+84     	; 0xbac <__pack_f+0xca>
     b58:	b8 01       	movw	r22, r16
     b5a:	a7 01       	movw	r20, r14
     b5c:	02 2e       	mov	r0, r18
     b5e:	04 c0       	rjmp	.+8      	; 0xb68 <__pack_f+0x86>
     b60:	76 95       	lsr	r23
     b62:	67 95       	ror	r22
     b64:	57 95       	ror	r21
     b66:	47 95       	ror	r20
     b68:	0a 94       	dec	r0
     b6a:	d2 f7       	brpl	.-12     	; 0xb60 <__pack_f+0x7e>
     b6c:	81 e0       	ldi	r24, 0x01	; 1
     b6e:	90 e0       	ldi	r25, 0x00	; 0
     b70:	a0 e0       	ldi	r26, 0x00	; 0
     b72:	b0 e0       	ldi	r27, 0x00	; 0
     b74:	04 c0       	rjmp	.+8      	; 0xb7e <__pack_f+0x9c>
     b76:	88 0f       	add	r24, r24
     b78:	99 1f       	adc	r25, r25
     b7a:	aa 1f       	adc	r26, r26
     b7c:	bb 1f       	adc	r27, r27
     b7e:	2a 95       	dec	r18
     b80:	d2 f7       	brpl	.-12     	; 0xb76 <__pack_f+0x94>
     b82:	01 97       	sbiw	r24, 0x01	; 1
     b84:	a1 09       	sbc	r26, r1
     b86:	b1 09       	sbc	r27, r1
     b88:	8e 21       	and	r24, r14
     b8a:	9f 21       	and	r25, r15
     b8c:	a0 23       	and	r26, r16
     b8e:	b1 23       	and	r27, r17
     b90:	00 97       	sbiw	r24, 0x00	; 0
     b92:	a1 05       	cpc	r26, r1
     b94:	b1 05       	cpc	r27, r1
     b96:	21 f0       	breq	.+8      	; 0xba0 <__pack_f+0xbe>
     b98:	81 e0       	ldi	r24, 0x01	; 1
     b9a:	90 e0       	ldi	r25, 0x00	; 0
     b9c:	a0 e0       	ldi	r26, 0x00	; 0
     b9e:	b0 e0       	ldi	r27, 0x00	; 0
     ba0:	9a 01       	movw	r18, r20
     ba2:	ab 01       	movw	r20, r22
     ba4:	28 2b       	or	r18, r24
     ba6:	39 2b       	or	r19, r25
     ba8:	4a 2b       	or	r20, r26
     baa:	5b 2b       	or	r21, r27
     bac:	da 01       	movw	r26, r20
     bae:	c9 01       	movw	r24, r18
     bb0:	8f 77       	andi	r24, 0x7F	; 127
     bb2:	90 70       	andi	r25, 0x00	; 0
     bb4:	a0 70       	andi	r26, 0x00	; 0
     bb6:	b0 70       	andi	r27, 0x00	; 0
     bb8:	80 34       	cpi	r24, 0x40	; 64
     bba:	91 05       	cpc	r25, r1
     bbc:	a1 05       	cpc	r26, r1
     bbe:	b1 05       	cpc	r27, r1
     bc0:	39 f4       	brne	.+14     	; 0xbd0 <__pack_f+0xee>
     bc2:	27 ff       	sbrs	r18, 7
     bc4:	09 c0       	rjmp	.+18     	; 0xbd8 <__pack_f+0xf6>
     bc6:	20 5c       	subi	r18, 0xC0	; 192
     bc8:	3f 4f       	sbci	r19, 0xFF	; 255
     bca:	4f 4f       	sbci	r20, 0xFF	; 255
     bcc:	5f 4f       	sbci	r21, 0xFF	; 255
     bce:	04 c0       	rjmp	.+8      	; 0xbd8 <__pack_f+0xf6>
     bd0:	21 5c       	subi	r18, 0xC1	; 193
     bd2:	3f 4f       	sbci	r19, 0xFF	; 255
     bd4:	4f 4f       	sbci	r20, 0xFF	; 255
     bd6:	5f 4f       	sbci	r21, 0xFF	; 255
     bd8:	e0 e0       	ldi	r30, 0x00	; 0
     bda:	f0 e0       	ldi	r31, 0x00	; 0
     bdc:	20 30       	cpi	r18, 0x00	; 0
     bde:	a0 e0       	ldi	r26, 0x00	; 0
     be0:	3a 07       	cpc	r19, r26
     be2:	a0 e0       	ldi	r26, 0x00	; 0
     be4:	4a 07       	cpc	r20, r26
     be6:	a0 e4       	ldi	r26, 0x40	; 64
     be8:	5a 07       	cpc	r21, r26
     bea:	10 f0       	brcs	.+4      	; 0xbf0 <__pack_f+0x10e>
     bec:	e1 e0       	ldi	r30, 0x01	; 1
     bee:	f0 e0       	ldi	r31, 0x00	; 0
     bf0:	79 01       	movw	r14, r18
     bf2:	8a 01       	movw	r16, r20
     bf4:	27 c0       	rjmp	.+78     	; 0xc44 <__pack_f+0x162>
     bf6:	60 38       	cpi	r22, 0x80	; 128
     bf8:	71 05       	cpc	r23, r1
     bfa:	64 f5       	brge	.+88     	; 0xc54 <__pack_f+0x172>
     bfc:	fb 01       	movw	r30, r22
     bfe:	e1 58       	subi	r30, 0x81	; 129
     c00:	ff 4f       	sbci	r31, 0xFF	; 255
     c02:	d8 01       	movw	r26, r16
     c04:	c7 01       	movw	r24, r14
     c06:	8f 77       	andi	r24, 0x7F	; 127
     c08:	90 70       	andi	r25, 0x00	; 0
     c0a:	a0 70       	andi	r26, 0x00	; 0
     c0c:	b0 70       	andi	r27, 0x00	; 0
     c0e:	80 34       	cpi	r24, 0x40	; 64
     c10:	91 05       	cpc	r25, r1
     c12:	a1 05       	cpc	r26, r1
     c14:	b1 05       	cpc	r27, r1
     c16:	39 f4       	brne	.+14     	; 0xc26 <__pack_f+0x144>
     c18:	e7 fe       	sbrs	r14, 7
     c1a:	0d c0       	rjmp	.+26     	; 0xc36 <__pack_f+0x154>
     c1c:	80 e4       	ldi	r24, 0x40	; 64
     c1e:	90 e0       	ldi	r25, 0x00	; 0
     c20:	a0 e0       	ldi	r26, 0x00	; 0
     c22:	b0 e0       	ldi	r27, 0x00	; 0
     c24:	04 c0       	rjmp	.+8      	; 0xc2e <__pack_f+0x14c>
     c26:	8f e3       	ldi	r24, 0x3F	; 63
     c28:	90 e0       	ldi	r25, 0x00	; 0
     c2a:	a0 e0       	ldi	r26, 0x00	; 0
     c2c:	b0 e0       	ldi	r27, 0x00	; 0
     c2e:	e8 0e       	add	r14, r24
     c30:	f9 1e       	adc	r15, r25
     c32:	0a 1f       	adc	r16, r26
     c34:	1b 1f       	adc	r17, r27
     c36:	17 ff       	sbrs	r17, 7
     c38:	05 c0       	rjmp	.+10     	; 0xc44 <__pack_f+0x162>
     c3a:	16 95       	lsr	r17
     c3c:	07 95       	ror	r16
     c3e:	f7 94       	ror	r15
     c40:	e7 94       	ror	r14
     c42:	31 96       	adiw	r30, 0x01	; 1
     c44:	87 e0       	ldi	r24, 0x07	; 7
     c46:	16 95       	lsr	r17
     c48:	07 95       	ror	r16
     c4a:	f7 94       	ror	r15
     c4c:	e7 94       	ror	r14
     c4e:	8a 95       	dec	r24
     c50:	d1 f7       	brne	.-12     	; 0xc46 <__pack_f+0x164>
     c52:	05 c0       	rjmp	.+10     	; 0xc5e <__pack_f+0x17c>
     c54:	ee 24       	eor	r14, r14
     c56:	ff 24       	eor	r15, r15
     c58:	87 01       	movw	r16, r14
     c5a:	ef ef       	ldi	r30, 0xFF	; 255
     c5c:	f0 e0       	ldi	r31, 0x00	; 0
     c5e:	6e 2f       	mov	r22, r30
     c60:	67 95       	ror	r22
     c62:	66 27       	eor	r22, r22
     c64:	67 95       	ror	r22
     c66:	90 2f       	mov	r25, r16
     c68:	9f 77       	andi	r25, 0x7F	; 127
     c6a:	d7 94       	ror	r13
     c6c:	dd 24       	eor	r13, r13
     c6e:	d7 94       	ror	r13
     c70:	8e 2f       	mov	r24, r30
     c72:	86 95       	lsr	r24
     c74:	49 2f       	mov	r20, r25
     c76:	46 2b       	or	r20, r22
     c78:	58 2f       	mov	r21, r24
     c7a:	5d 29       	or	r21, r13
     c7c:	b7 01       	movw	r22, r14
     c7e:	ca 01       	movw	r24, r20
     c80:	1f 91       	pop	r17
     c82:	0f 91       	pop	r16
     c84:	ff 90       	pop	r15
     c86:	ef 90       	pop	r14
     c88:	df 90       	pop	r13
     c8a:	08 95       	ret

00000c8c <__unpack_f>:
     c8c:	fc 01       	movw	r30, r24
     c8e:	db 01       	movw	r26, r22
     c90:	40 81       	ld	r20, Z
     c92:	51 81       	ldd	r21, Z+1	; 0x01
     c94:	22 81       	ldd	r18, Z+2	; 0x02
     c96:	62 2f       	mov	r22, r18
     c98:	6f 77       	andi	r22, 0x7F	; 127
     c9a:	70 e0       	ldi	r23, 0x00	; 0
     c9c:	22 1f       	adc	r18, r18
     c9e:	22 27       	eor	r18, r18
     ca0:	22 1f       	adc	r18, r18
     ca2:	93 81       	ldd	r25, Z+3	; 0x03
     ca4:	89 2f       	mov	r24, r25
     ca6:	88 0f       	add	r24, r24
     ca8:	82 2b       	or	r24, r18
     caa:	28 2f       	mov	r18, r24
     cac:	30 e0       	ldi	r19, 0x00	; 0
     cae:	99 1f       	adc	r25, r25
     cb0:	99 27       	eor	r25, r25
     cb2:	99 1f       	adc	r25, r25
     cb4:	11 96       	adiw	r26, 0x01	; 1
     cb6:	9c 93       	st	X, r25
     cb8:	11 97       	sbiw	r26, 0x01	; 1
     cba:	21 15       	cp	r18, r1
     cbc:	31 05       	cpc	r19, r1
     cbe:	a9 f5       	brne	.+106    	; 0xd2a <__unpack_f+0x9e>
     cc0:	41 15       	cp	r20, r1
     cc2:	51 05       	cpc	r21, r1
     cc4:	61 05       	cpc	r22, r1
     cc6:	71 05       	cpc	r23, r1
     cc8:	11 f4       	brne	.+4      	; 0xcce <__unpack_f+0x42>
     cca:	82 e0       	ldi	r24, 0x02	; 2
     ccc:	37 c0       	rjmp	.+110    	; 0xd3c <__unpack_f+0xb0>
     cce:	82 e8       	ldi	r24, 0x82	; 130
     cd0:	9f ef       	ldi	r25, 0xFF	; 255
     cd2:	13 96       	adiw	r26, 0x03	; 3
     cd4:	9c 93       	st	X, r25
     cd6:	8e 93       	st	-X, r24
     cd8:	12 97       	sbiw	r26, 0x02	; 2
     cda:	9a 01       	movw	r18, r20
     cdc:	ab 01       	movw	r20, r22
     cde:	67 e0       	ldi	r22, 0x07	; 7
     ce0:	22 0f       	add	r18, r18
     ce2:	33 1f       	adc	r19, r19
     ce4:	44 1f       	adc	r20, r20
     ce6:	55 1f       	adc	r21, r21
     ce8:	6a 95       	dec	r22
     cea:	d1 f7       	brne	.-12     	; 0xce0 <__unpack_f+0x54>
     cec:	83 e0       	ldi	r24, 0x03	; 3
     cee:	8c 93       	st	X, r24
     cf0:	0d c0       	rjmp	.+26     	; 0xd0c <__unpack_f+0x80>
     cf2:	22 0f       	add	r18, r18
     cf4:	33 1f       	adc	r19, r19
     cf6:	44 1f       	adc	r20, r20
     cf8:	55 1f       	adc	r21, r21
     cfa:	12 96       	adiw	r26, 0x02	; 2
     cfc:	8d 91       	ld	r24, X+
     cfe:	9c 91       	ld	r25, X
     d00:	13 97       	sbiw	r26, 0x03	; 3
     d02:	01 97       	sbiw	r24, 0x01	; 1
     d04:	13 96       	adiw	r26, 0x03	; 3
     d06:	9c 93       	st	X, r25
     d08:	8e 93       	st	-X, r24
     d0a:	12 97       	sbiw	r26, 0x02	; 2
     d0c:	20 30       	cpi	r18, 0x00	; 0
     d0e:	80 e0       	ldi	r24, 0x00	; 0
     d10:	38 07       	cpc	r19, r24
     d12:	80 e0       	ldi	r24, 0x00	; 0
     d14:	48 07       	cpc	r20, r24
     d16:	80 e4       	ldi	r24, 0x40	; 64
     d18:	58 07       	cpc	r21, r24
     d1a:	58 f3       	brcs	.-42     	; 0xcf2 <__unpack_f+0x66>
     d1c:	14 96       	adiw	r26, 0x04	; 4
     d1e:	2d 93       	st	X+, r18
     d20:	3d 93       	st	X+, r19
     d22:	4d 93       	st	X+, r20
     d24:	5c 93       	st	X, r21
     d26:	17 97       	sbiw	r26, 0x07	; 7
     d28:	08 95       	ret
     d2a:	2f 3f       	cpi	r18, 0xFF	; 255
     d2c:	31 05       	cpc	r19, r1
     d2e:	79 f4       	brne	.+30     	; 0xd4e <__unpack_f+0xc2>
     d30:	41 15       	cp	r20, r1
     d32:	51 05       	cpc	r21, r1
     d34:	61 05       	cpc	r22, r1
     d36:	71 05       	cpc	r23, r1
     d38:	19 f4       	brne	.+6      	; 0xd40 <__unpack_f+0xb4>
     d3a:	84 e0       	ldi	r24, 0x04	; 4
     d3c:	8c 93       	st	X, r24
     d3e:	08 95       	ret
     d40:	64 ff       	sbrs	r22, 4
     d42:	03 c0       	rjmp	.+6      	; 0xd4a <__unpack_f+0xbe>
     d44:	81 e0       	ldi	r24, 0x01	; 1
     d46:	8c 93       	st	X, r24
     d48:	12 c0       	rjmp	.+36     	; 0xd6e <__unpack_f+0xe2>
     d4a:	1c 92       	st	X, r1
     d4c:	10 c0       	rjmp	.+32     	; 0xd6e <__unpack_f+0xe2>
     d4e:	2f 57       	subi	r18, 0x7F	; 127
     d50:	30 40       	sbci	r19, 0x00	; 0
     d52:	13 96       	adiw	r26, 0x03	; 3
     d54:	3c 93       	st	X, r19
     d56:	2e 93       	st	-X, r18
     d58:	12 97       	sbiw	r26, 0x02	; 2
     d5a:	83 e0       	ldi	r24, 0x03	; 3
     d5c:	8c 93       	st	X, r24
     d5e:	87 e0       	ldi	r24, 0x07	; 7
     d60:	44 0f       	add	r20, r20
     d62:	55 1f       	adc	r21, r21
     d64:	66 1f       	adc	r22, r22
     d66:	77 1f       	adc	r23, r23
     d68:	8a 95       	dec	r24
     d6a:	d1 f7       	brne	.-12     	; 0xd60 <__unpack_f+0xd4>
     d6c:	70 64       	ori	r23, 0x40	; 64
     d6e:	14 96       	adiw	r26, 0x04	; 4
     d70:	4d 93       	st	X+, r20
     d72:	5d 93       	st	X+, r21
     d74:	6d 93       	st	X+, r22
     d76:	7c 93       	st	X, r23
     d78:	17 97       	sbiw	r26, 0x07	; 7
     d7a:	08 95       	ret

00000d7c <__fpcmp_parts_f>:
     d7c:	1f 93       	push	r17
     d7e:	dc 01       	movw	r26, r24
     d80:	fb 01       	movw	r30, r22
     d82:	9c 91       	ld	r25, X
     d84:	92 30       	cpi	r25, 0x02	; 2
     d86:	08 f4       	brcc	.+2      	; 0xd8a <__fpcmp_parts_f+0xe>
     d88:	47 c0       	rjmp	.+142    	; 0xe18 <__fpcmp_parts_f+0x9c>
     d8a:	80 81       	ld	r24, Z
     d8c:	82 30       	cpi	r24, 0x02	; 2
     d8e:	08 f4       	brcc	.+2      	; 0xd92 <__fpcmp_parts_f+0x16>
     d90:	43 c0       	rjmp	.+134    	; 0xe18 <__fpcmp_parts_f+0x9c>
     d92:	94 30       	cpi	r25, 0x04	; 4
     d94:	51 f4       	brne	.+20     	; 0xdaa <__fpcmp_parts_f+0x2e>
     d96:	11 96       	adiw	r26, 0x01	; 1
     d98:	1c 91       	ld	r17, X
     d9a:	84 30       	cpi	r24, 0x04	; 4
     d9c:	99 f5       	brne	.+102    	; 0xe04 <__fpcmp_parts_f+0x88>
     d9e:	81 81       	ldd	r24, Z+1	; 0x01
     da0:	68 2f       	mov	r22, r24
     da2:	70 e0       	ldi	r23, 0x00	; 0
     da4:	61 1b       	sub	r22, r17
     da6:	71 09       	sbc	r23, r1
     da8:	3f c0       	rjmp	.+126    	; 0xe28 <__fpcmp_parts_f+0xac>
     daa:	84 30       	cpi	r24, 0x04	; 4
     dac:	21 f0       	breq	.+8      	; 0xdb6 <__fpcmp_parts_f+0x3a>
     dae:	92 30       	cpi	r25, 0x02	; 2
     db0:	31 f4       	brne	.+12     	; 0xdbe <__fpcmp_parts_f+0x42>
     db2:	82 30       	cpi	r24, 0x02	; 2
     db4:	b9 f1       	breq	.+110    	; 0xe24 <__fpcmp_parts_f+0xa8>
     db6:	81 81       	ldd	r24, Z+1	; 0x01
     db8:	88 23       	and	r24, r24
     dba:	89 f1       	breq	.+98     	; 0xe1e <__fpcmp_parts_f+0xa2>
     dbc:	2d c0       	rjmp	.+90     	; 0xe18 <__fpcmp_parts_f+0x9c>
     dbe:	11 96       	adiw	r26, 0x01	; 1
     dc0:	1c 91       	ld	r17, X
     dc2:	11 97       	sbiw	r26, 0x01	; 1
     dc4:	82 30       	cpi	r24, 0x02	; 2
     dc6:	f1 f0       	breq	.+60     	; 0xe04 <__fpcmp_parts_f+0x88>
     dc8:	81 81       	ldd	r24, Z+1	; 0x01
     dca:	18 17       	cp	r17, r24
     dcc:	d9 f4       	brne	.+54     	; 0xe04 <__fpcmp_parts_f+0x88>
     dce:	12 96       	adiw	r26, 0x02	; 2
     dd0:	2d 91       	ld	r18, X+
     dd2:	3c 91       	ld	r19, X
     dd4:	13 97       	sbiw	r26, 0x03	; 3
     dd6:	82 81       	ldd	r24, Z+2	; 0x02
     dd8:	93 81       	ldd	r25, Z+3	; 0x03
     dda:	82 17       	cp	r24, r18
     ddc:	93 07       	cpc	r25, r19
     dde:	94 f0       	brlt	.+36     	; 0xe04 <__fpcmp_parts_f+0x88>
     de0:	28 17       	cp	r18, r24
     de2:	39 07       	cpc	r19, r25
     de4:	bc f0       	brlt	.+46     	; 0xe14 <__fpcmp_parts_f+0x98>
     de6:	14 96       	adiw	r26, 0x04	; 4
     de8:	8d 91       	ld	r24, X+
     dea:	9d 91       	ld	r25, X+
     dec:	0d 90       	ld	r0, X+
     dee:	bc 91       	ld	r27, X
     df0:	a0 2d       	mov	r26, r0
     df2:	24 81       	ldd	r18, Z+4	; 0x04
     df4:	35 81       	ldd	r19, Z+5	; 0x05
     df6:	46 81       	ldd	r20, Z+6	; 0x06
     df8:	57 81       	ldd	r21, Z+7	; 0x07
     dfa:	28 17       	cp	r18, r24
     dfc:	39 07       	cpc	r19, r25
     dfe:	4a 07       	cpc	r20, r26
     e00:	5b 07       	cpc	r21, r27
     e02:	18 f4       	brcc	.+6      	; 0xe0a <__fpcmp_parts_f+0x8e>
     e04:	11 23       	and	r17, r17
     e06:	41 f0       	breq	.+16     	; 0xe18 <__fpcmp_parts_f+0x9c>
     e08:	0a c0       	rjmp	.+20     	; 0xe1e <__fpcmp_parts_f+0xa2>
     e0a:	82 17       	cp	r24, r18
     e0c:	93 07       	cpc	r25, r19
     e0e:	a4 07       	cpc	r26, r20
     e10:	b5 07       	cpc	r27, r21
     e12:	40 f4       	brcc	.+16     	; 0xe24 <__fpcmp_parts_f+0xa8>
     e14:	11 23       	and	r17, r17
     e16:	19 f0       	breq	.+6      	; 0xe1e <__fpcmp_parts_f+0xa2>
     e18:	61 e0       	ldi	r22, 0x01	; 1
     e1a:	70 e0       	ldi	r23, 0x00	; 0
     e1c:	05 c0       	rjmp	.+10     	; 0xe28 <__fpcmp_parts_f+0xac>
     e1e:	6f ef       	ldi	r22, 0xFF	; 255
     e20:	7f ef       	ldi	r23, 0xFF	; 255
     e22:	02 c0       	rjmp	.+4      	; 0xe28 <__fpcmp_parts_f+0xac>
     e24:	60 e0       	ldi	r22, 0x00	; 0
     e26:	70 e0       	ldi	r23, 0x00	; 0
     e28:	cb 01       	movw	r24, r22
     e2a:	1f 91       	pop	r17
     e2c:	08 95       	ret

00000e2e <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     e2e:	df 93       	push	r29
     e30:	cf 93       	push	r28
     e32:	cd b7       	in	r28, 0x3d	; 61
     e34:	de b7       	in	r29, 0x3e	; 62
     e36:	27 97       	sbiw	r28, 0x07	; 7
     e38:	0f b6       	in	r0, 0x3f	; 63
     e3a:	f8 94       	cli
     e3c:	de bf       	out	0x3e, r29	; 62
     e3e:	0f be       	out	0x3f, r0	; 63
     e40:	cd bf       	out	0x3d, r28	; 61
     e42:	9d 83       	std	Y+5, r25	; 0x05
     e44:	8c 83       	std	Y+4, r24	; 0x04
     e46:	6e 83       	std	Y+6, r22	; 0x06
     e48:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     e4a:	8a e1       	ldi	r24, 0x1A	; 26
     e4c:	90 e0       	ldi	r25, 0x00	; 0
     e4e:	0e 94 ef 09 	call	0x13de	; 0x13de <pvPortMalloc>
     e52:	9a 83       	std	Y+2, r25	; 0x02
     e54:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
     e56:	89 81       	ldd	r24, Y+1	; 0x01
     e58:	9a 81       	ldd	r25, Y+2	; 0x02
     e5a:	00 97       	sbiw	r24, 0x00	; 0
     e5c:	09 f4       	brne	.+2      	; 0xe60 <xCoRoutineCreate+0x32>
     e5e:	6f c0       	rjmp	.+222    	; 0xf3e <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     e60:	80 91 bc 01 	lds	r24, 0x01BC
     e64:	90 91 bd 01 	lds	r25, 0x01BD
     e68:	00 97       	sbiw	r24, 0x00	; 0
     e6a:	41 f4       	brne	.+16     	; 0xe7c <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     e6c:	89 81       	ldd	r24, Y+1	; 0x01
     e6e:	9a 81       	ldd	r25, Y+2	; 0x02
     e70:	90 93 bd 01 	sts	0x01BD, r25
     e74:	80 93 bc 01 	sts	0x01BC, r24
			prvInitialiseCoRoutineLists();
     e78:	0e 94 7e 09 	call	0x12fc	; 0x12fc <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     e7c:	8e 81       	ldd	r24, Y+6	; 0x06
     e7e:	82 30       	cpi	r24, 0x02	; 2
     e80:	10 f0       	brcs	.+4      	; 0xe86 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     e82:	81 e0       	ldi	r24, 0x01	; 1
     e84:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     e86:	e9 81       	ldd	r30, Y+1	; 0x01
     e88:	fa 81       	ldd	r31, Y+2	; 0x02
     e8a:	11 8e       	std	Z+25, r1	; 0x19
     e8c:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     e8e:	e9 81       	ldd	r30, Y+1	; 0x01
     e90:	fa 81       	ldd	r31, Y+2	; 0x02
     e92:	8e 81       	ldd	r24, Y+6	; 0x06
     e94:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     e96:	e9 81       	ldd	r30, Y+1	; 0x01
     e98:	fa 81       	ldd	r31, Y+2	; 0x02
     e9a:	8f 81       	ldd	r24, Y+7	; 0x07
     e9c:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     e9e:	e9 81       	ldd	r30, Y+1	; 0x01
     ea0:	fa 81       	ldd	r31, Y+2	; 0x02
     ea2:	8c 81       	ldd	r24, Y+4	; 0x04
     ea4:	9d 81       	ldd	r25, Y+5	; 0x05
     ea6:	91 83       	std	Z+1, r25	; 0x01
     ea8:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     eaa:	89 81       	ldd	r24, Y+1	; 0x01
     eac:	9a 81       	ldd	r25, Y+2	; 0x02
     eae:	02 96       	adiw	r24, 0x02	; 2
     eb0:	0e 94 85 0a 	call	0x150a	; 0x150a <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     eb4:	89 81       	ldd	r24, Y+1	; 0x01
     eb6:	9a 81       	ldd	r25, Y+2	; 0x02
     eb8:	0c 96       	adiw	r24, 0x0c	; 12
     eba:	0e 94 85 0a 	call	0x150a	; 0x150a <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     ebe:	e9 81       	ldd	r30, Y+1	; 0x01
     ec0:	fa 81       	ldd	r31, Y+2	; 0x02
     ec2:	89 81       	ldd	r24, Y+1	; 0x01
     ec4:	9a 81       	ldd	r25, Y+2	; 0x02
     ec6:	91 87       	std	Z+9, r25	; 0x09
     ec8:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     eca:	e9 81       	ldd	r30, Y+1	; 0x01
     ecc:	fa 81       	ldd	r31, Y+2	; 0x02
     ece:	89 81       	ldd	r24, Y+1	; 0x01
     ed0:	9a 81       	ldd	r25, Y+2	; 0x02
     ed2:	93 8b       	std	Z+19, r25	; 0x13
     ed4:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     ed6:	8e 81       	ldd	r24, Y+6	; 0x06
     ed8:	28 2f       	mov	r18, r24
     eda:	30 e0       	ldi	r19, 0x00	; 0
     edc:	85 e0       	ldi	r24, 0x05	; 5
     ede:	90 e0       	ldi	r25, 0x00	; 0
     ee0:	82 1b       	sub	r24, r18
     ee2:	93 0b       	sbc	r25, r19
     ee4:	e9 81       	ldd	r30, Y+1	; 0x01
     ee6:	fa 81       	ldd	r31, Y+2	; 0x02
     ee8:	95 87       	std	Z+13, r25	; 0x0d
     eea:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     eec:	e9 81       	ldd	r30, Y+1	; 0x01
     eee:	fa 81       	ldd	r31, Y+2	; 0x02
     ef0:	96 89       	ldd	r25, Z+22	; 0x16
     ef2:	80 91 be 01 	lds	r24, 0x01BE
     ef6:	89 17       	cp	r24, r25
     ef8:	28 f4       	brcc	.+10     	; 0xf04 <xCoRoutineCreate+0xd6>
     efa:	e9 81       	ldd	r30, Y+1	; 0x01
     efc:	fa 81       	ldd	r31, Y+2	; 0x02
     efe:	86 89       	ldd	r24, Z+22	; 0x16
     f00:	80 93 be 01 	sts	0x01BE, r24
     f04:	e9 81       	ldd	r30, Y+1	; 0x01
     f06:	fa 81       	ldd	r31, Y+2	; 0x02
     f08:	86 89       	ldd	r24, Z+22	; 0x16
     f0a:	28 2f       	mov	r18, r24
     f0c:	30 e0       	ldi	r19, 0x00	; 0
     f0e:	c9 01       	movw	r24, r18
     f10:	88 0f       	add	r24, r24
     f12:	99 1f       	adc	r25, r25
     f14:	88 0f       	add	r24, r24
     f16:	99 1f       	adc	r25, r25
     f18:	88 0f       	add	r24, r24
     f1a:	99 1f       	adc	r25, r25
     f1c:	82 0f       	add	r24, r18
     f1e:	93 1f       	adc	r25, r19
     f20:	ac 01       	movw	r20, r24
     f22:	4b 53       	subi	r20, 0x3B	; 59
     f24:	5e 4f       	sbci	r21, 0xFE	; 254
     f26:	89 81       	ldd	r24, Y+1	; 0x01
     f28:	9a 81       	ldd	r25, Y+2	; 0x02
     f2a:	9c 01       	movw	r18, r24
     f2c:	2e 5f       	subi	r18, 0xFE	; 254
     f2e:	3f 4f       	sbci	r19, 0xFF	; 255
     f30:	ca 01       	movw	r24, r20
     f32:	b9 01       	movw	r22, r18
     f34:	0e 94 95 0a 	call	0x152a	; 0x152a <vListInsertEnd>

		xReturn = pdPASS;
     f38:	81 e0       	ldi	r24, 0x01	; 1
     f3a:	8b 83       	std	Y+3, r24	; 0x03
     f3c:	02 c0       	rjmp	.+4      	; 0xf42 <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     f3e:	8f ef       	ldi	r24, 0xFF	; 255
     f40:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
     f42:	8b 81       	ldd	r24, Y+3	; 0x03
}
     f44:	27 96       	adiw	r28, 0x07	; 7
     f46:	0f b6       	in	r0, 0x3f	; 63
     f48:	f8 94       	cli
     f4a:	de bf       	out	0x3e, r29	; 62
     f4c:	0f be       	out	0x3f, r0	; 63
     f4e:	cd bf       	out	0x3d, r28	; 61
     f50:	cf 91       	pop	r28
     f52:	df 91       	pop	r29
     f54:	08 95       	ret

00000f56 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     f56:	df 93       	push	r29
     f58:	cf 93       	push	r28
     f5a:	00 d0       	rcall	.+0      	; 0xf5c <vCoRoutineAddToDelayedList+0x6>
     f5c:	00 d0       	rcall	.+0      	; 0xf5e <vCoRoutineAddToDelayedList+0x8>
     f5e:	00 d0       	rcall	.+0      	; 0xf60 <vCoRoutineAddToDelayedList+0xa>
     f60:	cd b7       	in	r28, 0x3d	; 61
     f62:	de b7       	in	r29, 0x3e	; 62
     f64:	9c 83       	std	Y+4, r25	; 0x04
     f66:	8b 83       	std	Y+3, r24	; 0x03
     f68:	7e 83       	std	Y+6, r23	; 0x06
     f6a:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     f6c:	20 91 bf 01 	lds	r18, 0x01BF
     f70:	30 91 c0 01 	lds	r19, 0x01C0
     f74:	8b 81       	ldd	r24, Y+3	; 0x03
     f76:	9c 81       	ldd	r25, Y+4	; 0x04
     f78:	82 0f       	add	r24, r18
     f7a:	93 1f       	adc	r25, r19
     f7c:	9a 83       	std	Y+2, r25	; 0x02
     f7e:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     f80:	80 91 bc 01 	lds	r24, 0x01BC
     f84:	90 91 bd 01 	lds	r25, 0x01BD
     f88:	02 96       	adiw	r24, 0x02	; 2
     f8a:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     f8e:	e0 91 bc 01 	lds	r30, 0x01BC
     f92:	f0 91 bd 01 	lds	r31, 0x01BD
     f96:	89 81       	ldd	r24, Y+1	; 0x01
     f98:	9a 81       	ldd	r25, Y+2	; 0x02
     f9a:	93 83       	std	Z+3, r25	; 0x03
     f9c:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     f9e:	20 91 bf 01 	lds	r18, 0x01BF
     fa2:	30 91 c0 01 	lds	r19, 0x01C0
     fa6:	89 81       	ldd	r24, Y+1	; 0x01
     fa8:	9a 81       	ldd	r25, Y+2	; 0x02
     faa:	82 17       	cp	r24, r18
     fac:	93 07       	cpc	r25, r19
     fae:	70 f4       	brcc	.+28     	; 0xfcc <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     fb0:	80 91 eb 01 	lds	r24, 0x01EB
     fb4:	90 91 ec 01 	lds	r25, 0x01EC
     fb8:	20 91 bc 01 	lds	r18, 0x01BC
     fbc:	30 91 bd 01 	lds	r19, 0x01BD
     fc0:	2e 5f       	subi	r18, 0xFE	; 254
     fc2:	3f 4f       	sbci	r19, 0xFF	; 255
     fc4:	b9 01       	movw	r22, r18
     fc6:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <vListInsert>
     fca:	0d c0       	rjmp	.+26     	; 0xfe6 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     fcc:	80 91 e9 01 	lds	r24, 0x01E9
     fd0:	90 91 ea 01 	lds	r25, 0x01EA
     fd4:	20 91 bc 01 	lds	r18, 0x01BC
     fd8:	30 91 bd 01 	lds	r19, 0x01BD
     fdc:	2e 5f       	subi	r18, 0xFE	; 254
     fde:	3f 4f       	sbci	r19, 0xFF	; 255
     fe0:	b9 01       	movw	r22, r18
     fe2:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <vListInsert>
	}

	if( pxEventList )
     fe6:	8d 81       	ldd	r24, Y+5	; 0x05
     fe8:	9e 81       	ldd	r25, Y+6	; 0x06
     fea:	00 97       	sbiw	r24, 0x00	; 0
     fec:	61 f0       	breq	.+24     	; 0x1006 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     fee:	80 91 bc 01 	lds	r24, 0x01BC
     ff2:	90 91 bd 01 	lds	r25, 0x01BD
     ff6:	9c 01       	movw	r18, r24
     ff8:	24 5f       	subi	r18, 0xF4	; 244
     ffa:	3f 4f       	sbci	r19, 0xFF	; 255
     ffc:	8d 81       	ldd	r24, Y+5	; 0x05
     ffe:	9e 81       	ldd	r25, Y+6	; 0x06
    1000:	b9 01       	movw	r22, r18
    1002:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <vListInsert>
	}
}
    1006:	26 96       	adiw	r28, 0x06	; 6
    1008:	0f b6       	in	r0, 0x3f	; 63
    100a:	f8 94       	cli
    100c:	de bf       	out	0x3e, r29	; 62
    100e:	0f be       	out	0x3f, r0	; 63
    1010:	cd bf       	out	0x3d, r28	; 61
    1012:	cf 91       	pop	r28
    1014:	df 91       	pop	r29
    1016:	08 95       	ret

00001018 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    1018:	df 93       	push	r29
    101a:	cf 93       	push	r28
    101c:	00 d0       	rcall	.+0      	; 0x101e <prvCheckPendingReadyList+0x6>
    101e:	cd b7       	in	r28, 0x3d	; 61
    1020:	de b7       	in	r29, 0x3e	; 62
    1022:	3a c0       	rjmp	.+116    	; 0x1098 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    1024:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    1026:	e0 91 f2 01 	lds	r30, 0x01F2
    102a:	f0 91 f3 01 	lds	r31, 0x01F3
    102e:	86 81       	ldd	r24, Z+6	; 0x06
    1030:	97 81       	ldd	r25, Z+7	; 0x07
    1032:	9a 83       	std	Y+2, r25	; 0x02
    1034:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1036:	89 81       	ldd	r24, Y+1	; 0x01
    1038:	9a 81       	ldd	r25, Y+2	; 0x02
    103a:	0c 96       	adiw	r24, 0x0c	; 12
    103c:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>
		}
		portENABLE_INTERRUPTS();
    1040:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    1042:	89 81       	ldd	r24, Y+1	; 0x01
    1044:	9a 81       	ldd	r25, Y+2	; 0x02
    1046:	02 96       	adiw	r24, 0x02	; 2
    1048:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    104c:	e9 81       	ldd	r30, Y+1	; 0x01
    104e:	fa 81       	ldd	r31, Y+2	; 0x02
    1050:	96 89       	ldd	r25, Z+22	; 0x16
    1052:	80 91 be 01 	lds	r24, 0x01BE
    1056:	89 17       	cp	r24, r25
    1058:	28 f4       	brcc	.+10     	; 0x1064 <prvCheckPendingReadyList+0x4c>
    105a:	e9 81       	ldd	r30, Y+1	; 0x01
    105c:	fa 81       	ldd	r31, Y+2	; 0x02
    105e:	86 89       	ldd	r24, Z+22	; 0x16
    1060:	80 93 be 01 	sts	0x01BE, r24
    1064:	e9 81       	ldd	r30, Y+1	; 0x01
    1066:	fa 81       	ldd	r31, Y+2	; 0x02
    1068:	86 89       	ldd	r24, Z+22	; 0x16
    106a:	28 2f       	mov	r18, r24
    106c:	30 e0       	ldi	r19, 0x00	; 0
    106e:	c9 01       	movw	r24, r18
    1070:	88 0f       	add	r24, r24
    1072:	99 1f       	adc	r25, r25
    1074:	88 0f       	add	r24, r24
    1076:	99 1f       	adc	r25, r25
    1078:	88 0f       	add	r24, r24
    107a:	99 1f       	adc	r25, r25
    107c:	82 0f       	add	r24, r18
    107e:	93 1f       	adc	r25, r19
    1080:	ac 01       	movw	r20, r24
    1082:	4b 53       	subi	r20, 0x3B	; 59
    1084:	5e 4f       	sbci	r21, 0xFE	; 254
    1086:	89 81       	ldd	r24, Y+1	; 0x01
    1088:	9a 81       	ldd	r25, Y+2	; 0x02
    108a:	9c 01       	movw	r18, r24
    108c:	2e 5f       	subi	r18, 0xFE	; 254
    108e:	3f 4f       	sbci	r19, 0xFF	; 255
    1090:	ca 01       	movw	r24, r20
    1092:	b9 01       	movw	r22, r18
    1094:	0e 94 95 0a 	call	0x152a	; 0x152a <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1098:	80 91 ed 01 	lds	r24, 0x01ED
    109c:	88 23       	and	r24, r24
    109e:	09 f0       	breq	.+2      	; 0x10a2 <prvCheckPendingReadyList+0x8a>
    10a0:	c1 cf       	rjmp	.-126    	; 0x1024 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    10a2:	0f 90       	pop	r0
    10a4:	0f 90       	pop	r0
    10a6:	cf 91       	pop	r28
    10a8:	df 91       	pop	r29
    10aa:	08 95       	ret

000010ac <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    10ac:	df 93       	push	r29
    10ae:	cf 93       	push	r28
    10b0:	00 d0       	rcall	.+0      	; 0x10b2 <prvCheckDelayedList+0x6>
    10b2:	00 d0       	rcall	.+0      	; 0x10b4 <prvCheckDelayedList+0x8>
    10b4:	cd b7       	in	r28, 0x3d	; 61
    10b6:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    10b8:	0e 94 c6 17 	call	0x2f8c	; 0x2f8c <xTaskGetTickCount>
    10bc:	20 91 c1 01 	lds	r18, 0x01C1
    10c0:	30 91 c2 01 	lds	r19, 0x01C2
    10c4:	82 1b       	sub	r24, r18
    10c6:	93 0b       	sbc	r25, r19
    10c8:	90 93 c4 01 	sts	0x01C4, r25
    10cc:	80 93 c3 01 	sts	0x01C3, r24
    10d0:	85 c0       	rjmp	.+266    	; 0x11dc <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    10d2:	80 91 bf 01 	lds	r24, 0x01BF
    10d6:	90 91 c0 01 	lds	r25, 0x01C0
    10da:	01 96       	adiw	r24, 0x01	; 1
    10dc:	90 93 c0 01 	sts	0x01C0, r25
    10e0:	80 93 bf 01 	sts	0x01BF, r24
		xPassedTicks--;
    10e4:	80 91 c3 01 	lds	r24, 0x01C3
    10e8:	90 91 c4 01 	lds	r25, 0x01C4
    10ec:	01 97       	sbiw	r24, 0x01	; 1
    10ee:	90 93 c4 01 	sts	0x01C4, r25
    10f2:	80 93 c3 01 	sts	0x01C3, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    10f6:	80 91 bf 01 	lds	r24, 0x01BF
    10fa:	90 91 c0 01 	lds	r25, 0x01C0
    10fe:	00 97       	sbiw	r24, 0x00	; 0
    1100:	09 f0       	breq	.+2      	; 0x1104 <prvCheckDelayedList+0x58>
    1102:	64 c0       	rjmp	.+200    	; 0x11cc <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    1104:	80 91 e9 01 	lds	r24, 0x01E9
    1108:	90 91 ea 01 	lds	r25, 0x01EA
    110c:	9a 83       	std	Y+2, r25	; 0x02
    110e:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    1110:	80 91 eb 01 	lds	r24, 0x01EB
    1114:	90 91 ec 01 	lds	r25, 0x01EC
    1118:	90 93 ea 01 	sts	0x01EA, r25
    111c:	80 93 e9 01 	sts	0x01E9, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    1120:	89 81       	ldd	r24, Y+1	; 0x01
    1122:	9a 81       	ldd	r25, Y+2	; 0x02
    1124:	90 93 ec 01 	sts	0x01EC, r25
    1128:	80 93 eb 01 	sts	0x01EB, r24
    112c:	4f c0       	rjmp	.+158    	; 0x11cc <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    112e:	e0 91 e9 01 	lds	r30, 0x01E9
    1132:	f0 91 ea 01 	lds	r31, 0x01EA
    1136:	05 80       	ldd	r0, Z+5	; 0x05
    1138:	f6 81       	ldd	r31, Z+6	; 0x06
    113a:	e0 2d       	mov	r30, r0
    113c:	86 81       	ldd	r24, Z+6	; 0x06
    113e:	97 81       	ldd	r25, Z+7	; 0x07
    1140:	9c 83       	std	Y+4, r25	; 0x04
    1142:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    1144:	eb 81       	ldd	r30, Y+3	; 0x03
    1146:	fc 81       	ldd	r31, Y+4	; 0x04
    1148:	22 81       	ldd	r18, Z+2	; 0x02
    114a:	33 81       	ldd	r19, Z+3	; 0x03
    114c:	80 91 bf 01 	lds	r24, 0x01BF
    1150:	90 91 c0 01 	lds	r25, 0x01C0
    1154:	82 17       	cp	r24, r18
    1156:	93 07       	cpc	r25, r19
    1158:	08 f4       	brcc	.+2      	; 0x115c <prvCheckDelayedList+0xb0>
    115a:	40 c0       	rjmp	.+128    	; 0x11dc <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    115c:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    115e:	8b 81       	ldd	r24, Y+3	; 0x03
    1160:	9c 81       	ldd	r25, Y+4	; 0x04
    1162:	02 96       	adiw	r24, 0x02	; 2
    1164:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    1168:	eb 81       	ldd	r30, Y+3	; 0x03
    116a:	fc 81       	ldd	r31, Y+4	; 0x04
    116c:	84 89       	ldd	r24, Z+20	; 0x14
    116e:	95 89       	ldd	r25, Z+21	; 0x15
    1170:	00 97       	sbiw	r24, 0x00	; 0
    1172:	29 f0       	breq	.+10     	; 0x117e <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    1174:	8b 81       	ldd	r24, Y+3	; 0x03
    1176:	9c 81       	ldd	r25, Y+4	; 0x04
    1178:	0c 96       	adiw	r24, 0x0c	; 12
    117a:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    117e:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    1180:	eb 81       	ldd	r30, Y+3	; 0x03
    1182:	fc 81       	ldd	r31, Y+4	; 0x04
    1184:	96 89       	ldd	r25, Z+22	; 0x16
    1186:	80 91 be 01 	lds	r24, 0x01BE
    118a:	89 17       	cp	r24, r25
    118c:	28 f4       	brcc	.+10     	; 0x1198 <prvCheckDelayedList+0xec>
    118e:	eb 81       	ldd	r30, Y+3	; 0x03
    1190:	fc 81       	ldd	r31, Y+4	; 0x04
    1192:	86 89       	ldd	r24, Z+22	; 0x16
    1194:	80 93 be 01 	sts	0x01BE, r24
    1198:	eb 81       	ldd	r30, Y+3	; 0x03
    119a:	fc 81       	ldd	r31, Y+4	; 0x04
    119c:	86 89       	ldd	r24, Z+22	; 0x16
    119e:	28 2f       	mov	r18, r24
    11a0:	30 e0       	ldi	r19, 0x00	; 0
    11a2:	c9 01       	movw	r24, r18
    11a4:	88 0f       	add	r24, r24
    11a6:	99 1f       	adc	r25, r25
    11a8:	88 0f       	add	r24, r24
    11aa:	99 1f       	adc	r25, r25
    11ac:	88 0f       	add	r24, r24
    11ae:	99 1f       	adc	r25, r25
    11b0:	82 0f       	add	r24, r18
    11b2:	93 1f       	adc	r25, r19
    11b4:	ac 01       	movw	r20, r24
    11b6:	4b 53       	subi	r20, 0x3B	; 59
    11b8:	5e 4f       	sbci	r21, 0xFE	; 254
    11ba:	8b 81       	ldd	r24, Y+3	; 0x03
    11bc:	9c 81       	ldd	r25, Y+4	; 0x04
    11be:	9c 01       	movw	r18, r24
    11c0:	2e 5f       	subi	r18, 0xFE	; 254
    11c2:	3f 4f       	sbci	r19, 0xFF	; 255
    11c4:	ca 01       	movw	r24, r20
    11c6:	b9 01       	movw	r22, r18
    11c8:	0e 94 95 0a 	call	0x152a	; 0x152a <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    11cc:	e0 91 e9 01 	lds	r30, 0x01E9
    11d0:	f0 91 ea 01 	lds	r31, 0x01EA
    11d4:	80 81       	ld	r24, Z
    11d6:	88 23       	and	r24, r24
    11d8:	09 f0       	breq	.+2      	; 0x11dc <prvCheckDelayedList+0x130>
    11da:	a9 cf       	rjmp	.-174    	; 0x112e <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    11dc:	80 91 c3 01 	lds	r24, 0x01C3
    11e0:	90 91 c4 01 	lds	r25, 0x01C4
    11e4:	00 97       	sbiw	r24, 0x00	; 0
    11e6:	09 f0       	breq	.+2      	; 0x11ea <prvCheckDelayedList+0x13e>
    11e8:	74 cf       	rjmp	.-280    	; 0x10d2 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    11ea:	80 91 bf 01 	lds	r24, 0x01BF
    11ee:	90 91 c0 01 	lds	r25, 0x01C0
    11f2:	90 93 c2 01 	sts	0x01C2, r25
    11f6:	80 93 c1 01 	sts	0x01C1, r24
}
    11fa:	0f 90       	pop	r0
    11fc:	0f 90       	pop	r0
    11fe:	0f 90       	pop	r0
    1200:	0f 90       	pop	r0
    1202:	cf 91       	pop	r28
    1204:	df 91       	pop	r29
    1206:	08 95       	ret

00001208 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    1208:	df 93       	push	r29
    120a:	cf 93       	push	r28
    120c:	00 d0       	rcall	.+0      	; 0x120e <vCoRoutineSchedule+0x6>
    120e:	cd b7       	in	r28, 0x3d	; 61
    1210:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    1212:	0e 94 0c 08 	call	0x1018	; 0x1018 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    1216:	0e 94 56 08 	call	0x10ac	; 0x10ac <prvCheckDelayedList>
    121a:	0a c0       	rjmp	.+20     	; 0x1230 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    121c:	80 91 be 01 	lds	r24, 0x01BE
    1220:	88 23       	and	r24, r24
    1222:	09 f4       	brne	.+2      	; 0x1226 <vCoRoutineSchedule+0x1e>
    1224:	66 c0       	rjmp	.+204    	; 0x12f2 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    1226:	80 91 be 01 	lds	r24, 0x01BE
    122a:	81 50       	subi	r24, 0x01	; 1
    122c:	80 93 be 01 	sts	0x01BE, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1230:	80 91 be 01 	lds	r24, 0x01BE
    1234:	28 2f       	mov	r18, r24
    1236:	30 e0       	ldi	r19, 0x00	; 0
    1238:	c9 01       	movw	r24, r18
    123a:	88 0f       	add	r24, r24
    123c:	99 1f       	adc	r25, r25
    123e:	88 0f       	add	r24, r24
    1240:	99 1f       	adc	r25, r25
    1242:	88 0f       	add	r24, r24
    1244:	99 1f       	adc	r25, r25
    1246:	82 0f       	add	r24, r18
    1248:	93 1f       	adc	r25, r19
    124a:	fc 01       	movw	r30, r24
    124c:	eb 53       	subi	r30, 0x3B	; 59
    124e:	fe 4f       	sbci	r31, 0xFE	; 254
    1250:	80 81       	ld	r24, Z
    1252:	88 23       	and	r24, r24
    1254:	19 f3       	breq	.-58     	; 0x121c <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    1256:	80 91 be 01 	lds	r24, 0x01BE
    125a:	28 2f       	mov	r18, r24
    125c:	30 e0       	ldi	r19, 0x00	; 0
    125e:	c9 01       	movw	r24, r18
    1260:	88 0f       	add	r24, r24
    1262:	99 1f       	adc	r25, r25
    1264:	88 0f       	add	r24, r24
    1266:	99 1f       	adc	r25, r25
    1268:	88 0f       	add	r24, r24
    126a:	99 1f       	adc	r25, r25
    126c:	82 0f       	add	r24, r18
    126e:	93 1f       	adc	r25, r19
    1270:	8b 53       	subi	r24, 0x3B	; 59
    1272:	9e 4f       	sbci	r25, 0xFE	; 254
    1274:	9a 83       	std	Y+2, r25	; 0x02
    1276:	89 83       	std	Y+1, r24	; 0x01
    1278:	e9 81       	ldd	r30, Y+1	; 0x01
    127a:	fa 81       	ldd	r31, Y+2	; 0x02
    127c:	01 80       	ldd	r0, Z+1	; 0x01
    127e:	f2 81       	ldd	r31, Z+2	; 0x02
    1280:	e0 2d       	mov	r30, r0
    1282:	82 81       	ldd	r24, Z+2	; 0x02
    1284:	93 81       	ldd	r25, Z+3	; 0x03
    1286:	e9 81       	ldd	r30, Y+1	; 0x01
    1288:	fa 81       	ldd	r31, Y+2	; 0x02
    128a:	92 83       	std	Z+2, r25	; 0x02
    128c:	81 83       	std	Z+1, r24	; 0x01
    128e:	e9 81       	ldd	r30, Y+1	; 0x01
    1290:	fa 81       	ldd	r31, Y+2	; 0x02
    1292:	21 81       	ldd	r18, Z+1	; 0x01
    1294:	32 81       	ldd	r19, Z+2	; 0x02
    1296:	89 81       	ldd	r24, Y+1	; 0x01
    1298:	9a 81       	ldd	r25, Y+2	; 0x02
    129a:	03 96       	adiw	r24, 0x03	; 3
    129c:	28 17       	cp	r18, r24
    129e:	39 07       	cpc	r19, r25
    12a0:	59 f4       	brne	.+22     	; 0x12b8 <vCoRoutineSchedule+0xb0>
    12a2:	e9 81       	ldd	r30, Y+1	; 0x01
    12a4:	fa 81       	ldd	r31, Y+2	; 0x02
    12a6:	01 80       	ldd	r0, Z+1	; 0x01
    12a8:	f2 81       	ldd	r31, Z+2	; 0x02
    12aa:	e0 2d       	mov	r30, r0
    12ac:	82 81       	ldd	r24, Z+2	; 0x02
    12ae:	93 81       	ldd	r25, Z+3	; 0x03
    12b0:	e9 81       	ldd	r30, Y+1	; 0x01
    12b2:	fa 81       	ldd	r31, Y+2	; 0x02
    12b4:	92 83       	std	Z+2, r25	; 0x02
    12b6:	81 83       	std	Z+1, r24	; 0x01
    12b8:	e9 81       	ldd	r30, Y+1	; 0x01
    12ba:	fa 81       	ldd	r31, Y+2	; 0x02
    12bc:	01 80       	ldd	r0, Z+1	; 0x01
    12be:	f2 81       	ldd	r31, Z+2	; 0x02
    12c0:	e0 2d       	mov	r30, r0
    12c2:	86 81       	ldd	r24, Z+6	; 0x06
    12c4:	97 81       	ldd	r25, Z+7	; 0x07
    12c6:	90 93 bd 01 	sts	0x01BD, r25
    12ca:	80 93 bc 01 	sts	0x01BC, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    12ce:	e0 91 bc 01 	lds	r30, 0x01BC
    12d2:	f0 91 bd 01 	lds	r31, 0x01BD
    12d6:	40 81       	ld	r20, Z
    12d8:	51 81       	ldd	r21, Z+1	; 0x01
    12da:	80 91 bc 01 	lds	r24, 0x01BC
    12de:	90 91 bd 01 	lds	r25, 0x01BD
    12e2:	e0 91 bc 01 	lds	r30, 0x01BC
    12e6:	f0 91 bd 01 	lds	r31, 0x01BD
    12ea:	27 89       	ldd	r18, Z+23	; 0x17
    12ec:	62 2f       	mov	r22, r18
    12ee:	fa 01       	movw	r30, r20
    12f0:	09 95       	icall

	return;
}
    12f2:	0f 90       	pop	r0
    12f4:	0f 90       	pop	r0
    12f6:	cf 91       	pop	r28
    12f8:	df 91       	pop	r29
    12fa:	08 95       	ret

000012fc <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    12fc:	df 93       	push	r29
    12fe:	cf 93       	push	r28
    1300:	0f 92       	push	r0
    1302:	cd b7       	in	r28, 0x3d	; 61
    1304:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    1306:	19 82       	std	Y+1, r1	; 0x01
    1308:	13 c0       	rjmp	.+38     	; 0x1330 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    130a:	89 81       	ldd	r24, Y+1	; 0x01
    130c:	28 2f       	mov	r18, r24
    130e:	30 e0       	ldi	r19, 0x00	; 0
    1310:	c9 01       	movw	r24, r18
    1312:	88 0f       	add	r24, r24
    1314:	99 1f       	adc	r25, r25
    1316:	88 0f       	add	r24, r24
    1318:	99 1f       	adc	r25, r25
    131a:	88 0f       	add	r24, r24
    131c:	99 1f       	adc	r25, r25
    131e:	82 0f       	add	r24, r18
    1320:	93 1f       	adc	r25, r19
    1322:	8b 53       	subi	r24, 0x3B	; 59
    1324:	9e 4f       	sbci	r25, 0xFE	; 254
    1326:	0e 94 5b 0a 	call	0x14b6	; 0x14b6 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    132a:	89 81       	ldd	r24, Y+1	; 0x01
    132c:	8f 5f       	subi	r24, 0xFF	; 255
    132e:	89 83       	std	Y+1, r24	; 0x01
    1330:	89 81       	ldd	r24, Y+1	; 0x01
    1332:	82 30       	cpi	r24, 0x02	; 2
    1334:	50 f3       	brcs	.-44     	; 0x130a <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    1336:	87 ed       	ldi	r24, 0xD7	; 215
    1338:	91 e0       	ldi	r25, 0x01	; 1
    133a:	0e 94 5b 0a 	call	0x14b6	; 0x14b6 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    133e:	80 ee       	ldi	r24, 0xE0	; 224
    1340:	91 e0       	ldi	r25, 0x01	; 1
    1342:	0e 94 5b 0a 	call	0x14b6	; 0x14b6 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    1346:	8d ee       	ldi	r24, 0xED	; 237
    1348:	91 e0       	ldi	r25, 0x01	; 1
    134a:	0e 94 5b 0a 	call	0x14b6	; 0x14b6 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    134e:	87 ed       	ldi	r24, 0xD7	; 215
    1350:	91 e0       	ldi	r25, 0x01	; 1
    1352:	90 93 ea 01 	sts	0x01EA, r25
    1356:	80 93 e9 01 	sts	0x01E9, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    135a:	80 ee       	ldi	r24, 0xE0	; 224
    135c:	91 e0       	ldi	r25, 0x01	; 1
    135e:	90 93 ec 01 	sts	0x01EC, r25
    1362:	80 93 eb 01 	sts	0x01EB, r24
}
    1366:	0f 90       	pop	r0
    1368:	cf 91       	pop	r28
    136a:	df 91       	pop	r29
    136c:	08 95       	ret

0000136e <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    136e:	df 93       	push	r29
    1370:	cf 93       	push	r28
    1372:	00 d0       	rcall	.+0      	; 0x1374 <xCoRoutineRemoveFromEventList+0x6>
    1374:	00 d0       	rcall	.+0      	; 0x1376 <xCoRoutineRemoveFromEventList+0x8>
    1376:	0f 92       	push	r0
    1378:	cd b7       	in	r28, 0x3d	; 61
    137a:	de b7       	in	r29, 0x3e	; 62
    137c:	9d 83       	std	Y+5, r25	; 0x05
    137e:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1380:	ec 81       	ldd	r30, Y+4	; 0x04
    1382:	fd 81       	ldd	r31, Y+5	; 0x05
    1384:	05 80       	ldd	r0, Z+5	; 0x05
    1386:	f6 81       	ldd	r31, Z+6	; 0x06
    1388:	e0 2d       	mov	r30, r0
    138a:	86 81       	ldd	r24, Z+6	; 0x06
    138c:	97 81       	ldd	r25, Z+7	; 0x07
    138e:	9b 83       	std	Y+3, r25	; 0x03
    1390:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1392:	8a 81       	ldd	r24, Y+2	; 0x02
    1394:	9b 81       	ldd	r25, Y+3	; 0x03
    1396:	0c 96       	adiw	r24, 0x0c	; 12
    1398:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    139c:	8a 81       	ldd	r24, Y+2	; 0x02
    139e:	9b 81       	ldd	r25, Y+3	; 0x03
    13a0:	9c 01       	movw	r18, r24
    13a2:	24 5f       	subi	r18, 0xF4	; 244
    13a4:	3f 4f       	sbci	r19, 0xFF	; 255
    13a6:	8d ee       	ldi	r24, 0xED	; 237
    13a8:	91 e0       	ldi	r25, 0x01	; 1
    13aa:	b9 01       	movw	r22, r18
    13ac:	0e 94 95 0a 	call	0x152a	; 0x152a <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    13b0:	ea 81       	ldd	r30, Y+2	; 0x02
    13b2:	fb 81       	ldd	r31, Y+3	; 0x03
    13b4:	96 89       	ldd	r25, Z+22	; 0x16
    13b6:	e0 91 bc 01 	lds	r30, 0x01BC
    13ba:	f0 91 bd 01 	lds	r31, 0x01BD
    13be:	86 89       	ldd	r24, Z+22	; 0x16
    13c0:	98 17       	cp	r25, r24
    13c2:	18 f0       	brcs	.+6      	; 0x13ca <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    13c4:	81 e0       	ldi	r24, 0x01	; 1
    13c6:	89 83       	std	Y+1, r24	; 0x01
    13c8:	01 c0       	rjmp	.+2      	; 0x13cc <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    13ca:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    13cc:	89 81       	ldd	r24, Y+1	; 0x01
}
    13ce:	0f 90       	pop	r0
    13d0:	0f 90       	pop	r0
    13d2:	0f 90       	pop	r0
    13d4:	0f 90       	pop	r0
    13d6:	0f 90       	pop	r0
    13d8:	cf 91       	pop	r28
    13da:	df 91       	pop	r29
    13dc:	08 95       	ret

000013de <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    13de:	df 93       	push	r29
    13e0:	cf 93       	push	r28
    13e2:	00 d0       	rcall	.+0      	; 0x13e4 <pvPortMalloc+0x6>
    13e4:	00 d0       	rcall	.+0      	; 0x13e6 <pvPortMalloc+0x8>
    13e6:	cd b7       	in	r28, 0x3d	; 61
    13e8:	de b7       	in	r29, 0x3e	; 62
    13ea:	9c 83       	std	Y+4, r25	; 0x04
    13ec:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    13ee:	1a 82       	std	Y+2, r1	; 0x02
    13f0:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    13f2:	0e 94 32 17 	call	0x2e64	; 0x2e64 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    13f6:	80 91 f6 01 	lds	r24, 0x01F6
    13fa:	90 91 f7 01 	lds	r25, 0x01F7
    13fe:	2b 81       	ldd	r18, Y+3	; 0x03
    1400:	3c 81       	ldd	r19, Y+4	; 0x04
    1402:	82 0f       	add	r24, r18
    1404:	93 1f       	adc	r25, r19
    1406:	24 e0       	ldi	r18, 0x04	; 4
    1408:	80 3b       	cpi	r24, 0xB0	; 176
    140a:	92 07       	cpc	r25, r18
    140c:	18 f5       	brcc	.+70     	; 0x1454 <pvPortMalloc+0x76>
    140e:	20 91 f6 01 	lds	r18, 0x01F6
    1412:	30 91 f7 01 	lds	r19, 0x01F7
    1416:	8b 81       	ldd	r24, Y+3	; 0x03
    1418:	9c 81       	ldd	r25, Y+4	; 0x04
    141a:	28 0f       	add	r18, r24
    141c:	39 1f       	adc	r19, r25
    141e:	80 91 f6 01 	lds	r24, 0x01F6
    1422:	90 91 f7 01 	lds	r25, 0x01F7
    1426:	82 17       	cp	r24, r18
    1428:	93 07       	cpc	r25, r19
    142a:	a0 f4       	brcc	.+40     	; 0x1454 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    142c:	80 91 f6 01 	lds	r24, 0x01F6
    1430:	90 91 f7 01 	lds	r25, 0x01F7
    1434:	88 50       	subi	r24, 0x08	; 8
    1436:	9e 4f       	sbci	r25, 0xFE	; 254
    1438:	9a 83       	std	Y+2, r25	; 0x02
    143a:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    143c:	20 91 f6 01 	lds	r18, 0x01F6
    1440:	30 91 f7 01 	lds	r19, 0x01F7
    1444:	8b 81       	ldd	r24, Y+3	; 0x03
    1446:	9c 81       	ldd	r25, Y+4	; 0x04
    1448:	82 0f       	add	r24, r18
    144a:	93 1f       	adc	r25, r19
    144c:	90 93 f7 01 	sts	0x01F7, r25
    1450:	80 93 f6 01 	sts	0x01F6, r24
		}	
	}
	xTaskResumeAll();
    1454:	0e 94 3e 17 	call	0x2e7c	; 0x2e7c <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    1458:	89 81       	ldd	r24, Y+1	; 0x01
    145a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    145c:	0f 90       	pop	r0
    145e:	0f 90       	pop	r0
    1460:	0f 90       	pop	r0
    1462:	0f 90       	pop	r0
    1464:	cf 91       	pop	r28
    1466:	df 91       	pop	r29
    1468:	08 95       	ret

0000146a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    146a:	df 93       	push	r29
    146c:	cf 93       	push	r28
    146e:	00 d0       	rcall	.+0      	; 0x1470 <vPortFree+0x6>
    1470:	cd b7       	in	r28, 0x3d	; 61
    1472:	de b7       	in	r29, 0x3e	; 62
    1474:	9a 83       	std	Y+2, r25	; 0x02
    1476:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    1478:	0f 90       	pop	r0
    147a:	0f 90       	pop	r0
    147c:	cf 91       	pop	r28
    147e:	df 91       	pop	r29
    1480:	08 95       	ret

00001482 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    1482:	df 93       	push	r29
    1484:	cf 93       	push	r28
    1486:	cd b7       	in	r28, 0x3d	; 61
    1488:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    148a:	10 92 f7 01 	sts	0x01F7, r1
    148e:	10 92 f6 01 	sts	0x01F6, r1
}
    1492:	cf 91       	pop	r28
    1494:	df 91       	pop	r29
    1496:	08 95       	ret

00001498 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    1498:	df 93       	push	r29
    149a:	cf 93       	push	r28
    149c:	cd b7       	in	r28, 0x3d	; 61
    149e:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    14a0:	20 91 f6 01 	lds	r18, 0x01F6
    14a4:	30 91 f7 01 	lds	r19, 0x01F7
    14a8:	80 eb       	ldi	r24, 0xB0	; 176
    14aa:	94 e0       	ldi	r25, 0x04	; 4
    14ac:	82 1b       	sub	r24, r18
    14ae:	93 0b       	sbc	r25, r19
}
    14b0:	cf 91       	pop	r28
    14b2:	df 91       	pop	r29
    14b4:	08 95       	ret

000014b6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    14b6:	df 93       	push	r29
    14b8:	cf 93       	push	r28
    14ba:	00 d0       	rcall	.+0      	; 0x14bc <vListInitialise+0x6>
    14bc:	cd b7       	in	r28, 0x3d	; 61
    14be:	de b7       	in	r29, 0x3e	; 62
    14c0:	9a 83       	std	Y+2, r25	; 0x02
    14c2:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    14c4:	89 81       	ldd	r24, Y+1	; 0x01
    14c6:	9a 81       	ldd	r25, Y+2	; 0x02
    14c8:	03 96       	adiw	r24, 0x03	; 3
    14ca:	e9 81       	ldd	r30, Y+1	; 0x01
    14cc:	fa 81       	ldd	r31, Y+2	; 0x02
    14ce:	92 83       	std	Z+2, r25	; 0x02
    14d0:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    14d2:	e9 81       	ldd	r30, Y+1	; 0x01
    14d4:	fa 81       	ldd	r31, Y+2	; 0x02
    14d6:	8f ef       	ldi	r24, 0xFF	; 255
    14d8:	9f ef       	ldi	r25, 0xFF	; 255
    14da:	94 83       	std	Z+4, r25	; 0x04
    14dc:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    14de:	89 81       	ldd	r24, Y+1	; 0x01
    14e0:	9a 81       	ldd	r25, Y+2	; 0x02
    14e2:	03 96       	adiw	r24, 0x03	; 3
    14e4:	e9 81       	ldd	r30, Y+1	; 0x01
    14e6:	fa 81       	ldd	r31, Y+2	; 0x02
    14e8:	96 83       	std	Z+6, r25	; 0x06
    14ea:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    14ec:	89 81       	ldd	r24, Y+1	; 0x01
    14ee:	9a 81       	ldd	r25, Y+2	; 0x02
    14f0:	03 96       	adiw	r24, 0x03	; 3
    14f2:	e9 81       	ldd	r30, Y+1	; 0x01
    14f4:	fa 81       	ldd	r31, Y+2	; 0x02
    14f6:	90 87       	std	Z+8, r25	; 0x08
    14f8:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    14fa:	e9 81       	ldd	r30, Y+1	; 0x01
    14fc:	fa 81       	ldd	r31, Y+2	; 0x02
    14fe:	10 82       	st	Z, r1
}
    1500:	0f 90       	pop	r0
    1502:	0f 90       	pop	r0
    1504:	cf 91       	pop	r28
    1506:	df 91       	pop	r29
    1508:	08 95       	ret

0000150a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    150a:	df 93       	push	r29
    150c:	cf 93       	push	r28
    150e:	00 d0       	rcall	.+0      	; 0x1510 <vListInitialiseItem+0x6>
    1510:	cd b7       	in	r28, 0x3d	; 61
    1512:	de b7       	in	r29, 0x3e	; 62
    1514:	9a 83       	std	Y+2, r25	; 0x02
    1516:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1518:	e9 81       	ldd	r30, Y+1	; 0x01
    151a:	fa 81       	ldd	r31, Y+2	; 0x02
    151c:	11 86       	std	Z+9, r1	; 0x09
    151e:	10 86       	std	Z+8, r1	; 0x08
}
    1520:	0f 90       	pop	r0
    1522:	0f 90       	pop	r0
    1524:	cf 91       	pop	r28
    1526:	df 91       	pop	r29
    1528:	08 95       	ret

0000152a <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    152a:	df 93       	push	r29
    152c:	cf 93       	push	r28
    152e:	00 d0       	rcall	.+0      	; 0x1530 <vListInsertEnd+0x6>
    1530:	00 d0       	rcall	.+0      	; 0x1532 <vListInsertEnd+0x8>
    1532:	00 d0       	rcall	.+0      	; 0x1534 <vListInsertEnd+0xa>
    1534:	cd b7       	in	r28, 0x3d	; 61
    1536:	de b7       	in	r29, 0x3e	; 62
    1538:	9c 83       	std	Y+4, r25	; 0x04
    153a:	8b 83       	std	Y+3, r24	; 0x03
    153c:	7e 83       	std	Y+6, r23	; 0x06
    153e:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1540:	eb 81       	ldd	r30, Y+3	; 0x03
    1542:	fc 81       	ldd	r31, Y+4	; 0x04
    1544:	81 81       	ldd	r24, Z+1	; 0x01
    1546:	92 81       	ldd	r25, Z+2	; 0x02
    1548:	9a 83       	std	Y+2, r25	; 0x02
    154a:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    154c:	e9 81       	ldd	r30, Y+1	; 0x01
    154e:	fa 81       	ldd	r31, Y+2	; 0x02
    1550:	82 81       	ldd	r24, Z+2	; 0x02
    1552:	93 81       	ldd	r25, Z+3	; 0x03
    1554:	ed 81       	ldd	r30, Y+5	; 0x05
    1556:	fe 81       	ldd	r31, Y+6	; 0x06
    1558:	93 83       	std	Z+3, r25	; 0x03
    155a:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    155c:	eb 81       	ldd	r30, Y+3	; 0x03
    155e:	fc 81       	ldd	r31, Y+4	; 0x04
    1560:	81 81       	ldd	r24, Z+1	; 0x01
    1562:	92 81       	ldd	r25, Z+2	; 0x02
    1564:	ed 81       	ldd	r30, Y+5	; 0x05
    1566:	fe 81       	ldd	r31, Y+6	; 0x06
    1568:	95 83       	std	Z+5, r25	; 0x05
    156a:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    156c:	e9 81       	ldd	r30, Y+1	; 0x01
    156e:	fa 81       	ldd	r31, Y+2	; 0x02
    1570:	02 80       	ldd	r0, Z+2	; 0x02
    1572:	f3 81       	ldd	r31, Z+3	; 0x03
    1574:	e0 2d       	mov	r30, r0
    1576:	8d 81       	ldd	r24, Y+5	; 0x05
    1578:	9e 81       	ldd	r25, Y+6	; 0x06
    157a:	95 83       	std	Z+5, r25	; 0x05
    157c:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    157e:	8d 81       	ldd	r24, Y+5	; 0x05
    1580:	9e 81       	ldd	r25, Y+6	; 0x06
    1582:	e9 81       	ldd	r30, Y+1	; 0x01
    1584:	fa 81       	ldd	r31, Y+2	; 0x02
    1586:	93 83       	std	Z+3, r25	; 0x03
    1588:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    158a:	8d 81       	ldd	r24, Y+5	; 0x05
    158c:	9e 81       	ldd	r25, Y+6	; 0x06
    158e:	eb 81       	ldd	r30, Y+3	; 0x03
    1590:	fc 81       	ldd	r31, Y+4	; 0x04
    1592:	92 83       	std	Z+2, r25	; 0x02
    1594:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1596:	ed 81       	ldd	r30, Y+5	; 0x05
    1598:	fe 81       	ldd	r31, Y+6	; 0x06
    159a:	8b 81       	ldd	r24, Y+3	; 0x03
    159c:	9c 81       	ldd	r25, Y+4	; 0x04
    159e:	91 87       	std	Z+9, r25	; 0x09
    15a0:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    15a2:	eb 81       	ldd	r30, Y+3	; 0x03
    15a4:	fc 81       	ldd	r31, Y+4	; 0x04
    15a6:	80 81       	ld	r24, Z
    15a8:	8f 5f       	subi	r24, 0xFF	; 255
    15aa:	eb 81       	ldd	r30, Y+3	; 0x03
    15ac:	fc 81       	ldd	r31, Y+4	; 0x04
    15ae:	80 83       	st	Z, r24
}
    15b0:	26 96       	adiw	r28, 0x06	; 6
    15b2:	0f b6       	in	r0, 0x3f	; 63
    15b4:	f8 94       	cli
    15b6:	de bf       	out	0x3e, r29	; 62
    15b8:	0f be       	out	0x3f, r0	; 63
    15ba:	cd bf       	out	0x3d, r28	; 61
    15bc:	cf 91       	pop	r28
    15be:	df 91       	pop	r29
    15c0:	08 95       	ret

000015c2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    15c2:	df 93       	push	r29
    15c4:	cf 93       	push	r28
    15c6:	cd b7       	in	r28, 0x3d	; 61
    15c8:	de b7       	in	r29, 0x3e	; 62
    15ca:	28 97       	sbiw	r28, 0x08	; 8
    15cc:	0f b6       	in	r0, 0x3f	; 63
    15ce:	f8 94       	cli
    15d0:	de bf       	out	0x3e, r29	; 62
    15d2:	0f be       	out	0x3f, r0	; 63
    15d4:	cd bf       	out	0x3d, r28	; 61
    15d6:	9e 83       	std	Y+6, r25	; 0x06
    15d8:	8d 83       	std	Y+5, r24	; 0x05
    15da:	78 87       	std	Y+8, r23	; 0x08
    15dc:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    15de:	ef 81       	ldd	r30, Y+7	; 0x07
    15e0:	f8 85       	ldd	r31, Y+8	; 0x08
    15e2:	80 81       	ld	r24, Z
    15e4:	91 81       	ldd	r25, Z+1	; 0x01
    15e6:	9a 83       	std	Y+2, r25	; 0x02
    15e8:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    15ea:	89 81       	ldd	r24, Y+1	; 0x01
    15ec:	9a 81       	ldd	r25, Y+2	; 0x02
    15ee:	2f ef       	ldi	r18, 0xFF	; 255
    15f0:	8f 3f       	cpi	r24, 0xFF	; 255
    15f2:	92 07       	cpc	r25, r18
    15f4:	39 f4       	brne	.+14     	; 0x1604 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    15f6:	ed 81       	ldd	r30, Y+5	; 0x05
    15f8:	fe 81       	ldd	r31, Y+6	; 0x06
    15fa:	87 81       	ldd	r24, Z+7	; 0x07
    15fc:	90 85       	ldd	r25, Z+8	; 0x08
    15fe:	9c 83       	std	Y+4, r25	; 0x04
    1600:	8b 83       	std	Y+3, r24	; 0x03
    1602:	18 c0       	rjmp	.+48     	; 0x1634 <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1604:	8d 81       	ldd	r24, Y+5	; 0x05
    1606:	9e 81       	ldd	r25, Y+6	; 0x06
    1608:	03 96       	adiw	r24, 0x03	; 3
    160a:	9c 83       	std	Y+4, r25	; 0x04
    160c:	8b 83       	std	Y+3, r24	; 0x03
    160e:	06 c0       	rjmp	.+12     	; 0x161c <vListInsert+0x5a>
    1610:	eb 81       	ldd	r30, Y+3	; 0x03
    1612:	fc 81       	ldd	r31, Y+4	; 0x04
    1614:	82 81       	ldd	r24, Z+2	; 0x02
    1616:	93 81       	ldd	r25, Z+3	; 0x03
    1618:	9c 83       	std	Y+4, r25	; 0x04
    161a:	8b 83       	std	Y+3, r24	; 0x03
    161c:	eb 81       	ldd	r30, Y+3	; 0x03
    161e:	fc 81       	ldd	r31, Y+4	; 0x04
    1620:	02 80       	ldd	r0, Z+2	; 0x02
    1622:	f3 81       	ldd	r31, Z+3	; 0x03
    1624:	e0 2d       	mov	r30, r0
    1626:	20 81       	ld	r18, Z
    1628:	31 81       	ldd	r19, Z+1	; 0x01
    162a:	89 81       	ldd	r24, Y+1	; 0x01
    162c:	9a 81       	ldd	r25, Y+2	; 0x02
    162e:	82 17       	cp	r24, r18
    1630:	93 07       	cpc	r25, r19
    1632:	70 f7       	brcc	.-36     	; 0x1610 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1634:	eb 81       	ldd	r30, Y+3	; 0x03
    1636:	fc 81       	ldd	r31, Y+4	; 0x04
    1638:	82 81       	ldd	r24, Z+2	; 0x02
    163a:	93 81       	ldd	r25, Z+3	; 0x03
    163c:	ef 81       	ldd	r30, Y+7	; 0x07
    163e:	f8 85       	ldd	r31, Y+8	; 0x08
    1640:	93 83       	std	Z+3, r25	; 0x03
    1642:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1644:	ef 81       	ldd	r30, Y+7	; 0x07
    1646:	f8 85       	ldd	r31, Y+8	; 0x08
    1648:	02 80       	ldd	r0, Z+2	; 0x02
    164a:	f3 81       	ldd	r31, Z+3	; 0x03
    164c:	e0 2d       	mov	r30, r0
    164e:	8f 81       	ldd	r24, Y+7	; 0x07
    1650:	98 85       	ldd	r25, Y+8	; 0x08
    1652:	95 83       	std	Z+5, r25	; 0x05
    1654:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1656:	ef 81       	ldd	r30, Y+7	; 0x07
    1658:	f8 85       	ldd	r31, Y+8	; 0x08
    165a:	8b 81       	ldd	r24, Y+3	; 0x03
    165c:	9c 81       	ldd	r25, Y+4	; 0x04
    165e:	95 83       	std	Z+5, r25	; 0x05
    1660:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1662:	8f 81       	ldd	r24, Y+7	; 0x07
    1664:	98 85       	ldd	r25, Y+8	; 0x08
    1666:	eb 81       	ldd	r30, Y+3	; 0x03
    1668:	fc 81       	ldd	r31, Y+4	; 0x04
    166a:	93 83       	std	Z+3, r25	; 0x03
    166c:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    166e:	ef 81       	ldd	r30, Y+7	; 0x07
    1670:	f8 85       	ldd	r31, Y+8	; 0x08
    1672:	8d 81       	ldd	r24, Y+5	; 0x05
    1674:	9e 81       	ldd	r25, Y+6	; 0x06
    1676:	91 87       	std	Z+9, r25	; 0x09
    1678:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    167a:	ed 81       	ldd	r30, Y+5	; 0x05
    167c:	fe 81       	ldd	r31, Y+6	; 0x06
    167e:	80 81       	ld	r24, Z
    1680:	8f 5f       	subi	r24, 0xFF	; 255
    1682:	ed 81       	ldd	r30, Y+5	; 0x05
    1684:	fe 81       	ldd	r31, Y+6	; 0x06
    1686:	80 83       	st	Z, r24
}
    1688:	28 96       	adiw	r28, 0x08	; 8
    168a:	0f b6       	in	r0, 0x3f	; 63
    168c:	f8 94       	cli
    168e:	de bf       	out	0x3e, r29	; 62
    1690:	0f be       	out	0x3f, r0	; 63
    1692:	cd bf       	out	0x3d, r28	; 61
    1694:	cf 91       	pop	r28
    1696:	df 91       	pop	r29
    1698:	08 95       	ret

0000169a <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    169a:	df 93       	push	r29
    169c:	cf 93       	push	r28
    169e:	00 d0       	rcall	.+0      	; 0x16a0 <vListRemove+0x6>
    16a0:	00 d0       	rcall	.+0      	; 0x16a2 <vListRemove+0x8>
    16a2:	cd b7       	in	r28, 0x3d	; 61
    16a4:	de b7       	in	r29, 0x3e	; 62
    16a6:	9c 83       	std	Y+4, r25	; 0x04
    16a8:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    16aa:	eb 81       	ldd	r30, Y+3	; 0x03
    16ac:	fc 81       	ldd	r31, Y+4	; 0x04
    16ae:	a2 81       	ldd	r26, Z+2	; 0x02
    16b0:	b3 81       	ldd	r27, Z+3	; 0x03
    16b2:	eb 81       	ldd	r30, Y+3	; 0x03
    16b4:	fc 81       	ldd	r31, Y+4	; 0x04
    16b6:	84 81       	ldd	r24, Z+4	; 0x04
    16b8:	95 81       	ldd	r25, Z+5	; 0x05
    16ba:	15 96       	adiw	r26, 0x05	; 5
    16bc:	9c 93       	st	X, r25
    16be:	8e 93       	st	-X, r24
    16c0:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    16c2:	eb 81       	ldd	r30, Y+3	; 0x03
    16c4:	fc 81       	ldd	r31, Y+4	; 0x04
    16c6:	a4 81       	ldd	r26, Z+4	; 0x04
    16c8:	b5 81       	ldd	r27, Z+5	; 0x05
    16ca:	eb 81       	ldd	r30, Y+3	; 0x03
    16cc:	fc 81       	ldd	r31, Y+4	; 0x04
    16ce:	82 81       	ldd	r24, Z+2	; 0x02
    16d0:	93 81       	ldd	r25, Z+3	; 0x03
    16d2:	13 96       	adiw	r26, 0x03	; 3
    16d4:	9c 93       	st	X, r25
    16d6:	8e 93       	st	-X, r24
    16d8:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    16da:	eb 81       	ldd	r30, Y+3	; 0x03
    16dc:	fc 81       	ldd	r31, Y+4	; 0x04
    16de:	80 85       	ldd	r24, Z+8	; 0x08
    16e0:	91 85       	ldd	r25, Z+9	; 0x09
    16e2:	9a 83       	std	Y+2, r25	; 0x02
    16e4:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    16e6:	e9 81       	ldd	r30, Y+1	; 0x01
    16e8:	fa 81       	ldd	r31, Y+2	; 0x02
    16ea:	21 81       	ldd	r18, Z+1	; 0x01
    16ec:	32 81       	ldd	r19, Z+2	; 0x02
    16ee:	8b 81       	ldd	r24, Y+3	; 0x03
    16f0:	9c 81       	ldd	r25, Y+4	; 0x04
    16f2:	28 17       	cp	r18, r24
    16f4:	39 07       	cpc	r19, r25
    16f6:	41 f4       	brne	.+16     	; 0x1708 <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    16f8:	eb 81       	ldd	r30, Y+3	; 0x03
    16fa:	fc 81       	ldd	r31, Y+4	; 0x04
    16fc:	84 81       	ldd	r24, Z+4	; 0x04
    16fe:	95 81       	ldd	r25, Z+5	; 0x05
    1700:	e9 81       	ldd	r30, Y+1	; 0x01
    1702:	fa 81       	ldd	r31, Y+2	; 0x02
    1704:	92 83       	std	Z+2, r25	; 0x02
    1706:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    1708:	eb 81       	ldd	r30, Y+3	; 0x03
    170a:	fc 81       	ldd	r31, Y+4	; 0x04
    170c:	11 86       	std	Z+9, r1	; 0x09
    170e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1710:	e9 81       	ldd	r30, Y+1	; 0x01
    1712:	fa 81       	ldd	r31, Y+2	; 0x02
    1714:	80 81       	ld	r24, Z
    1716:	81 50       	subi	r24, 0x01	; 1
    1718:	e9 81       	ldd	r30, Y+1	; 0x01
    171a:	fa 81       	ldd	r31, Y+2	; 0x02
    171c:	80 83       	st	Z, r24
}
    171e:	0f 90       	pop	r0
    1720:	0f 90       	pop	r0
    1722:	0f 90       	pop	r0
    1724:	0f 90       	pop	r0
    1726:	cf 91       	pop	r28
    1728:	df 91       	pop	r29
    172a:	08 95       	ret

0000172c <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    172c:	df 93       	push	r29
    172e:	cf 93       	push	r28
    1730:	cd b7       	in	r28, 0x3d	; 61
    1732:	de b7       	in	r29, 0x3e	; 62
    1734:	28 97       	sbiw	r28, 0x08	; 8
    1736:	0f b6       	in	r0, 0x3f	; 63
    1738:	f8 94       	cli
    173a:	de bf       	out	0x3e, r29	; 62
    173c:	0f be       	out	0x3f, r0	; 63
    173e:	cd bf       	out	0x3d, r28	; 61
    1740:	9c 83       	std	Y+4, r25	; 0x04
    1742:	8b 83       	std	Y+3, r24	; 0x03
    1744:	7e 83       	std	Y+6, r23	; 0x06
    1746:	6d 83       	std	Y+5, r22	; 0x05
    1748:	58 87       	std	Y+8, r21	; 0x08
    174a:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    174c:	eb 81       	ldd	r30, Y+3	; 0x03
    174e:	fc 81       	ldd	r31, Y+4	; 0x04
    1750:	81 e1       	ldi	r24, 0x11	; 17
    1752:	80 83       	st	Z, r24
	pxTopOfStack--;
    1754:	8b 81       	ldd	r24, Y+3	; 0x03
    1756:	9c 81       	ldd	r25, Y+4	; 0x04
    1758:	01 97       	sbiw	r24, 0x01	; 1
    175a:	9c 83       	std	Y+4, r25	; 0x04
    175c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    175e:	eb 81       	ldd	r30, Y+3	; 0x03
    1760:	fc 81       	ldd	r31, Y+4	; 0x04
    1762:	82 e2       	ldi	r24, 0x22	; 34
    1764:	80 83       	st	Z, r24
	pxTopOfStack--;
    1766:	8b 81       	ldd	r24, Y+3	; 0x03
    1768:	9c 81       	ldd	r25, Y+4	; 0x04
    176a:	01 97       	sbiw	r24, 0x01	; 1
    176c:	9c 83       	std	Y+4, r25	; 0x04
    176e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    1770:	eb 81       	ldd	r30, Y+3	; 0x03
    1772:	fc 81       	ldd	r31, Y+4	; 0x04
    1774:	83 e3       	ldi	r24, 0x33	; 51
    1776:	80 83       	st	Z, r24
	pxTopOfStack--;
    1778:	8b 81       	ldd	r24, Y+3	; 0x03
    177a:	9c 81       	ldd	r25, Y+4	; 0x04
    177c:	01 97       	sbiw	r24, 0x01	; 1
    177e:	9c 83       	std	Y+4, r25	; 0x04
    1780:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    1782:	8d 81       	ldd	r24, Y+5	; 0x05
    1784:	9e 81       	ldd	r25, Y+6	; 0x06
    1786:	9a 83       	std	Y+2, r25	; 0x02
    1788:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    178a:	89 81       	ldd	r24, Y+1	; 0x01
    178c:	eb 81       	ldd	r30, Y+3	; 0x03
    178e:	fc 81       	ldd	r31, Y+4	; 0x04
    1790:	80 83       	st	Z, r24
	pxTopOfStack--;
    1792:	8b 81       	ldd	r24, Y+3	; 0x03
    1794:	9c 81       	ldd	r25, Y+4	; 0x04
    1796:	01 97       	sbiw	r24, 0x01	; 1
    1798:	9c 83       	std	Y+4, r25	; 0x04
    179a:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    179c:	89 81       	ldd	r24, Y+1	; 0x01
    179e:	9a 81       	ldd	r25, Y+2	; 0x02
    17a0:	89 2f       	mov	r24, r25
    17a2:	99 27       	eor	r25, r25
    17a4:	9a 83       	std	Y+2, r25	; 0x02
    17a6:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    17a8:	89 81       	ldd	r24, Y+1	; 0x01
    17aa:	eb 81       	ldd	r30, Y+3	; 0x03
    17ac:	fc 81       	ldd	r31, Y+4	; 0x04
    17ae:	80 83       	st	Z, r24
	pxTopOfStack--;
    17b0:	8b 81       	ldd	r24, Y+3	; 0x03
    17b2:	9c 81       	ldd	r25, Y+4	; 0x04
    17b4:	01 97       	sbiw	r24, 0x01	; 1
    17b6:	9c 83       	std	Y+4, r25	; 0x04
    17b8:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    17ba:	eb 81       	ldd	r30, Y+3	; 0x03
    17bc:	fc 81       	ldd	r31, Y+4	; 0x04
    17be:	10 82       	st	Z, r1
	pxTopOfStack--;
    17c0:	8b 81       	ldd	r24, Y+3	; 0x03
    17c2:	9c 81       	ldd	r25, Y+4	; 0x04
    17c4:	01 97       	sbiw	r24, 0x01	; 1
    17c6:	9c 83       	std	Y+4, r25	; 0x04
    17c8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    17ca:	eb 81       	ldd	r30, Y+3	; 0x03
    17cc:	fc 81       	ldd	r31, Y+4	; 0x04
    17ce:	80 e8       	ldi	r24, 0x80	; 128
    17d0:	80 83       	st	Z, r24
	pxTopOfStack--;
    17d2:	8b 81       	ldd	r24, Y+3	; 0x03
    17d4:	9c 81       	ldd	r25, Y+4	; 0x04
    17d6:	01 97       	sbiw	r24, 0x01	; 1
    17d8:	9c 83       	std	Y+4, r25	; 0x04
    17da:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    17dc:	eb 81       	ldd	r30, Y+3	; 0x03
    17de:	fc 81       	ldd	r31, Y+4	; 0x04
    17e0:	10 82       	st	Z, r1
	pxTopOfStack--;
    17e2:	8b 81       	ldd	r24, Y+3	; 0x03
    17e4:	9c 81       	ldd	r25, Y+4	; 0x04
    17e6:	01 97       	sbiw	r24, 0x01	; 1
    17e8:	9c 83       	std	Y+4, r25	; 0x04
    17ea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    17ec:	eb 81       	ldd	r30, Y+3	; 0x03
    17ee:	fc 81       	ldd	r31, Y+4	; 0x04
    17f0:	82 e0       	ldi	r24, 0x02	; 2
    17f2:	80 83       	st	Z, r24
	pxTopOfStack--;
    17f4:	8b 81       	ldd	r24, Y+3	; 0x03
    17f6:	9c 81       	ldd	r25, Y+4	; 0x04
    17f8:	01 97       	sbiw	r24, 0x01	; 1
    17fa:	9c 83       	std	Y+4, r25	; 0x04
    17fc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    17fe:	eb 81       	ldd	r30, Y+3	; 0x03
    1800:	fc 81       	ldd	r31, Y+4	; 0x04
    1802:	83 e0       	ldi	r24, 0x03	; 3
    1804:	80 83       	st	Z, r24
	pxTopOfStack--;
    1806:	8b 81       	ldd	r24, Y+3	; 0x03
    1808:	9c 81       	ldd	r25, Y+4	; 0x04
    180a:	01 97       	sbiw	r24, 0x01	; 1
    180c:	9c 83       	std	Y+4, r25	; 0x04
    180e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    1810:	eb 81       	ldd	r30, Y+3	; 0x03
    1812:	fc 81       	ldd	r31, Y+4	; 0x04
    1814:	84 e0       	ldi	r24, 0x04	; 4
    1816:	80 83       	st	Z, r24
	pxTopOfStack--;
    1818:	8b 81       	ldd	r24, Y+3	; 0x03
    181a:	9c 81       	ldd	r25, Y+4	; 0x04
    181c:	01 97       	sbiw	r24, 0x01	; 1
    181e:	9c 83       	std	Y+4, r25	; 0x04
    1820:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    1822:	eb 81       	ldd	r30, Y+3	; 0x03
    1824:	fc 81       	ldd	r31, Y+4	; 0x04
    1826:	85 e0       	ldi	r24, 0x05	; 5
    1828:	80 83       	st	Z, r24
	pxTopOfStack--;
    182a:	8b 81       	ldd	r24, Y+3	; 0x03
    182c:	9c 81       	ldd	r25, Y+4	; 0x04
    182e:	01 97       	sbiw	r24, 0x01	; 1
    1830:	9c 83       	std	Y+4, r25	; 0x04
    1832:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    1834:	eb 81       	ldd	r30, Y+3	; 0x03
    1836:	fc 81       	ldd	r31, Y+4	; 0x04
    1838:	86 e0       	ldi	r24, 0x06	; 6
    183a:	80 83       	st	Z, r24
	pxTopOfStack--;
    183c:	8b 81       	ldd	r24, Y+3	; 0x03
    183e:	9c 81       	ldd	r25, Y+4	; 0x04
    1840:	01 97       	sbiw	r24, 0x01	; 1
    1842:	9c 83       	std	Y+4, r25	; 0x04
    1844:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    1846:	eb 81       	ldd	r30, Y+3	; 0x03
    1848:	fc 81       	ldd	r31, Y+4	; 0x04
    184a:	87 e0       	ldi	r24, 0x07	; 7
    184c:	80 83       	st	Z, r24
	pxTopOfStack--;
    184e:	8b 81       	ldd	r24, Y+3	; 0x03
    1850:	9c 81       	ldd	r25, Y+4	; 0x04
    1852:	01 97       	sbiw	r24, 0x01	; 1
    1854:	9c 83       	std	Y+4, r25	; 0x04
    1856:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    1858:	eb 81       	ldd	r30, Y+3	; 0x03
    185a:	fc 81       	ldd	r31, Y+4	; 0x04
    185c:	88 e0       	ldi	r24, 0x08	; 8
    185e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1860:	8b 81       	ldd	r24, Y+3	; 0x03
    1862:	9c 81       	ldd	r25, Y+4	; 0x04
    1864:	01 97       	sbiw	r24, 0x01	; 1
    1866:	9c 83       	std	Y+4, r25	; 0x04
    1868:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    186a:	eb 81       	ldd	r30, Y+3	; 0x03
    186c:	fc 81       	ldd	r31, Y+4	; 0x04
    186e:	89 e0       	ldi	r24, 0x09	; 9
    1870:	80 83       	st	Z, r24
	pxTopOfStack--;
    1872:	8b 81       	ldd	r24, Y+3	; 0x03
    1874:	9c 81       	ldd	r25, Y+4	; 0x04
    1876:	01 97       	sbiw	r24, 0x01	; 1
    1878:	9c 83       	std	Y+4, r25	; 0x04
    187a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    187c:	eb 81       	ldd	r30, Y+3	; 0x03
    187e:	fc 81       	ldd	r31, Y+4	; 0x04
    1880:	80 e1       	ldi	r24, 0x10	; 16
    1882:	80 83       	st	Z, r24
	pxTopOfStack--;
    1884:	8b 81       	ldd	r24, Y+3	; 0x03
    1886:	9c 81       	ldd	r25, Y+4	; 0x04
    1888:	01 97       	sbiw	r24, 0x01	; 1
    188a:	9c 83       	std	Y+4, r25	; 0x04
    188c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    188e:	eb 81       	ldd	r30, Y+3	; 0x03
    1890:	fc 81       	ldd	r31, Y+4	; 0x04
    1892:	81 e1       	ldi	r24, 0x11	; 17
    1894:	80 83       	st	Z, r24
	pxTopOfStack--;
    1896:	8b 81       	ldd	r24, Y+3	; 0x03
    1898:	9c 81       	ldd	r25, Y+4	; 0x04
    189a:	01 97       	sbiw	r24, 0x01	; 1
    189c:	9c 83       	std	Y+4, r25	; 0x04
    189e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    18a0:	eb 81       	ldd	r30, Y+3	; 0x03
    18a2:	fc 81       	ldd	r31, Y+4	; 0x04
    18a4:	82 e1       	ldi	r24, 0x12	; 18
    18a6:	80 83       	st	Z, r24
	pxTopOfStack--;
    18a8:	8b 81       	ldd	r24, Y+3	; 0x03
    18aa:	9c 81       	ldd	r25, Y+4	; 0x04
    18ac:	01 97       	sbiw	r24, 0x01	; 1
    18ae:	9c 83       	std	Y+4, r25	; 0x04
    18b0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    18b2:	eb 81       	ldd	r30, Y+3	; 0x03
    18b4:	fc 81       	ldd	r31, Y+4	; 0x04
    18b6:	83 e1       	ldi	r24, 0x13	; 19
    18b8:	80 83       	st	Z, r24
	pxTopOfStack--;
    18ba:	8b 81       	ldd	r24, Y+3	; 0x03
    18bc:	9c 81       	ldd	r25, Y+4	; 0x04
    18be:	01 97       	sbiw	r24, 0x01	; 1
    18c0:	9c 83       	std	Y+4, r25	; 0x04
    18c2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    18c4:	eb 81       	ldd	r30, Y+3	; 0x03
    18c6:	fc 81       	ldd	r31, Y+4	; 0x04
    18c8:	84 e1       	ldi	r24, 0x14	; 20
    18ca:	80 83       	st	Z, r24
	pxTopOfStack--;
    18cc:	8b 81       	ldd	r24, Y+3	; 0x03
    18ce:	9c 81       	ldd	r25, Y+4	; 0x04
    18d0:	01 97       	sbiw	r24, 0x01	; 1
    18d2:	9c 83       	std	Y+4, r25	; 0x04
    18d4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    18d6:	eb 81       	ldd	r30, Y+3	; 0x03
    18d8:	fc 81       	ldd	r31, Y+4	; 0x04
    18da:	85 e1       	ldi	r24, 0x15	; 21
    18dc:	80 83       	st	Z, r24
	pxTopOfStack--;
    18de:	8b 81       	ldd	r24, Y+3	; 0x03
    18e0:	9c 81       	ldd	r25, Y+4	; 0x04
    18e2:	01 97       	sbiw	r24, 0x01	; 1
    18e4:	9c 83       	std	Y+4, r25	; 0x04
    18e6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    18e8:	eb 81       	ldd	r30, Y+3	; 0x03
    18ea:	fc 81       	ldd	r31, Y+4	; 0x04
    18ec:	86 e1       	ldi	r24, 0x16	; 22
    18ee:	80 83       	st	Z, r24
	pxTopOfStack--;
    18f0:	8b 81       	ldd	r24, Y+3	; 0x03
    18f2:	9c 81       	ldd	r25, Y+4	; 0x04
    18f4:	01 97       	sbiw	r24, 0x01	; 1
    18f6:	9c 83       	std	Y+4, r25	; 0x04
    18f8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    18fa:	eb 81       	ldd	r30, Y+3	; 0x03
    18fc:	fc 81       	ldd	r31, Y+4	; 0x04
    18fe:	87 e1       	ldi	r24, 0x17	; 23
    1900:	80 83       	st	Z, r24
	pxTopOfStack--;
    1902:	8b 81       	ldd	r24, Y+3	; 0x03
    1904:	9c 81       	ldd	r25, Y+4	; 0x04
    1906:	01 97       	sbiw	r24, 0x01	; 1
    1908:	9c 83       	std	Y+4, r25	; 0x04
    190a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    190c:	eb 81       	ldd	r30, Y+3	; 0x03
    190e:	fc 81       	ldd	r31, Y+4	; 0x04
    1910:	88 e1       	ldi	r24, 0x18	; 24
    1912:	80 83       	st	Z, r24
	pxTopOfStack--;
    1914:	8b 81       	ldd	r24, Y+3	; 0x03
    1916:	9c 81       	ldd	r25, Y+4	; 0x04
    1918:	01 97       	sbiw	r24, 0x01	; 1
    191a:	9c 83       	std	Y+4, r25	; 0x04
    191c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    191e:	eb 81       	ldd	r30, Y+3	; 0x03
    1920:	fc 81       	ldd	r31, Y+4	; 0x04
    1922:	89 e1       	ldi	r24, 0x19	; 25
    1924:	80 83       	st	Z, r24
	pxTopOfStack--;
    1926:	8b 81       	ldd	r24, Y+3	; 0x03
    1928:	9c 81       	ldd	r25, Y+4	; 0x04
    192a:	01 97       	sbiw	r24, 0x01	; 1
    192c:	9c 83       	std	Y+4, r25	; 0x04
    192e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    1930:	eb 81       	ldd	r30, Y+3	; 0x03
    1932:	fc 81       	ldd	r31, Y+4	; 0x04
    1934:	80 e2       	ldi	r24, 0x20	; 32
    1936:	80 83       	st	Z, r24
	pxTopOfStack--;
    1938:	8b 81       	ldd	r24, Y+3	; 0x03
    193a:	9c 81       	ldd	r25, Y+4	; 0x04
    193c:	01 97       	sbiw	r24, 0x01	; 1
    193e:	9c 83       	std	Y+4, r25	; 0x04
    1940:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    1942:	eb 81       	ldd	r30, Y+3	; 0x03
    1944:	fc 81       	ldd	r31, Y+4	; 0x04
    1946:	81 e2       	ldi	r24, 0x21	; 33
    1948:	80 83       	st	Z, r24
	pxTopOfStack--;
    194a:	8b 81       	ldd	r24, Y+3	; 0x03
    194c:	9c 81       	ldd	r25, Y+4	; 0x04
    194e:	01 97       	sbiw	r24, 0x01	; 1
    1950:	9c 83       	std	Y+4, r25	; 0x04
    1952:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    1954:	eb 81       	ldd	r30, Y+3	; 0x03
    1956:	fc 81       	ldd	r31, Y+4	; 0x04
    1958:	82 e2       	ldi	r24, 0x22	; 34
    195a:	80 83       	st	Z, r24
	pxTopOfStack--;
    195c:	8b 81       	ldd	r24, Y+3	; 0x03
    195e:	9c 81       	ldd	r25, Y+4	; 0x04
    1960:	01 97       	sbiw	r24, 0x01	; 1
    1962:	9c 83       	std	Y+4, r25	; 0x04
    1964:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    1966:	eb 81       	ldd	r30, Y+3	; 0x03
    1968:	fc 81       	ldd	r31, Y+4	; 0x04
    196a:	83 e2       	ldi	r24, 0x23	; 35
    196c:	80 83       	st	Z, r24
	pxTopOfStack--;
    196e:	8b 81       	ldd	r24, Y+3	; 0x03
    1970:	9c 81       	ldd	r25, Y+4	; 0x04
    1972:	01 97       	sbiw	r24, 0x01	; 1
    1974:	9c 83       	std	Y+4, r25	; 0x04
    1976:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    1978:	8f 81       	ldd	r24, Y+7	; 0x07
    197a:	98 85       	ldd	r25, Y+8	; 0x08
    197c:	9a 83       	std	Y+2, r25	; 0x02
    197e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1980:	89 81       	ldd	r24, Y+1	; 0x01
    1982:	eb 81       	ldd	r30, Y+3	; 0x03
    1984:	fc 81       	ldd	r31, Y+4	; 0x04
    1986:	80 83       	st	Z, r24
	pxTopOfStack--;
    1988:	8b 81       	ldd	r24, Y+3	; 0x03
    198a:	9c 81       	ldd	r25, Y+4	; 0x04
    198c:	01 97       	sbiw	r24, 0x01	; 1
    198e:	9c 83       	std	Y+4, r25	; 0x04
    1990:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1992:	89 81       	ldd	r24, Y+1	; 0x01
    1994:	9a 81       	ldd	r25, Y+2	; 0x02
    1996:	89 2f       	mov	r24, r25
    1998:	99 27       	eor	r25, r25
    199a:	9a 83       	std	Y+2, r25	; 0x02
    199c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    199e:	89 81       	ldd	r24, Y+1	; 0x01
    19a0:	eb 81       	ldd	r30, Y+3	; 0x03
    19a2:	fc 81       	ldd	r31, Y+4	; 0x04
    19a4:	80 83       	st	Z, r24
	pxTopOfStack--;
    19a6:	8b 81       	ldd	r24, Y+3	; 0x03
    19a8:	9c 81       	ldd	r25, Y+4	; 0x04
    19aa:	01 97       	sbiw	r24, 0x01	; 1
    19ac:	9c 83       	std	Y+4, r25	; 0x04
    19ae:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    19b0:	eb 81       	ldd	r30, Y+3	; 0x03
    19b2:	fc 81       	ldd	r31, Y+4	; 0x04
    19b4:	86 e2       	ldi	r24, 0x26	; 38
    19b6:	80 83       	st	Z, r24
	pxTopOfStack--;
    19b8:	8b 81       	ldd	r24, Y+3	; 0x03
    19ba:	9c 81       	ldd	r25, Y+4	; 0x04
    19bc:	01 97       	sbiw	r24, 0x01	; 1
    19be:	9c 83       	std	Y+4, r25	; 0x04
    19c0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    19c2:	eb 81       	ldd	r30, Y+3	; 0x03
    19c4:	fc 81       	ldd	r31, Y+4	; 0x04
    19c6:	87 e2       	ldi	r24, 0x27	; 39
    19c8:	80 83       	st	Z, r24
	pxTopOfStack--;
    19ca:	8b 81       	ldd	r24, Y+3	; 0x03
    19cc:	9c 81       	ldd	r25, Y+4	; 0x04
    19ce:	01 97       	sbiw	r24, 0x01	; 1
    19d0:	9c 83       	std	Y+4, r25	; 0x04
    19d2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    19d4:	eb 81       	ldd	r30, Y+3	; 0x03
    19d6:	fc 81       	ldd	r31, Y+4	; 0x04
    19d8:	88 e2       	ldi	r24, 0x28	; 40
    19da:	80 83       	st	Z, r24
	pxTopOfStack--;
    19dc:	8b 81       	ldd	r24, Y+3	; 0x03
    19de:	9c 81       	ldd	r25, Y+4	; 0x04
    19e0:	01 97       	sbiw	r24, 0x01	; 1
    19e2:	9c 83       	std	Y+4, r25	; 0x04
    19e4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    19e6:	eb 81       	ldd	r30, Y+3	; 0x03
    19e8:	fc 81       	ldd	r31, Y+4	; 0x04
    19ea:	89 e2       	ldi	r24, 0x29	; 41
    19ec:	80 83       	st	Z, r24
	pxTopOfStack--;
    19ee:	8b 81       	ldd	r24, Y+3	; 0x03
    19f0:	9c 81       	ldd	r25, Y+4	; 0x04
    19f2:	01 97       	sbiw	r24, 0x01	; 1
    19f4:	9c 83       	std	Y+4, r25	; 0x04
    19f6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    19f8:	eb 81       	ldd	r30, Y+3	; 0x03
    19fa:	fc 81       	ldd	r31, Y+4	; 0x04
    19fc:	80 e3       	ldi	r24, 0x30	; 48
    19fe:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a00:	8b 81       	ldd	r24, Y+3	; 0x03
    1a02:	9c 81       	ldd	r25, Y+4	; 0x04
    1a04:	01 97       	sbiw	r24, 0x01	; 1
    1a06:	9c 83       	std	Y+4, r25	; 0x04
    1a08:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    1a0a:	eb 81       	ldd	r30, Y+3	; 0x03
    1a0c:	fc 81       	ldd	r31, Y+4	; 0x04
    1a0e:	81 e3       	ldi	r24, 0x31	; 49
    1a10:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a12:	8b 81       	ldd	r24, Y+3	; 0x03
    1a14:	9c 81       	ldd	r25, Y+4	; 0x04
    1a16:	01 97       	sbiw	r24, 0x01	; 1
    1a18:	9c 83       	std	Y+4, r25	; 0x04
    1a1a:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    1a1c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a1e:	9c 81       	ldd	r25, Y+4	; 0x04
}
    1a20:	28 96       	adiw	r28, 0x08	; 8
    1a22:	0f b6       	in	r0, 0x3f	; 63
    1a24:	f8 94       	cli
    1a26:	de bf       	out	0x3e, r29	; 62
    1a28:	0f be       	out	0x3f, r0	; 63
    1a2a:	cd bf       	out	0x3d, r28	; 61
    1a2c:	cf 91       	pop	r28
    1a2e:	df 91       	pop	r29
    1a30:	08 95       	ret

00001a32 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    1a32:	df 93       	push	r29
    1a34:	cf 93       	push	r28
    1a36:	cd b7       	in	r28, 0x3d	; 61
    1a38:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    1a3a:	0e 94 09 0e 	call	0x1c12	; 0x1c12 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1a3e:	a0 91 a8 06 	lds	r26, 0x06A8
    1a42:	b0 91 a9 06 	lds	r27, 0x06A9
    1a46:	cd 91       	ld	r28, X+
    1a48:	cd bf       	out	0x3d, r28	; 61
    1a4a:	dd 91       	ld	r29, X+
    1a4c:	de bf       	out	0x3e, r29	; 62
    1a4e:	ff 91       	pop	r31
    1a50:	ef 91       	pop	r30
    1a52:	df 91       	pop	r29
    1a54:	cf 91       	pop	r28
    1a56:	bf 91       	pop	r27
    1a58:	af 91       	pop	r26
    1a5a:	9f 91       	pop	r25
    1a5c:	8f 91       	pop	r24
    1a5e:	7f 91       	pop	r23
    1a60:	6f 91       	pop	r22
    1a62:	5f 91       	pop	r21
    1a64:	4f 91       	pop	r20
    1a66:	3f 91       	pop	r19
    1a68:	2f 91       	pop	r18
    1a6a:	1f 91       	pop	r17
    1a6c:	0f 91       	pop	r16
    1a6e:	ff 90       	pop	r15
    1a70:	ef 90       	pop	r14
    1a72:	df 90       	pop	r13
    1a74:	cf 90       	pop	r12
    1a76:	bf 90       	pop	r11
    1a78:	af 90       	pop	r10
    1a7a:	9f 90       	pop	r9
    1a7c:	8f 90       	pop	r8
    1a7e:	7f 90       	pop	r7
    1a80:	6f 90       	pop	r6
    1a82:	5f 90       	pop	r5
    1a84:	4f 90       	pop	r4
    1a86:	3f 90       	pop	r3
    1a88:	2f 90       	pop	r2
    1a8a:	1f 90       	pop	r1
    1a8c:	0f 90       	pop	r0
    1a8e:	0f be       	out	0x3f, r0	; 63
    1a90:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1a92:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    1a94:	81 e0       	ldi	r24, 0x01	; 1
}
    1a96:	cf 91       	pop	r28
    1a98:	df 91       	pop	r29
    1a9a:	08 95       	ret

00001a9c <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1a9c:	df 93       	push	r29
    1a9e:	cf 93       	push	r28
    1aa0:	cd b7       	in	r28, 0x3d	; 61
    1aa2:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1aa4:	cf 91       	pop	r28
    1aa6:	df 91       	pop	r29
    1aa8:	08 95       	ret

00001aaa <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1aaa:	0f 92       	push	r0
    1aac:	0f b6       	in	r0, 0x3f	; 63
    1aae:	f8 94       	cli
    1ab0:	0f 92       	push	r0
    1ab2:	1f 92       	push	r1
    1ab4:	11 24       	eor	r1, r1
    1ab6:	2f 92       	push	r2
    1ab8:	3f 92       	push	r3
    1aba:	4f 92       	push	r4
    1abc:	5f 92       	push	r5
    1abe:	6f 92       	push	r6
    1ac0:	7f 92       	push	r7
    1ac2:	8f 92       	push	r8
    1ac4:	9f 92       	push	r9
    1ac6:	af 92       	push	r10
    1ac8:	bf 92       	push	r11
    1aca:	cf 92       	push	r12
    1acc:	df 92       	push	r13
    1ace:	ef 92       	push	r14
    1ad0:	ff 92       	push	r15
    1ad2:	0f 93       	push	r16
    1ad4:	1f 93       	push	r17
    1ad6:	2f 93       	push	r18
    1ad8:	3f 93       	push	r19
    1ada:	4f 93       	push	r20
    1adc:	5f 93       	push	r21
    1ade:	6f 93       	push	r22
    1ae0:	7f 93       	push	r23
    1ae2:	8f 93       	push	r24
    1ae4:	9f 93       	push	r25
    1ae6:	af 93       	push	r26
    1ae8:	bf 93       	push	r27
    1aea:	cf 93       	push	r28
    1aec:	df 93       	push	r29
    1aee:	ef 93       	push	r30
    1af0:	ff 93       	push	r31
    1af2:	a0 91 a8 06 	lds	r26, 0x06A8
    1af6:	b0 91 a9 06 	lds	r27, 0x06A9
    1afa:	0d b6       	in	r0, 0x3d	; 61
    1afc:	0d 92       	st	X+, r0
    1afe:	0e b6       	in	r0, 0x3e	; 62
    1b00:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1b02:	0e 94 d0 18 	call	0x31a0	; 0x31a0 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1b06:	a0 91 a8 06 	lds	r26, 0x06A8
    1b0a:	b0 91 a9 06 	lds	r27, 0x06A9
    1b0e:	cd 91       	ld	r28, X+
    1b10:	cd bf       	out	0x3d, r28	; 61
    1b12:	dd 91       	ld	r29, X+
    1b14:	de bf       	out	0x3e, r29	; 62
    1b16:	ff 91       	pop	r31
    1b18:	ef 91       	pop	r30
    1b1a:	df 91       	pop	r29
    1b1c:	cf 91       	pop	r28
    1b1e:	bf 91       	pop	r27
    1b20:	af 91       	pop	r26
    1b22:	9f 91       	pop	r25
    1b24:	8f 91       	pop	r24
    1b26:	7f 91       	pop	r23
    1b28:	6f 91       	pop	r22
    1b2a:	5f 91       	pop	r21
    1b2c:	4f 91       	pop	r20
    1b2e:	3f 91       	pop	r19
    1b30:	2f 91       	pop	r18
    1b32:	1f 91       	pop	r17
    1b34:	0f 91       	pop	r16
    1b36:	ff 90       	pop	r15
    1b38:	ef 90       	pop	r14
    1b3a:	df 90       	pop	r13
    1b3c:	cf 90       	pop	r12
    1b3e:	bf 90       	pop	r11
    1b40:	af 90       	pop	r10
    1b42:	9f 90       	pop	r9
    1b44:	8f 90       	pop	r8
    1b46:	7f 90       	pop	r7
    1b48:	6f 90       	pop	r6
    1b4a:	5f 90       	pop	r5
    1b4c:	4f 90       	pop	r4
    1b4e:	3f 90       	pop	r3
    1b50:	2f 90       	pop	r2
    1b52:	1f 90       	pop	r1
    1b54:	0f 90       	pop	r0
    1b56:	0f be       	out	0x3f, r0	; 63
    1b58:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1b5a:	08 95       	ret

00001b5c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1b5c:	0f 92       	push	r0
    1b5e:	0f b6       	in	r0, 0x3f	; 63
    1b60:	f8 94       	cli
    1b62:	0f 92       	push	r0
    1b64:	1f 92       	push	r1
    1b66:	11 24       	eor	r1, r1
    1b68:	2f 92       	push	r2
    1b6a:	3f 92       	push	r3
    1b6c:	4f 92       	push	r4
    1b6e:	5f 92       	push	r5
    1b70:	6f 92       	push	r6
    1b72:	7f 92       	push	r7
    1b74:	8f 92       	push	r8
    1b76:	9f 92       	push	r9
    1b78:	af 92       	push	r10
    1b7a:	bf 92       	push	r11
    1b7c:	cf 92       	push	r12
    1b7e:	df 92       	push	r13
    1b80:	ef 92       	push	r14
    1b82:	ff 92       	push	r15
    1b84:	0f 93       	push	r16
    1b86:	1f 93       	push	r17
    1b88:	2f 93       	push	r18
    1b8a:	3f 93       	push	r19
    1b8c:	4f 93       	push	r20
    1b8e:	5f 93       	push	r21
    1b90:	6f 93       	push	r22
    1b92:	7f 93       	push	r23
    1b94:	8f 93       	push	r24
    1b96:	9f 93       	push	r25
    1b98:	af 93       	push	r26
    1b9a:	bf 93       	push	r27
    1b9c:	cf 93       	push	r28
    1b9e:	df 93       	push	r29
    1ba0:	ef 93       	push	r30
    1ba2:	ff 93       	push	r31
    1ba4:	a0 91 a8 06 	lds	r26, 0x06A8
    1ba8:	b0 91 a9 06 	lds	r27, 0x06A9
    1bac:	0d b6       	in	r0, 0x3d	; 61
    1bae:	0d 92       	st	X+, r0
    1bb0:	0e b6       	in	r0, 0x3e	; 62
    1bb2:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1bb4:	0e 94 fb 17 	call	0x2ff6	; 0x2ff6 <vTaskIncrementTick>
	vTaskSwitchContext();
    1bb8:	0e 94 d0 18 	call	0x31a0	; 0x31a0 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1bbc:	a0 91 a8 06 	lds	r26, 0x06A8
    1bc0:	b0 91 a9 06 	lds	r27, 0x06A9
    1bc4:	cd 91       	ld	r28, X+
    1bc6:	cd bf       	out	0x3d, r28	; 61
    1bc8:	dd 91       	ld	r29, X+
    1bca:	de bf       	out	0x3e, r29	; 62
    1bcc:	ff 91       	pop	r31
    1bce:	ef 91       	pop	r30
    1bd0:	df 91       	pop	r29
    1bd2:	cf 91       	pop	r28
    1bd4:	bf 91       	pop	r27
    1bd6:	af 91       	pop	r26
    1bd8:	9f 91       	pop	r25
    1bda:	8f 91       	pop	r24
    1bdc:	7f 91       	pop	r23
    1bde:	6f 91       	pop	r22
    1be0:	5f 91       	pop	r21
    1be2:	4f 91       	pop	r20
    1be4:	3f 91       	pop	r19
    1be6:	2f 91       	pop	r18
    1be8:	1f 91       	pop	r17
    1bea:	0f 91       	pop	r16
    1bec:	ff 90       	pop	r15
    1bee:	ef 90       	pop	r14
    1bf0:	df 90       	pop	r13
    1bf2:	cf 90       	pop	r12
    1bf4:	bf 90       	pop	r11
    1bf6:	af 90       	pop	r10
    1bf8:	9f 90       	pop	r9
    1bfa:	8f 90       	pop	r8
    1bfc:	7f 90       	pop	r7
    1bfe:	6f 90       	pop	r6
    1c00:	5f 90       	pop	r5
    1c02:	4f 90       	pop	r4
    1c04:	3f 90       	pop	r3
    1c06:	2f 90       	pop	r2
    1c08:	1f 90       	pop	r1
    1c0a:	0f 90       	pop	r0
    1c0c:	0f be       	out	0x3f, r0	; 63
    1c0e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1c10:	08 95       	ret

00001c12 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    1c12:	df 93       	push	r29
    1c14:	cf 93       	push	r28
    1c16:	00 d0       	rcall	.+0      	; 0x1c18 <prvSetupTimerInterrupt+0x6>
    1c18:	00 d0       	rcall	.+0      	; 0x1c1a <prvSetupTimerInterrupt+0x8>
    1c1a:	00 d0       	rcall	.+0      	; 0x1c1c <prvSetupTimerInterrupt+0xa>
    1c1c:	cd b7       	in	r28, 0x3d	; 61
    1c1e:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    1c20:	80 e8       	ldi	r24, 0x80	; 128
    1c22:	9e e3       	ldi	r25, 0x3E	; 62
    1c24:	a0 e0       	ldi	r26, 0x00	; 0
    1c26:	b0 e0       	ldi	r27, 0x00	; 0
    1c28:	8b 83       	std	Y+3, r24	; 0x03
    1c2a:	9c 83       	std	Y+4, r25	; 0x04
    1c2c:	ad 83       	std	Y+5, r26	; 0x05
    1c2e:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    1c30:	8b 81       	ldd	r24, Y+3	; 0x03
    1c32:	9c 81       	ldd	r25, Y+4	; 0x04
    1c34:	ad 81       	ldd	r26, Y+5	; 0x05
    1c36:	be 81       	ldd	r27, Y+6	; 0x06
    1c38:	68 94       	set
    1c3a:	15 f8       	bld	r1, 5
    1c3c:	b6 95       	lsr	r27
    1c3e:	a7 95       	ror	r26
    1c40:	97 95       	ror	r25
    1c42:	87 95       	ror	r24
    1c44:	16 94       	lsr	r1
    1c46:	d1 f7       	brne	.-12     	; 0x1c3c <prvSetupTimerInterrupt+0x2a>
    1c48:	8b 83       	std	Y+3, r24	; 0x03
    1c4a:	9c 83       	std	Y+4, r25	; 0x04
    1c4c:	ad 83       	std	Y+5, r26	; 0x05
    1c4e:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    1c50:	8b 81       	ldd	r24, Y+3	; 0x03
    1c52:	9c 81       	ldd	r25, Y+4	; 0x04
    1c54:	ad 81       	ldd	r26, Y+5	; 0x05
    1c56:	be 81       	ldd	r27, Y+6	; 0x06
    1c58:	01 97       	sbiw	r24, 0x01	; 1
    1c5a:	a1 09       	sbc	r26, r1
    1c5c:	b1 09       	sbc	r27, r1
    1c5e:	8b 83       	std	Y+3, r24	; 0x03
    1c60:	9c 83       	std	Y+4, r25	; 0x04
    1c62:	ad 83       	std	Y+5, r26	; 0x05
    1c64:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    1c66:	8b 81       	ldd	r24, Y+3	; 0x03
    1c68:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    1c6a:	8b 81       	ldd	r24, Y+3	; 0x03
    1c6c:	9c 81       	ldd	r25, Y+4	; 0x04
    1c6e:	ad 81       	ldd	r26, Y+5	; 0x05
    1c70:	be 81       	ldd	r27, Y+6	; 0x06
    1c72:	89 2f       	mov	r24, r25
    1c74:	9a 2f       	mov	r25, r26
    1c76:	ab 2f       	mov	r26, r27
    1c78:	bb 27       	eor	r27, r27
    1c7a:	8b 83       	std	Y+3, r24	; 0x03
    1c7c:	9c 83       	std	Y+4, r25	; 0x04
    1c7e:	ad 83       	std	Y+5, r26	; 0x05
    1c80:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    1c82:	8b 81       	ldd	r24, Y+3	; 0x03
    1c84:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    1c86:	eb e4       	ldi	r30, 0x4B	; 75
    1c88:	f0 e0       	ldi	r31, 0x00	; 0
    1c8a:	8a 81       	ldd	r24, Y+2	; 0x02
    1c8c:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    1c8e:	ea e4       	ldi	r30, 0x4A	; 74
    1c90:	f0 e0       	ldi	r31, 0x00	; 0
    1c92:	89 81       	ldd	r24, Y+1	; 0x01
    1c94:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    1c96:	8b e0       	ldi	r24, 0x0B	; 11
    1c98:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    1c9a:	ee e4       	ldi	r30, 0x4E	; 78
    1c9c:	f0 e0       	ldi	r31, 0x00	; 0
    1c9e:	89 81       	ldd	r24, Y+1	; 0x01
    1ca0:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1ca2:	e9 e5       	ldi	r30, 0x59	; 89
    1ca4:	f0 e0       	ldi	r31, 0x00	; 0
    1ca6:	80 81       	ld	r24, Z
    1ca8:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1caa:	89 81       	ldd	r24, Y+1	; 0x01
    1cac:	80 61       	ori	r24, 0x10	; 16
    1cae:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    1cb0:	e9 e5       	ldi	r30, 0x59	; 89
    1cb2:	f0 e0       	ldi	r31, 0x00	; 0
    1cb4:	89 81       	ldd	r24, Y+1	; 0x01
    1cb6:	80 83       	st	Z, r24
}
    1cb8:	26 96       	adiw	r28, 0x06	; 6
    1cba:	0f b6       	in	r0, 0x3f	; 63
    1cbc:	f8 94       	cli
    1cbe:	de bf       	out	0x3e, r29	; 62
    1cc0:	0f be       	out	0x3f, r0	; 63
    1cc2:	cd bf       	out	0x3d, r28	; 61
    1cc4:	cf 91       	pop	r28
    1cc6:	df 91       	pop	r29
    1cc8:	08 95       	ret

00001cca <__vector_7>:
	 * tick count.  We don't need to switch context, this can only be done by
	 * manual calls to taskYIELD();
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
    1cca:	1f 92       	push	r1
    1ccc:	0f 92       	push	r0
    1cce:	0f b6       	in	r0, 0x3f	; 63
    1cd0:	0f 92       	push	r0
    1cd2:	11 24       	eor	r1, r1
    1cd4:	2f 93       	push	r18
    1cd6:	3f 93       	push	r19
    1cd8:	4f 93       	push	r20
    1cda:	5f 93       	push	r21
    1cdc:	6f 93       	push	r22
    1cde:	7f 93       	push	r23
    1ce0:	8f 93       	push	r24
    1ce2:	9f 93       	push	r25
    1ce4:	af 93       	push	r26
    1ce6:	bf 93       	push	r27
    1ce8:	ef 93       	push	r30
    1cea:	ff 93       	push	r31
    1cec:	df 93       	push	r29
    1cee:	cf 93       	push	r28
    1cf0:	cd b7       	in	r28, 0x3d	; 61
    1cf2:	de b7       	in	r29, 0x3e	; 62
		vTaskIncrementTick();
    1cf4:	0e 94 fb 17 	call	0x2ff6	; 0x2ff6 <vTaskIncrementTick>
	}
    1cf8:	cf 91       	pop	r28
    1cfa:	df 91       	pop	r29
    1cfc:	ff 91       	pop	r31
    1cfe:	ef 91       	pop	r30
    1d00:	bf 91       	pop	r27
    1d02:	af 91       	pop	r26
    1d04:	9f 91       	pop	r25
    1d06:	8f 91       	pop	r24
    1d08:	7f 91       	pop	r23
    1d0a:	6f 91       	pop	r22
    1d0c:	5f 91       	pop	r21
    1d0e:	4f 91       	pop	r20
    1d10:	3f 91       	pop	r19
    1d12:	2f 91       	pop	r18
    1d14:	0f 90       	pop	r0
    1d16:	0f be       	out	0x3f, r0	; 63
    1d18:	0f 90       	pop	r0
    1d1a:	1f 90       	pop	r1
    1d1c:	18 95       	reti

00001d1e <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    1d1e:	df 93       	push	r29
    1d20:	cf 93       	push	r28
    1d22:	cd b7       	in	r28, 0x3d	; 61
    1d24:	de b7       	in	r29, 0x3e	; 62
    1d26:	28 97       	sbiw	r28, 0x08	; 8
    1d28:	0f b6       	in	r0, 0x3f	; 63
    1d2a:	f8 94       	cli
    1d2c:	de bf       	out	0x3e, r29	; 62
    1d2e:	0f be       	out	0x3f, r0	; 63
    1d30:	cd bf       	out	0x3d, r28	; 61
    1d32:	8f 83       	std	Y+7, r24	; 0x07
    1d34:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    1d36:	1a 82       	std	Y+2, r1	; 0x02
    1d38:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    1d3a:	8f 81       	ldd	r24, Y+7	; 0x07
    1d3c:	88 23       	and	r24, r24
    1d3e:	09 f4       	brne	.+2      	; 0x1d42 <xQueueCreate+0x24>
    1d40:	8c c0       	rjmp	.+280    	; 0x1e5a <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    1d42:	8f e1       	ldi	r24, 0x1F	; 31
    1d44:	90 e0       	ldi	r25, 0x00	; 0
    1d46:	0e 94 ef 09 	call	0x13de	; 0x13de <pvPortMalloc>
    1d4a:	9e 83       	std	Y+6, r25	; 0x06
    1d4c:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    1d4e:	8d 81       	ldd	r24, Y+5	; 0x05
    1d50:	9e 81       	ldd	r25, Y+6	; 0x06
    1d52:	00 97       	sbiw	r24, 0x00	; 0
    1d54:	09 f4       	brne	.+2      	; 0x1d58 <xQueueCreate+0x3a>
    1d56:	81 c0       	rjmp	.+258    	; 0x1e5a <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    1d58:	8f 81       	ldd	r24, Y+7	; 0x07
    1d5a:	28 2f       	mov	r18, r24
    1d5c:	30 e0       	ldi	r19, 0x00	; 0
    1d5e:	88 85       	ldd	r24, Y+8	; 0x08
    1d60:	88 2f       	mov	r24, r24
    1d62:	90 e0       	ldi	r25, 0x00	; 0
    1d64:	ac 01       	movw	r20, r24
    1d66:	24 9f       	mul	r18, r20
    1d68:	c0 01       	movw	r24, r0
    1d6a:	25 9f       	mul	r18, r21
    1d6c:	90 0d       	add	r25, r0
    1d6e:	34 9f       	mul	r19, r20
    1d70:	90 0d       	add	r25, r0
    1d72:	11 24       	eor	r1, r1
    1d74:	01 96       	adiw	r24, 0x01	; 1
    1d76:	9c 83       	std	Y+4, r25	; 0x04
    1d78:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    1d7a:	8b 81       	ldd	r24, Y+3	; 0x03
    1d7c:	9c 81       	ldd	r25, Y+4	; 0x04
    1d7e:	0e 94 ef 09 	call	0x13de	; 0x13de <pvPortMalloc>
    1d82:	ed 81       	ldd	r30, Y+5	; 0x05
    1d84:	fe 81       	ldd	r31, Y+6	; 0x06
    1d86:	91 83       	std	Z+1, r25	; 0x01
    1d88:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    1d8a:	ed 81       	ldd	r30, Y+5	; 0x05
    1d8c:	fe 81       	ldd	r31, Y+6	; 0x06
    1d8e:	80 81       	ld	r24, Z
    1d90:	91 81       	ldd	r25, Z+1	; 0x01
    1d92:	00 97       	sbiw	r24, 0x00	; 0
    1d94:	09 f4       	brne	.+2      	; 0x1d98 <xQueueCreate+0x7a>
    1d96:	5d c0       	rjmp	.+186    	; 0x1e52 <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    1d98:	ed 81       	ldd	r30, Y+5	; 0x05
    1d9a:	fe 81       	ldd	r31, Y+6	; 0x06
    1d9c:	40 81       	ld	r20, Z
    1d9e:	51 81       	ldd	r21, Z+1	; 0x01
    1da0:	8f 81       	ldd	r24, Y+7	; 0x07
    1da2:	28 2f       	mov	r18, r24
    1da4:	30 e0       	ldi	r19, 0x00	; 0
    1da6:	88 85       	ldd	r24, Y+8	; 0x08
    1da8:	88 2f       	mov	r24, r24
    1daa:	90 e0       	ldi	r25, 0x00	; 0
    1dac:	bc 01       	movw	r22, r24
    1dae:	26 9f       	mul	r18, r22
    1db0:	c0 01       	movw	r24, r0
    1db2:	27 9f       	mul	r18, r23
    1db4:	90 0d       	add	r25, r0
    1db6:	36 9f       	mul	r19, r22
    1db8:	90 0d       	add	r25, r0
    1dba:	11 24       	eor	r1, r1
    1dbc:	84 0f       	add	r24, r20
    1dbe:	95 1f       	adc	r25, r21
    1dc0:	ed 81       	ldd	r30, Y+5	; 0x05
    1dc2:	fe 81       	ldd	r31, Y+6	; 0x06
    1dc4:	93 83       	std	Z+3, r25	; 0x03
    1dc6:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1dc8:	ed 81       	ldd	r30, Y+5	; 0x05
    1dca:	fe 81       	ldd	r31, Y+6	; 0x06
    1dcc:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    1dce:	ed 81       	ldd	r30, Y+5	; 0x05
    1dd0:	fe 81       	ldd	r31, Y+6	; 0x06
    1dd2:	80 81       	ld	r24, Z
    1dd4:	91 81       	ldd	r25, Z+1	; 0x01
    1dd6:	ed 81       	ldd	r30, Y+5	; 0x05
    1dd8:	fe 81       	ldd	r31, Y+6	; 0x06
    1dda:	95 83       	std	Z+5, r25	; 0x05
    1ddc:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    1dde:	ed 81       	ldd	r30, Y+5	; 0x05
    1de0:	fe 81       	ldd	r31, Y+6	; 0x06
    1de2:	40 81       	ld	r20, Z
    1de4:	51 81       	ldd	r21, Z+1	; 0x01
    1de6:	8f 81       	ldd	r24, Y+7	; 0x07
    1de8:	88 2f       	mov	r24, r24
    1dea:	90 e0       	ldi	r25, 0x00	; 0
    1dec:	9c 01       	movw	r18, r24
    1dee:	21 50       	subi	r18, 0x01	; 1
    1df0:	30 40       	sbci	r19, 0x00	; 0
    1df2:	88 85       	ldd	r24, Y+8	; 0x08
    1df4:	88 2f       	mov	r24, r24
    1df6:	90 e0       	ldi	r25, 0x00	; 0
    1df8:	bc 01       	movw	r22, r24
    1dfa:	26 9f       	mul	r18, r22
    1dfc:	c0 01       	movw	r24, r0
    1dfe:	27 9f       	mul	r18, r23
    1e00:	90 0d       	add	r25, r0
    1e02:	36 9f       	mul	r19, r22
    1e04:	90 0d       	add	r25, r0
    1e06:	11 24       	eor	r1, r1
    1e08:	84 0f       	add	r24, r20
    1e0a:	95 1f       	adc	r25, r21
    1e0c:	ed 81       	ldd	r30, Y+5	; 0x05
    1e0e:	fe 81       	ldd	r31, Y+6	; 0x06
    1e10:	97 83       	std	Z+7, r25	; 0x07
    1e12:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    1e14:	ed 81       	ldd	r30, Y+5	; 0x05
    1e16:	fe 81       	ldd	r31, Y+6	; 0x06
    1e18:	8f 81       	ldd	r24, Y+7	; 0x07
    1e1a:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1e1c:	ed 81       	ldd	r30, Y+5	; 0x05
    1e1e:	fe 81       	ldd	r31, Y+6	; 0x06
    1e20:	88 85       	ldd	r24, Y+8	; 0x08
    1e22:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    1e24:	ed 81       	ldd	r30, Y+5	; 0x05
    1e26:	fe 81       	ldd	r31, Y+6	; 0x06
    1e28:	8f ef       	ldi	r24, 0xFF	; 255
    1e2a:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    1e2c:	ed 81       	ldd	r30, Y+5	; 0x05
    1e2e:	fe 81       	ldd	r31, Y+6	; 0x06
    1e30:	8f ef       	ldi	r24, 0xFF	; 255
    1e32:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1e34:	8d 81       	ldd	r24, Y+5	; 0x05
    1e36:	9e 81       	ldd	r25, Y+6	; 0x06
    1e38:	08 96       	adiw	r24, 0x08	; 8
    1e3a:	0e 94 5b 0a 	call	0x14b6	; 0x14b6 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1e3e:	8d 81       	ldd	r24, Y+5	; 0x05
    1e40:	9e 81       	ldd	r25, Y+6	; 0x06
    1e42:	41 96       	adiw	r24, 0x11	; 17
    1e44:	0e 94 5b 0a 	call	0x14b6	; 0x14b6 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    1e48:	8d 81       	ldd	r24, Y+5	; 0x05
    1e4a:	9e 81       	ldd	r25, Y+6	; 0x06
    1e4c:	9a 83       	std	Y+2, r25	; 0x02
    1e4e:	89 83       	std	Y+1, r24	; 0x01
    1e50:	04 c0       	rjmp	.+8      	; 0x1e5a <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    1e52:	8d 81       	ldd	r24, Y+5	; 0x05
    1e54:	9e 81       	ldd	r25, Y+6	; 0x06
    1e56:	0e 94 35 0a 	call	0x146a	; 0x146a <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    1e5a:	89 81       	ldd	r24, Y+1	; 0x01
    1e5c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1e5e:	28 96       	adiw	r28, 0x08	; 8
    1e60:	0f b6       	in	r0, 0x3f	; 63
    1e62:	f8 94       	cli
    1e64:	de bf       	out	0x3e, r29	; 62
    1e66:	0f be       	out	0x3f, r0	; 63
    1e68:	cd bf       	out	0x3d, r28	; 61
    1e6a:	cf 91       	pop	r28
    1e6c:	df 91       	pop	r29
    1e6e:	08 95       	ret

00001e70 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1e70:	df 93       	push	r29
    1e72:	cf 93       	push	r28
    1e74:	cd b7       	in	r28, 0x3d	; 61
    1e76:	de b7       	in	r29, 0x3e	; 62
    1e78:	2c 97       	sbiw	r28, 0x0c	; 12
    1e7a:	0f b6       	in	r0, 0x3f	; 63
    1e7c:	f8 94       	cli
    1e7e:	de bf       	out	0x3e, r29	; 62
    1e80:	0f be       	out	0x3f, r0	; 63
    1e82:	cd bf       	out	0x3d, r28	; 61
    1e84:	9e 83       	std	Y+6, r25	; 0x06
    1e86:	8d 83       	std	Y+5, r24	; 0x05
    1e88:	78 87       	std	Y+8, r23	; 0x08
    1e8a:	6f 83       	std	Y+7, r22	; 0x07
    1e8c:	5a 87       	std	Y+10, r21	; 0x0a
    1e8e:	49 87       	std	Y+9, r20	; 0x09
    1e90:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1e92:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1e94:	0f b6       	in	r0, 0x3f	; 63
    1e96:	f8 94       	cli
    1e98:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1e9a:	ed 81       	ldd	r30, Y+5	; 0x05
    1e9c:	fe 81       	ldd	r31, Y+6	; 0x06
    1e9e:	92 8d       	ldd	r25, Z+26	; 0x1a
    1ea0:	ed 81       	ldd	r30, Y+5	; 0x05
    1ea2:	fe 81       	ldd	r31, Y+6	; 0x06
    1ea4:	83 8d       	ldd	r24, Z+27	; 0x1b
    1ea6:	98 17       	cp	r25, r24
    1ea8:	d8 f4       	brcc	.+54     	; 0x1ee0 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1eaa:	8d 81       	ldd	r24, Y+5	; 0x05
    1eac:	9e 81       	ldd	r25, Y+6	; 0x06
    1eae:	2f 81       	ldd	r18, Y+7	; 0x07
    1eb0:	38 85       	ldd	r19, Y+8	; 0x08
    1eb2:	b9 01       	movw	r22, r18
    1eb4:	4b 85       	ldd	r20, Y+11	; 0x0b
    1eb6:	0e 94 73 11 	call	0x22e6	; 0x22e6 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1eba:	ed 81       	ldd	r30, Y+5	; 0x05
    1ebc:	fe 81       	ldd	r31, Y+6	; 0x06
    1ebe:	81 89       	ldd	r24, Z+17	; 0x11
    1ec0:	88 23       	and	r24, r24
    1ec2:	49 f0       	breq	.+18     	; 0x1ed6 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1ec4:	8d 81       	ldd	r24, Y+5	; 0x05
    1ec6:	9e 81       	ldd	r25, Y+6	; 0x06
    1ec8:	41 96       	adiw	r24, 0x11	; 17
    1eca:	0e 94 b5 19 	call	0x336a	; 0x336a <xTaskRemoveFromEventList>
    1ece:	81 30       	cpi	r24, 0x01	; 1
    1ed0:	11 f4       	brne	.+4      	; 0x1ed6 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    1ed2:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    1ed6:	0f 90       	pop	r0
    1ed8:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    1eda:	81 e0       	ldi	r24, 0x01	; 1
    1edc:	8c 87       	std	Y+12, r24	; 0x0c
    1ede:	5c c0       	rjmp	.+184    	; 0x1f98 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1ee0:	89 85       	ldd	r24, Y+9	; 0x09
    1ee2:	9a 85       	ldd	r25, Y+10	; 0x0a
    1ee4:	00 97       	sbiw	r24, 0x00	; 0
    1ee6:	21 f4       	brne	.+8      	; 0x1ef0 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1ee8:	0f 90       	pop	r0
    1eea:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1eec:	1c 86       	std	Y+12, r1	; 0x0c
    1eee:	54 c0       	rjmp	.+168    	; 0x1f98 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    1ef0:	89 81       	ldd	r24, Y+1	; 0x01
    1ef2:	88 23       	and	r24, r24
    1ef4:	31 f4       	brne	.+12     	; 0x1f02 <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1ef6:	ce 01       	movw	r24, r28
    1ef8:	02 96       	adiw	r24, 0x02	; 2
    1efa:	0e 94 1d 1a 	call	0x343a	; 0x343a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1efe:	81 e0       	ldi	r24, 0x01	; 1
    1f00:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    1f02:	0f 90       	pop	r0
    1f04:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1f06:	0e 94 32 17 	call	0x2e64	; 0x2e64 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1f0a:	0f b6       	in	r0, 0x3f	; 63
    1f0c:	f8 94       	cli
    1f0e:	0f 92       	push	r0
    1f10:	ed 81       	ldd	r30, Y+5	; 0x05
    1f12:	fe 81       	ldd	r31, Y+6	; 0x06
    1f14:	85 8d       	ldd	r24, Z+29	; 0x1d
    1f16:	8f 3f       	cpi	r24, 0xFF	; 255
    1f18:	19 f4       	brne	.+6      	; 0x1f20 <xQueueGenericSend+0xb0>
    1f1a:	ed 81       	ldd	r30, Y+5	; 0x05
    1f1c:	fe 81       	ldd	r31, Y+6	; 0x06
    1f1e:	15 8e       	std	Z+29, r1	; 0x1d
    1f20:	ed 81       	ldd	r30, Y+5	; 0x05
    1f22:	fe 81       	ldd	r31, Y+6	; 0x06
    1f24:	86 8d       	ldd	r24, Z+30	; 0x1e
    1f26:	8f 3f       	cpi	r24, 0xFF	; 255
    1f28:	19 f4       	brne	.+6      	; 0x1f30 <xQueueGenericSend+0xc0>
    1f2a:	ed 81       	ldd	r30, Y+5	; 0x05
    1f2c:	fe 81       	ldd	r31, Y+6	; 0x06
    1f2e:	16 8e       	std	Z+30, r1	; 0x1e
    1f30:	0f 90       	pop	r0
    1f32:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1f34:	ce 01       	movw	r24, r28
    1f36:	02 96       	adiw	r24, 0x02	; 2
    1f38:	9e 01       	movw	r18, r28
    1f3a:	27 5f       	subi	r18, 0xF7	; 247
    1f3c:	3f 4f       	sbci	r19, 0xFF	; 255
    1f3e:	b9 01       	movw	r22, r18
    1f40:	0e 94 36 1a 	call	0x346c	; 0x346c <xTaskCheckForTimeOut>
    1f44:	88 23       	and	r24, r24
    1f46:	09 f5       	brne	.+66     	; 0x1f8a <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1f48:	8d 81       	ldd	r24, Y+5	; 0x05
    1f4a:	9e 81       	ldd	r25, Y+6	; 0x06
    1f4c:	0e 94 d7 12 	call	0x25ae	; 0x25ae <prvIsQueueFull>
    1f50:	88 23       	and	r24, r24
    1f52:	a1 f0       	breq	.+40     	; 0x1f7c <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1f54:	8d 81       	ldd	r24, Y+5	; 0x05
    1f56:	9e 81       	ldd	r25, Y+6	; 0x06
    1f58:	08 96       	adiw	r24, 0x08	; 8
    1f5a:	29 85       	ldd	r18, Y+9	; 0x09
    1f5c:	3a 85       	ldd	r19, Y+10	; 0x0a
    1f5e:	b9 01       	movw	r22, r18
    1f60:	0e 94 36 19 	call	0x326c	; 0x326c <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1f64:	8d 81       	ldd	r24, Y+5	; 0x05
    1f66:	9e 81       	ldd	r25, Y+6	; 0x06
    1f68:	0e 94 50 12 	call	0x24a0	; 0x24a0 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1f6c:	0e 94 3e 17 	call	0x2e7c	; 0x2e7c <xTaskResumeAll>
    1f70:	88 23       	and	r24, r24
    1f72:	09 f0       	breq	.+2      	; 0x1f76 <xQueueGenericSend+0x106>
    1f74:	8f cf       	rjmp	.-226    	; 0x1e94 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    1f76:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <vPortYield>
    1f7a:	8c cf       	rjmp	.-232    	; 0x1e94 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1f7c:	8d 81       	ldd	r24, Y+5	; 0x05
    1f7e:	9e 81       	ldd	r25, Y+6	; 0x06
    1f80:	0e 94 50 12 	call	0x24a0	; 0x24a0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1f84:	0e 94 3e 17 	call	0x2e7c	; 0x2e7c <xTaskResumeAll>
    1f88:	85 cf       	rjmp	.-246    	; 0x1e94 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1f8a:	8d 81       	ldd	r24, Y+5	; 0x05
    1f8c:	9e 81       	ldd	r25, Y+6	; 0x06
    1f8e:	0e 94 50 12 	call	0x24a0	; 0x24a0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1f92:	0e 94 3e 17 	call	0x2e7c	; 0x2e7c <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1f96:	1c 86       	std	Y+12, r1	; 0x0c
    1f98:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    1f9a:	2c 96       	adiw	r28, 0x0c	; 12
    1f9c:	0f b6       	in	r0, 0x3f	; 63
    1f9e:	f8 94       	cli
    1fa0:	de bf       	out	0x3e, r29	; 62
    1fa2:	0f be       	out	0x3f, r0	; 63
    1fa4:	cd bf       	out	0x3d, r28	; 61
    1fa6:	cf 91       	pop	r28
    1fa8:	df 91       	pop	r29
    1faa:	08 95       	ret

00001fac <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1fac:	df 93       	push	r29
    1fae:	cf 93       	push	r28
    1fb0:	cd b7       	in	r28, 0x3d	; 61
    1fb2:	de b7       	in	r29, 0x3e	; 62
    1fb4:	29 97       	sbiw	r28, 0x09	; 9
    1fb6:	0f b6       	in	r0, 0x3f	; 63
    1fb8:	f8 94       	cli
    1fba:	de bf       	out	0x3e, r29	; 62
    1fbc:	0f be       	out	0x3f, r0	; 63
    1fbe:	cd bf       	out	0x3d, r28	; 61
    1fc0:	9c 83       	std	Y+4, r25	; 0x04
    1fc2:	8b 83       	std	Y+3, r24	; 0x03
    1fc4:	7e 83       	std	Y+6, r23	; 0x06
    1fc6:	6d 83       	std	Y+5, r22	; 0x05
    1fc8:	58 87       	std	Y+8, r21	; 0x08
    1fca:	4f 83       	std	Y+7, r20	; 0x07
    1fcc:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1fce:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1fd0:	eb 81       	ldd	r30, Y+3	; 0x03
    1fd2:	fc 81       	ldd	r31, Y+4	; 0x04
    1fd4:	92 8d       	ldd	r25, Z+26	; 0x1a
    1fd6:	eb 81       	ldd	r30, Y+3	; 0x03
    1fd8:	fc 81       	ldd	r31, Y+4	; 0x04
    1fda:	83 8d       	ldd	r24, Z+27	; 0x1b
    1fdc:	98 17       	cp	r25, r24
    1fde:	40 f5       	brcc	.+80     	; 0x2030 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1fe0:	8b 81       	ldd	r24, Y+3	; 0x03
    1fe2:	9c 81       	ldd	r25, Y+4	; 0x04
    1fe4:	2d 81       	ldd	r18, Y+5	; 0x05
    1fe6:	3e 81       	ldd	r19, Y+6	; 0x06
    1fe8:	b9 01       	movw	r22, r18
    1fea:	49 85       	ldd	r20, Y+9	; 0x09
    1fec:	0e 94 73 11 	call	0x22e6	; 0x22e6 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1ff0:	eb 81       	ldd	r30, Y+3	; 0x03
    1ff2:	fc 81       	ldd	r31, Y+4	; 0x04
    1ff4:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ff6:	8f 3f       	cpi	r24, 0xFF	; 255
    1ff8:	89 f4       	brne	.+34     	; 0x201c <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1ffa:	eb 81       	ldd	r30, Y+3	; 0x03
    1ffc:	fc 81       	ldd	r31, Y+4	; 0x04
    1ffe:	81 89       	ldd	r24, Z+17	; 0x11
    2000:	88 23       	and	r24, r24
    2002:	99 f0       	breq	.+38     	; 0x202a <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2004:	8b 81       	ldd	r24, Y+3	; 0x03
    2006:	9c 81       	ldd	r25, Y+4	; 0x04
    2008:	41 96       	adiw	r24, 0x11	; 17
    200a:	0e 94 b5 19 	call	0x336a	; 0x336a <xTaskRemoveFromEventList>
    200e:	88 23       	and	r24, r24
    2010:	61 f0       	breq	.+24     	; 0x202a <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    2012:	ef 81       	ldd	r30, Y+7	; 0x07
    2014:	f8 85       	ldd	r31, Y+8	; 0x08
    2016:	81 e0       	ldi	r24, 0x01	; 1
    2018:	80 83       	st	Z, r24
    201a:	07 c0       	rjmp	.+14     	; 0x202a <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    201c:	eb 81       	ldd	r30, Y+3	; 0x03
    201e:	fc 81       	ldd	r31, Y+4	; 0x04
    2020:	86 8d       	ldd	r24, Z+30	; 0x1e
    2022:	8f 5f       	subi	r24, 0xFF	; 255
    2024:	eb 81       	ldd	r30, Y+3	; 0x03
    2026:	fc 81       	ldd	r31, Y+4	; 0x04
    2028:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    202a:	81 e0       	ldi	r24, 0x01	; 1
    202c:	8a 83       	std	Y+2, r24	; 0x02
    202e:	01 c0       	rjmp	.+2      	; 0x2032 <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2030:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2032:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2034:	29 96       	adiw	r28, 0x09	; 9
    2036:	0f b6       	in	r0, 0x3f	; 63
    2038:	f8 94       	cli
    203a:	de bf       	out	0x3e, r29	; 62
    203c:	0f be       	out	0x3f, r0	; 63
    203e:	cd bf       	out	0x3d, r28	; 61
    2040:	cf 91       	pop	r28
    2042:	df 91       	pop	r29
    2044:	08 95       	ret

00002046 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    2046:	df 93       	push	r29
    2048:	cf 93       	push	r28
    204a:	cd b7       	in	r28, 0x3d	; 61
    204c:	de b7       	in	r29, 0x3e	; 62
    204e:	2e 97       	sbiw	r28, 0x0e	; 14
    2050:	0f b6       	in	r0, 0x3f	; 63
    2052:	f8 94       	cli
    2054:	de bf       	out	0x3e, r29	; 62
    2056:	0f be       	out	0x3f, r0	; 63
    2058:	cd bf       	out	0x3d, r28	; 61
    205a:	98 87       	std	Y+8, r25	; 0x08
    205c:	8f 83       	std	Y+7, r24	; 0x07
    205e:	7a 87       	std	Y+10, r23	; 0x0a
    2060:	69 87       	std	Y+9, r22	; 0x09
    2062:	5c 87       	std	Y+12, r21	; 0x0c
    2064:	4b 87       	std	Y+11, r20	; 0x0b
    2066:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    2068:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    206a:	0f b6       	in	r0, 0x3f	; 63
    206c:	f8 94       	cli
    206e:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    2070:	ef 81       	ldd	r30, Y+7	; 0x07
    2072:	f8 85       	ldd	r31, Y+8	; 0x08
    2074:	82 8d       	ldd	r24, Z+26	; 0x1a
    2076:	88 23       	and	r24, r24
    2078:	09 f4       	brne	.+2      	; 0x207c <xQueueGenericReceive+0x36>
    207a:	3f c0       	rjmp	.+126    	; 0x20fa <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    207c:	ef 81       	ldd	r30, Y+7	; 0x07
    207e:	f8 85       	ldd	r31, Y+8	; 0x08
    2080:	86 81       	ldd	r24, Z+6	; 0x06
    2082:	97 81       	ldd	r25, Z+7	; 0x07
    2084:	9a 83       	std	Y+2, r25	; 0x02
    2086:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2088:	8f 81       	ldd	r24, Y+7	; 0x07
    208a:	98 85       	ldd	r25, Y+8	; 0x08
    208c:	29 85       	ldd	r18, Y+9	; 0x09
    208e:	3a 85       	ldd	r19, Y+10	; 0x0a
    2090:	b9 01       	movw	r22, r18
    2092:	0e 94 08 12 	call	0x2410	; 0x2410 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    2096:	8d 85       	ldd	r24, Y+13	; 0x0d
    2098:	88 23       	and	r24, r24
    209a:	b1 f4       	brne	.+44     	; 0x20c8 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    209c:	ef 81       	ldd	r30, Y+7	; 0x07
    209e:	f8 85       	ldd	r31, Y+8	; 0x08
    20a0:	82 8d       	ldd	r24, Z+26	; 0x1a
    20a2:	81 50       	subi	r24, 0x01	; 1
    20a4:	ef 81       	ldd	r30, Y+7	; 0x07
    20a6:	f8 85       	ldd	r31, Y+8	; 0x08
    20a8:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    20aa:	ef 81       	ldd	r30, Y+7	; 0x07
    20ac:	f8 85       	ldd	r31, Y+8	; 0x08
    20ae:	80 85       	ldd	r24, Z+8	; 0x08
    20b0:	88 23       	and	r24, r24
    20b2:	f1 f0       	breq	.+60     	; 0x20f0 <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    20b4:	8f 81       	ldd	r24, Y+7	; 0x07
    20b6:	98 85       	ldd	r25, Y+8	; 0x08
    20b8:	08 96       	adiw	r24, 0x08	; 8
    20ba:	0e 94 b5 19 	call	0x336a	; 0x336a <xTaskRemoveFromEventList>
    20be:	81 30       	cpi	r24, 0x01	; 1
    20c0:	b9 f4       	brne	.+46     	; 0x20f0 <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    20c2:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <vPortYield>
    20c6:	14 c0       	rjmp	.+40     	; 0x20f0 <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    20c8:	ef 81       	ldd	r30, Y+7	; 0x07
    20ca:	f8 85       	ldd	r31, Y+8	; 0x08
    20cc:	89 81       	ldd	r24, Y+1	; 0x01
    20ce:	9a 81       	ldd	r25, Y+2	; 0x02
    20d0:	97 83       	std	Z+7, r25	; 0x07
    20d2:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    20d4:	ef 81       	ldd	r30, Y+7	; 0x07
    20d6:	f8 85       	ldd	r31, Y+8	; 0x08
    20d8:	81 89       	ldd	r24, Z+17	; 0x11
    20da:	88 23       	and	r24, r24
    20dc:	49 f0       	breq	.+18     	; 0x20f0 <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    20de:	8f 81       	ldd	r24, Y+7	; 0x07
    20e0:	98 85       	ldd	r25, Y+8	; 0x08
    20e2:	41 96       	adiw	r24, 0x11	; 17
    20e4:	0e 94 b5 19 	call	0x336a	; 0x336a <xTaskRemoveFromEventList>
    20e8:	88 23       	and	r24, r24
    20ea:	11 f0       	breq	.+4      	; 0x20f0 <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    20ec:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    20f0:	0f 90       	pop	r0
    20f2:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    20f4:	81 e0       	ldi	r24, 0x01	; 1
    20f6:	8e 87       	std	Y+14, r24	; 0x0e
    20f8:	5c c0       	rjmp	.+184    	; 0x21b2 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    20fa:	8b 85       	ldd	r24, Y+11	; 0x0b
    20fc:	9c 85       	ldd	r25, Y+12	; 0x0c
    20fe:	00 97       	sbiw	r24, 0x00	; 0
    2100:	21 f4       	brne	.+8      	; 0x210a <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2102:	0f 90       	pop	r0
    2104:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2106:	1e 86       	std	Y+14, r1	; 0x0e
    2108:	54 c0       	rjmp	.+168    	; 0x21b2 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    210a:	8b 81       	ldd	r24, Y+3	; 0x03
    210c:	88 23       	and	r24, r24
    210e:	31 f4       	brne	.+12     	; 0x211c <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2110:	ce 01       	movw	r24, r28
    2112:	04 96       	adiw	r24, 0x04	; 4
    2114:	0e 94 1d 1a 	call	0x343a	; 0x343a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2118:	81 e0       	ldi	r24, 0x01	; 1
    211a:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    211c:	0f 90       	pop	r0
    211e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2120:	0e 94 32 17 	call	0x2e64	; 0x2e64 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2124:	0f b6       	in	r0, 0x3f	; 63
    2126:	f8 94       	cli
    2128:	0f 92       	push	r0
    212a:	ef 81       	ldd	r30, Y+7	; 0x07
    212c:	f8 85       	ldd	r31, Y+8	; 0x08
    212e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2130:	8f 3f       	cpi	r24, 0xFF	; 255
    2132:	19 f4       	brne	.+6      	; 0x213a <xQueueGenericReceive+0xf4>
    2134:	ef 81       	ldd	r30, Y+7	; 0x07
    2136:	f8 85       	ldd	r31, Y+8	; 0x08
    2138:	15 8e       	std	Z+29, r1	; 0x1d
    213a:	ef 81       	ldd	r30, Y+7	; 0x07
    213c:	f8 85       	ldd	r31, Y+8	; 0x08
    213e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2140:	8f 3f       	cpi	r24, 0xFF	; 255
    2142:	19 f4       	brne	.+6      	; 0x214a <xQueueGenericReceive+0x104>
    2144:	ef 81       	ldd	r30, Y+7	; 0x07
    2146:	f8 85       	ldd	r31, Y+8	; 0x08
    2148:	16 8e       	std	Z+30, r1	; 0x1e
    214a:	0f 90       	pop	r0
    214c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    214e:	ce 01       	movw	r24, r28
    2150:	04 96       	adiw	r24, 0x04	; 4
    2152:	9e 01       	movw	r18, r28
    2154:	25 5f       	subi	r18, 0xF5	; 245
    2156:	3f 4f       	sbci	r19, 0xFF	; 255
    2158:	b9 01       	movw	r22, r18
    215a:	0e 94 36 1a 	call	0x346c	; 0x346c <xTaskCheckForTimeOut>
    215e:	88 23       	and	r24, r24
    2160:	09 f5       	brne	.+66     	; 0x21a4 <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2162:	8f 81       	ldd	r24, Y+7	; 0x07
    2164:	98 85       	ldd	r25, Y+8	; 0x08
    2166:	0e 94 a4 12 	call	0x2548	; 0x2548 <prvIsQueueEmpty>
    216a:	88 23       	and	r24, r24
    216c:	a1 f0       	breq	.+40     	; 0x2196 <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    216e:	8f 81       	ldd	r24, Y+7	; 0x07
    2170:	98 85       	ldd	r25, Y+8	; 0x08
    2172:	41 96       	adiw	r24, 0x11	; 17
    2174:	2b 85       	ldd	r18, Y+11	; 0x0b
    2176:	3c 85       	ldd	r19, Y+12	; 0x0c
    2178:	b9 01       	movw	r22, r18
    217a:	0e 94 36 19 	call	0x326c	; 0x326c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    217e:	8f 81       	ldd	r24, Y+7	; 0x07
    2180:	98 85       	ldd	r25, Y+8	; 0x08
    2182:	0e 94 50 12 	call	0x24a0	; 0x24a0 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2186:	0e 94 3e 17 	call	0x2e7c	; 0x2e7c <xTaskResumeAll>
    218a:	88 23       	and	r24, r24
    218c:	09 f0       	breq	.+2      	; 0x2190 <xQueueGenericReceive+0x14a>
    218e:	6d cf       	rjmp	.-294    	; 0x206a <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    2190:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <vPortYield>
    2194:	6a cf       	rjmp	.-300    	; 0x206a <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2196:	8f 81       	ldd	r24, Y+7	; 0x07
    2198:	98 85       	ldd	r25, Y+8	; 0x08
    219a:	0e 94 50 12 	call	0x24a0	; 0x24a0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    219e:	0e 94 3e 17 	call	0x2e7c	; 0x2e7c <xTaskResumeAll>
    21a2:	63 cf       	rjmp	.-314    	; 0x206a <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    21a4:	8f 81       	ldd	r24, Y+7	; 0x07
    21a6:	98 85       	ldd	r25, Y+8	; 0x08
    21a8:	0e 94 50 12 	call	0x24a0	; 0x24a0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    21ac:	0e 94 3e 17 	call	0x2e7c	; 0x2e7c <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    21b0:	1e 86       	std	Y+14, r1	; 0x0e
    21b2:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    21b4:	2e 96       	adiw	r28, 0x0e	; 14
    21b6:	0f b6       	in	r0, 0x3f	; 63
    21b8:	f8 94       	cli
    21ba:	de bf       	out	0x3e, r29	; 62
    21bc:	0f be       	out	0x3f, r0	; 63
    21be:	cd bf       	out	0x3d, r28	; 61
    21c0:	cf 91       	pop	r28
    21c2:	df 91       	pop	r29
    21c4:	08 95       	ret

000021c6 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    21c6:	df 93       	push	r29
    21c8:	cf 93       	push	r28
    21ca:	cd b7       	in	r28, 0x3d	; 61
    21cc:	de b7       	in	r29, 0x3e	; 62
    21ce:	28 97       	sbiw	r28, 0x08	; 8
    21d0:	0f b6       	in	r0, 0x3f	; 63
    21d2:	f8 94       	cli
    21d4:	de bf       	out	0x3e, r29	; 62
    21d6:	0f be       	out	0x3f, r0	; 63
    21d8:	cd bf       	out	0x3d, r28	; 61
    21da:	9c 83       	std	Y+4, r25	; 0x04
    21dc:	8b 83       	std	Y+3, r24	; 0x03
    21de:	7e 83       	std	Y+6, r23	; 0x06
    21e0:	6d 83       	std	Y+5, r22	; 0x05
    21e2:	58 87       	std	Y+8, r21	; 0x08
    21e4:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    21e6:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    21e8:	eb 81       	ldd	r30, Y+3	; 0x03
    21ea:	fc 81       	ldd	r31, Y+4	; 0x04
    21ec:	82 8d       	ldd	r24, Z+26	; 0x1a
    21ee:	88 23       	and	r24, r24
    21f0:	71 f1       	breq	.+92     	; 0x224e <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    21f2:	8b 81       	ldd	r24, Y+3	; 0x03
    21f4:	9c 81       	ldd	r25, Y+4	; 0x04
    21f6:	2d 81       	ldd	r18, Y+5	; 0x05
    21f8:	3e 81       	ldd	r19, Y+6	; 0x06
    21fa:	b9 01       	movw	r22, r18
    21fc:	0e 94 08 12 	call	0x2410	; 0x2410 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    2200:	eb 81       	ldd	r30, Y+3	; 0x03
    2202:	fc 81       	ldd	r31, Y+4	; 0x04
    2204:	82 8d       	ldd	r24, Z+26	; 0x1a
    2206:	81 50       	subi	r24, 0x01	; 1
    2208:	eb 81       	ldd	r30, Y+3	; 0x03
    220a:	fc 81       	ldd	r31, Y+4	; 0x04
    220c:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    220e:	eb 81       	ldd	r30, Y+3	; 0x03
    2210:	fc 81       	ldd	r31, Y+4	; 0x04
    2212:	85 8d       	ldd	r24, Z+29	; 0x1d
    2214:	8f 3f       	cpi	r24, 0xFF	; 255
    2216:	89 f4       	brne	.+34     	; 0x223a <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2218:	eb 81       	ldd	r30, Y+3	; 0x03
    221a:	fc 81       	ldd	r31, Y+4	; 0x04
    221c:	80 85       	ldd	r24, Z+8	; 0x08
    221e:	88 23       	and	r24, r24
    2220:	99 f0       	breq	.+38     	; 0x2248 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2222:	8b 81       	ldd	r24, Y+3	; 0x03
    2224:	9c 81       	ldd	r25, Y+4	; 0x04
    2226:	08 96       	adiw	r24, 0x08	; 8
    2228:	0e 94 b5 19 	call	0x336a	; 0x336a <xTaskRemoveFromEventList>
    222c:	88 23       	and	r24, r24
    222e:	61 f0       	breq	.+24     	; 0x2248 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    2230:	ef 81       	ldd	r30, Y+7	; 0x07
    2232:	f8 85       	ldd	r31, Y+8	; 0x08
    2234:	81 e0       	ldi	r24, 0x01	; 1
    2236:	80 83       	st	Z, r24
    2238:	07 c0       	rjmp	.+14     	; 0x2248 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    223a:	eb 81       	ldd	r30, Y+3	; 0x03
    223c:	fc 81       	ldd	r31, Y+4	; 0x04
    223e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2240:	8f 5f       	subi	r24, 0xFF	; 255
    2242:	eb 81       	ldd	r30, Y+3	; 0x03
    2244:	fc 81       	ldd	r31, Y+4	; 0x04
    2246:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    2248:	81 e0       	ldi	r24, 0x01	; 1
    224a:	8a 83       	std	Y+2, r24	; 0x02
    224c:	01 c0       	rjmp	.+2      	; 0x2250 <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    224e:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2250:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2252:	28 96       	adiw	r28, 0x08	; 8
    2254:	0f b6       	in	r0, 0x3f	; 63
    2256:	f8 94       	cli
    2258:	de bf       	out	0x3e, r29	; 62
    225a:	0f be       	out	0x3f, r0	; 63
    225c:	cd bf       	out	0x3d, r28	; 61
    225e:	cf 91       	pop	r28
    2260:	df 91       	pop	r29
    2262:	08 95       	ret

00002264 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    2264:	df 93       	push	r29
    2266:	cf 93       	push	r28
    2268:	00 d0       	rcall	.+0      	; 0x226a <uxQueueMessagesWaiting+0x6>
    226a:	0f 92       	push	r0
    226c:	cd b7       	in	r28, 0x3d	; 61
    226e:	de b7       	in	r29, 0x3e	; 62
    2270:	9b 83       	std	Y+3, r25	; 0x03
    2272:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2274:	0f b6       	in	r0, 0x3f	; 63
    2276:	f8 94       	cli
    2278:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    227a:	ea 81       	ldd	r30, Y+2	; 0x02
    227c:	fb 81       	ldd	r31, Y+3	; 0x03
    227e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2280:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    2282:	0f 90       	pop	r0
    2284:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2286:	89 81       	ldd	r24, Y+1	; 0x01
}
    2288:	0f 90       	pop	r0
    228a:	0f 90       	pop	r0
    228c:	0f 90       	pop	r0
    228e:	cf 91       	pop	r28
    2290:	df 91       	pop	r29
    2292:	08 95       	ret

00002294 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    2294:	df 93       	push	r29
    2296:	cf 93       	push	r28
    2298:	00 d0       	rcall	.+0      	; 0x229a <uxQueueMessagesWaitingFromISR+0x6>
    229a:	0f 92       	push	r0
    229c:	cd b7       	in	r28, 0x3d	; 61
    229e:	de b7       	in	r29, 0x3e	; 62
    22a0:	9b 83       	std	Y+3, r25	; 0x03
    22a2:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    22a4:	ea 81       	ldd	r30, Y+2	; 0x02
    22a6:	fb 81       	ldd	r31, Y+3	; 0x03
    22a8:	82 8d       	ldd	r24, Z+26	; 0x1a
    22aa:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    22ac:	89 81       	ldd	r24, Y+1	; 0x01
}
    22ae:	0f 90       	pop	r0
    22b0:	0f 90       	pop	r0
    22b2:	0f 90       	pop	r0
    22b4:	cf 91       	pop	r28
    22b6:	df 91       	pop	r29
    22b8:	08 95       	ret

000022ba <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    22ba:	df 93       	push	r29
    22bc:	cf 93       	push	r28
    22be:	00 d0       	rcall	.+0      	; 0x22c0 <vQueueDelete+0x6>
    22c0:	cd b7       	in	r28, 0x3d	; 61
    22c2:	de b7       	in	r29, 0x3e	; 62
    22c4:	9a 83       	std	Y+2, r25	; 0x02
    22c6:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    22c8:	e9 81       	ldd	r30, Y+1	; 0x01
    22ca:	fa 81       	ldd	r31, Y+2	; 0x02
    22cc:	80 81       	ld	r24, Z
    22ce:	91 81       	ldd	r25, Z+1	; 0x01
    22d0:	0e 94 35 0a 	call	0x146a	; 0x146a <vPortFree>
	vPortFree( pxQueue );
    22d4:	89 81       	ldd	r24, Y+1	; 0x01
    22d6:	9a 81       	ldd	r25, Y+2	; 0x02
    22d8:	0e 94 35 0a 	call	0x146a	; 0x146a <vPortFree>
}
    22dc:	0f 90       	pop	r0
    22de:	0f 90       	pop	r0
    22e0:	cf 91       	pop	r28
    22e2:	df 91       	pop	r29
    22e4:	08 95       	ret

000022e6 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    22e6:	df 93       	push	r29
    22e8:	cf 93       	push	r28
    22ea:	00 d0       	rcall	.+0      	; 0x22ec <prvCopyDataToQueue+0x6>
    22ec:	00 d0       	rcall	.+0      	; 0x22ee <prvCopyDataToQueue+0x8>
    22ee:	0f 92       	push	r0
    22f0:	cd b7       	in	r28, 0x3d	; 61
    22f2:	de b7       	in	r29, 0x3e	; 62
    22f4:	9a 83       	std	Y+2, r25	; 0x02
    22f6:	89 83       	std	Y+1, r24	; 0x01
    22f8:	7c 83       	std	Y+4, r23	; 0x04
    22fa:	6b 83       	std	Y+3, r22	; 0x03
    22fc:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    22fe:	e9 81       	ldd	r30, Y+1	; 0x01
    2300:	fa 81       	ldd	r31, Y+2	; 0x02
    2302:	84 8d       	ldd	r24, Z+28	; 0x1c
    2304:	88 23       	and	r24, r24
    2306:	09 f4       	brne	.+2      	; 0x230a <prvCopyDataToQueue+0x24>
    2308:	74 c0       	rjmp	.+232    	; 0x23f2 <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    230a:	8d 81       	ldd	r24, Y+5	; 0x05
    230c:	88 23       	and	r24, r24
    230e:	99 f5       	brne	.+102    	; 0x2376 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    2310:	e9 81       	ldd	r30, Y+1	; 0x01
    2312:	fa 81       	ldd	r31, Y+2	; 0x02
    2314:	64 81       	ldd	r22, Z+4	; 0x04
    2316:	75 81       	ldd	r23, Z+5	; 0x05
    2318:	e9 81       	ldd	r30, Y+1	; 0x01
    231a:	fa 81       	ldd	r31, Y+2	; 0x02
    231c:	84 8d       	ldd	r24, Z+28	; 0x1c
    231e:	48 2f       	mov	r20, r24
    2320:	50 e0       	ldi	r21, 0x00	; 0
    2322:	2b 81       	ldd	r18, Y+3	; 0x03
    2324:	3c 81       	ldd	r19, Y+4	; 0x04
    2326:	cb 01       	movw	r24, r22
    2328:	b9 01       	movw	r22, r18
    232a:	0e 94 75 34 	call	0x68ea	; 0x68ea <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    232e:	e9 81       	ldd	r30, Y+1	; 0x01
    2330:	fa 81       	ldd	r31, Y+2	; 0x02
    2332:	24 81       	ldd	r18, Z+4	; 0x04
    2334:	35 81       	ldd	r19, Z+5	; 0x05
    2336:	e9 81       	ldd	r30, Y+1	; 0x01
    2338:	fa 81       	ldd	r31, Y+2	; 0x02
    233a:	84 8d       	ldd	r24, Z+28	; 0x1c
    233c:	88 2f       	mov	r24, r24
    233e:	90 e0       	ldi	r25, 0x00	; 0
    2340:	82 0f       	add	r24, r18
    2342:	93 1f       	adc	r25, r19
    2344:	e9 81       	ldd	r30, Y+1	; 0x01
    2346:	fa 81       	ldd	r31, Y+2	; 0x02
    2348:	95 83       	std	Z+5, r25	; 0x05
    234a:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    234c:	e9 81       	ldd	r30, Y+1	; 0x01
    234e:	fa 81       	ldd	r31, Y+2	; 0x02
    2350:	24 81       	ldd	r18, Z+4	; 0x04
    2352:	35 81       	ldd	r19, Z+5	; 0x05
    2354:	e9 81       	ldd	r30, Y+1	; 0x01
    2356:	fa 81       	ldd	r31, Y+2	; 0x02
    2358:	82 81       	ldd	r24, Z+2	; 0x02
    235a:	93 81       	ldd	r25, Z+3	; 0x03
    235c:	28 17       	cp	r18, r24
    235e:	39 07       	cpc	r19, r25
    2360:	08 f4       	brcc	.+2      	; 0x2364 <prvCopyDataToQueue+0x7e>
    2362:	47 c0       	rjmp	.+142    	; 0x23f2 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    2364:	e9 81       	ldd	r30, Y+1	; 0x01
    2366:	fa 81       	ldd	r31, Y+2	; 0x02
    2368:	80 81       	ld	r24, Z
    236a:	91 81       	ldd	r25, Z+1	; 0x01
    236c:	e9 81       	ldd	r30, Y+1	; 0x01
    236e:	fa 81       	ldd	r31, Y+2	; 0x02
    2370:	95 83       	std	Z+5, r25	; 0x05
    2372:	84 83       	std	Z+4, r24	; 0x04
    2374:	3e c0       	rjmp	.+124    	; 0x23f2 <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    2376:	e9 81       	ldd	r30, Y+1	; 0x01
    2378:	fa 81       	ldd	r31, Y+2	; 0x02
    237a:	66 81       	ldd	r22, Z+6	; 0x06
    237c:	77 81       	ldd	r23, Z+7	; 0x07
    237e:	e9 81       	ldd	r30, Y+1	; 0x01
    2380:	fa 81       	ldd	r31, Y+2	; 0x02
    2382:	84 8d       	ldd	r24, Z+28	; 0x1c
    2384:	48 2f       	mov	r20, r24
    2386:	50 e0       	ldi	r21, 0x00	; 0
    2388:	2b 81       	ldd	r18, Y+3	; 0x03
    238a:	3c 81       	ldd	r19, Y+4	; 0x04
    238c:	cb 01       	movw	r24, r22
    238e:	b9 01       	movw	r22, r18
    2390:	0e 94 75 34 	call	0x68ea	; 0x68ea <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    2394:	e9 81       	ldd	r30, Y+1	; 0x01
    2396:	fa 81       	ldd	r31, Y+2	; 0x02
    2398:	26 81       	ldd	r18, Z+6	; 0x06
    239a:	37 81       	ldd	r19, Z+7	; 0x07
    239c:	e9 81       	ldd	r30, Y+1	; 0x01
    239e:	fa 81       	ldd	r31, Y+2	; 0x02
    23a0:	84 8d       	ldd	r24, Z+28	; 0x1c
    23a2:	88 2f       	mov	r24, r24
    23a4:	90 e0       	ldi	r25, 0x00	; 0
    23a6:	90 95       	com	r25
    23a8:	81 95       	neg	r24
    23aa:	9f 4f       	sbci	r25, 0xFF	; 255
    23ac:	82 0f       	add	r24, r18
    23ae:	93 1f       	adc	r25, r19
    23b0:	e9 81       	ldd	r30, Y+1	; 0x01
    23b2:	fa 81       	ldd	r31, Y+2	; 0x02
    23b4:	97 83       	std	Z+7, r25	; 0x07
    23b6:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    23b8:	e9 81       	ldd	r30, Y+1	; 0x01
    23ba:	fa 81       	ldd	r31, Y+2	; 0x02
    23bc:	26 81       	ldd	r18, Z+6	; 0x06
    23be:	37 81       	ldd	r19, Z+7	; 0x07
    23c0:	e9 81       	ldd	r30, Y+1	; 0x01
    23c2:	fa 81       	ldd	r31, Y+2	; 0x02
    23c4:	80 81       	ld	r24, Z
    23c6:	91 81       	ldd	r25, Z+1	; 0x01
    23c8:	28 17       	cp	r18, r24
    23ca:	39 07       	cpc	r19, r25
    23cc:	90 f4       	brcc	.+36     	; 0x23f2 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    23ce:	e9 81       	ldd	r30, Y+1	; 0x01
    23d0:	fa 81       	ldd	r31, Y+2	; 0x02
    23d2:	22 81       	ldd	r18, Z+2	; 0x02
    23d4:	33 81       	ldd	r19, Z+3	; 0x03
    23d6:	e9 81       	ldd	r30, Y+1	; 0x01
    23d8:	fa 81       	ldd	r31, Y+2	; 0x02
    23da:	84 8d       	ldd	r24, Z+28	; 0x1c
    23dc:	88 2f       	mov	r24, r24
    23de:	90 e0       	ldi	r25, 0x00	; 0
    23e0:	90 95       	com	r25
    23e2:	81 95       	neg	r24
    23e4:	9f 4f       	sbci	r25, 0xFF	; 255
    23e6:	82 0f       	add	r24, r18
    23e8:	93 1f       	adc	r25, r19
    23ea:	e9 81       	ldd	r30, Y+1	; 0x01
    23ec:	fa 81       	ldd	r31, Y+2	; 0x02
    23ee:	97 83       	std	Z+7, r25	; 0x07
    23f0:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    23f2:	e9 81       	ldd	r30, Y+1	; 0x01
    23f4:	fa 81       	ldd	r31, Y+2	; 0x02
    23f6:	82 8d       	ldd	r24, Z+26	; 0x1a
    23f8:	8f 5f       	subi	r24, 0xFF	; 255
    23fa:	e9 81       	ldd	r30, Y+1	; 0x01
    23fc:	fa 81       	ldd	r31, Y+2	; 0x02
    23fe:	82 8f       	std	Z+26, r24	; 0x1a
}
    2400:	0f 90       	pop	r0
    2402:	0f 90       	pop	r0
    2404:	0f 90       	pop	r0
    2406:	0f 90       	pop	r0
    2408:	0f 90       	pop	r0
    240a:	cf 91       	pop	r28
    240c:	df 91       	pop	r29
    240e:	08 95       	ret

00002410 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    2410:	df 93       	push	r29
    2412:	cf 93       	push	r28
    2414:	00 d0       	rcall	.+0      	; 0x2416 <prvCopyDataFromQueue+0x6>
    2416:	00 d0       	rcall	.+0      	; 0x2418 <prvCopyDataFromQueue+0x8>
    2418:	cd b7       	in	r28, 0x3d	; 61
    241a:	de b7       	in	r29, 0x3e	; 62
    241c:	9a 83       	std	Y+2, r25	; 0x02
    241e:	89 83       	std	Y+1, r24	; 0x01
    2420:	7c 83       	std	Y+4, r23	; 0x04
    2422:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    2424:	e9 81       	ldd	r30, Y+1	; 0x01
    2426:	fa 81       	ldd	r31, Y+2	; 0x02
    2428:	80 81       	ld	r24, Z
    242a:	91 81       	ldd	r25, Z+1	; 0x01
    242c:	00 97       	sbiw	r24, 0x00	; 0
    242e:	89 f1       	breq	.+98     	; 0x2492 <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    2430:	e9 81       	ldd	r30, Y+1	; 0x01
    2432:	fa 81       	ldd	r31, Y+2	; 0x02
    2434:	26 81       	ldd	r18, Z+6	; 0x06
    2436:	37 81       	ldd	r19, Z+7	; 0x07
    2438:	e9 81       	ldd	r30, Y+1	; 0x01
    243a:	fa 81       	ldd	r31, Y+2	; 0x02
    243c:	84 8d       	ldd	r24, Z+28	; 0x1c
    243e:	88 2f       	mov	r24, r24
    2440:	90 e0       	ldi	r25, 0x00	; 0
    2442:	82 0f       	add	r24, r18
    2444:	93 1f       	adc	r25, r19
    2446:	e9 81       	ldd	r30, Y+1	; 0x01
    2448:	fa 81       	ldd	r31, Y+2	; 0x02
    244a:	97 83       	std	Z+7, r25	; 0x07
    244c:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    244e:	e9 81       	ldd	r30, Y+1	; 0x01
    2450:	fa 81       	ldd	r31, Y+2	; 0x02
    2452:	26 81       	ldd	r18, Z+6	; 0x06
    2454:	37 81       	ldd	r19, Z+7	; 0x07
    2456:	e9 81       	ldd	r30, Y+1	; 0x01
    2458:	fa 81       	ldd	r31, Y+2	; 0x02
    245a:	82 81       	ldd	r24, Z+2	; 0x02
    245c:	93 81       	ldd	r25, Z+3	; 0x03
    245e:	28 17       	cp	r18, r24
    2460:	39 07       	cpc	r19, r25
    2462:	40 f0       	brcs	.+16     	; 0x2474 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    2464:	e9 81       	ldd	r30, Y+1	; 0x01
    2466:	fa 81       	ldd	r31, Y+2	; 0x02
    2468:	80 81       	ld	r24, Z
    246a:	91 81       	ldd	r25, Z+1	; 0x01
    246c:	e9 81       	ldd	r30, Y+1	; 0x01
    246e:	fa 81       	ldd	r31, Y+2	; 0x02
    2470:	97 83       	std	Z+7, r25	; 0x07
    2472:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2474:	e9 81       	ldd	r30, Y+1	; 0x01
    2476:	fa 81       	ldd	r31, Y+2	; 0x02
    2478:	46 81       	ldd	r20, Z+6	; 0x06
    247a:	57 81       	ldd	r21, Z+7	; 0x07
    247c:	e9 81       	ldd	r30, Y+1	; 0x01
    247e:	fa 81       	ldd	r31, Y+2	; 0x02
    2480:	84 8d       	ldd	r24, Z+28	; 0x1c
    2482:	28 2f       	mov	r18, r24
    2484:	30 e0       	ldi	r19, 0x00	; 0
    2486:	8b 81       	ldd	r24, Y+3	; 0x03
    2488:	9c 81       	ldd	r25, Y+4	; 0x04
    248a:	ba 01       	movw	r22, r20
    248c:	a9 01       	movw	r20, r18
    248e:	0e 94 75 34 	call	0x68ea	; 0x68ea <memcpy>
	}
}
    2492:	0f 90       	pop	r0
    2494:	0f 90       	pop	r0
    2496:	0f 90       	pop	r0
    2498:	0f 90       	pop	r0
    249a:	cf 91       	pop	r28
    249c:	df 91       	pop	r29
    249e:	08 95       	ret

000024a0 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    24a0:	df 93       	push	r29
    24a2:	cf 93       	push	r28
    24a4:	00 d0       	rcall	.+0      	; 0x24a6 <prvUnlockQueue+0x6>
    24a6:	cd b7       	in	r28, 0x3d	; 61
    24a8:	de b7       	in	r29, 0x3e	; 62
    24aa:	9a 83       	std	Y+2, r25	; 0x02
    24ac:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    24ae:	0f b6       	in	r0, 0x3f	; 63
    24b0:	f8 94       	cli
    24b2:	0f 92       	push	r0
    24b4:	15 c0       	rjmp	.+42     	; 0x24e0 <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    24b6:	e9 81       	ldd	r30, Y+1	; 0x01
    24b8:	fa 81       	ldd	r31, Y+2	; 0x02
    24ba:	81 89       	ldd	r24, Z+17	; 0x11
    24bc:	88 23       	and	r24, r24
    24be:	a9 f0       	breq	.+42     	; 0x24ea <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    24c0:	89 81       	ldd	r24, Y+1	; 0x01
    24c2:	9a 81       	ldd	r25, Y+2	; 0x02
    24c4:	41 96       	adiw	r24, 0x11	; 17
    24c6:	0e 94 b5 19 	call	0x336a	; 0x336a <xTaskRemoveFromEventList>
    24ca:	88 23       	and	r24, r24
    24cc:	11 f0       	breq	.+4      	; 0x24d2 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    24ce:	0e 94 9d 1a 	call	0x353a	; 0x353a <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    24d2:	e9 81       	ldd	r30, Y+1	; 0x01
    24d4:	fa 81       	ldd	r31, Y+2	; 0x02
    24d6:	86 8d       	ldd	r24, Z+30	; 0x1e
    24d8:	81 50       	subi	r24, 0x01	; 1
    24da:	e9 81       	ldd	r30, Y+1	; 0x01
    24dc:	fa 81       	ldd	r31, Y+2	; 0x02
    24de:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    24e0:	e9 81       	ldd	r30, Y+1	; 0x01
    24e2:	fa 81       	ldd	r31, Y+2	; 0x02
    24e4:	86 8d       	ldd	r24, Z+30	; 0x1e
    24e6:	18 16       	cp	r1, r24
    24e8:	34 f3       	brlt	.-52     	; 0x24b6 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    24ea:	e9 81       	ldd	r30, Y+1	; 0x01
    24ec:	fa 81       	ldd	r31, Y+2	; 0x02
    24ee:	8f ef       	ldi	r24, 0xFF	; 255
    24f0:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    24f2:	0f 90       	pop	r0
    24f4:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    24f6:	0f b6       	in	r0, 0x3f	; 63
    24f8:	f8 94       	cli
    24fa:	0f 92       	push	r0
    24fc:	15 c0       	rjmp	.+42     	; 0x2528 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    24fe:	e9 81       	ldd	r30, Y+1	; 0x01
    2500:	fa 81       	ldd	r31, Y+2	; 0x02
    2502:	80 85       	ldd	r24, Z+8	; 0x08
    2504:	88 23       	and	r24, r24
    2506:	a9 f0       	breq	.+42     	; 0x2532 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2508:	89 81       	ldd	r24, Y+1	; 0x01
    250a:	9a 81       	ldd	r25, Y+2	; 0x02
    250c:	08 96       	adiw	r24, 0x08	; 8
    250e:	0e 94 b5 19 	call	0x336a	; 0x336a <xTaskRemoveFromEventList>
    2512:	88 23       	and	r24, r24
    2514:	11 f0       	breq	.+4      	; 0x251a <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    2516:	0e 94 9d 1a 	call	0x353a	; 0x353a <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    251a:	e9 81       	ldd	r30, Y+1	; 0x01
    251c:	fa 81       	ldd	r31, Y+2	; 0x02
    251e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2520:	81 50       	subi	r24, 0x01	; 1
    2522:	e9 81       	ldd	r30, Y+1	; 0x01
    2524:	fa 81       	ldd	r31, Y+2	; 0x02
    2526:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2528:	e9 81       	ldd	r30, Y+1	; 0x01
    252a:	fa 81       	ldd	r31, Y+2	; 0x02
    252c:	85 8d       	ldd	r24, Z+29	; 0x1d
    252e:	18 16       	cp	r1, r24
    2530:	34 f3       	brlt	.-52     	; 0x24fe <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    2532:	e9 81       	ldd	r30, Y+1	; 0x01
    2534:	fa 81       	ldd	r31, Y+2	; 0x02
    2536:	8f ef       	ldi	r24, 0xFF	; 255
    2538:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    253a:	0f 90       	pop	r0
    253c:	0f be       	out	0x3f, r0	; 63
}
    253e:	0f 90       	pop	r0
    2540:	0f 90       	pop	r0
    2542:	cf 91       	pop	r28
    2544:	df 91       	pop	r29
    2546:	08 95       	ret

00002548 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    2548:	df 93       	push	r29
    254a:	cf 93       	push	r28
    254c:	00 d0       	rcall	.+0      	; 0x254e <prvIsQueueEmpty+0x6>
    254e:	0f 92       	push	r0
    2550:	cd b7       	in	r28, 0x3d	; 61
    2552:	de b7       	in	r29, 0x3e	; 62
    2554:	9b 83       	std	Y+3, r25	; 0x03
    2556:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    2558:	0f b6       	in	r0, 0x3f	; 63
    255a:	f8 94       	cli
    255c:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    255e:	ea 81       	ldd	r30, Y+2	; 0x02
    2560:	fb 81       	ldd	r31, Y+3	; 0x03
    2562:	82 8d       	ldd	r24, Z+26	; 0x1a
    2564:	19 82       	std	Y+1, r1	; 0x01
    2566:	88 23       	and	r24, r24
    2568:	11 f4       	brne	.+4      	; 0x256e <prvIsQueueEmpty+0x26>
    256a:	81 e0       	ldi	r24, 0x01	; 1
    256c:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    256e:	0f 90       	pop	r0
    2570:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2572:	89 81       	ldd	r24, Y+1	; 0x01
}
    2574:	0f 90       	pop	r0
    2576:	0f 90       	pop	r0
    2578:	0f 90       	pop	r0
    257a:	cf 91       	pop	r28
    257c:	df 91       	pop	r29
    257e:	08 95       	ret

00002580 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    2580:	df 93       	push	r29
    2582:	cf 93       	push	r28
    2584:	00 d0       	rcall	.+0      	; 0x2586 <xQueueIsQueueEmptyFromISR+0x6>
    2586:	0f 92       	push	r0
    2588:	cd b7       	in	r28, 0x3d	; 61
    258a:	de b7       	in	r29, 0x3e	; 62
    258c:	9b 83       	std	Y+3, r25	; 0x03
    258e:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    2590:	ea 81       	ldd	r30, Y+2	; 0x02
    2592:	fb 81       	ldd	r31, Y+3	; 0x03
    2594:	82 8d       	ldd	r24, Z+26	; 0x1a
    2596:	19 82       	std	Y+1, r1	; 0x01
    2598:	88 23       	and	r24, r24
    259a:	11 f4       	brne	.+4      	; 0x25a0 <xQueueIsQueueEmptyFromISR+0x20>
    259c:	81 e0       	ldi	r24, 0x01	; 1
    259e:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    25a0:	89 81       	ldd	r24, Y+1	; 0x01
}
    25a2:	0f 90       	pop	r0
    25a4:	0f 90       	pop	r0
    25a6:	0f 90       	pop	r0
    25a8:	cf 91       	pop	r28
    25aa:	df 91       	pop	r29
    25ac:	08 95       	ret

000025ae <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    25ae:	df 93       	push	r29
    25b0:	cf 93       	push	r28
    25b2:	00 d0       	rcall	.+0      	; 0x25b4 <prvIsQueueFull+0x6>
    25b4:	0f 92       	push	r0
    25b6:	cd b7       	in	r28, 0x3d	; 61
    25b8:	de b7       	in	r29, 0x3e	; 62
    25ba:	9b 83       	std	Y+3, r25	; 0x03
    25bc:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    25be:	0f b6       	in	r0, 0x3f	; 63
    25c0:	f8 94       	cli
    25c2:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    25c4:	ea 81       	ldd	r30, Y+2	; 0x02
    25c6:	fb 81       	ldd	r31, Y+3	; 0x03
    25c8:	92 8d       	ldd	r25, Z+26	; 0x1a
    25ca:	ea 81       	ldd	r30, Y+2	; 0x02
    25cc:	fb 81       	ldd	r31, Y+3	; 0x03
    25ce:	83 8d       	ldd	r24, Z+27	; 0x1b
    25d0:	19 82       	std	Y+1, r1	; 0x01
    25d2:	98 17       	cp	r25, r24
    25d4:	11 f4       	brne	.+4      	; 0x25da <prvIsQueueFull+0x2c>
    25d6:	81 e0       	ldi	r24, 0x01	; 1
    25d8:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    25da:	0f 90       	pop	r0
    25dc:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    25de:	89 81       	ldd	r24, Y+1	; 0x01
}
    25e0:	0f 90       	pop	r0
    25e2:	0f 90       	pop	r0
    25e4:	0f 90       	pop	r0
    25e6:	cf 91       	pop	r28
    25e8:	df 91       	pop	r29
    25ea:	08 95       	ret

000025ec <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    25ec:	df 93       	push	r29
    25ee:	cf 93       	push	r28
    25f0:	00 d0       	rcall	.+0      	; 0x25f2 <xQueueIsQueueFullFromISR+0x6>
    25f2:	0f 92       	push	r0
    25f4:	cd b7       	in	r28, 0x3d	; 61
    25f6:	de b7       	in	r29, 0x3e	; 62
    25f8:	9b 83       	std	Y+3, r25	; 0x03
    25fa:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    25fc:	ea 81       	ldd	r30, Y+2	; 0x02
    25fe:	fb 81       	ldd	r31, Y+3	; 0x03
    2600:	92 8d       	ldd	r25, Z+26	; 0x1a
    2602:	ea 81       	ldd	r30, Y+2	; 0x02
    2604:	fb 81       	ldd	r31, Y+3	; 0x03
    2606:	83 8d       	ldd	r24, Z+27	; 0x1b
    2608:	19 82       	std	Y+1, r1	; 0x01
    260a:	98 17       	cp	r25, r24
    260c:	11 f4       	brne	.+4      	; 0x2612 <xQueueIsQueueFullFromISR+0x26>
    260e:	81 e0       	ldi	r24, 0x01	; 1
    2610:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    2612:	89 81       	ldd	r24, Y+1	; 0x01
}
    2614:	0f 90       	pop	r0
    2616:	0f 90       	pop	r0
    2618:	0f 90       	pop	r0
    261a:	cf 91       	pop	r28
    261c:	df 91       	pop	r29
    261e:	08 95       	ret

00002620 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vQueueWaitForMessageRestricted( xQueueHandle pxQueue, portTickType xTicksToWait )
	{
    2620:	df 93       	push	r29
    2622:	cf 93       	push	r28
    2624:	00 d0       	rcall	.+0      	; 0x2626 <vQueueWaitForMessageRestricted+0x6>
    2626:	00 d0       	rcall	.+0      	; 0x2628 <vQueueWaitForMessageRestricted+0x8>
    2628:	cd b7       	in	r28, 0x3d	; 61
    262a:	de b7       	in	r29, 0x3e	; 62
    262c:	9a 83       	std	Y+2, r25	; 0x02
    262e:	89 83       	std	Y+1, r24	; 0x01
    2630:	7c 83       	std	Y+4, r23	; 0x04
    2632:	6b 83       	std	Y+3, r22	; 0x03
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    2634:	0f b6       	in	r0, 0x3f	; 63
    2636:	f8 94       	cli
    2638:	0f 92       	push	r0
    263a:	e9 81       	ldd	r30, Y+1	; 0x01
    263c:	fa 81       	ldd	r31, Y+2	; 0x02
    263e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2640:	8f 3f       	cpi	r24, 0xFF	; 255
    2642:	19 f4       	brne	.+6      	; 0x264a <vQueueWaitForMessageRestricted+0x2a>
    2644:	e9 81       	ldd	r30, Y+1	; 0x01
    2646:	fa 81       	ldd	r31, Y+2	; 0x02
    2648:	15 8e       	std	Z+29, r1	; 0x1d
    264a:	e9 81       	ldd	r30, Y+1	; 0x01
    264c:	fa 81       	ldd	r31, Y+2	; 0x02
    264e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2650:	8f 3f       	cpi	r24, 0xFF	; 255
    2652:	19 f4       	brne	.+6      	; 0x265a <vQueueWaitForMessageRestricted+0x3a>
    2654:	e9 81       	ldd	r30, Y+1	; 0x01
    2656:	fa 81       	ldd	r31, Y+2	; 0x02
    2658:	16 8e       	std	Z+30, r1	; 0x1e
    265a:	0f 90       	pop	r0
    265c:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
    265e:	e9 81       	ldd	r30, Y+1	; 0x01
    2660:	fa 81       	ldd	r31, Y+2	; 0x02
    2662:	82 8d       	ldd	r24, Z+26	; 0x1a
    2664:	88 23       	and	r24, r24
    2666:	41 f4       	brne	.+16     	; 0x2678 <vQueueWaitForMessageRestricted+0x58>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2668:	89 81       	ldd	r24, Y+1	; 0x01
    266a:	9a 81       	ldd	r25, Y+2	; 0x02
    266c:	41 96       	adiw	r24, 0x11	; 17
    266e:	2b 81       	ldd	r18, Y+3	; 0x03
    2670:	3c 81       	ldd	r19, Y+4	; 0x04
    2672:	b9 01       	movw	r22, r18
    2674:	0e 94 7f 19 	call	0x32fe	; 0x32fe <vTaskPlaceOnEventListRestricted>
		}
		prvUnlockQueue( pxQueue );
    2678:	89 81       	ldd	r24, Y+1	; 0x01
    267a:	9a 81       	ldd	r25, Y+2	; 0x02
    267c:	0e 94 50 12 	call	0x24a0	; 0x24a0 <prvUnlockQueue>
	}
    2680:	0f 90       	pop	r0
    2682:	0f 90       	pop	r0
    2684:	0f 90       	pop	r0
    2686:	0f 90       	pop	r0
    2688:	cf 91       	pop	r28
    268a:	df 91       	pop	r29
    268c:	08 95       	ret

0000268e <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    268e:	af 92       	push	r10
    2690:	bf 92       	push	r11
    2692:	cf 92       	push	r12
    2694:	df 92       	push	r13
    2696:	ef 92       	push	r14
    2698:	ff 92       	push	r15
    269a:	0f 93       	push	r16
    269c:	1f 93       	push	r17
    269e:	df 93       	push	r29
    26a0:	cf 93       	push	r28
    26a2:	cd b7       	in	r28, 0x3d	; 61
    26a4:	de b7       	in	r29, 0x3e	; 62
    26a6:	64 97       	sbiw	r28, 0x14	; 20
    26a8:	0f b6       	in	r0, 0x3f	; 63
    26aa:	f8 94       	cli
    26ac:	de bf       	out	0x3e, r29	; 62
    26ae:	0f be       	out	0x3f, r0	; 63
    26b0:	cd bf       	out	0x3d, r28	; 61
    26b2:	9f 83       	std	Y+7, r25	; 0x07
    26b4:	8e 83       	std	Y+6, r24	; 0x06
    26b6:	79 87       	std	Y+9, r23	; 0x09
    26b8:	68 87       	std	Y+8, r22	; 0x08
    26ba:	5b 87       	std	Y+11, r21	; 0x0b
    26bc:	4a 87       	std	Y+10, r20	; 0x0a
    26be:	3d 87       	std	Y+13, r19	; 0x0d
    26c0:	2c 87       	std	Y+12, r18	; 0x0c
    26c2:	0e 87       	std	Y+14, r16	; 0x0e
    26c4:	f8 8a       	std	Y+16, r15	; 0x10
    26c6:	ef 86       	std	Y+15, r14	; 0x0f
    26c8:	da 8a       	std	Y+18, r13	; 0x12
    26ca:	c9 8a       	std	Y+17, r12	; 0x11
    26cc:	bc 8a       	std	Y+20, r11	; 0x14
    26ce:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    26d0:	8a 85       	ldd	r24, Y+10	; 0x0a
    26d2:	9b 85       	ldd	r25, Y+11	; 0x0b
    26d4:	29 89       	ldd	r18, Y+17	; 0x11
    26d6:	3a 89       	ldd	r19, Y+18	; 0x12
    26d8:	b9 01       	movw	r22, r18
    26da:	0e 94 97 1b 	call	0x372e	; 0x372e <prvAllocateTCBAndStack>
    26de:	9c 83       	std	Y+4, r25	; 0x04
    26e0:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    26e2:	8b 81       	ldd	r24, Y+3	; 0x03
    26e4:	9c 81       	ldd	r25, Y+4	; 0x04
    26e6:	00 97       	sbiw	r24, 0x00	; 0
    26e8:	09 f4       	brne	.+2      	; 0x26ec <xTaskGenericCreate+0x5e>
    26ea:	99 c0       	rjmp	.+306    	; 0x281e <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    26ec:	eb 81       	ldd	r30, Y+3	; 0x03
    26ee:	fc 81       	ldd	r31, Y+4	; 0x04
    26f0:	27 89       	ldd	r18, Z+23	; 0x17
    26f2:	30 8d       	ldd	r19, Z+24	; 0x18
    26f4:	8a 85       	ldd	r24, Y+10	; 0x0a
    26f6:	9b 85       	ldd	r25, Y+11	; 0x0b
    26f8:	01 97       	sbiw	r24, 0x01	; 1
    26fa:	82 0f       	add	r24, r18
    26fc:	93 1f       	adc	r25, r19
    26fe:	9a 83       	std	Y+2, r25	; 0x02
    2700:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    2702:	8b 81       	ldd	r24, Y+3	; 0x03
    2704:	9c 81       	ldd	r25, Y+4	; 0x04
    2706:	28 85       	ldd	r18, Y+8	; 0x08
    2708:	39 85       	ldd	r19, Y+9	; 0x09
    270a:	eb 89       	ldd	r30, Y+19	; 0x13
    270c:	fc 89       	ldd	r31, Y+20	; 0x14
    270e:	aa 85       	ldd	r26, Y+10	; 0x0a
    2710:	bb 85       	ldd	r27, Y+11	; 0x0b
    2712:	b9 01       	movw	r22, r18
    2714:	4e 85       	ldd	r20, Y+14	; 0x0e
    2716:	9f 01       	movw	r18, r30
    2718:	8d 01       	movw	r16, r26
    271a:	0e 94 b3 1a 	call	0x3566	; 0x3566 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    271e:	89 81       	ldd	r24, Y+1	; 0x01
    2720:	9a 81       	ldd	r25, Y+2	; 0x02
    2722:	2e 81       	ldd	r18, Y+6	; 0x06
    2724:	3f 81       	ldd	r19, Y+7	; 0x07
    2726:	4c 85       	ldd	r20, Y+12	; 0x0c
    2728:	5d 85       	ldd	r21, Y+13	; 0x0d
    272a:	b9 01       	movw	r22, r18
    272c:	0e 94 96 0b 	call	0x172c	; 0x172c <pxPortInitialiseStack>
    2730:	eb 81       	ldd	r30, Y+3	; 0x03
    2732:	fc 81       	ldd	r31, Y+4	; 0x04
    2734:	91 83       	std	Z+1, r25	; 0x01
    2736:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    2738:	8f 85       	ldd	r24, Y+15	; 0x0f
    273a:	98 89       	ldd	r25, Y+16	; 0x10
    273c:	00 97       	sbiw	r24, 0x00	; 0
    273e:	31 f0       	breq	.+12     	; 0x274c <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    2740:	ef 85       	ldd	r30, Y+15	; 0x0f
    2742:	f8 89       	ldd	r31, Y+16	; 0x10
    2744:	8b 81       	ldd	r24, Y+3	; 0x03
    2746:	9c 81       	ldd	r25, Y+4	; 0x04
    2748:	91 83       	std	Z+1, r25	; 0x01
    274a:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    274c:	0f b6       	in	r0, 0x3f	; 63
    274e:	f8 94       	cli
    2750:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    2752:	80 91 aa 06 	lds	r24, 0x06AA
    2756:	8f 5f       	subi	r24, 0xFF	; 255
    2758:	80 93 aa 06 	sts	0x06AA, r24
			if( pxCurrentTCB == NULL )
    275c:	80 91 a8 06 	lds	r24, 0x06A8
    2760:	90 91 a9 06 	lds	r25, 0x06A9
    2764:	00 97       	sbiw	r24, 0x00	; 0
    2766:	69 f4       	brne	.+26     	; 0x2782 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    2768:	8b 81       	ldd	r24, Y+3	; 0x03
    276a:	9c 81       	ldd	r25, Y+4	; 0x04
    276c:	90 93 a9 06 	sts	0x06A9, r25
    2770:	80 93 a8 06 	sts	0x06A8, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    2774:	80 91 aa 06 	lds	r24, 0x06AA
    2778:	81 30       	cpi	r24, 0x01	; 1
    277a:	a9 f4       	brne	.+42     	; 0x27a6 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    277c:	0e 94 0a 1b 	call	0x3614	; 0x3614 <prvInitialiseTaskLists>
    2780:	12 c0       	rjmp	.+36     	; 0x27a6 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    2782:	80 91 af 06 	lds	r24, 0x06AF
    2786:	88 23       	and	r24, r24
    2788:	71 f4       	brne	.+28     	; 0x27a6 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    278a:	e0 91 a8 06 	lds	r30, 0x06A8
    278e:	f0 91 a9 06 	lds	r31, 0x06A9
    2792:	96 89       	ldd	r25, Z+22	; 0x16
    2794:	8e 85       	ldd	r24, Y+14	; 0x0e
    2796:	89 17       	cp	r24, r25
    2798:	30 f0       	brcs	.+12     	; 0x27a6 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    279a:	8b 81       	ldd	r24, Y+3	; 0x03
    279c:	9c 81       	ldd	r25, Y+4	; 0x04
    279e:	90 93 a9 06 	sts	0x06A9, r25
    27a2:	80 93 a8 06 	sts	0x06A8, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    27a6:	eb 81       	ldd	r30, Y+3	; 0x03
    27a8:	fc 81       	ldd	r31, Y+4	; 0x04
    27aa:	96 89       	ldd	r25, Z+22	; 0x16
    27ac:	80 91 ad 06 	lds	r24, 0x06AD
    27b0:	89 17       	cp	r24, r25
    27b2:	28 f4       	brcc	.+10     	; 0x27be <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    27b4:	eb 81       	ldd	r30, Y+3	; 0x03
    27b6:	fc 81       	ldd	r31, Y+4	; 0x04
    27b8:	86 89       	ldd	r24, Z+22	; 0x16
    27ba:	80 93 ad 06 	sts	0x06AD, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    27be:	80 91 b4 06 	lds	r24, 0x06B4
    27c2:	8f 5f       	subi	r24, 0xFF	; 255
    27c4:	80 93 b4 06 	sts	0x06B4, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    27c8:	eb 81       	ldd	r30, Y+3	; 0x03
    27ca:	fc 81       	ldd	r31, Y+4	; 0x04
    27cc:	96 89       	ldd	r25, Z+22	; 0x16
    27ce:	80 91 ae 06 	lds	r24, 0x06AE
    27d2:	89 17       	cp	r24, r25
    27d4:	28 f4       	brcc	.+10     	; 0x27e0 <xTaskGenericCreate+0x152>
    27d6:	eb 81       	ldd	r30, Y+3	; 0x03
    27d8:	fc 81       	ldd	r31, Y+4	; 0x04
    27da:	86 89       	ldd	r24, Z+22	; 0x16
    27dc:	80 93 ae 06 	sts	0x06AE, r24
    27e0:	eb 81       	ldd	r30, Y+3	; 0x03
    27e2:	fc 81       	ldd	r31, Y+4	; 0x04
    27e4:	86 89       	ldd	r24, Z+22	; 0x16
    27e6:	28 2f       	mov	r18, r24
    27e8:	30 e0       	ldi	r19, 0x00	; 0
    27ea:	c9 01       	movw	r24, r18
    27ec:	88 0f       	add	r24, r24
    27ee:	99 1f       	adc	r25, r25
    27f0:	88 0f       	add	r24, r24
    27f2:	99 1f       	adc	r25, r25
    27f4:	88 0f       	add	r24, r24
    27f6:	99 1f       	adc	r25, r25
    27f8:	82 0f       	add	r24, r18
    27fa:	93 1f       	adc	r25, r19
    27fc:	ac 01       	movw	r20, r24
    27fe:	4b 54       	subi	r20, 0x4B	; 75
    2800:	59 4f       	sbci	r21, 0xF9	; 249
    2802:	8b 81       	ldd	r24, Y+3	; 0x03
    2804:	9c 81       	ldd	r25, Y+4	; 0x04
    2806:	9c 01       	movw	r18, r24
    2808:	2e 5f       	subi	r18, 0xFE	; 254
    280a:	3f 4f       	sbci	r19, 0xFF	; 255
    280c:	ca 01       	movw	r24, r20
    280e:	b9 01       	movw	r22, r18
    2810:	0e 94 95 0a 	call	0x152a	; 0x152a <vListInsertEnd>

			xReturn = pdPASS;
    2814:	81 e0       	ldi	r24, 0x01	; 1
    2816:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    2818:	0f 90       	pop	r0
    281a:	0f be       	out	0x3f, r0	; 63
    281c:	02 c0       	rjmp	.+4      	; 0x2822 <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    281e:	8f ef       	ldi	r24, 0xFF	; 255
    2820:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    2822:	8d 81       	ldd	r24, Y+5	; 0x05
    2824:	81 30       	cpi	r24, 0x01	; 1
    2826:	71 f4       	brne	.+28     	; 0x2844 <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    2828:	80 91 af 06 	lds	r24, 0x06AF
    282c:	88 23       	and	r24, r24
    282e:	51 f0       	breq	.+20     	; 0x2844 <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    2830:	e0 91 a8 06 	lds	r30, 0x06A8
    2834:	f0 91 a9 06 	lds	r31, 0x06A9
    2838:	96 89       	ldd	r25, Z+22	; 0x16
    283a:	8e 85       	ldd	r24, Y+14	; 0x0e
    283c:	98 17       	cp	r25, r24
    283e:	10 f4       	brcc	.+4      	; 0x2844 <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    2840:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <vPortYield>
			}
		}
	}

	return xReturn;
    2844:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2846:	64 96       	adiw	r28, 0x14	; 20
    2848:	0f b6       	in	r0, 0x3f	; 63
    284a:	f8 94       	cli
    284c:	de bf       	out	0x3e, r29	; 62
    284e:	0f be       	out	0x3f, r0	; 63
    2850:	cd bf       	out	0x3d, r28	; 61
    2852:	cf 91       	pop	r28
    2854:	df 91       	pop	r29
    2856:	1f 91       	pop	r17
    2858:	0f 91       	pop	r16
    285a:	ff 90       	pop	r15
    285c:	ef 90       	pop	r14
    285e:	df 90       	pop	r13
    2860:	cf 90       	pop	r12
    2862:	bf 90       	pop	r11
    2864:	af 90       	pop	r10
    2866:	08 95       	ret

00002868 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    2868:	df 93       	push	r29
    286a:	cf 93       	push	r28
    286c:	cd b7       	in	r28, 0x3d	; 61
    286e:	de b7       	in	r29, 0x3e	; 62
    2870:	28 97       	sbiw	r28, 0x08	; 8
    2872:	0f b6       	in	r0, 0x3f	; 63
    2874:	f8 94       	cli
    2876:	de bf       	out	0x3e, r29	; 62
    2878:	0f be       	out	0x3f, r0	; 63
    287a:	cd bf       	out	0x3d, r28	; 61
    287c:	9e 83       	std	Y+6, r25	; 0x06
    287e:	8d 83       	std	Y+5, r24	; 0x05
    2880:	78 87       	std	Y+8, r23	; 0x08
    2882:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    2884:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    2886:	0e 94 32 17 	call	0x2e64	; 0x2e64 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    288a:	ed 81       	ldd	r30, Y+5	; 0x05
    288c:	fe 81       	ldd	r31, Y+6	; 0x06
    288e:	20 81       	ld	r18, Z
    2890:	31 81       	ldd	r19, Z+1	; 0x01
    2892:	8f 81       	ldd	r24, Y+7	; 0x07
    2894:	98 85       	ldd	r25, Y+8	; 0x08
    2896:	82 0f       	add	r24, r18
    2898:	93 1f       	adc	r25, r19
    289a:	9c 83       	std	Y+4, r25	; 0x04
    289c:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    289e:	ed 81       	ldd	r30, Y+5	; 0x05
    28a0:	fe 81       	ldd	r31, Y+6	; 0x06
    28a2:	20 81       	ld	r18, Z
    28a4:	31 81       	ldd	r19, Z+1	; 0x01
    28a6:	80 91 ab 06 	lds	r24, 0x06AB
    28aa:	90 91 ac 06 	lds	r25, 0x06AC
    28ae:	82 17       	cp	r24, r18
    28b0:	93 07       	cpc	r25, r19
    28b2:	a8 f4       	brcc	.+42     	; 0x28de <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    28b4:	ed 81       	ldd	r30, Y+5	; 0x05
    28b6:	fe 81       	ldd	r31, Y+6	; 0x06
    28b8:	20 81       	ld	r18, Z
    28ba:	31 81       	ldd	r19, Z+1	; 0x01
    28bc:	8b 81       	ldd	r24, Y+3	; 0x03
    28be:	9c 81       	ldd	r25, Y+4	; 0x04
    28c0:	82 17       	cp	r24, r18
    28c2:	93 07       	cpc	r25, r19
    28c4:	00 f5       	brcc	.+64     	; 0x2906 <vTaskDelayUntil+0x9e>
    28c6:	20 91 ab 06 	lds	r18, 0x06AB
    28ca:	30 91 ac 06 	lds	r19, 0x06AC
    28ce:	8b 81       	ldd	r24, Y+3	; 0x03
    28d0:	9c 81       	ldd	r25, Y+4	; 0x04
    28d2:	28 17       	cp	r18, r24
    28d4:	39 07       	cpc	r19, r25
    28d6:	b8 f4       	brcc	.+46     	; 0x2906 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    28d8:	81 e0       	ldi	r24, 0x01	; 1
    28da:	89 83       	std	Y+1, r24	; 0x01
    28dc:	14 c0       	rjmp	.+40     	; 0x2906 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    28de:	ed 81       	ldd	r30, Y+5	; 0x05
    28e0:	fe 81       	ldd	r31, Y+6	; 0x06
    28e2:	20 81       	ld	r18, Z
    28e4:	31 81       	ldd	r19, Z+1	; 0x01
    28e6:	8b 81       	ldd	r24, Y+3	; 0x03
    28e8:	9c 81       	ldd	r25, Y+4	; 0x04
    28ea:	82 17       	cp	r24, r18
    28ec:	93 07       	cpc	r25, r19
    28ee:	48 f0       	brcs	.+18     	; 0x2902 <vTaskDelayUntil+0x9a>
    28f0:	20 91 ab 06 	lds	r18, 0x06AB
    28f4:	30 91 ac 06 	lds	r19, 0x06AC
    28f8:	8b 81       	ldd	r24, Y+3	; 0x03
    28fa:	9c 81       	ldd	r25, Y+4	; 0x04
    28fc:	28 17       	cp	r18, r24
    28fe:	39 07       	cpc	r19, r25
    2900:	10 f4       	brcc	.+4      	; 0x2906 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    2902:	81 e0       	ldi	r24, 0x01	; 1
    2904:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2906:	ed 81       	ldd	r30, Y+5	; 0x05
    2908:	fe 81       	ldd	r31, Y+6	; 0x06
    290a:	8b 81       	ldd	r24, Y+3	; 0x03
    290c:	9c 81       	ldd	r25, Y+4	; 0x04
    290e:	91 83       	std	Z+1, r25	; 0x01
    2910:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    2912:	89 81       	ldd	r24, Y+1	; 0x01
    2914:	88 23       	and	r24, r24
    2916:	59 f0       	breq	.+22     	; 0x292e <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2918:	80 91 a8 06 	lds	r24, 0x06A8
    291c:	90 91 a9 06 	lds	r25, 0x06A9
    2920:	02 96       	adiw	r24, 0x02	; 2
    2922:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2926:	8b 81       	ldd	r24, Y+3	; 0x03
    2928:	9c 81       	ldd	r25, Y+4	; 0x04
    292a:	0e 94 4e 1b 	call	0x369c	; 0x369c <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    292e:	0e 94 3e 17 	call	0x2e7c	; 0x2e7c <xTaskResumeAll>
    2932:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2934:	8a 81       	ldd	r24, Y+2	; 0x02
    2936:	88 23       	and	r24, r24
    2938:	11 f4       	brne	.+4      	; 0x293e <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    293a:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <vPortYield>
		}
	}
    293e:	28 96       	adiw	r28, 0x08	; 8
    2940:	0f b6       	in	r0, 0x3f	; 63
    2942:	f8 94       	cli
    2944:	de bf       	out	0x3e, r29	; 62
    2946:	0f be       	out	0x3f, r0	; 63
    2948:	cd bf       	out	0x3d, r28	; 61
    294a:	cf 91       	pop	r28
    294c:	df 91       	pop	r29
    294e:	08 95       	ret

00002950 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2950:	df 93       	push	r29
    2952:	cf 93       	push	r28
    2954:	00 d0       	rcall	.+0      	; 0x2956 <vTaskDelay+0x6>
    2956:	00 d0       	rcall	.+0      	; 0x2958 <vTaskDelay+0x8>
    2958:	0f 92       	push	r0
    295a:	cd b7       	in	r28, 0x3d	; 61
    295c:	de b7       	in	r29, 0x3e	; 62
    295e:	9d 83       	std	Y+5, r25	; 0x05
    2960:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2962:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2964:	8c 81       	ldd	r24, Y+4	; 0x04
    2966:	9d 81       	ldd	r25, Y+5	; 0x05
    2968:	00 97       	sbiw	r24, 0x00	; 0
    296a:	d1 f0       	breq	.+52     	; 0x29a0 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    296c:	0e 94 32 17 	call	0x2e64	; 0x2e64 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2970:	20 91 ab 06 	lds	r18, 0x06AB
    2974:	30 91 ac 06 	lds	r19, 0x06AC
    2978:	8c 81       	ldd	r24, Y+4	; 0x04
    297a:	9d 81       	ldd	r25, Y+5	; 0x05
    297c:	82 0f       	add	r24, r18
    297e:	93 1f       	adc	r25, r19
    2980:	9b 83       	std	Y+3, r25	; 0x03
    2982:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2984:	80 91 a8 06 	lds	r24, 0x06A8
    2988:	90 91 a9 06 	lds	r25, 0x06A9
    298c:	02 96       	adiw	r24, 0x02	; 2
    298e:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2992:	8a 81       	ldd	r24, Y+2	; 0x02
    2994:	9b 81       	ldd	r25, Y+3	; 0x03
    2996:	0e 94 4e 1b 	call	0x369c	; 0x369c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    299a:	0e 94 3e 17 	call	0x2e7c	; 0x2e7c <xTaskResumeAll>
    299e:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    29a0:	89 81       	ldd	r24, Y+1	; 0x01
    29a2:	88 23       	and	r24, r24
    29a4:	11 f4       	brne	.+4      	; 0x29aa <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    29a6:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <vPortYield>
		}
	}
    29aa:	0f 90       	pop	r0
    29ac:	0f 90       	pop	r0
    29ae:	0f 90       	pop	r0
    29b0:	0f 90       	pop	r0
    29b2:	0f 90       	pop	r0
    29b4:	cf 91       	pop	r28
    29b6:	df 91       	pop	r29
    29b8:	08 95       	ret

000029ba <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
	{
    29ba:	df 93       	push	r29
    29bc:	cf 93       	push	r28
    29be:	cd b7       	in	r28, 0x3d	; 61
    29c0:	de b7       	in	r29, 0x3e	; 62
    29c2:	29 97       	sbiw	r28, 0x09	; 9
    29c4:	0f b6       	in	r0, 0x3f	; 63
    29c6:	f8 94       	cli
    29c8:	de bf       	out	0x3e, r29	; 62
    29ca:	0f be       	out	0x3f, r0	; 63
    29cc:	cd bf       	out	0x3d, r28	; 61
    29ce:	9e 83       	std	Y+6, r25	; 0x06
    29d0:	8d 83       	std	Y+5, r24	; 0x05
    29d2:	6f 83       	std	Y+7, r22	; 0x07
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxCurrentPriority;
	portBASE_TYPE xYieldRequired = pdFALSE;
    29d4:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= configMAX_PRIORITIES )
    29d6:	8f 81       	ldd	r24, Y+7	; 0x07
    29d8:	85 30       	cpi	r24, 0x05	; 5
    29da:	10 f0       	brcs	.+4      	; 0x29e0 <vTaskPrioritySet+0x26>
		{
			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    29dc:	84 e0       	ldi	r24, 0x04	; 4
    29de:	8f 83       	std	Y+7, r24	; 0x07
		}

		taskENTER_CRITICAL();
    29e0:	0f b6       	in	r0, 0x3f	; 63
    29e2:	f8 94       	cli
    29e4:	0f 92       	push	r0
		{
			if( pxTask == pxCurrentTCB )
    29e6:	20 91 a8 06 	lds	r18, 0x06A8
    29ea:	30 91 a9 06 	lds	r19, 0x06A9
    29ee:	8d 81       	ldd	r24, Y+5	; 0x05
    29f0:	9e 81       	ldd	r25, Y+6	; 0x06
    29f2:	82 17       	cp	r24, r18
    29f4:	93 07       	cpc	r25, r19
    29f6:	11 f4       	brne	.+4      	; 0x29fc <vTaskPrioritySet+0x42>
			{
				pxTask = NULL;
    29f8:	1e 82       	std	Y+6, r1	; 0x06
    29fa:	1d 82       	std	Y+5, r1	; 0x05
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    29fc:	8d 81       	ldd	r24, Y+5	; 0x05
    29fe:	9e 81       	ldd	r25, Y+6	; 0x06
    2a00:	00 97       	sbiw	r24, 0x00	; 0
    2a02:	39 f4       	brne	.+14     	; 0x2a12 <vTaskPrioritySet+0x58>
    2a04:	80 91 a8 06 	lds	r24, 0x06A8
    2a08:	90 91 a9 06 	lds	r25, 0x06A9
    2a0c:	99 87       	std	Y+9, r25	; 0x09
    2a0e:	88 87       	std	Y+8, r24	; 0x08
    2a10:	04 c0       	rjmp	.+8      	; 0x2a1a <vTaskPrioritySet+0x60>
    2a12:	8d 81       	ldd	r24, Y+5	; 0x05
    2a14:	9e 81       	ldd	r25, Y+6	; 0x06
    2a16:	99 87       	std	Y+9, r25	; 0x09
    2a18:	88 87       	std	Y+8, r24	; 0x08
    2a1a:	88 85       	ldd	r24, Y+8	; 0x08
    2a1c:	99 85       	ldd	r25, Y+9	; 0x09
    2a1e:	9c 83       	std	Y+4, r25	; 0x04
    2a20:	8b 83       	std	Y+3, r24	; 0x03
			{
				uxCurrentPriority = pxTCB->uxBasePriority;
			}
			#else
			{
				uxCurrentPriority = pxTCB->uxPriority;
    2a22:	eb 81       	ldd	r30, Y+3	; 0x03
    2a24:	fc 81       	ldd	r31, Y+4	; 0x04
    2a26:	86 89       	ldd	r24, Z+22	; 0x16
    2a28:	8a 83       	std	Y+2, r24	; 0x02
			}
			#endif

			if( uxCurrentPriority != uxNewPriority )
    2a2a:	9a 81       	ldd	r25, Y+2	; 0x02
    2a2c:	8f 81       	ldd	r24, Y+7	; 0x07
    2a2e:	98 17       	cp	r25, r24
    2a30:	09 f4       	brne	.+2      	; 0x2a34 <vTaskPrioritySet+0x7a>
    2a32:	65 c0       	rjmp	.+202    	; 0x2afe <vTaskPrioritySet+0x144>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentPriority )
    2a34:	9f 81       	ldd	r25, Y+7	; 0x07
    2a36:	8a 81       	ldd	r24, Y+2	; 0x02
    2a38:	89 17       	cp	r24, r25
    2a3a:	38 f4       	brcc	.+14     	; 0x2a4a <vTaskPrioritySet+0x90>
				{
					if( pxTask != NULL )
    2a3c:	8d 81       	ldd	r24, Y+5	; 0x05
    2a3e:	9e 81       	ldd	r25, Y+6	; 0x06
    2a40:	00 97       	sbiw	r24, 0x00	; 0
    2a42:	49 f0       	breq	.+18     	; 0x2a56 <vTaskPrioritySet+0x9c>
					{
						/* The priority of another task is being raised.  If we
						were raising the priority of the currently running task
						there would be no need to switch as it must have already
						been the highest priority task. */
						xYieldRequired = pdTRUE;
    2a44:	81 e0       	ldi	r24, 0x01	; 1
    2a46:	89 83       	std	Y+1, r24	; 0x01
    2a48:	06 c0       	rjmp	.+12     	; 0x2a56 <vTaskPrioritySet+0x9c>
					}
				}
				else if( pxTask == NULL )
    2a4a:	8d 81       	ldd	r24, Y+5	; 0x05
    2a4c:	9e 81       	ldd	r25, Y+6	; 0x06
    2a4e:	00 97       	sbiw	r24, 0x00	; 0
    2a50:	11 f4       	brne	.+4      	; 0x2a56 <vTaskPrioritySet+0x9c>
				{
					/* Setting our own priority down means there may now be another
					task of higher priority that is ready to execute. */
					xYieldRequired = pdTRUE;
    2a52:	81 e0       	ldi	r24, 0x01	; 1
    2a54:	89 83       	std	Y+1, r24	; 0x01
					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
				}
				#else
				{
					pxTCB->uxPriority = uxNewPriority;
    2a56:	eb 81       	ldd	r30, Y+3	; 0x03
    2a58:	fc 81       	ldd	r31, Y+4	; 0x04
    2a5a:	8f 81       	ldd	r24, Y+7	; 0x07
    2a5c:	86 8b       	std	Z+22, r24	; 0x16
				}
				#endif

				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) );
    2a5e:	8f 81       	ldd	r24, Y+7	; 0x07
    2a60:	28 2f       	mov	r18, r24
    2a62:	30 e0       	ldi	r19, 0x00	; 0
    2a64:	85 e0       	ldi	r24, 0x05	; 5
    2a66:	90 e0       	ldi	r25, 0x00	; 0
    2a68:	82 1b       	sub	r24, r18
    2a6a:	93 0b       	sbc	r25, r19
    2a6c:	eb 81       	ldd	r30, Y+3	; 0x03
    2a6e:	fc 81       	ldd	r31, Y+4	; 0x04
    2a70:	95 87       	std	Z+13, r25	; 0x0d
    2a72:	84 87       	std	Z+12, r24	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the queue appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
    2a74:	eb 81       	ldd	r30, Y+3	; 0x03
    2a76:	fc 81       	ldd	r31, Y+4	; 0x04
    2a78:	42 85       	ldd	r20, Z+10	; 0x0a
    2a7a:	53 85       	ldd	r21, Z+11	; 0x0b
    2a7c:	8a 81       	ldd	r24, Y+2	; 0x02
    2a7e:	28 2f       	mov	r18, r24
    2a80:	30 e0       	ldi	r19, 0x00	; 0
    2a82:	c9 01       	movw	r24, r18
    2a84:	88 0f       	add	r24, r24
    2a86:	99 1f       	adc	r25, r25
    2a88:	88 0f       	add	r24, r24
    2a8a:	99 1f       	adc	r25, r25
    2a8c:	88 0f       	add	r24, r24
    2a8e:	99 1f       	adc	r25, r25
    2a90:	82 0f       	add	r24, r18
    2a92:	93 1f       	adc	r25, r19
    2a94:	8b 54       	subi	r24, 0x4B	; 75
    2a96:	99 4f       	sbci	r25, 0xF9	; 249
    2a98:	48 17       	cp	r20, r24
    2a9a:	59 07       	cpc	r21, r25
    2a9c:	59 f5       	brne	.+86     	; 0x2af4 <vTaskPrioritySet+0x13a>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					vListRemove( &( pxTCB->xGenericListItem ) );
    2a9e:	8b 81       	ldd	r24, Y+3	; 0x03
    2aa0:	9c 81       	ldd	r25, Y+4	; 0x04
    2aa2:	02 96       	adiw	r24, 0x02	; 2
    2aa4:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2aa8:	eb 81       	ldd	r30, Y+3	; 0x03
    2aaa:	fc 81       	ldd	r31, Y+4	; 0x04
    2aac:	96 89       	ldd	r25, Z+22	; 0x16
    2aae:	80 91 ae 06 	lds	r24, 0x06AE
    2ab2:	89 17       	cp	r24, r25
    2ab4:	28 f4       	brcc	.+10     	; 0x2ac0 <vTaskPrioritySet+0x106>
    2ab6:	eb 81       	ldd	r30, Y+3	; 0x03
    2ab8:	fc 81       	ldd	r31, Y+4	; 0x04
    2aba:	86 89       	ldd	r24, Z+22	; 0x16
    2abc:	80 93 ae 06 	sts	0x06AE, r24
    2ac0:	eb 81       	ldd	r30, Y+3	; 0x03
    2ac2:	fc 81       	ldd	r31, Y+4	; 0x04
    2ac4:	86 89       	ldd	r24, Z+22	; 0x16
    2ac6:	28 2f       	mov	r18, r24
    2ac8:	30 e0       	ldi	r19, 0x00	; 0
    2aca:	c9 01       	movw	r24, r18
    2acc:	88 0f       	add	r24, r24
    2ace:	99 1f       	adc	r25, r25
    2ad0:	88 0f       	add	r24, r24
    2ad2:	99 1f       	adc	r25, r25
    2ad4:	88 0f       	add	r24, r24
    2ad6:	99 1f       	adc	r25, r25
    2ad8:	82 0f       	add	r24, r18
    2ada:	93 1f       	adc	r25, r19
    2adc:	ac 01       	movw	r20, r24
    2ade:	4b 54       	subi	r20, 0x4B	; 75
    2ae0:	59 4f       	sbci	r21, 0xF9	; 249
    2ae2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ae4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ae6:	9c 01       	movw	r18, r24
    2ae8:	2e 5f       	subi	r18, 0xFE	; 254
    2aea:	3f 4f       	sbci	r19, 0xFF	; 255
    2aec:	ca 01       	movw	r24, r20
    2aee:	b9 01       	movw	r22, r18
    2af0:	0e 94 95 0a 	call	0x152a	; 0x152a <vListInsertEnd>
				}

				if( xYieldRequired == pdTRUE )
    2af4:	89 81       	ldd	r24, Y+1	; 0x01
    2af6:	81 30       	cpi	r24, 0x01	; 1
    2af8:	11 f4       	brne	.+4      	; 0x2afe <vTaskPrioritySet+0x144>
				{
					portYIELD_WITHIN_API();
    2afa:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <vPortYield>
				}
			}
		}
		taskEXIT_CRITICAL();
    2afe:	0f 90       	pop	r0
    2b00:	0f be       	out	0x3f, r0	; 63
	}
    2b02:	29 96       	adiw	r28, 0x09	; 9
    2b04:	0f b6       	in	r0, 0x3f	; 63
    2b06:	f8 94       	cli
    2b08:	de bf       	out	0x3e, r29	; 62
    2b0a:	0f be       	out	0x3f, r0	; 63
    2b0c:	cd bf       	out	0x3d, r28	; 61
    2b0e:	cf 91       	pop	r28
    2b10:	df 91       	pop	r29
    2b12:	08 95       	ret

00002b14 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
    2b14:	df 93       	push	r29
    2b16:	cf 93       	push	r28
    2b18:	00 d0       	rcall	.+0      	; 0x2b1a <vTaskSuspend+0x6>
    2b1a:	00 d0       	rcall	.+0      	; 0x2b1c <vTaskSuspend+0x8>
    2b1c:	00 d0       	rcall	.+0      	; 0x2b1e <vTaskSuspend+0xa>
    2b1e:	cd b7       	in	r28, 0x3d	; 61
    2b20:	de b7       	in	r29, 0x3e	; 62
    2b22:	9c 83       	std	Y+4, r25	; 0x04
    2b24:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    2b26:	0f b6       	in	r0, 0x3f	; 63
    2b28:	f8 94       	cli
    2b2a:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
    2b2c:	20 91 a8 06 	lds	r18, 0x06A8
    2b30:	30 91 a9 06 	lds	r19, 0x06A9
    2b34:	8b 81       	ldd	r24, Y+3	; 0x03
    2b36:	9c 81       	ldd	r25, Y+4	; 0x04
    2b38:	82 17       	cp	r24, r18
    2b3a:	93 07       	cpc	r25, r19
    2b3c:	11 f4       	brne	.+4      	; 0x2b42 <vTaskSuspend+0x2e>
			{
				pxTaskToSuspend = NULL;
    2b3e:	1c 82       	std	Y+4, r1	; 0x04
    2b40:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    2b42:	8b 81       	ldd	r24, Y+3	; 0x03
    2b44:	9c 81       	ldd	r25, Y+4	; 0x04
    2b46:	00 97       	sbiw	r24, 0x00	; 0
    2b48:	39 f4       	brne	.+14     	; 0x2b58 <vTaskSuspend+0x44>
    2b4a:	80 91 a8 06 	lds	r24, 0x06A8
    2b4e:	90 91 a9 06 	lds	r25, 0x06A9
    2b52:	9e 83       	std	Y+6, r25	; 0x06
    2b54:	8d 83       	std	Y+5, r24	; 0x05
    2b56:	04 c0       	rjmp	.+8      	; 0x2b60 <vTaskSuspend+0x4c>
    2b58:	8b 81       	ldd	r24, Y+3	; 0x03
    2b5a:	9c 81       	ldd	r25, Y+4	; 0x04
    2b5c:	9e 83       	std	Y+6, r25	; 0x06
    2b5e:	8d 83       	std	Y+5, r24	; 0x05
    2b60:	8d 81       	ldd	r24, Y+5	; 0x05
    2b62:	9e 81       	ldd	r25, Y+6	; 0x06
    2b64:	9a 83       	std	Y+2, r25	; 0x02
    2b66:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    2b68:	89 81       	ldd	r24, Y+1	; 0x01
    2b6a:	9a 81       	ldd	r25, Y+2	; 0x02
    2b6c:	02 96       	adiw	r24, 0x02	; 2
    2b6e:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    2b72:	e9 81       	ldd	r30, Y+1	; 0x01
    2b74:	fa 81       	ldd	r31, Y+2	; 0x02
    2b76:	84 89       	ldd	r24, Z+20	; 0x14
    2b78:	95 89       	ldd	r25, Z+21	; 0x15
    2b7a:	00 97       	sbiw	r24, 0x00	; 0
    2b7c:	29 f0       	breq	.+10     	; 0x2b88 <vTaskSuspend+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    2b7e:	89 81       	ldd	r24, Y+1	; 0x01
    2b80:	9a 81       	ldd	r25, Y+2	; 0x02
    2b82:	0c 96       	adiw	r24, 0x0c	; 12
    2b84:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    2b88:	89 81       	ldd	r24, Y+1	; 0x01
    2b8a:	9a 81       	ldd	r25, Y+2	; 0x02
    2b8c:	9c 01       	movw	r18, r24
    2b8e:	2e 5f       	subi	r18, 0xFE	; 254
    2b90:	3f 4f       	sbci	r19, 0xFF	; 255
    2b92:	81 e0       	ldi	r24, 0x01	; 1
    2b94:	97 e0       	ldi	r25, 0x07	; 7
    2b96:	b9 01       	movw	r22, r18
    2b98:	0e 94 95 0a 	call	0x152a	; 0x152a <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    2b9c:	0f 90       	pop	r0
    2b9e:	0f be       	out	0x3f, r0	; 63

		if( ( void * ) pxTaskToSuspend == NULL )
    2ba0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ba2:	9c 81       	ldd	r25, Y+4	; 0x04
    2ba4:	00 97       	sbiw	r24, 0x00	; 0
    2ba6:	a1 f4       	brne	.+40     	; 0x2bd0 <vTaskSuspend+0xbc>
		{
			if( xSchedulerRunning != pdFALSE )
    2ba8:	80 91 af 06 	lds	r24, 0x06AF
    2bac:	88 23       	and	r24, r24
    2bae:	19 f0       	breq	.+6      	; 0x2bb6 <vTaskSuspend+0xa2>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
    2bb0:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <vPortYield>
    2bb4:	0d c0       	rjmp	.+26     	; 0x2bd0 <vTaskSuspend+0xbc>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    2bb6:	90 91 01 07 	lds	r25, 0x0701
    2bba:	80 91 aa 06 	lds	r24, 0x06AA
    2bbe:	98 17       	cp	r25, r24
    2bc0:	29 f4       	brne	.+10     	; 0x2bcc <vTaskSuspend+0xb8>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    2bc2:	10 92 a9 06 	sts	0x06A9, r1
    2bc6:	10 92 a8 06 	sts	0x06A8, r1
    2bca:	02 c0       	rjmp	.+4      	; 0x2bd0 <vTaskSuspend+0xbc>
				}
				else
				{
					vTaskSwitchContext();
    2bcc:	0e 94 d0 18 	call	0x31a0	; 0x31a0 <vTaskSwitchContext>
				}
			}
		}
	}
    2bd0:	26 96       	adiw	r28, 0x06	; 6
    2bd2:	0f b6       	in	r0, 0x3f	; 63
    2bd4:	f8 94       	cli
    2bd6:	de bf       	out	0x3e, r29	; 62
    2bd8:	0f be       	out	0x3f, r0	; 63
    2bda:	cd bf       	out	0x3d, r28	; 61
    2bdc:	cf 91       	pop	r28
    2bde:	df 91       	pop	r29
    2be0:	08 95       	ret

00002be2 <xTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
    2be2:	df 93       	push	r29
    2be4:	cf 93       	push	r28
    2be6:	00 d0       	rcall	.+0      	; 0x2be8 <xTaskIsTaskSuspended+0x6>
    2be8:	00 d0       	rcall	.+0      	; 0x2bea <xTaskIsTaskSuspended+0x8>
    2bea:	0f 92       	push	r0
    2bec:	cd b7       	in	r28, 0x3d	; 61
    2bee:	de b7       	in	r29, 0x3e	; 62
    2bf0:	9d 83       	std	Y+5, r25	; 0x05
    2bf2:	8c 83       	std	Y+4, r24	; 0x04
	portBASE_TYPE xReturn = pdFALSE;
    2bf4:	1b 82       	std	Y+3, r1	; 0x03
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
    2bf6:	8c 81       	ldd	r24, Y+4	; 0x04
    2bf8:	9d 81       	ldd	r25, Y+5	; 0x05
    2bfa:	9a 83       	std	Y+2, r25	; 0x02
    2bfc:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2bfe:	e9 81       	ldd	r30, Y+1	; 0x01
    2c00:	fa 81       	ldd	r31, Y+2	; 0x02
    2c02:	82 85       	ldd	r24, Z+10	; 0x0a
    2c04:	93 85       	ldd	r25, Z+11	; 0x0b
    2c06:	27 e0       	ldi	r18, 0x07	; 7
    2c08:	81 30       	cpi	r24, 0x01	; 1
    2c0a:	92 07       	cpc	r25, r18
    2c0c:	81 f4       	brne	.+32     	; 0x2c2e <xTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    2c0e:	e9 81       	ldd	r30, Y+1	; 0x01
    2c10:	fa 81       	ldd	r31, Y+2	; 0x02
    2c12:	84 89       	ldd	r24, Z+20	; 0x14
    2c14:	95 89       	ldd	r25, Z+21	; 0x15
    2c16:	26 e0       	ldi	r18, 0x06	; 6
    2c18:	88 3f       	cpi	r24, 0xF8	; 248
    2c1a:	92 07       	cpc	r25, r18
    2c1c:	41 f0       	breq	.+16     	; 0x2c2e <xTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
    2c1e:	e9 81       	ldd	r30, Y+1	; 0x01
    2c20:	fa 81       	ldd	r31, Y+2	; 0x02
    2c22:	84 89       	ldd	r24, Z+20	; 0x14
    2c24:	95 89       	ldd	r25, Z+21	; 0x15
    2c26:	00 97       	sbiw	r24, 0x00	; 0
    2c28:	11 f4       	brne	.+4      	; 0x2c2e <xTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    2c2a:	81 e0       	ldi	r24, 0x01	; 1
    2c2c:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}

		return xReturn;
    2c2e:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    2c30:	0f 90       	pop	r0
    2c32:	0f 90       	pop	r0
    2c34:	0f 90       	pop	r0
    2c36:	0f 90       	pop	r0
    2c38:	0f 90       	pop	r0
    2c3a:	cf 91       	pop	r28
    2c3c:	df 91       	pop	r29
    2c3e:	08 95       	ret

00002c40 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
    2c40:	df 93       	push	r29
    2c42:	cf 93       	push	r28
    2c44:	00 d0       	rcall	.+0      	; 0x2c46 <vTaskResume+0x6>
    2c46:	00 d0       	rcall	.+0      	; 0x2c48 <vTaskResume+0x8>
    2c48:	cd b7       	in	r28, 0x3d	; 61
    2c4a:	de b7       	in	r29, 0x3e	; 62
    2c4c:	9c 83       	std	Y+4, r25	; 0x04
    2c4e:	8b 83       	std	Y+3, r24	; 0x03
		/* It does not make sense to resume the calling task. */
		configASSERT( pxTaskToResume );

		/* Remove the task from whichever list it is currently in, and place
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;
    2c50:	8b 81       	ldd	r24, Y+3	; 0x03
    2c52:	9c 81       	ldd	r25, Y+4	; 0x04
    2c54:	9a 83       	std	Y+2, r25	; 0x02
    2c56:	89 83       	std	Y+1, r24	; 0x01

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    2c58:	89 81       	ldd	r24, Y+1	; 0x01
    2c5a:	9a 81       	ldd	r25, Y+2	; 0x02
    2c5c:	00 97       	sbiw	r24, 0x00	; 0
    2c5e:	09 f4       	brne	.+2      	; 0x2c62 <vTaskResume+0x22>
    2c60:	4c c0       	rjmp	.+152    	; 0x2cfa <vTaskResume+0xba>
    2c62:	20 91 a8 06 	lds	r18, 0x06A8
    2c66:	30 91 a9 06 	lds	r19, 0x06A9
    2c6a:	89 81       	ldd	r24, Y+1	; 0x01
    2c6c:	9a 81       	ldd	r25, Y+2	; 0x02
    2c6e:	82 17       	cp	r24, r18
    2c70:	93 07       	cpc	r25, r19
    2c72:	09 f4       	brne	.+2      	; 0x2c76 <vTaskResume+0x36>
    2c74:	42 c0       	rjmp	.+132    	; 0x2cfa <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    2c76:	0f b6       	in	r0, 0x3f	; 63
    2c78:	f8 94       	cli
    2c7a:	0f 92       	push	r0
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    2c7c:	89 81       	ldd	r24, Y+1	; 0x01
    2c7e:	9a 81       	ldd	r25, Y+2	; 0x02
    2c80:	0e 94 f1 15 	call	0x2be2	; 0x2be2 <xTaskIsTaskSuspended>
    2c84:	81 30       	cpi	r24, 0x01	; 1
    2c86:	b9 f5       	brne	.+110    	; 0x2cf6 <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
    2c88:	89 81       	ldd	r24, Y+1	; 0x01
    2c8a:	9a 81       	ldd	r25, Y+2	; 0x02
    2c8c:	02 96       	adiw	r24, 0x02	; 2
    2c8e:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2c92:	e9 81       	ldd	r30, Y+1	; 0x01
    2c94:	fa 81       	ldd	r31, Y+2	; 0x02
    2c96:	96 89       	ldd	r25, Z+22	; 0x16
    2c98:	80 91 ae 06 	lds	r24, 0x06AE
    2c9c:	89 17       	cp	r24, r25
    2c9e:	28 f4       	brcc	.+10     	; 0x2caa <vTaskResume+0x6a>
    2ca0:	e9 81       	ldd	r30, Y+1	; 0x01
    2ca2:	fa 81       	ldd	r31, Y+2	; 0x02
    2ca4:	86 89       	ldd	r24, Z+22	; 0x16
    2ca6:	80 93 ae 06 	sts	0x06AE, r24
    2caa:	e9 81       	ldd	r30, Y+1	; 0x01
    2cac:	fa 81       	ldd	r31, Y+2	; 0x02
    2cae:	86 89       	ldd	r24, Z+22	; 0x16
    2cb0:	28 2f       	mov	r18, r24
    2cb2:	30 e0       	ldi	r19, 0x00	; 0
    2cb4:	c9 01       	movw	r24, r18
    2cb6:	88 0f       	add	r24, r24
    2cb8:	99 1f       	adc	r25, r25
    2cba:	88 0f       	add	r24, r24
    2cbc:	99 1f       	adc	r25, r25
    2cbe:	88 0f       	add	r24, r24
    2cc0:	99 1f       	adc	r25, r25
    2cc2:	82 0f       	add	r24, r18
    2cc4:	93 1f       	adc	r25, r19
    2cc6:	ac 01       	movw	r20, r24
    2cc8:	4b 54       	subi	r20, 0x4B	; 75
    2cca:	59 4f       	sbci	r21, 0xF9	; 249
    2ccc:	89 81       	ldd	r24, Y+1	; 0x01
    2cce:	9a 81       	ldd	r25, Y+2	; 0x02
    2cd0:	9c 01       	movw	r18, r24
    2cd2:	2e 5f       	subi	r18, 0xFE	; 254
    2cd4:	3f 4f       	sbci	r19, 0xFF	; 255
    2cd6:	ca 01       	movw	r24, r20
    2cd8:	b9 01       	movw	r22, r18
    2cda:	0e 94 95 0a 	call	0x152a	; 0x152a <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2cde:	e9 81       	ldd	r30, Y+1	; 0x01
    2ce0:	fa 81       	ldd	r31, Y+2	; 0x02
    2ce2:	96 89       	ldd	r25, Z+22	; 0x16
    2ce4:	e0 91 a8 06 	lds	r30, 0x06A8
    2ce8:	f0 91 a9 06 	lds	r31, 0x06A9
    2cec:	86 89       	ldd	r24, Z+22	; 0x16
    2cee:	98 17       	cp	r25, r24
    2cf0:	10 f0       	brcs	.+4      	; 0x2cf6 <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
    2cf2:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <vPortYield>
					}
				}
			}
			taskEXIT_CRITICAL();
    2cf6:	0f 90       	pop	r0
    2cf8:	0f be       	out	0x3f, r0	; 63
		}
	}
    2cfa:	0f 90       	pop	r0
    2cfc:	0f 90       	pop	r0
    2cfe:	0f 90       	pop	r0
    2d00:	0f 90       	pop	r0
    2d02:	cf 91       	pop	r28
    2d04:	df 91       	pop	r29
    2d06:	08 95       	ret

00002d08 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
    2d08:	df 93       	push	r29
    2d0a:	cf 93       	push	r28
    2d0c:	00 d0       	rcall	.+0      	; 0x2d0e <xTaskResumeFromISR+0x6>
    2d0e:	00 d0       	rcall	.+0      	; 0x2d10 <xTaskResumeFromISR+0x8>
    2d10:	0f 92       	push	r0
    2d12:	cd b7       	in	r28, 0x3d	; 61
    2d14:	de b7       	in	r29, 0x3e	; 62
    2d16:	9d 83       	std	Y+5, r25	; 0x05
    2d18:	8c 83       	std	Y+4, r24	; 0x04
	portBASE_TYPE xYieldRequired = pdFALSE;
    2d1a:	1b 82       	std	Y+3, r1	; 0x03
	tskTCB *pxTCB;

		configASSERT( pxTaskToResume );

		pxTCB = ( tskTCB * ) pxTaskToResume;
    2d1c:	8c 81       	ldd	r24, Y+4	; 0x04
    2d1e:	9d 81       	ldd	r25, Y+5	; 0x05
    2d20:	9a 83       	std	Y+2, r25	; 0x02
    2d22:	89 83       	std	Y+1, r24	; 0x01

		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    2d24:	89 81       	ldd	r24, Y+1	; 0x01
    2d26:	9a 81       	ldd	r25, Y+2	; 0x02
    2d28:	0e 94 f1 15 	call	0x2be2	; 0x2be2 <xTaskIsTaskSuspended>
    2d2c:	81 30       	cpi	r24, 0x01	; 1
    2d2e:	09 f0       	breq	.+2      	; 0x2d32 <xTaskResumeFromISR+0x2a>
    2d30:	47 c0       	rjmp	.+142    	; 0x2dc0 <xTaskResumeFromISR+0xb8>
		{
			traceTASK_RESUME_FROM_ISR( pxTCB );

			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2d32:	80 91 b0 06 	lds	r24, 0x06B0
    2d36:	88 23       	and	r24, r24
    2d38:	c9 f5       	brne	.+114    	; 0x2dac <xTaskResumeFromISR+0xa4>
			{
				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
    2d3a:	e9 81       	ldd	r30, Y+1	; 0x01
    2d3c:	fa 81       	ldd	r31, Y+2	; 0x02
    2d3e:	96 89       	ldd	r25, Z+22	; 0x16
    2d40:	e0 91 a8 06 	lds	r30, 0x06A8
    2d44:	f0 91 a9 06 	lds	r31, 0x06A9
    2d48:	86 89       	ldd	r24, Z+22	; 0x16
    2d4a:	1b 82       	std	Y+3, r1	; 0x03
    2d4c:	98 17       	cp	r25, r24
    2d4e:	10 f0       	brcs	.+4      	; 0x2d54 <xTaskResumeFromISR+0x4c>
    2d50:	81 e0       	ldi	r24, 0x01	; 1
    2d52:	8b 83       	std	Y+3, r24	; 0x03
				vListRemove(  &( pxTCB->xGenericListItem ) );
    2d54:	89 81       	ldd	r24, Y+1	; 0x01
    2d56:	9a 81       	ldd	r25, Y+2	; 0x02
    2d58:	02 96       	adiw	r24, 0x02	; 2
    2d5a:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>
				prvAddTaskToReadyQueue( pxTCB );
    2d5e:	e9 81       	ldd	r30, Y+1	; 0x01
    2d60:	fa 81       	ldd	r31, Y+2	; 0x02
    2d62:	96 89       	ldd	r25, Z+22	; 0x16
    2d64:	80 91 ae 06 	lds	r24, 0x06AE
    2d68:	89 17       	cp	r24, r25
    2d6a:	28 f4       	brcc	.+10     	; 0x2d76 <xTaskResumeFromISR+0x6e>
    2d6c:	e9 81       	ldd	r30, Y+1	; 0x01
    2d6e:	fa 81       	ldd	r31, Y+2	; 0x02
    2d70:	86 89       	ldd	r24, Z+22	; 0x16
    2d72:	80 93 ae 06 	sts	0x06AE, r24
    2d76:	e9 81       	ldd	r30, Y+1	; 0x01
    2d78:	fa 81       	ldd	r31, Y+2	; 0x02
    2d7a:	86 89       	ldd	r24, Z+22	; 0x16
    2d7c:	28 2f       	mov	r18, r24
    2d7e:	30 e0       	ldi	r19, 0x00	; 0
    2d80:	c9 01       	movw	r24, r18
    2d82:	88 0f       	add	r24, r24
    2d84:	99 1f       	adc	r25, r25
    2d86:	88 0f       	add	r24, r24
    2d88:	99 1f       	adc	r25, r25
    2d8a:	88 0f       	add	r24, r24
    2d8c:	99 1f       	adc	r25, r25
    2d8e:	82 0f       	add	r24, r18
    2d90:	93 1f       	adc	r25, r19
    2d92:	ac 01       	movw	r20, r24
    2d94:	4b 54       	subi	r20, 0x4B	; 75
    2d96:	59 4f       	sbci	r21, 0xF9	; 249
    2d98:	89 81       	ldd	r24, Y+1	; 0x01
    2d9a:	9a 81       	ldd	r25, Y+2	; 0x02
    2d9c:	9c 01       	movw	r18, r24
    2d9e:	2e 5f       	subi	r18, 0xFE	; 254
    2da0:	3f 4f       	sbci	r19, 0xFF	; 255
    2da2:	ca 01       	movw	r24, r20
    2da4:	b9 01       	movw	r22, r18
    2da6:	0e 94 95 0a 	call	0x152a	; 0x152a <vListInsertEnd>
    2daa:	0a c0       	rjmp	.+20     	; 0x2dc0 <xTaskResumeFromISR+0xb8>
			else
			{
				/* We cannot access the delayed or ready lists, so will hold this
				task pending until the scheduler is resumed, at which point a
				yield will be performed if necessary. */
				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    2dac:	89 81       	ldd	r24, Y+1	; 0x01
    2dae:	9a 81       	ldd	r25, Y+2	; 0x02
    2db0:	9c 01       	movw	r18, r24
    2db2:	24 5f       	subi	r18, 0xF4	; 244
    2db4:	3f 4f       	sbci	r19, 0xFF	; 255
    2db6:	88 ef       	ldi	r24, 0xF8	; 248
    2db8:	96 e0       	ldi	r25, 0x06	; 6
    2dba:	b9 01       	movw	r22, r18
    2dbc:	0e 94 95 0a 	call	0x152a	; 0x152a <vListInsertEnd>
			}
		}

		return xYieldRequired;
    2dc0:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    2dc2:	0f 90       	pop	r0
    2dc4:	0f 90       	pop	r0
    2dc6:	0f 90       	pop	r0
    2dc8:	0f 90       	pop	r0
    2dca:	0f 90       	pop	r0
    2dcc:	cf 91       	pop	r28
    2dce:	df 91       	pop	r29
    2dd0:	08 95       	ret

00002dd2 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    2dd2:	af 92       	push	r10
    2dd4:	bf 92       	push	r11
    2dd6:	cf 92       	push	r12
    2dd8:	df 92       	push	r13
    2dda:	ef 92       	push	r14
    2ddc:	ff 92       	push	r15
    2dde:	0f 93       	push	r16
    2de0:	df 93       	push	r29
    2de2:	cf 93       	push	r28
    2de4:	0f 92       	push	r0
    2de6:	cd b7       	in	r28, 0x3d	; 61
    2de8:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    2dea:	20 e6       	ldi	r18, 0x60	; 96
    2dec:	30 e0       	ldi	r19, 0x00	; 0
    2dee:	87 ea       	ldi	r24, 0xA7	; 167
    2df0:	9a e1       	ldi	r25, 0x1A	; 26
    2df2:	b9 01       	movw	r22, r18
    2df4:	45 e5       	ldi	r20, 0x55	; 85
    2df6:	50 e0       	ldi	r21, 0x00	; 0
    2df8:	20 e0       	ldi	r18, 0x00	; 0
    2dfa:	30 e0       	ldi	r19, 0x00	; 0
    2dfc:	00 e0       	ldi	r16, 0x00	; 0
    2dfe:	ee 24       	eor	r14, r14
    2e00:	ff 24       	eor	r15, r15
    2e02:	cc 24       	eor	r12, r12
    2e04:	dd 24       	eor	r13, r13
    2e06:	aa 24       	eor	r10, r10
    2e08:	bb 24       	eor	r11, r11
    2e0a:	0e 94 47 13 	call	0x268e	; 0x268e <xTaskGenericCreate>
    2e0e:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
    2e10:	89 81       	ldd	r24, Y+1	; 0x01
    2e12:	81 30       	cpi	r24, 0x01	; 1
    2e14:	19 f4       	brne	.+6      	; 0x2e1c <vTaskStartScheduler+0x4a>
		{
			xReturn = xTimerCreateTimerTask();
    2e16:	0e 94 00 1c 	call	0x3800	; 0x3800 <xTimerCreateTimerTask>
    2e1a:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	#endif

	if( xReturn == pdPASS )
    2e1c:	89 81       	ldd	r24, Y+1	; 0x01
    2e1e:	81 30       	cpi	r24, 0x01	; 1
    2e20:	51 f4       	brne	.+20     	; 0x2e36 <vTaskStartScheduler+0x64>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    2e22:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    2e24:	81 e0       	ldi	r24, 0x01	; 1
    2e26:	80 93 af 06 	sts	0x06AF, r24
		xTickCount = ( portTickType ) 0U;
    2e2a:	10 92 ac 06 	sts	0x06AC, r1
    2e2e:	10 92 ab 06 	sts	0x06AB, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    2e32:	0e 94 19 0d 	call	0x1a32	; 0x1a32 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    2e36:	0f 90       	pop	r0
    2e38:	cf 91       	pop	r28
    2e3a:	df 91       	pop	r29
    2e3c:	0f 91       	pop	r16
    2e3e:	ff 90       	pop	r15
    2e40:	ef 90       	pop	r14
    2e42:	df 90       	pop	r13
    2e44:	cf 90       	pop	r12
    2e46:	bf 90       	pop	r11
    2e48:	af 90       	pop	r10
    2e4a:	08 95       	ret

00002e4c <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    2e4c:	df 93       	push	r29
    2e4e:	cf 93       	push	r28
    2e50:	cd b7       	in	r28, 0x3d	; 61
    2e52:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    2e54:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    2e56:	10 92 af 06 	sts	0x06AF, r1
	vPortEndScheduler();
    2e5a:	0e 94 4e 0d 	call	0x1a9c	; 0x1a9c <vPortEndScheduler>
}
    2e5e:	cf 91       	pop	r28
    2e60:	df 91       	pop	r29
    2e62:	08 95       	ret

00002e64 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    2e64:	df 93       	push	r29
    2e66:	cf 93       	push	r28
    2e68:	cd b7       	in	r28, 0x3d	; 61
    2e6a:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2e6c:	80 91 b0 06 	lds	r24, 0x06B0
    2e70:	8f 5f       	subi	r24, 0xFF	; 255
    2e72:	80 93 b0 06 	sts	0x06B0, r24
}
    2e76:	cf 91       	pop	r28
    2e78:	df 91       	pop	r29
    2e7a:	08 95       	ret

00002e7c <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    2e7c:	df 93       	push	r29
    2e7e:	cf 93       	push	r28
    2e80:	00 d0       	rcall	.+0      	; 0x2e82 <xTaskResumeAll+0x6>
    2e82:	00 d0       	rcall	.+0      	; 0x2e84 <xTaskResumeAll+0x8>
    2e84:	cd b7       	in	r28, 0x3d	; 61
    2e86:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2e88:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2e8a:	0f b6       	in	r0, 0x3f	; 63
    2e8c:	f8 94       	cli
    2e8e:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2e90:	80 91 b0 06 	lds	r24, 0x06B0
    2e94:	81 50       	subi	r24, 0x01	; 1
    2e96:	80 93 b0 06 	sts	0x06B0, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2e9a:	80 91 b0 06 	lds	r24, 0x06B0
    2e9e:	88 23       	and	r24, r24
    2ea0:	09 f0       	breq	.+2      	; 0x2ea4 <xTaskResumeAll+0x28>
    2ea2:	6a c0       	rjmp	.+212    	; 0x2f78 <xTaskResumeAll+0xfc>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    2ea4:	80 91 aa 06 	lds	r24, 0x06AA
    2ea8:	88 23       	and	r24, r24
    2eaa:	09 f4       	brne	.+2      	; 0x2eae <xTaskResumeAll+0x32>
    2eac:	65 c0       	rjmp	.+202    	; 0x2f78 <xTaskResumeAll+0xfc>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    2eae:	19 82       	std	Y+1, r1	; 0x01
    2eb0:	41 c0       	rjmp	.+130    	; 0x2f34 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    2eb2:	e0 91 fd 06 	lds	r30, 0x06FD
    2eb6:	f0 91 fe 06 	lds	r31, 0x06FE
    2eba:	86 81       	ldd	r24, Z+6	; 0x06
    2ebc:	97 81       	ldd	r25, Z+7	; 0x07
    2ebe:	9c 83       	std	Y+4, r25	; 0x04
    2ec0:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    2ec2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ec4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ec6:	0c 96       	adiw	r24, 0x0c	; 12
    2ec8:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    2ecc:	8b 81       	ldd	r24, Y+3	; 0x03
    2ece:	9c 81       	ldd	r25, Y+4	; 0x04
    2ed0:	02 96       	adiw	r24, 0x02	; 2
    2ed2:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2ed6:	eb 81       	ldd	r30, Y+3	; 0x03
    2ed8:	fc 81       	ldd	r31, Y+4	; 0x04
    2eda:	96 89       	ldd	r25, Z+22	; 0x16
    2edc:	80 91 ae 06 	lds	r24, 0x06AE
    2ee0:	89 17       	cp	r24, r25
    2ee2:	28 f4       	brcc	.+10     	; 0x2eee <xTaskResumeAll+0x72>
    2ee4:	eb 81       	ldd	r30, Y+3	; 0x03
    2ee6:	fc 81       	ldd	r31, Y+4	; 0x04
    2ee8:	86 89       	ldd	r24, Z+22	; 0x16
    2eea:	80 93 ae 06 	sts	0x06AE, r24
    2eee:	eb 81       	ldd	r30, Y+3	; 0x03
    2ef0:	fc 81       	ldd	r31, Y+4	; 0x04
    2ef2:	86 89       	ldd	r24, Z+22	; 0x16
    2ef4:	28 2f       	mov	r18, r24
    2ef6:	30 e0       	ldi	r19, 0x00	; 0
    2ef8:	c9 01       	movw	r24, r18
    2efa:	88 0f       	add	r24, r24
    2efc:	99 1f       	adc	r25, r25
    2efe:	88 0f       	add	r24, r24
    2f00:	99 1f       	adc	r25, r25
    2f02:	88 0f       	add	r24, r24
    2f04:	99 1f       	adc	r25, r25
    2f06:	82 0f       	add	r24, r18
    2f08:	93 1f       	adc	r25, r19
    2f0a:	8b 54       	subi	r24, 0x4B	; 75
    2f0c:	99 4f       	sbci	r25, 0xF9	; 249
    2f0e:	2b 81       	ldd	r18, Y+3	; 0x03
    2f10:	3c 81       	ldd	r19, Y+4	; 0x04
    2f12:	2e 5f       	subi	r18, 0xFE	; 254
    2f14:	3f 4f       	sbci	r19, 0xFF	; 255
    2f16:	b9 01       	movw	r22, r18
    2f18:	0e 94 95 0a 	call	0x152a	; 0x152a <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2f1c:	eb 81       	ldd	r30, Y+3	; 0x03
    2f1e:	fc 81       	ldd	r31, Y+4	; 0x04
    2f20:	96 89       	ldd	r25, Z+22	; 0x16
    2f22:	e0 91 a8 06 	lds	r30, 0x06A8
    2f26:	f0 91 a9 06 	lds	r31, 0x06A9
    2f2a:	86 89       	ldd	r24, Z+22	; 0x16
    2f2c:	98 17       	cp	r25, r24
    2f2e:	10 f0       	brcs	.+4      	; 0x2f34 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    2f30:	81 e0       	ldi	r24, 0x01	; 1
    2f32:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2f34:	80 91 f8 06 	lds	r24, 0x06F8
    2f38:	88 23       	and	r24, r24
    2f3a:	09 f0       	breq	.+2      	; 0x2f3e <xTaskResumeAll+0xc2>
    2f3c:	ba cf       	rjmp	.-140    	; 0x2eb2 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2f3e:	80 91 b1 06 	lds	r24, 0x06B1
    2f42:	88 23       	and	r24, r24
    2f44:	61 f0       	breq	.+24     	; 0x2f5e <xTaskResumeAll+0xe2>
    2f46:	07 c0       	rjmp	.+14     	; 0x2f56 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    2f48:	0e 94 fb 17 	call	0x2ff6	; 0x2ff6 <vTaskIncrementTick>
						--uxMissedTicks;
    2f4c:	80 91 b1 06 	lds	r24, 0x06B1
    2f50:	81 50       	subi	r24, 0x01	; 1
    2f52:	80 93 b1 06 	sts	0x06B1, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2f56:	80 91 b1 06 	lds	r24, 0x06B1
    2f5a:	88 23       	and	r24, r24
    2f5c:	a9 f7       	brne	.-22     	; 0x2f48 <xTaskResumeAll+0xcc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    2f5e:	89 81       	ldd	r24, Y+1	; 0x01
    2f60:	81 30       	cpi	r24, 0x01	; 1
    2f62:	21 f0       	breq	.+8      	; 0x2f6c <xTaskResumeAll+0xf0>
    2f64:	80 91 b2 06 	lds	r24, 0x06B2
    2f68:	81 30       	cpi	r24, 0x01	; 1
    2f6a:	31 f4       	brne	.+12     	; 0x2f78 <xTaskResumeAll+0xfc>
				{
					xAlreadyYielded = pdTRUE;
    2f6c:	81 e0       	ldi	r24, 0x01	; 1
    2f6e:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    2f70:	10 92 b2 06 	sts	0x06B2, r1
					portYIELD_WITHIN_API();
    2f74:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    2f78:	0f 90       	pop	r0
    2f7a:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    2f7c:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2f7e:	0f 90       	pop	r0
    2f80:	0f 90       	pop	r0
    2f82:	0f 90       	pop	r0
    2f84:	0f 90       	pop	r0
    2f86:	cf 91       	pop	r28
    2f88:	df 91       	pop	r29
    2f8a:	08 95       	ret

00002f8c <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    2f8c:	df 93       	push	r29
    2f8e:	cf 93       	push	r28
    2f90:	00 d0       	rcall	.+0      	; 0x2f92 <xTaskGetTickCount+0x6>
    2f92:	cd b7       	in	r28, 0x3d	; 61
    2f94:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    2f96:	0f b6       	in	r0, 0x3f	; 63
    2f98:	f8 94       	cli
    2f9a:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    2f9c:	80 91 ab 06 	lds	r24, 0x06AB
    2fa0:	90 91 ac 06 	lds	r25, 0x06AC
    2fa4:	9a 83       	std	Y+2, r25	; 0x02
    2fa6:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    2fa8:	0f 90       	pop	r0
    2faa:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    2fac:	89 81       	ldd	r24, Y+1	; 0x01
    2fae:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2fb0:	0f 90       	pop	r0
    2fb2:	0f 90       	pop	r0
    2fb4:	cf 91       	pop	r28
    2fb6:	df 91       	pop	r29
    2fb8:	08 95       	ret

00002fba <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    2fba:	df 93       	push	r29
    2fbc:	cf 93       	push	r28
    2fbe:	00 d0       	rcall	.+0      	; 0x2fc0 <xTaskGetTickCountFromISR+0x6>
    2fc0:	0f 92       	push	r0
    2fc2:	cd b7       	in	r28, 0x3d	; 61
    2fc4:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2fc6:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    2fc8:	80 91 ab 06 	lds	r24, 0x06AB
    2fcc:	90 91 ac 06 	lds	r25, 0x06AC
    2fd0:	9b 83       	std	Y+3, r25	; 0x03
    2fd2:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2fd4:	8a 81       	ldd	r24, Y+2	; 0x02
    2fd6:	9b 81       	ldd	r25, Y+3	; 0x03
}
    2fd8:	0f 90       	pop	r0
    2fda:	0f 90       	pop	r0
    2fdc:	0f 90       	pop	r0
    2fde:	cf 91       	pop	r28
    2fe0:	df 91       	pop	r29
    2fe2:	08 95       	ret

00002fe4 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    2fe4:	df 93       	push	r29
    2fe6:	cf 93       	push	r28
    2fe8:	cd b7       	in	r28, 0x3d	; 61
    2fea:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    2fec:	80 91 aa 06 	lds	r24, 0x06AA
}
    2ff0:	cf 91       	pop	r28
    2ff2:	df 91       	pop	r29
    2ff4:	08 95       	ret

00002ff6 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    2ff6:	df 93       	push	r29
    2ff8:	cf 93       	push	r28
    2ffa:	00 d0       	rcall	.+0      	; 0x2ffc <vTaskIncrementTick+0x6>
    2ffc:	00 d0       	rcall	.+0      	; 0x2ffe <vTaskIncrementTick+0x8>
    2ffe:	00 d0       	rcall	.+0      	; 0x3000 <vTaskIncrementTick+0xa>
    3000:	cd b7       	in	r28, 0x3d	; 61
    3002:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    3004:	80 91 b0 06 	lds	r24, 0x06B0
    3008:	88 23       	and	r24, r24
    300a:	09 f0       	breq	.+2      	; 0x300e <vTaskIncrementTick+0x18>
    300c:	bb c0       	rjmp	.+374    	; 0x3184 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    300e:	80 91 ab 06 	lds	r24, 0x06AB
    3012:	90 91 ac 06 	lds	r25, 0x06AC
    3016:	01 96       	adiw	r24, 0x01	; 1
    3018:	90 93 ac 06 	sts	0x06AC, r25
    301c:	80 93 ab 06 	sts	0x06AB, r24
		if( xTickCount == ( portTickType ) 0U )
    3020:	80 91 ab 06 	lds	r24, 0x06AB
    3024:	90 91 ac 06 	lds	r25, 0x06AC
    3028:	00 97       	sbiw	r24, 0x00	; 0
    302a:	d1 f5       	brne	.+116    	; 0x30a0 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    302c:	80 91 f4 06 	lds	r24, 0x06F4
    3030:	90 91 f5 06 	lds	r25, 0x06F5
    3034:	9c 83       	std	Y+4, r25	; 0x04
    3036:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    3038:	80 91 f6 06 	lds	r24, 0x06F6
    303c:	90 91 f7 06 	lds	r25, 0x06F7
    3040:	90 93 f5 06 	sts	0x06F5, r25
    3044:	80 93 f4 06 	sts	0x06F4, r24
			pxOverflowDelayedTaskList = pxTemp;
    3048:	8b 81       	ldd	r24, Y+3	; 0x03
    304a:	9c 81       	ldd	r25, Y+4	; 0x04
    304c:	90 93 f7 06 	sts	0x06F7, r25
    3050:	80 93 f6 06 	sts	0x06F6, r24
			xNumOfOverflows++;
    3054:	80 91 b3 06 	lds	r24, 0x06B3
    3058:	8f 5f       	subi	r24, 0xFF	; 255
    305a:	80 93 b3 06 	sts	0x06B3, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    305e:	e0 91 f4 06 	lds	r30, 0x06F4
    3062:	f0 91 f5 06 	lds	r31, 0x06F5
    3066:	80 81       	ld	r24, Z
    3068:	88 23       	and	r24, r24
    306a:	39 f4       	brne	.+14     	; 0x307a <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    306c:	8f ef       	ldi	r24, 0xFF	; 255
    306e:	9f ef       	ldi	r25, 0xFF	; 255
    3070:	90 93 a0 01 	sts	0x01A0, r25
    3074:	80 93 9f 01 	sts	0x019F, r24
    3078:	13 c0       	rjmp	.+38     	; 0x30a0 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    307a:	e0 91 f4 06 	lds	r30, 0x06F4
    307e:	f0 91 f5 06 	lds	r31, 0x06F5
    3082:	05 80       	ldd	r0, Z+5	; 0x05
    3084:	f6 81       	ldd	r31, Z+6	; 0x06
    3086:	e0 2d       	mov	r30, r0
    3088:	86 81       	ldd	r24, Z+6	; 0x06
    308a:	97 81       	ldd	r25, Z+7	; 0x07
    308c:	9e 83       	std	Y+6, r25	; 0x06
    308e:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    3090:	ed 81       	ldd	r30, Y+5	; 0x05
    3092:	fe 81       	ldd	r31, Y+6	; 0x06
    3094:	82 81       	ldd	r24, Z+2	; 0x02
    3096:	93 81       	ldd	r25, Z+3	; 0x03
    3098:	90 93 a0 01 	sts	0x01A0, r25
    309c:	80 93 9f 01 	sts	0x019F, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    30a0:	20 91 ab 06 	lds	r18, 0x06AB
    30a4:	30 91 ac 06 	lds	r19, 0x06AC
    30a8:	80 91 9f 01 	lds	r24, 0x019F
    30ac:	90 91 a0 01 	lds	r25, 0x01A0
    30b0:	28 17       	cp	r18, r24
    30b2:	39 07       	cpc	r19, r25
    30b4:	08 f4       	brcc	.+2      	; 0x30b8 <vTaskIncrementTick+0xc2>
    30b6:	6b c0       	rjmp	.+214    	; 0x318e <vTaskIncrementTick+0x198>
    30b8:	e0 91 f4 06 	lds	r30, 0x06F4
    30bc:	f0 91 f5 06 	lds	r31, 0x06F5
    30c0:	80 81       	ld	r24, Z
    30c2:	88 23       	and	r24, r24
    30c4:	39 f4       	brne	.+14     	; 0x30d4 <vTaskIncrementTick+0xde>
    30c6:	8f ef       	ldi	r24, 0xFF	; 255
    30c8:	9f ef       	ldi	r25, 0xFF	; 255
    30ca:	90 93 a0 01 	sts	0x01A0, r25
    30ce:	80 93 9f 01 	sts	0x019F, r24
    30d2:	5d c0       	rjmp	.+186    	; 0x318e <vTaskIncrementTick+0x198>
    30d4:	e0 91 f4 06 	lds	r30, 0x06F4
    30d8:	f0 91 f5 06 	lds	r31, 0x06F5
    30dc:	05 80       	ldd	r0, Z+5	; 0x05
    30de:	f6 81       	ldd	r31, Z+6	; 0x06
    30e0:	e0 2d       	mov	r30, r0
    30e2:	86 81       	ldd	r24, Z+6	; 0x06
    30e4:	97 81       	ldd	r25, Z+7	; 0x07
    30e6:	9e 83       	std	Y+6, r25	; 0x06
    30e8:	8d 83       	std	Y+5, r24	; 0x05
    30ea:	ed 81       	ldd	r30, Y+5	; 0x05
    30ec:	fe 81       	ldd	r31, Y+6	; 0x06
    30ee:	82 81       	ldd	r24, Z+2	; 0x02
    30f0:	93 81       	ldd	r25, Z+3	; 0x03
    30f2:	9a 83       	std	Y+2, r25	; 0x02
    30f4:	89 83       	std	Y+1, r24	; 0x01
    30f6:	20 91 ab 06 	lds	r18, 0x06AB
    30fa:	30 91 ac 06 	lds	r19, 0x06AC
    30fe:	89 81       	ldd	r24, Y+1	; 0x01
    3100:	9a 81       	ldd	r25, Y+2	; 0x02
    3102:	28 17       	cp	r18, r24
    3104:	39 07       	cpc	r19, r25
    3106:	38 f4       	brcc	.+14     	; 0x3116 <vTaskIncrementTick+0x120>
    3108:	89 81       	ldd	r24, Y+1	; 0x01
    310a:	9a 81       	ldd	r25, Y+2	; 0x02
    310c:	90 93 a0 01 	sts	0x01A0, r25
    3110:	80 93 9f 01 	sts	0x019F, r24
    3114:	3c c0       	rjmp	.+120    	; 0x318e <vTaskIncrementTick+0x198>
    3116:	8d 81       	ldd	r24, Y+5	; 0x05
    3118:	9e 81       	ldd	r25, Y+6	; 0x06
    311a:	02 96       	adiw	r24, 0x02	; 2
    311c:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>
    3120:	ed 81       	ldd	r30, Y+5	; 0x05
    3122:	fe 81       	ldd	r31, Y+6	; 0x06
    3124:	84 89       	ldd	r24, Z+20	; 0x14
    3126:	95 89       	ldd	r25, Z+21	; 0x15
    3128:	00 97       	sbiw	r24, 0x00	; 0
    312a:	29 f0       	breq	.+10     	; 0x3136 <vTaskIncrementTick+0x140>
    312c:	8d 81       	ldd	r24, Y+5	; 0x05
    312e:	9e 81       	ldd	r25, Y+6	; 0x06
    3130:	0c 96       	adiw	r24, 0x0c	; 12
    3132:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>
    3136:	ed 81       	ldd	r30, Y+5	; 0x05
    3138:	fe 81       	ldd	r31, Y+6	; 0x06
    313a:	96 89       	ldd	r25, Z+22	; 0x16
    313c:	80 91 ae 06 	lds	r24, 0x06AE
    3140:	89 17       	cp	r24, r25
    3142:	28 f4       	brcc	.+10     	; 0x314e <vTaskIncrementTick+0x158>
    3144:	ed 81       	ldd	r30, Y+5	; 0x05
    3146:	fe 81       	ldd	r31, Y+6	; 0x06
    3148:	86 89       	ldd	r24, Z+22	; 0x16
    314a:	80 93 ae 06 	sts	0x06AE, r24
    314e:	ed 81       	ldd	r30, Y+5	; 0x05
    3150:	fe 81       	ldd	r31, Y+6	; 0x06
    3152:	86 89       	ldd	r24, Z+22	; 0x16
    3154:	28 2f       	mov	r18, r24
    3156:	30 e0       	ldi	r19, 0x00	; 0
    3158:	c9 01       	movw	r24, r18
    315a:	88 0f       	add	r24, r24
    315c:	99 1f       	adc	r25, r25
    315e:	88 0f       	add	r24, r24
    3160:	99 1f       	adc	r25, r25
    3162:	88 0f       	add	r24, r24
    3164:	99 1f       	adc	r25, r25
    3166:	82 0f       	add	r24, r18
    3168:	93 1f       	adc	r25, r19
    316a:	ac 01       	movw	r20, r24
    316c:	4b 54       	subi	r20, 0x4B	; 75
    316e:	59 4f       	sbci	r21, 0xF9	; 249
    3170:	8d 81       	ldd	r24, Y+5	; 0x05
    3172:	9e 81       	ldd	r25, Y+6	; 0x06
    3174:	9c 01       	movw	r18, r24
    3176:	2e 5f       	subi	r18, 0xFE	; 254
    3178:	3f 4f       	sbci	r19, 0xFF	; 255
    317a:	ca 01       	movw	r24, r20
    317c:	b9 01       	movw	r22, r18
    317e:	0e 94 95 0a 	call	0x152a	; 0x152a <vListInsertEnd>
    3182:	9a cf       	rjmp	.-204    	; 0x30b8 <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    3184:	80 91 b1 06 	lds	r24, 0x06B1
    3188:	8f 5f       	subi	r24, 0xFF	; 255
    318a:	80 93 b1 06 	sts	0x06B1, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    318e:	26 96       	adiw	r28, 0x06	; 6
    3190:	0f b6       	in	r0, 0x3f	; 63
    3192:	f8 94       	cli
    3194:	de bf       	out	0x3e, r29	; 62
    3196:	0f be       	out	0x3f, r0	; 63
    3198:	cd bf       	out	0x3d, r28	; 61
    319a:	cf 91       	pop	r28
    319c:	df 91       	pop	r29
    319e:	08 95       	ret

000031a0 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    31a0:	df 93       	push	r29
    31a2:	cf 93       	push	r28
    31a4:	00 d0       	rcall	.+0      	; 0x31a6 <vTaskSwitchContext+0x6>
    31a6:	cd b7       	in	r28, 0x3d	; 61
    31a8:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    31aa:	80 91 b0 06 	lds	r24, 0x06B0
    31ae:	88 23       	and	r24, r24
    31b0:	49 f0       	breq	.+18     	; 0x31c4 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    31b2:	81 e0       	ldi	r24, 0x01	; 1
    31b4:	80 93 b2 06 	sts	0x06B2, r24
    31b8:	54 c0       	rjmp	.+168    	; 0x3262 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    31ba:	80 91 ae 06 	lds	r24, 0x06AE
    31be:	81 50       	subi	r24, 0x01	; 1
    31c0:	80 93 ae 06 	sts	0x06AE, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    31c4:	80 91 ae 06 	lds	r24, 0x06AE
    31c8:	28 2f       	mov	r18, r24
    31ca:	30 e0       	ldi	r19, 0x00	; 0
    31cc:	c9 01       	movw	r24, r18
    31ce:	88 0f       	add	r24, r24
    31d0:	99 1f       	adc	r25, r25
    31d2:	88 0f       	add	r24, r24
    31d4:	99 1f       	adc	r25, r25
    31d6:	88 0f       	add	r24, r24
    31d8:	99 1f       	adc	r25, r25
    31da:	82 0f       	add	r24, r18
    31dc:	93 1f       	adc	r25, r19
    31de:	fc 01       	movw	r30, r24
    31e0:	eb 54       	subi	r30, 0x4B	; 75
    31e2:	f9 4f       	sbci	r31, 0xF9	; 249
    31e4:	80 81       	ld	r24, Z
    31e6:	88 23       	and	r24, r24
    31e8:	41 f3       	breq	.-48     	; 0x31ba <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    31ea:	80 91 ae 06 	lds	r24, 0x06AE
    31ee:	28 2f       	mov	r18, r24
    31f0:	30 e0       	ldi	r19, 0x00	; 0
    31f2:	c9 01       	movw	r24, r18
    31f4:	88 0f       	add	r24, r24
    31f6:	99 1f       	adc	r25, r25
    31f8:	88 0f       	add	r24, r24
    31fa:	99 1f       	adc	r25, r25
    31fc:	88 0f       	add	r24, r24
    31fe:	99 1f       	adc	r25, r25
    3200:	82 0f       	add	r24, r18
    3202:	93 1f       	adc	r25, r19
    3204:	8b 54       	subi	r24, 0x4B	; 75
    3206:	99 4f       	sbci	r25, 0xF9	; 249
    3208:	9a 83       	std	Y+2, r25	; 0x02
    320a:	89 83       	std	Y+1, r24	; 0x01
    320c:	e9 81       	ldd	r30, Y+1	; 0x01
    320e:	fa 81       	ldd	r31, Y+2	; 0x02
    3210:	01 80       	ldd	r0, Z+1	; 0x01
    3212:	f2 81       	ldd	r31, Z+2	; 0x02
    3214:	e0 2d       	mov	r30, r0
    3216:	82 81       	ldd	r24, Z+2	; 0x02
    3218:	93 81       	ldd	r25, Z+3	; 0x03
    321a:	e9 81       	ldd	r30, Y+1	; 0x01
    321c:	fa 81       	ldd	r31, Y+2	; 0x02
    321e:	92 83       	std	Z+2, r25	; 0x02
    3220:	81 83       	std	Z+1, r24	; 0x01
    3222:	e9 81       	ldd	r30, Y+1	; 0x01
    3224:	fa 81       	ldd	r31, Y+2	; 0x02
    3226:	21 81       	ldd	r18, Z+1	; 0x01
    3228:	32 81       	ldd	r19, Z+2	; 0x02
    322a:	89 81       	ldd	r24, Y+1	; 0x01
    322c:	9a 81       	ldd	r25, Y+2	; 0x02
    322e:	03 96       	adiw	r24, 0x03	; 3
    3230:	28 17       	cp	r18, r24
    3232:	39 07       	cpc	r19, r25
    3234:	59 f4       	brne	.+22     	; 0x324c <vTaskSwitchContext+0xac>
    3236:	e9 81       	ldd	r30, Y+1	; 0x01
    3238:	fa 81       	ldd	r31, Y+2	; 0x02
    323a:	01 80       	ldd	r0, Z+1	; 0x01
    323c:	f2 81       	ldd	r31, Z+2	; 0x02
    323e:	e0 2d       	mov	r30, r0
    3240:	82 81       	ldd	r24, Z+2	; 0x02
    3242:	93 81       	ldd	r25, Z+3	; 0x03
    3244:	e9 81       	ldd	r30, Y+1	; 0x01
    3246:	fa 81       	ldd	r31, Y+2	; 0x02
    3248:	92 83       	std	Z+2, r25	; 0x02
    324a:	81 83       	std	Z+1, r24	; 0x01
    324c:	e9 81       	ldd	r30, Y+1	; 0x01
    324e:	fa 81       	ldd	r31, Y+2	; 0x02
    3250:	01 80       	ldd	r0, Z+1	; 0x01
    3252:	f2 81       	ldd	r31, Z+2	; 0x02
    3254:	e0 2d       	mov	r30, r0
    3256:	86 81       	ldd	r24, Z+6	; 0x06
    3258:	97 81       	ldd	r25, Z+7	; 0x07
    325a:	90 93 a9 06 	sts	0x06A9, r25
    325e:	80 93 a8 06 	sts	0x06A8, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    3262:	0f 90       	pop	r0
    3264:	0f 90       	pop	r0
    3266:	cf 91       	pop	r28
    3268:	df 91       	pop	r29
    326a:	08 95       	ret

0000326c <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    326c:	df 93       	push	r29
    326e:	cf 93       	push	r28
    3270:	00 d0       	rcall	.+0      	; 0x3272 <vTaskPlaceOnEventList+0x6>
    3272:	00 d0       	rcall	.+0      	; 0x3274 <vTaskPlaceOnEventList+0x8>
    3274:	00 d0       	rcall	.+0      	; 0x3276 <vTaskPlaceOnEventList+0xa>
    3276:	cd b7       	in	r28, 0x3d	; 61
    3278:	de b7       	in	r29, 0x3e	; 62
    327a:	9c 83       	std	Y+4, r25	; 0x04
    327c:	8b 83       	std	Y+3, r24	; 0x03
    327e:	7e 83       	std	Y+6, r23	; 0x06
    3280:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    3282:	4b 81       	ldd	r20, Y+3	; 0x03
    3284:	5c 81       	ldd	r21, Y+4	; 0x04
    3286:	80 91 a8 06 	lds	r24, 0x06A8
    328a:	90 91 a9 06 	lds	r25, 0x06A9
    328e:	9c 01       	movw	r18, r24
    3290:	24 5f       	subi	r18, 0xF4	; 244
    3292:	3f 4f       	sbci	r19, 0xFF	; 255
    3294:	ca 01       	movw	r24, r20
    3296:	b9 01       	movw	r22, r18
    3298:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    329c:	80 91 a8 06 	lds	r24, 0x06A8
    32a0:	90 91 a9 06 	lds	r25, 0x06A9
    32a4:	02 96       	adiw	r24, 0x02	; 2
    32a6:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    32aa:	8d 81       	ldd	r24, Y+5	; 0x05
    32ac:	9e 81       	ldd	r25, Y+6	; 0x06
    32ae:	2f ef       	ldi	r18, 0xFF	; 255
    32b0:	8f 3f       	cpi	r24, 0xFF	; 255
    32b2:	92 07       	cpc	r25, r18
    32b4:	69 f4       	brne	.+26     	; 0x32d0 <vTaskPlaceOnEventList+0x64>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    32b6:	80 91 a8 06 	lds	r24, 0x06A8
    32ba:	90 91 a9 06 	lds	r25, 0x06A9
    32be:	9c 01       	movw	r18, r24
    32c0:	2e 5f       	subi	r18, 0xFE	; 254
    32c2:	3f 4f       	sbci	r19, 0xFF	; 255
    32c4:	81 e0       	ldi	r24, 0x01	; 1
    32c6:	97 e0       	ldi	r25, 0x07	; 7
    32c8:	b9 01       	movw	r22, r18
    32ca:	0e 94 95 0a 	call	0x152a	; 0x152a <vListInsertEnd>
    32ce:	0e c0       	rjmp	.+28     	; 0x32ec <vTaskPlaceOnEventList+0x80>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    32d0:	20 91 ab 06 	lds	r18, 0x06AB
    32d4:	30 91 ac 06 	lds	r19, 0x06AC
    32d8:	8d 81       	ldd	r24, Y+5	; 0x05
    32da:	9e 81       	ldd	r25, Y+6	; 0x06
    32dc:	82 0f       	add	r24, r18
    32de:	93 1f       	adc	r25, r19
    32e0:	9a 83       	std	Y+2, r25	; 0x02
    32e2:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    32e4:	89 81       	ldd	r24, Y+1	; 0x01
    32e6:	9a 81       	ldd	r25, Y+2	; 0x02
    32e8:	0e 94 4e 1b 	call	0x369c	; 0x369c <prvAddCurrentTaskToDelayedList>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
    32ec:	26 96       	adiw	r28, 0x06	; 6
    32ee:	0f b6       	in	r0, 0x3f	; 63
    32f0:	f8 94       	cli
    32f2:	de bf       	out	0x3e, r29	; 62
    32f4:	0f be       	out	0x3f, r0	; 63
    32f6:	cd bf       	out	0x3d, r28	; 61
    32f8:	cf 91       	pop	r28
    32fa:	df 91       	pop	r29
    32fc:	08 95       	ret

000032fe <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vTaskPlaceOnEventListRestricted( const xList * const pxEventList, portTickType xTicksToWait )
	{
    32fe:	df 93       	push	r29
    3300:	cf 93       	push	r28
    3302:	00 d0       	rcall	.+0      	; 0x3304 <vTaskPlaceOnEventListRestricted+0x6>
    3304:	00 d0       	rcall	.+0      	; 0x3306 <vTaskPlaceOnEventListRestricted+0x8>
    3306:	00 d0       	rcall	.+0      	; 0x3308 <vTaskPlaceOnEventListRestricted+0xa>
    3308:	cd b7       	in	r28, 0x3d	; 61
    330a:	de b7       	in	r29, 0x3e	; 62
    330c:	9c 83       	std	Y+4, r25	; 0x04
    330e:	8b 83       	std	Y+3, r24	; 0x03
    3310:	7e 83       	std	Y+6, r23	; 0x06
    3312:	6d 83       	std	Y+5, r22	; 0x05
	
		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    3314:	4b 81       	ldd	r20, Y+3	; 0x03
    3316:	5c 81       	ldd	r21, Y+4	; 0x04
    3318:	80 91 a8 06 	lds	r24, 0x06A8
    331c:	90 91 a9 06 	lds	r25, 0x06A9
    3320:	9c 01       	movw	r18, r24
    3322:	24 5f       	subi	r18, 0xF4	; 244
    3324:	3f 4f       	sbci	r19, 0xFF	; 255
    3326:	ca 01       	movw	r24, r20
    3328:	b9 01       	movw	r22, r18
    332a:	0e 94 95 0a 	call	0x152a	; 0x152a <vListInsertEnd>

		/* We must remove this task from the ready list before adding it to the
		blocked list as the same list item is used for both lists.  This
		function is called form a critical section. */
		vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    332e:	80 91 a8 06 	lds	r24, 0x06A8
    3332:	90 91 a9 06 	lds	r25, 0x06A9
    3336:	02 96       	adiw	r24, 0x02	; 2
    3338:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>

		/* Calculate the time at which the task should be woken if the event does
		not occur.  This may overflow but this doesn't matter. */
		xTimeToWake = xTickCount + xTicksToWait;
    333c:	20 91 ab 06 	lds	r18, 0x06AB
    3340:	30 91 ac 06 	lds	r19, 0x06AC
    3344:	8d 81       	ldd	r24, Y+5	; 0x05
    3346:	9e 81       	ldd	r25, Y+6	; 0x06
    3348:	82 0f       	add	r24, r18
    334a:	93 1f       	adc	r25, r19
    334c:	9a 83       	std	Y+2, r25	; 0x02
    334e:	89 83       	std	Y+1, r24	; 0x01
		prvAddCurrentTaskToDelayedList( xTimeToWake );
    3350:	89 81       	ldd	r24, Y+1	; 0x01
    3352:	9a 81       	ldd	r25, Y+2	; 0x02
    3354:	0e 94 4e 1b 	call	0x369c	; 0x369c <prvAddCurrentTaskToDelayedList>
	}
    3358:	26 96       	adiw	r28, 0x06	; 6
    335a:	0f b6       	in	r0, 0x3f	; 63
    335c:	f8 94       	cli
    335e:	de bf       	out	0x3e, r29	; 62
    3360:	0f be       	out	0x3f, r0	; 63
    3362:	cd bf       	out	0x3d, r28	; 61
    3364:	cf 91       	pop	r28
    3366:	df 91       	pop	r29
    3368:	08 95       	ret

0000336a <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    336a:	df 93       	push	r29
    336c:	cf 93       	push	r28
    336e:	00 d0       	rcall	.+0      	; 0x3370 <xTaskRemoveFromEventList+0x6>
    3370:	00 d0       	rcall	.+0      	; 0x3372 <xTaskRemoveFromEventList+0x8>
    3372:	0f 92       	push	r0
    3374:	cd b7       	in	r28, 0x3d	; 61
    3376:	de b7       	in	r29, 0x3e	; 62
    3378:	9d 83       	std	Y+5, r25	; 0x05
    337a:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    337c:	ec 81       	ldd	r30, Y+4	; 0x04
    337e:	fd 81       	ldd	r31, Y+5	; 0x05
    3380:	05 80       	ldd	r0, Z+5	; 0x05
    3382:	f6 81       	ldd	r31, Z+6	; 0x06
    3384:	e0 2d       	mov	r30, r0
    3386:	86 81       	ldd	r24, Z+6	; 0x06
    3388:	97 81       	ldd	r25, Z+7	; 0x07
    338a:	9b 83       	std	Y+3, r25	; 0x03
    338c:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    338e:	8a 81       	ldd	r24, Y+2	; 0x02
    3390:	9b 81       	ldd	r25, Y+3	; 0x03
    3392:	0c 96       	adiw	r24, 0x0c	; 12
    3394:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    3398:	80 91 b0 06 	lds	r24, 0x06B0
    339c:	88 23       	and	r24, r24
    339e:	61 f5       	brne	.+88     	; 0x33f8 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    33a0:	8a 81       	ldd	r24, Y+2	; 0x02
    33a2:	9b 81       	ldd	r25, Y+3	; 0x03
    33a4:	02 96       	adiw	r24, 0x02	; 2
    33a6:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    33aa:	ea 81       	ldd	r30, Y+2	; 0x02
    33ac:	fb 81       	ldd	r31, Y+3	; 0x03
    33ae:	96 89       	ldd	r25, Z+22	; 0x16
    33b0:	80 91 ae 06 	lds	r24, 0x06AE
    33b4:	89 17       	cp	r24, r25
    33b6:	28 f4       	brcc	.+10     	; 0x33c2 <xTaskRemoveFromEventList+0x58>
    33b8:	ea 81       	ldd	r30, Y+2	; 0x02
    33ba:	fb 81       	ldd	r31, Y+3	; 0x03
    33bc:	86 89       	ldd	r24, Z+22	; 0x16
    33be:	80 93 ae 06 	sts	0x06AE, r24
    33c2:	ea 81       	ldd	r30, Y+2	; 0x02
    33c4:	fb 81       	ldd	r31, Y+3	; 0x03
    33c6:	86 89       	ldd	r24, Z+22	; 0x16
    33c8:	28 2f       	mov	r18, r24
    33ca:	30 e0       	ldi	r19, 0x00	; 0
    33cc:	c9 01       	movw	r24, r18
    33ce:	88 0f       	add	r24, r24
    33d0:	99 1f       	adc	r25, r25
    33d2:	88 0f       	add	r24, r24
    33d4:	99 1f       	adc	r25, r25
    33d6:	88 0f       	add	r24, r24
    33d8:	99 1f       	adc	r25, r25
    33da:	82 0f       	add	r24, r18
    33dc:	93 1f       	adc	r25, r19
    33de:	ac 01       	movw	r20, r24
    33e0:	4b 54       	subi	r20, 0x4B	; 75
    33e2:	59 4f       	sbci	r21, 0xF9	; 249
    33e4:	8a 81       	ldd	r24, Y+2	; 0x02
    33e6:	9b 81       	ldd	r25, Y+3	; 0x03
    33e8:	9c 01       	movw	r18, r24
    33ea:	2e 5f       	subi	r18, 0xFE	; 254
    33ec:	3f 4f       	sbci	r19, 0xFF	; 255
    33ee:	ca 01       	movw	r24, r20
    33f0:	b9 01       	movw	r22, r18
    33f2:	0e 94 95 0a 	call	0x152a	; 0x152a <vListInsertEnd>
    33f6:	0a c0       	rjmp	.+20     	; 0x340c <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    33f8:	8a 81       	ldd	r24, Y+2	; 0x02
    33fa:	9b 81       	ldd	r25, Y+3	; 0x03
    33fc:	9c 01       	movw	r18, r24
    33fe:	24 5f       	subi	r18, 0xF4	; 244
    3400:	3f 4f       	sbci	r19, 0xFF	; 255
    3402:	88 ef       	ldi	r24, 0xF8	; 248
    3404:	96 e0       	ldi	r25, 0x06	; 6
    3406:	b9 01       	movw	r22, r18
    3408:	0e 94 95 0a 	call	0x152a	; 0x152a <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    340c:	ea 81       	ldd	r30, Y+2	; 0x02
    340e:	fb 81       	ldd	r31, Y+3	; 0x03
    3410:	96 89       	ldd	r25, Z+22	; 0x16
    3412:	e0 91 a8 06 	lds	r30, 0x06A8
    3416:	f0 91 a9 06 	lds	r31, 0x06A9
    341a:	86 89       	ldd	r24, Z+22	; 0x16
    341c:	98 17       	cp	r25, r24
    341e:	18 f0       	brcs	.+6      	; 0x3426 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    3420:	81 e0       	ldi	r24, 0x01	; 1
    3422:	89 83       	std	Y+1, r24	; 0x01
    3424:	01 c0       	rjmp	.+2      	; 0x3428 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    3426:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3428:	89 81       	ldd	r24, Y+1	; 0x01
}
    342a:	0f 90       	pop	r0
    342c:	0f 90       	pop	r0
    342e:	0f 90       	pop	r0
    3430:	0f 90       	pop	r0
    3432:	0f 90       	pop	r0
    3434:	cf 91       	pop	r28
    3436:	df 91       	pop	r29
    3438:	08 95       	ret

0000343a <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    343a:	df 93       	push	r29
    343c:	cf 93       	push	r28
    343e:	00 d0       	rcall	.+0      	; 0x3440 <vTaskSetTimeOutState+0x6>
    3440:	cd b7       	in	r28, 0x3d	; 61
    3442:	de b7       	in	r29, 0x3e	; 62
    3444:	9a 83       	std	Y+2, r25	; 0x02
    3446:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    3448:	80 91 b3 06 	lds	r24, 0x06B3
    344c:	e9 81       	ldd	r30, Y+1	; 0x01
    344e:	fa 81       	ldd	r31, Y+2	; 0x02
    3450:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    3452:	80 91 ab 06 	lds	r24, 0x06AB
    3456:	90 91 ac 06 	lds	r25, 0x06AC
    345a:	e9 81       	ldd	r30, Y+1	; 0x01
    345c:	fa 81       	ldd	r31, Y+2	; 0x02
    345e:	92 83       	std	Z+2, r25	; 0x02
    3460:	81 83       	std	Z+1, r24	; 0x01
}
    3462:	0f 90       	pop	r0
    3464:	0f 90       	pop	r0
    3466:	cf 91       	pop	r28
    3468:	df 91       	pop	r29
    346a:	08 95       	ret

0000346c <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    346c:	df 93       	push	r29
    346e:	cf 93       	push	r28
    3470:	00 d0       	rcall	.+0      	; 0x3472 <xTaskCheckForTimeOut+0x6>
    3472:	00 d0       	rcall	.+0      	; 0x3474 <xTaskCheckForTimeOut+0x8>
    3474:	0f 92       	push	r0
    3476:	cd b7       	in	r28, 0x3d	; 61
    3478:	de b7       	in	r29, 0x3e	; 62
    347a:	9b 83       	std	Y+3, r25	; 0x03
    347c:	8a 83       	std	Y+2, r24	; 0x02
    347e:	7d 83       	std	Y+5, r23	; 0x05
    3480:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    3482:	0f b6       	in	r0, 0x3f	; 63
    3484:	f8 94       	cli
    3486:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    3488:	ec 81       	ldd	r30, Y+4	; 0x04
    348a:	fd 81       	ldd	r31, Y+5	; 0x05
    348c:	80 81       	ld	r24, Z
    348e:	91 81       	ldd	r25, Z+1	; 0x01
    3490:	2f ef       	ldi	r18, 0xFF	; 255
    3492:	8f 3f       	cpi	r24, 0xFF	; 255
    3494:	92 07       	cpc	r25, r18
    3496:	11 f4       	brne	.+4      	; 0x349c <xTaskCheckForTimeOut+0x30>
			{
				xReturn = pdFALSE;
    3498:	19 82       	std	Y+1, r1	; 0x01
    349a:	44 c0       	rjmp	.+136    	; 0x3524 <xTaskCheckForTimeOut+0xb8>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    349c:	ea 81       	ldd	r30, Y+2	; 0x02
    349e:	fb 81       	ldd	r31, Y+3	; 0x03
    34a0:	90 81       	ld	r25, Z
    34a2:	80 91 b3 06 	lds	r24, 0x06B3
    34a6:	98 17       	cp	r25, r24
    34a8:	71 f0       	breq	.+28     	; 0x34c6 <xTaskCheckForTimeOut+0x5a>
    34aa:	ea 81       	ldd	r30, Y+2	; 0x02
    34ac:	fb 81       	ldd	r31, Y+3	; 0x03
    34ae:	21 81       	ldd	r18, Z+1	; 0x01
    34b0:	32 81       	ldd	r19, Z+2	; 0x02
    34b2:	80 91 ab 06 	lds	r24, 0x06AB
    34b6:	90 91 ac 06 	lds	r25, 0x06AC
    34ba:	82 17       	cp	r24, r18
    34bc:	93 07       	cpc	r25, r19
    34be:	18 f0       	brcs	.+6      	; 0x34c6 <xTaskCheckForTimeOut+0x5a>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    34c0:	81 e0       	ldi	r24, 0x01	; 1
    34c2:	89 83       	std	Y+1, r24	; 0x01
    34c4:	2f c0       	rjmp	.+94     	; 0x3524 <xTaskCheckForTimeOut+0xb8>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    34c6:	20 91 ab 06 	lds	r18, 0x06AB
    34ca:	30 91 ac 06 	lds	r19, 0x06AC
    34ce:	ea 81       	ldd	r30, Y+2	; 0x02
    34d0:	fb 81       	ldd	r31, Y+3	; 0x03
    34d2:	81 81       	ldd	r24, Z+1	; 0x01
    34d4:	92 81       	ldd	r25, Z+2	; 0x02
    34d6:	28 1b       	sub	r18, r24
    34d8:	39 0b       	sbc	r19, r25
    34da:	ec 81       	ldd	r30, Y+4	; 0x04
    34dc:	fd 81       	ldd	r31, Y+5	; 0x05
    34de:	80 81       	ld	r24, Z
    34e0:	91 81       	ldd	r25, Z+1	; 0x01
    34e2:	28 17       	cp	r18, r24
    34e4:	39 07       	cpc	r19, r25
    34e6:	e0 f4       	brcc	.+56     	; 0x3520 <xTaskCheckForTimeOut+0xb4>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    34e8:	ec 81       	ldd	r30, Y+4	; 0x04
    34ea:	fd 81       	ldd	r31, Y+5	; 0x05
    34ec:	40 81       	ld	r20, Z
    34ee:	51 81       	ldd	r21, Z+1	; 0x01
    34f0:	ea 81       	ldd	r30, Y+2	; 0x02
    34f2:	fb 81       	ldd	r31, Y+3	; 0x03
    34f4:	21 81       	ldd	r18, Z+1	; 0x01
    34f6:	32 81       	ldd	r19, Z+2	; 0x02
    34f8:	80 91 ab 06 	lds	r24, 0x06AB
    34fc:	90 91 ac 06 	lds	r25, 0x06AC
    3500:	b9 01       	movw	r22, r18
    3502:	68 1b       	sub	r22, r24
    3504:	79 0b       	sbc	r23, r25
    3506:	cb 01       	movw	r24, r22
    3508:	84 0f       	add	r24, r20
    350a:	95 1f       	adc	r25, r21
    350c:	ec 81       	ldd	r30, Y+4	; 0x04
    350e:	fd 81       	ldd	r31, Y+5	; 0x05
    3510:	91 83       	std	Z+1, r25	; 0x01
    3512:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    3514:	8a 81       	ldd	r24, Y+2	; 0x02
    3516:	9b 81       	ldd	r25, Y+3	; 0x03
    3518:	0e 94 1d 1a 	call	0x343a	; 0x343a <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    351c:	19 82       	std	Y+1, r1	; 0x01
    351e:	02 c0       	rjmp	.+4      	; 0x3524 <xTaskCheckForTimeOut+0xb8>
		}
		else
		{
			xReturn = pdTRUE;
    3520:	81 e0       	ldi	r24, 0x01	; 1
    3522:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    3524:	0f 90       	pop	r0
    3526:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3528:	89 81       	ldd	r24, Y+1	; 0x01
}
    352a:	0f 90       	pop	r0
    352c:	0f 90       	pop	r0
    352e:	0f 90       	pop	r0
    3530:	0f 90       	pop	r0
    3532:	0f 90       	pop	r0
    3534:	cf 91       	pop	r28
    3536:	df 91       	pop	r29
    3538:	08 95       	ret

0000353a <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    353a:	df 93       	push	r29
    353c:	cf 93       	push	r28
    353e:	cd b7       	in	r28, 0x3d	; 61
    3540:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    3542:	81 e0       	ldi	r24, 0x01	; 1
    3544:	80 93 b2 06 	sts	0x06B2, r24
}
    3548:	cf 91       	pop	r28
    354a:	df 91       	pop	r29
    354c:	08 95       	ret

0000354e <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    354e:	df 93       	push	r29
    3550:	cf 93       	push	r28
    3552:	00 d0       	rcall	.+0      	; 0x3554 <prvIdleTask+0x6>
    3554:	cd b7       	in	r28, 0x3d	; 61
    3556:	de b7       	in	r29, 0x3e	; 62
    3558:	9a 83       	std	Y+2, r25	; 0x02
    355a:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    355c:	0e 94 47 1b 	call	0x368e	; 0x368e <prvCheckTasksWaitingTermination>
		{
			/* If we are not using preemption we keep forcing a task switch to
			see if any other task has become available.  If we are using
			preemption we don't need to do this as any task becoming available
			will automatically get the processor anyway. */
			taskYIELD();
    3560:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <vPortYield>
    3564:	fb cf       	rjmp	.-10     	; 0x355c <prvIdleTask+0xe>

00003566 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    3566:	0f 93       	push	r16
    3568:	1f 93       	push	r17
    356a:	df 93       	push	r29
    356c:	cf 93       	push	r28
    356e:	cd b7       	in	r28, 0x3d	; 61
    3570:	de b7       	in	r29, 0x3e	; 62
    3572:	29 97       	sbiw	r28, 0x09	; 9
    3574:	0f b6       	in	r0, 0x3f	; 63
    3576:	f8 94       	cli
    3578:	de bf       	out	0x3e, r29	; 62
    357a:	0f be       	out	0x3f, r0	; 63
    357c:	cd bf       	out	0x3d, r28	; 61
    357e:	9a 83       	std	Y+2, r25	; 0x02
    3580:	89 83       	std	Y+1, r24	; 0x01
    3582:	7c 83       	std	Y+4, r23	; 0x04
    3584:	6b 83       	std	Y+3, r22	; 0x03
    3586:	4d 83       	std	Y+5, r20	; 0x05
    3588:	3f 83       	std	Y+7, r19	; 0x07
    358a:	2e 83       	std	Y+6, r18	; 0x06
    358c:	19 87       	std	Y+9, r17	; 0x09
    358e:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    3590:	89 81       	ldd	r24, Y+1	; 0x01
    3592:	9a 81       	ldd	r25, Y+2	; 0x02
    3594:	49 96       	adiw	r24, 0x19	; 25
    3596:	2b 81       	ldd	r18, Y+3	; 0x03
    3598:	3c 81       	ldd	r19, Y+4	; 0x04
    359a:	b9 01       	movw	r22, r18
    359c:	48 e0       	ldi	r20, 0x08	; 8
    359e:	50 e0       	ldi	r21, 0x00	; 0
    35a0:	0e 94 85 34 	call	0x690a	; 0x690a <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    35a4:	e9 81       	ldd	r30, Y+1	; 0x01
    35a6:	fa 81       	ldd	r31, Y+2	; 0x02
    35a8:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    35aa:	8d 81       	ldd	r24, Y+5	; 0x05
    35ac:	85 30       	cpi	r24, 0x05	; 5
    35ae:	10 f0       	brcs	.+4      	; 0x35b4 <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    35b0:	84 e0       	ldi	r24, 0x04	; 4
    35b2:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    35b4:	e9 81       	ldd	r30, Y+1	; 0x01
    35b6:	fa 81       	ldd	r31, Y+2	; 0x02
    35b8:	8d 81       	ldd	r24, Y+5	; 0x05
    35ba:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    35bc:	89 81       	ldd	r24, Y+1	; 0x01
    35be:	9a 81       	ldd	r25, Y+2	; 0x02
    35c0:	02 96       	adiw	r24, 0x02	; 2
    35c2:	0e 94 85 0a 	call	0x150a	; 0x150a <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    35c6:	89 81       	ldd	r24, Y+1	; 0x01
    35c8:	9a 81       	ldd	r25, Y+2	; 0x02
    35ca:	0c 96       	adiw	r24, 0x0c	; 12
    35cc:	0e 94 85 0a 	call	0x150a	; 0x150a <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    35d0:	e9 81       	ldd	r30, Y+1	; 0x01
    35d2:	fa 81       	ldd	r31, Y+2	; 0x02
    35d4:	89 81       	ldd	r24, Y+1	; 0x01
    35d6:	9a 81       	ldd	r25, Y+2	; 0x02
    35d8:	91 87       	std	Z+9, r25	; 0x09
    35da:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    35dc:	8d 81       	ldd	r24, Y+5	; 0x05
    35de:	28 2f       	mov	r18, r24
    35e0:	30 e0       	ldi	r19, 0x00	; 0
    35e2:	85 e0       	ldi	r24, 0x05	; 5
    35e4:	90 e0       	ldi	r25, 0x00	; 0
    35e6:	82 1b       	sub	r24, r18
    35e8:	93 0b       	sbc	r25, r19
    35ea:	e9 81       	ldd	r30, Y+1	; 0x01
    35ec:	fa 81       	ldd	r31, Y+2	; 0x02
    35ee:	95 87       	std	Z+13, r25	; 0x0d
    35f0:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    35f2:	e9 81       	ldd	r30, Y+1	; 0x01
    35f4:	fa 81       	ldd	r31, Y+2	; 0x02
    35f6:	89 81       	ldd	r24, Y+1	; 0x01
    35f8:	9a 81       	ldd	r25, Y+2	; 0x02
    35fa:	93 8b       	std	Z+19, r25	; 0x13
    35fc:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    35fe:	29 96       	adiw	r28, 0x09	; 9
    3600:	0f b6       	in	r0, 0x3f	; 63
    3602:	f8 94       	cli
    3604:	de bf       	out	0x3e, r29	; 62
    3606:	0f be       	out	0x3f, r0	; 63
    3608:	cd bf       	out	0x3d, r28	; 61
    360a:	cf 91       	pop	r28
    360c:	df 91       	pop	r29
    360e:	1f 91       	pop	r17
    3610:	0f 91       	pop	r16
    3612:	08 95       	ret

00003614 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    3614:	df 93       	push	r29
    3616:	cf 93       	push	r28
    3618:	0f 92       	push	r0
    361a:	cd b7       	in	r28, 0x3d	; 61
    361c:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    361e:	19 82       	std	Y+1, r1	; 0x01
    3620:	13 c0       	rjmp	.+38     	; 0x3648 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    3622:	89 81       	ldd	r24, Y+1	; 0x01
    3624:	28 2f       	mov	r18, r24
    3626:	30 e0       	ldi	r19, 0x00	; 0
    3628:	c9 01       	movw	r24, r18
    362a:	88 0f       	add	r24, r24
    362c:	99 1f       	adc	r25, r25
    362e:	88 0f       	add	r24, r24
    3630:	99 1f       	adc	r25, r25
    3632:	88 0f       	add	r24, r24
    3634:	99 1f       	adc	r25, r25
    3636:	82 0f       	add	r24, r18
    3638:	93 1f       	adc	r25, r19
    363a:	8b 54       	subi	r24, 0x4B	; 75
    363c:	99 4f       	sbci	r25, 0xF9	; 249
    363e:	0e 94 5b 0a 	call	0x14b6	; 0x14b6 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    3642:	89 81       	ldd	r24, Y+1	; 0x01
    3644:	8f 5f       	subi	r24, 0xFF	; 255
    3646:	89 83       	std	Y+1, r24	; 0x01
    3648:	89 81       	ldd	r24, Y+1	; 0x01
    364a:	85 30       	cpi	r24, 0x05	; 5
    364c:	50 f3       	brcs	.-44     	; 0x3622 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    364e:	82 ee       	ldi	r24, 0xE2	; 226
    3650:	96 e0       	ldi	r25, 0x06	; 6
    3652:	0e 94 5b 0a 	call	0x14b6	; 0x14b6 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    3656:	8b ee       	ldi	r24, 0xEB	; 235
    3658:	96 e0       	ldi	r25, 0x06	; 6
    365a:	0e 94 5b 0a 	call	0x14b6	; 0x14b6 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    365e:	88 ef       	ldi	r24, 0xF8	; 248
    3660:	96 e0       	ldi	r25, 0x06	; 6
    3662:	0e 94 5b 0a 	call	0x14b6	; 0x14b6 <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    3666:	81 e0       	ldi	r24, 0x01	; 1
    3668:	97 e0       	ldi	r25, 0x07	; 7
    366a:	0e 94 5b 0a 	call	0x14b6	; 0x14b6 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    366e:	82 ee       	ldi	r24, 0xE2	; 226
    3670:	96 e0       	ldi	r25, 0x06	; 6
    3672:	90 93 f5 06 	sts	0x06F5, r25
    3676:	80 93 f4 06 	sts	0x06F4, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    367a:	8b ee       	ldi	r24, 0xEB	; 235
    367c:	96 e0       	ldi	r25, 0x06	; 6
    367e:	90 93 f7 06 	sts	0x06F7, r25
    3682:	80 93 f6 06 	sts	0x06F6, r24
}
    3686:	0f 90       	pop	r0
    3688:	cf 91       	pop	r28
    368a:	df 91       	pop	r29
    368c:	08 95       	ret

0000368e <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    368e:	df 93       	push	r29
    3690:	cf 93       	push	r28
    3692:	cd b7       	in	r28, 0x3d	; 61
    3694:	de b7       	in	r29, 0x3e	; 62
				prvDeleteTCB( pxTCB );
			}
		}
	}
	#endif
}
    3696:	cf 91       	pop	r28
    3698:	df 91       	pop	r29
    369a:	08 95       	ret

0000369c <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    369c:	df 93       	push	r29
    369e:	cf 93       	push	r28
    36a0:	00 d0       	rcall	.+0      	; 0x36a2 <prvAddCurrentTaskToDelayedList+0x6>
    36a2:	cd b7       	in	r28, 0x3d	; 61
    36a4:	de b7       	in	r29, 0x3e	; 62
    36a6:	9a 83       	std	Y+2, r25	; 0x02
    36a8:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    36aa:	e0 91 a8 06 	lds	r30, 0x06A8
    36ae:	f0 91 a9 06 	lds	r31, 0x06A9
    36b2:	89 81       	ldd	r24, Y+1	; 0x01
    36b4:	9a 81       	ldd	r25, Y+2	; 0x02
    36b6:	93 83       	std	Z+3, r25	; 0x03
    36b8:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    36ba:	20 91 ab 06 	lds	r18, 0x06AB
    36be:	30 91 ac 06 	lds	r19, 0x06AC
    36c2:	89 81       	ldd	r24, Y+1	; 0x01
    36c4:	9a 81       	ldd	r25, Y+2	; 0x02
    36c6:	82 17       	cp	r24, r18
    36c8:	93 07       	cpc	r25, r19
    36ca:	70 f4       	brcc	.+28     	; 0x36e8 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    36cc:	80 91 f6 06 	lds	r24, 0x06F6
    36d0:	90 91 f7 06 	lds	r25, 0x06F7
    36d4:	20 91 a8 06 	lds	r18, 0x06A8
    36d8:	30 91 a9 06 	lds	r19, 0x06A9
    36dc:	2e 5f       	subi	r18, 0xFE	; 254
    36de:	3f 4f       	sbci	r19, 0xFF	; 255
    36e0:	b9 01       	movw	r22, r18
    36e2:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <vListInsert>
    36e6:	1e c0       	rjmp	.+60     	; 0x3724 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    36e8:	40 91 f4 06 	lds	r20, 0x06F4
    36ec:	50 91 f5 06 	lds	r21, 0x06F5
    36f0:	80 91 a8 06 	lds	r24, 0x06A8
    36f4:	90 91 a9 06 	lds	r25, 0x06A9
    36f8:	9c 01       	movw	r18, r24
    36fa:	2e 5f       	subi	r18, 0xFE	; 254
    36fc:	3f 4f       	sbci	r19, 0xFF	; 255
    36fe:	ca 01       	movw	r24, r20
    3700:	b9 01       	movw	r22, r18
    3702:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    3706:	20 91 9f 01 	lds	r18, 0x019F
    370a:	30 91 a0 01 	lds	r19, 0x01A0
    370e:	89 81       	ldd	r24, Y+1	; 0x01
    3710:	9a 81       	ldd	r25, Y+2	; 0x02
    3712:	82 17       	cp	r24, r18
    3714:	93 07       	cpc	r25, r19
    3716:	30 f4       	brcc	.+12     	; 0x3724 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    3718:	89 81       	ldd	r24, Y+1	; 0x01
    371a:	9a 81       	ldd	r25, Y+2	; 0x02
    371c:	90 93 a0 01 	sts	0x01A0, r25
    3720:	80 93 9f 01 	sts	0x019F, r24
		}
	}
}
    3724:	0f 90       	pop	r0
    3726:	0f 90       	pop	r0
    3728:	cf 91       	pop	r28
    372a:	df 91       	pop	r29
    372c:	08 95       	ret

0000372e <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    372e:	df 93       	push	r29
    3730:	cf 93       	push	r28
    3732:	cd b7       	in	r28, 0x3d	; 61
    3734:	de b7       	in	r29, 0x3e	; 62
    3736:	28 97       	sbiw	r28, 0x08	; 8
    3738:	0f b6       	in	r0, 0x3f	; 63
    373a:	f8 94       	cli
    373c:	de bf       	out	0x3e, r29	; 62
    373e:	0f be       	out	0x3f, r0	; 63
    3740:	cd bf       	out	0x3d, r28	; 61
    3742:	9c 83       	std	Y+4, r25	; 0x04
    3744:	8b 83       	std	Y+3, r24	; 0x03
    3746:	7e 83       	std	Y+6, r23	; 0x06
    3748:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    374a:	81 e2       	ldi	r24, 0x21	; 33
    374c:	90 e0       	ldi	r25, 0x00	; 0
    374e:	0e 94 ef 09 	call	0x13de	; 0x13de <pvPortMalloc>
    3752:	9a 83       	std	Y+2, r25	; 0x02
    3754:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    3756:	89 81       	ldd	r24, Y+1	; 0x01
    3758:	9a 81       	ldd	r25, Y+2	; 0x02
    375a:	00 97       	sbiw	r24, 0x00	; 0
    375c:	69 f1       	breq	.+90     	; 0x37b8 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    375e:	8d 81       	ldd	r24, Y+5	; 0x05
    3760:	9e 81       	ldd	r25, Y+6	; 0x06
    3762:	00 97       	sbiw	r24, 0x00	; 0
    3764:	39 f4       	brne	.+14     	; 0x3774 <prvAllocateTCBAndStack+0x46>
    3766:	8b 81       	ldd	r24, Y+3	; 0x03
    3768:	9c 81       	ldd	r25, Y+4	; 0x04
    376a:	0e 94 ef 09 	call	0x13de	; 0x13de <pvPortMalloc>
    376e:	98 87       	std	Y+8, r25	; 0x08
    3770:	8f 83       	std	Y+7, r24	; 0x07
    3772:	04 c0       	rjmp	.+8      	; 0x377c <prvAllocateTCBAndStack+0x4e>
    3774:	8d 81       	ldd	r24, Y+5	; 0x05
    3776:	9e 81       	ldd	r25, Y+6	; 0x06
    3778:	98 87       	std	Y+8, r25	; 0x08
    377a:	8f 83       	std	Y+7, r24	; 0x07
    377c:	e9 81       	ldd	r30, Y+1	; 0x01
    377e:	fa 81       	ldd	r31, Y+2	; 0x02
    3780:	8f 81       	ldd	r24, Y+7	; 0x07
    3782:	98 85       	ldd	r25, Y+8	; 0x08
    3784:	90 8f       	std	Z+24, r25	; 0x18
    3786:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    3788:	e9 81       	ldd	r30, Y+1	; 0x01
    378a:	fa 81       	ldd	r31, Y+2	; 0x02
    378c:	87 89       	ldd	r24, Z+23	; 0x17
    378e:	90 8d       	ldd	r25, Z+24	; 0x18
    3790:	00 97       	sbiw	r24, 0x00	; 0
    3792:	39 f4       	brne	.+14     	; 0x37a2 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    3794:	89 81       	ldd	r24, Y+1	; 0x01
    3796:	9a 81       	ldd	r25, Y+2	; 0x02
    3798:	0e 94 35 0a 	call	0x146a	; 0x146a <vPortFree>
			pxNewTCB = NULL;
    379c:	1a 82       	std	Y+2, r1	; 0x02
    379e:	19 82       	std	Y+1, r1	; 0x01
    37a0:	0b c0       	rjmp	.+22     	; 0x37b8 <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    37a2:	e9 81       	ldd	r30, Y+1	; 0x01
    37a4:	fa 81       	ldd	r31, Y+2	; 0x02
    37a6:	87 89       	ldd	r24, Z+23	; 0x17
    37a8:	90 8d       	ldd	r25, Z+24	; 0x18
    37aa:	2b 81       	ldd	r18, Y+3	; 0x03
    37ac:	3c 81       	ldd	r19, Y+4	; 0x04
    37ae:	65 ea       	ldi	r22, 0xA5	; 165
    37b0:	70 e0       	ldi	r23, 0x00	; 0
    37b2:	a9 01       	movw	r20, r18
    37b4:	0e 94 7e 34 	call	0x68fc	; 0x68fc <memset>
		}
	}

	return pxNewTCB;
    37b8:	89 81       	ldd	r24, Y+1	; 0x01
    37ba:	9a 81       	ldd	r25, Y+2	; 0x02
}
    37bc:	28 96       	adiw	r28, 0x08	; 8
    37be:	0f b6       	in	r0, 0x3f	; 63
    37c0:	f8 94       	cli
    37c2:	de bf       	out	0x3e, r29	; 62
    37c4:	0f be       	out	0x3f, r0	; 63
    37c6:	cd bf       	out	0x3d, r28	; 61
    37c8:	cf 91       	pop	r28
    37ca:	df 91       	pop	r29
    37cc:	08 95       	ret

000037ce <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

	portBASE_TYPE xTaskGetSchedulerState( void )
	{
    37ce:	df 93       	push	r29
    37d0:	cf 93       	push	r28
    37d2:	0f 92       	push	r0
    37d4:	cd b7       	in	r28, 0x3d	; 61
    37d6:	de b7       	in	r29, 0x3e	; 62
	portBASE_TYPE xReturn;

		if( xSchedulerRunning == pdFALSE )
    37d8:	80 91 af 06 	lds	r24, 0x06AF
    37dc:	88 23       	and	r24, r24
    37de:	11 f4       	brne	.+4      	; 0x37e4 <xTaskGetSchedulerState+0x16>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    37e0:	19 82       	std	Y+1, r1	; 0x01
    37e2:	09 c0       	rjmp	.+18     	; 0x37f6 <xTaskGetSchedulerState+0x28>
		}
		else
		{
			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    37e4:	80 91 b0 06 	lds	r24, 0x06B0
    37e8:	88 23       	and	r24, r24
    37ea:	19 f4       	brne	.+6      	; 0x37f2 <xTaskGetSchedulerState+0x24>
			{
				xReturn = taskSCHEDULER_RUNNING;
    37ec:	81 e0       	ldi	r24, 0x01	; 1
    37ee:	89 83       	std	Y+1, r24	; 0x01
    37f0:	02 c0       	rjmp	.+4      	; 0x37f6 <xTaskGetSchedulerState+0x28>
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    37f2:	82 e0       	ldi	r24, 0x02	; 2
    37f4:	89 83       	std	Y+1, r24	; 0x01
			}
		}

		return xReturn;
    37f6:	89 81       	ldd	r24, Y+1	; 0x01
	}
    37f8:	0f 90       	pop	r0
    37fa:	cf 91       	pop	r28
    37fc:	df 91       	pop	r29
    37fe:	08 95       	ret

00003800 <xTimerCreateTimerTask>:
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty ) PRIVILEGED_FUNCTION;

/*-----------------------------------------------------------*/

portBASE_TYPE xTimerCreateTimerTask( void )
{
    3800:	af 92       	push	r10
    3802:	bf 92       	push	r11
    3804:	cf 92       	push	r12
    3806:	df 92       	push	r13
    3808:	ef 92       	push	r14
    380a:	ff 92       	push	r15
    380c:	0f 93       	push	r16
    380e:	df 93       	push	r29
    3810:	cf 93       	push	r28
    3812:	0f 92       	push	r0
    3814:	cd b7       	in	r28, 0x3d	; 61
    3816:	de b7       	in	r29, 0x3e	; 62
portBASE_TYPE xReturn = pdFAIL;
    3818:	19 82       	std	Y+1, r1	; 0x01

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
    381a:	0e 94 cb 1f 	call	0x3f96	; 0x3f96 <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
    381e:	80 91 0a 07 	lds	r24, 0x070A
    3822:	90 91 0b 07 	lds	r25, 0x070B
    3826:	00 97       	sbiw	r24, 0x00	; 0
    3828:	99 f0       	breq	.+38     	; 0x3850 <xTimerCreateTimerTask+0x50>
			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY, &xTimerTaskHandle );
		}
		#else
		{
			/* Create the timer task without storing its handle. */
			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY, NULL);
    382a:	25 e6       	ldi	r18, 0x65	; 101
    382c:	30 e0       	ldi	r19, 0x00	; 0
    382e:	8c e4       	ldi	r24, 0x4C	; 76
    3830:	9d e1       	ldi	r25, 0x1D	; 29
    3832:	b9 01       	movw	r22, r18
    3834:	45 e5       	ldi	r20, 0x55	; 85
    3836:	50 e0       	ldi	r21, 0x00	; 0
    3838:	20 e0       	ldi	r18, 0x00	; 0
    383a:	30 e0       	ldi	r19, 0x00	; 0
    383c:	04 e0       	ldi	r16, 0x04	; 4
    383e:	ee 24       	eor	r14, r14
    3840:	ff 24       	eor	r15, r15
    3842:	cc 24       	eor	r12, r12
    3844:	dd 24       	eor	r13, r13
    3846:	aa 24       	eor	r10, r10
    3848:	bb 24       	eor	r11, r11
    384a:	0e 94 47 13 	call	0x268e	; 0x268e <xTaskGenericCreate>
    384e:	89 83       	std	Y+1, r24	; 0x01
		}
		#endif
	}

	configASSERT( xReturn );
	return xReturn;
    3850:	89 81       	ldd	r24, Y+1	; 0x01
}
    3852:	0f 90       	pop	r0
    3854:	cf 91       	pop	r28
    3856:	df 91       	pop	r29
    3858:	0f 91       	pop	r16
    385a:	ff 90       	pop	r15
    385c:	ef 90       	pop	r14
    385e:	df 90       	pop	r13
    3860:	cf 90       	pop	r12
    3862:	bf 90       	pop	r11
    3864:	af 90       	pop	r10
    3866:	08 95       	ret

00003868 <xTimerCreate>:
/*-----------------------------------------------------------*/

xTimerHandle xTimerCreate( const signed char *pcTimerName, portTickType xTimerPeriodInTicks, unsigned portBASE_TYPE uxAutoReload, void *pvTimerID, tmrTIMER_CALLBACK pxCallbackFunction )
{
    3868:	0f 93       	push	r16
    386a:	1f 93       	push	r17
    386c:	df 93       	push	r29
    386e:	cf 93       	push	r28
    3870:	cd b7       	in	r28, 0x3d	; 61
    3872:	de b7       	in	r29, 0x3e	; 62
    3874:	2b 97       	sbiw	r28, 0x0b	; 11
    3876:	0f b6       	in	r0, 0x3f	; 63
    3878:	f8 94       	cli
    387a:	de bf       	out	0x3e, r29	; 62
    387c:	0f be       	out	0x3f, r0	; 63
    387e:	cd bf       	out	0x3d, r28	; 61
    3880:	9c 83       	std	Y+4, r25	; 0x04
    3882:	8b 83       	std	Y+3, r24	; 0x03
    3884:	7e 83       	std	Y+6, r23	; 0x06
    3886:	6d 83       	std	Y+5, r22	; 0x05
    3888:	4f 83       	std	Y+7, r20	; 0x07
    388a:	39 87       	std	Y+9, r19	; 0x09
    388c:	28 87       	std	Y+8, r18	; 0x08
    388e:	1b 87       	std	Y+11, r17	; 0x0b
    3890:	0a 87       	std	Y+10, r16	; 0x0a
xTIMER *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( portTickType ) 0U )
    3892:	8d 81       	ldd	r24, Y+5	; 0x05
    3894:	9e 81       	ldd	r25, Y+6	; 0x06
    3896:	00 97       	sbiw	r24, 0x00	; 0
    3898:	19 f4       	brne	.+6      	; 0x38a0 <xTimerCreate+0x38>
	{
		pxNewTimer = NULL;
    389a:	1a 82       	std	Y+2, r1	; 0x02
    389c:	19 82       	std	Y+1, r1	; 0x01
    389e:	2d c0       	rjmp	.+90     	; 0x38fa <xTimerCreate+0x92>
		configASSERT( ( xTimerPeriodInTicks > 0 ) );
	}
	else
	{
		pxNewTimer = ( xTIMER * ) pvPortMalloc( sizeof( xTIMER ) );
    38a0:	83 e1       	ldi	r24, 0x13	; 19
    38a2:	90 e0       	ldi	r25, 0x00	; 0
    38a4:	0e 94 ef 09 	call	0x13de	; 0x13de <pvPortMalloc>
    38a8:	9a 83       	std	Y+2, r25	; 0x02
    38aa:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewTimer != NULL )
    38ac:	89 81       	ldd	r24, Y+1	; 0x01
    38ae:	9a 81       	ldd	r25, Y+2	; 0x02
    38b0:	00 97       	sbiw	r24, 0x00	; 0
    38b2:	19 f1       	breq	.+70     	; 0x38fa <xTimerCreate+0x92>
		{
			/* Ensure the infrastructure used by the timer service task has been
			created/initialised. */
			prvCheckForValidListAndQueue();
    38b4:	0e 94 cb 1f 	call	0x3f96	; 0x3f96 <prvCheckForValidListAndQueue>

			/* Initialise the timer structure members using the function parameters. */
			pxNewTimer->pcTimerName = pcTimerName;
    38b8:	e9 81       	ldd	r30, Y+1	; 0x01
    38ba:	fa 81       	ldd	r31, Y+2	; 0x02
    38bc:	8b 81       	ldd	r24, Y+3	; 0x03
    38be:	9c 81       	ldd	r25, Y+4	; 0x04
    38c0:	91 83       	std	Z+1, r25	; 0x01
    38c2:	80 83       	st	Z, r24
			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    38c4:	e9 81       	ldd	r30, Y+1	; 0x01
    38c6:	fa 81       	ldd	r31, Y+2	; 0x02
    38c8:	8d 81       	ldd	r24, Y+5	; 0x05
    38ca:	9e 81       	ldd	r25, Y+6	; 0x06
    38cc:	95 87       	std	Z+13, r25	; 0x0d
    38ce:	84 87       	std	Z+12, r24	; 0x0c
			pxNewTimer->uxAutoReload = uxAutoReload;
    38d0:	e9 81       	ldd	r30, Y+1	; 0x01
    38d2:	fa 81       	ldd	r31, Y+2	; 0x02
    38d4:	8f 81       	ldd	r24, Y+7	; 0x07
    38d6:	86 87       	std	Z+14, r24	; 0x0e
			pxNewTimer->pvTimerID = pvTimerID;
    38d8:	e9 81       	ldd	r30, Y+1	; 0x01
    38da:	fa 81       	ldd	r31, Y+2	; 0x02
    38dc:	88 85       	ldd	r24, Y+8	; 0x08
    38de:	99 85       	ldd	r25, Y+9	; 0x09
    38e0:	90 8b       	std	Z+16, r25	; 0x10
    38e2:	87 87       	std	Z+15, r24	; 0x0f
			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    38e4:	e9 81       	ldd	r30, Y+1	; 0x01
    38e6:	fa 81       	ldd	r31, Y+2	; 0x02
    38e8:	8a 85       	ldd	r24, Y+10	; 0x0a
    38ea:	9b 85       	ldd	r25, Y+11	; 0x0b
    38ec:	92 8b       	std	Z+18, r25	; 0x12
    38ee:	81 8b       	std	Z+17, r24	; 0x11
			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    38f0:	89 81       	ldd	r24, Y+1	; 0x01
    38f2:	9a 81       	ldd	r25, Y+2	; 0x02
    38f4:	02 96       	adiw	r24, 0x02	; 2
    38f6:	0e 94 85 0a 	call	0x150a	; 0x150a <vListInitialiseItem>
		{
			traceTIMER_CREATE_FAILED();
		}
	}

	return ( xTimerHandle ) pxNewTimer;
    38fa:	89 81       	ldd	r24, Y+1	; 0x01
    38fc:	9a 81       	ldd	r25, Y+2	; 0x02
}
    38fe:	2b 96       	adiw	r28, 0x0b	; 11
    3900:	0f b6       	in	r0, 0x3f	; 63
    3902:	f8 94       	cli
    3904:	de bf       	out	0x3e, r29	; 62
    3906:	0f be       	out	0x3f, r0	; 63
    3908:	cd bf       	out	0x3d, r28	; 61
    390a:	cf 91       	pop	r28
    390c:	df 91       	pop	r29
    390e:	1f 91       	pop	r17
    3910:	0f 91       	pop	r16
    3912:	08 95       	ret

00003914 <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
    3914:	0f 93       	push	r16
    3916:	1f 93       	push	r17
    3918:	df 93       	push	r29
    391a:	cf 93       	push	r28
    391c:	cd b7       	in	r28, 0x3d	; 61
    391e:	de b7       	in	r29, 0x3e	; 62
    3920:	2f 97       	sbiw	r28, 0x0f	; 15
    3922:	0f b6       	in	r0, 0x3f	; 63
    3924:	f8 94       	cli
    3926:	de bf       	out	0x3e, r29	; 62
    3928:	0f be       	out	0x3f, r0	; 63
    392a:	cd bf       	out	0x3d, r28	; 61
    392c:	98 87       	std	Y+8, r25	; 0x08
    392e:	8f 83       	std	Y+7, r24	; 0x07
    3930:	69 87       	std	Y+9, r22	; 0x09
    3932:	5b 87       	std	Y+11, r21	; 0x0b
    3934:	4a 87       	std	Y+10, r20	; 0x0a
    3936:	3d 87       	std	Y+13, r19	; 0x0d
    3938:	2c 87       	std	Y+12, r18	; 0x0c
    393a:	1f 87       	std	Y+15, r17	; 0x0f
    393c:	0e 87       	std	Y+14, r16	; 0x0e
portBASE_TYPE xReturn = pdFAIL;
    393e:	19 82       	std	Y+1, r1	; 0x01
xTIMER_MESSAGE xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    3940:	80 91 0a 07 	lds	r24, 0x070A
    3944:	90 91 0b 07 	lds	r25, 0x070B
    3948:	00 97       	sbiw	r24, 0x00	; 0
    394a:	09 f4       	brne	.+2      	; 0x394e <xTimerGenericCommand+0x3a>
    394c:	3e c0       	rjmp	.+124    	; 0x39ca <xTimerGenericCommand+0xb6>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    394e:	89 85       	ldd	r24, Y+9	; 0x09
    3950:	8a 83       	std	Y+2, r24	; 0x02
		xMessage.xMessageValue = xOptionalValue;
    3952:	8a 85       	ldd	r24, Y+10	; 0x0a
    3954:	9b 85       	ldd	r25, Y+11	; 0x0b
    3956:	9c 83       	std	Y+4, r25	; 0x04
    3958:	8b 83       	std	Y+3, r24	; 0x03
		xMessage.pxTimer = ( xTIMER * ) xTimer;
    395a:	8f 81       	ldd	r24, Y+7	; 0x07
    395c:	98 85       	ldd	r25, Y+8	; 0x08
    395e:	9e 83       	std	Y+6, r25	; 0x06
    3960:	8d 83       	std	Y+5, r24	; 0x05

		if( pxHigherPriorityTaskWoken == NULL )
    3962:	8c 85       	ldd	r24, Y+12	; 0x0c
    3964:	9d 85       	ldd	r25, Y+13	; 0x0d
    3966:	00 97       	sbiw	r24, 0x00	; 0
    3968:	11 f5       	brne	.+68     	; 0x39ae <xTimerGenericCommand+0x9a>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    396a:	0e 94 e7 1b 	call	0x37ce	; 0x37ce <xTaskGetSchedulerState>
    396e:	81 30       	cpi	r24, 0x01	; 1
    3970:	79 f4       	brne	.+30     	; 0x3990 <xTimerGenericCommand+0x7c>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xBlockTime );
    3972:	80 91 0a 07 	lds	r24, 0x070A
    3976:	90 91 0b 07 	lds	r25, 0x070B
    397a:	9e 01       	movw	r18, r28
    397c:	2e 5f       	subi	r18, 0xFE	; 254
    397e:	3f 4f       	sbci	r19, 0xFF	; 255
    3980:	4e 85       	ldd	r20, Y+14	; 0x0e
    3982:	5f 85       	ldd	r21, Y+15	; 0x0f
    3984:	b9 01       	movw	r22, r18
    3986:	20 e0       	ldi	r18, 0x00	; 0
    3988:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <xQueueGenericSend>
    398c:	89 83       	std	Y+1, r24	; 0x01
    398e:	1d c0       	rjmp	.+58     	; 0x39ca <xTimerGenericCommand+0xb6>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    3990:	80 91 0a 07 	lds	r24, 0x070A
    3994:	90 91 0b 07 	lds	r25, 0x070B
    3998:	9e 01       	movw	r18, r28
    399a:	2e 5f       	subi	r18, 0xFE	; 254
    399c:	3f 4f       	sbci	r19, 0xFF	; 255
    399e:	b9 01       	movw	r22, r18
    39a0:	40 e0       	ldi	r20, 0x00	; 0
    39a2:	50 e0       	ldi	r21, 0x00	; 0
    39a4:	20 e0       	ldi	r18, 0x00	; 0
    39a6:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <xQueueGenericSend>
    39aa:	89 83       	std	Y+1, r24	; 0x01
    39ac:	0e c0       	rjmp	.+28     	; 0x39ca <xTimerGenericCommand+0xb6>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    39ae:	80 91 0a 07 	lds	r24, 0x070A
    39b2:	90 91 0b 07 	lds	r25, 0x070B
    39b6:	4c 85       	ldd	r20, Y+12	; 0x0c
    39b8:	5d 85       	ldd	r21, Y+13	; 0x0d
    39ba:	9e 01       	movw	r18, r28
    39bc:	2e 5f       	subi	r18, 0xFE	; 254
    39be:	3f 4f       	sbci	r19, 0xFF	; 255
    39c0:	b9 01       	movw	r22, r18
    39c2:	20 e0       	ldi	r18, 0x00	; 0
    39c4:	0e 94 d6 0f 	call	0x1fac	; 0x1fac <xQueueGenericSendFromISR>
    39c8:	89 83       	std	Y+1, r24	; 0x01
		}

		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
	}

	return xReturn;
    39ca:	89 81       	ldd	r24, Y+1	; 0x01
}
    39cc:	2f 96       	adiw	r28, 0x0f	; 15
    39ce:	0f b6       	in	r0, 0x3f	; 63
    39d0:	f8 94       	cli
    39d2:	de bf       	out	0x3e, r29	; 62
    39d4:	0f be       	out	0x3f, r0	; 63
    39d6:	cd bf       	out	0x3d, r28	; 61
    39d8:	cf 91       	pop	r28
    39da:	df 91       	pop	r29
    39dc:	1f 91       	pop	r17
    39de:	0f 91       	pop	r16
    39e0:	08 95       	ret

000039e2 <prvProcessExpiredTimer>:

#endif
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( portTickType xNextExpireTime, portTickType xTimeNow )
{
    39e2:	0f 93       	push	r16
    39e4:	1f 93       	push	r17
    39e6:	df 93       	push	r29
    39e8:	cf 93       	push	r28
    39ea:	cd b7       	in	r28, 0x3d	; 61
    39ec:	de b7       	in	r29, 0x3e	; 62
    39ee:	27 97       	sbiw	r28, 0x07	; 7
    39f0:	0f b6       	in	r0, 0x3f	; 63
    39f2:	f8 94       	cli
    39f4:	de bf       	out	0x3e, r29	; 62
    39f6:	0f be       	out	0x3f, r0	; 63
    39f8:	cd bf       	out	0x3d, r28	; 61
    39fa:	9d 83       	std	Y+5, r25	; 0x05
    39fc:	8c 83       	std	Y+4, r24	; 0x04
    39fe:	7f 83       	std	Y+7, r23	; 0x07
    3a00:	6e 83       	std	Y+6, r22	; 0x06
xTIMER *pxTimer;
portBASE_TYPE xResult;

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    3a02:	e0 91 20 07 	lds	r30, 0x0720
    3a06:	f0 91 21 07 	lds	r31, 0x0721
    3a0a:	05 80       	ldd	r0, Z+5	; 0x05
    3a0c:	f6 81       	ldd	r31, Z+6	; 0x06
    3a0e:	e0 2d       	mov	r30, r0
    3a10:	86 81       	ldd	r24, Z+6	; 0x06
    3a12:	97 81       	ldd	r25, Z+7	; 0x07
    3a14:	9b 83       	std	Y+3, r25	; 0x03
    3a16:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxTimer->xTimerListItem ) );
    3a18:	8a 81       	ldd	r24, Y+2	; 0x02
    3a1a:	9b 81       	ldd	r25, Y+3	; 0x03
    3a1c:	02 96       	adiw	r24, 0x02	; 2
    3a1e:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
    3a22:	ea 81       	ldd	r30, Y+2	; 0x02
    3a24:	fb 81       	ldd	r31, Y+3	; 0x03
    3a26:	86 85       	ldd	r24, Z+14	; 0x0e
    3a28:	81 30       	cpi	r24, 0x01	; 1
    3a2a:	19 f5       	brne	.+70     	; 0x3a72 <prvProcessExpiredTimer+0x90>
		a time relative to anything other than the current time.  It
		will therefore be inserted into the correct list relative to
		the time this task thinks it is now, even if a command to
		switch lists due to a tick count overflow is already waiting in
		the timer queue. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
    3a2c:	ea 81       	ldd	r30, Y+2	; 0x02
    3a2e:	fb 81       	ldd	r31, Y+3	; 0x03
    3a30:	24 85       	ldd	r18, Z+12	; 0x0c
    3a32:	35 85       	ldd	r19, Z+13	; 0x0d
    3a34:	8c 81       	ldd	r24, Y+4	; 0x04
    3a36:	9d 81       	ldd	r25, Y+5	; 0x05
    3a38:	a9 01       	movw	r20, r18
    3a3a:	48 0f       	add	r20, r24
    3a3c:	59 1f       	adc	r21, r25
    3a3e:	8a 81       	ldd	r24, Y+2	; 0x02
    3a40:	9b 81       	ldd	r25, Y+3	; 0x03
    3a42:	2e 81       	ldd	r18, Y+6	; 0x06
    3a44:	3f 81       	ldd	r19, Y+7	; 0x07
    3a46:	ec 81       	ldd	r30, Y+4	; 0x04
    3a48:	fd 81       	ldd	r31, Y+5	; 0x05
    3a4a:	ba 01       	movw	r22, r20
    3a4c:	a9 01       	movw	r20, r18
    3a4e:	9f 01       	movw	r18, r30
    3a50:	0e 94 13 1e 	call	0x3c26	; 0x3c26 <prvInsertTimerInActiveList>
    3a54:	81 30       	cpi	r24, 0x01	; 1
    3a56:	69 f4       	brne	.+26     	; 0x3a72 <prvProcessExpiredTimer+0x90>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
    3a58:	8a 81       	ldd	r24, Y+2	; 0x02
    3a5a:	9b 81       	ldd	r25, Y+3	; 0x03
    3a5c:	2c 81       	ldd	r18, Y+4	; 0x04
    3a5e:	3d 81       	ldd	r19, Y+5	; 0x05
    3a60:	60 e0       	ldi	r22, 0x00	; 0
    3a62:	a9 01       	movw	r20, r18
    3a64:	20 e0       	ldi	r18, 0x00	; 0
    3a66:	30 e0       	ldi	r19, 0x00	; 0
    3a68:	00 e0       	ldi	r16, 0x00	; 0
    3a6a:	10 e0       	ldi	r17, 0x00	; 0
    3a6c:	0e 94 8a 1c 	call	0x3914	; 0x3914 <xTimerGenericCommand>
    3a70:	89 83       	std	Y+1, r24	; 0x01
			( void ) xResult;
		}
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
    3a72:	ea 81       	ldd	r30, Y+2	; 0x02
    3a74:	fb 81       	ldd	r31, Y+3	; 0x03
    3a76:	01 88       	ldd	r0, Z+17	; 0x11
    3a78:	f2 89       	ldd	r31, Z+18	; 0x12
    3a7a:	e0 2d       	mov	r30, r0
    3a7c:	8a 81       	ldd	r24, Y+2	; 0x02
    3a7e:	9b 81       	ldd	r25, Y+3	; 0x03
    3a80:	09 95       	icall
}
    3a82:	27 96       	adiw	r28, 0x07	; 7
    3a84:	0f b6       	in	r0, 0x3f	; 63
    3a86:	f8 94       	cli
    3a88:	de bf       	out	0x3e, r29	; 62
    3a8a:	0f be       	out	0x3f, r0	; 63
    3a8c:	cd bf       	out	0x3d, r28	; 61
    3a8e:	cf 91       	pop	r28
    3a90:	df 91       	pop	r29
    3a92:	1f 91       	pop	r17
    3a94:	0f 91       	pop	r16
    3a96:	08 95       	ret

00003a98 <prvTimerTask>:
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    3a98:	df 93       	push	r29
    3a9a:	cf 93       	push	r28
    3a9c:	00 d0       	rcall	.+0      	; 0x3a9e <prvTimerTask+0x6>
    3a9e:	00 d0       	rcall	.+0      	; 0x3aa0 <prvTimerTask+0x8>
    3aa0:	0f 92       	push	r0
    3aa2:	cd b7       	in	r28, 0x3d	; 61
    3aa4:	de b7       	in	r29, 0x3e	; 62
    3aa6:	9d 83       	std	Y+5, r25	; 0x05
    3aa8:	8c 83       	std	Y+4, r24	; 0x04

	for( ;; )
	{
		/* Query the timers list to see if it contains any timers, and if so,
		obtain the time at which the next timer will expire. */
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
    3aaa:	ce 01       	movw	r24, r28
    3aac:	03 96       	adiw	r24, 0x03	; 3
    3aae:	0e 94 ad 1d 	call	0x3b5a	; 0x3b5a <prvGetNextExpireTime>
    3ab2:	9a 83       	std	Y+2, r25	; 0x02
    3ab4:	89 83       	std	Y+1, r24	; 0x01

		/* If a timer has expired, process it.  Otherwise, block this task
		until either a timer does expire, or a command is received. */
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
    3ab6:	2b 81       	ldd	r18, Y+3	; 0x03
    3ab8:	89 81       	ldd	r24, Y+1	; 0x01
    3aba:	9a 81       	ldd	r25, Y+2	; 0x02
    3abc:	62 2f       	mov	r22, r18
    3abe:	0e 94 64 1d 	call	0x3ac8	; 0x3ac8 <prvProcessTimerOrBlockTask>

		/* Empty the command queue. */
		prvProcessReceivedCommands();
    3ac2:	0e 94 7b 1e 	call	0x3cf6	; 0x3cf6 <prvProcessReceivedCommands>
    3ac6:	f1 cf       	rjmp	.-30     	; 0x3aaa <prvTimerTask+0x12>

00003ac8 <prvProcessTimerOrBlockTask>:
	}
}
/*-----------------------------------------------------------*/

static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
{
    3ac8:	df 93       	push	r29
    3aca:	cf 93       	push	r28
    3acc:	00 d0       	rcall	.+0      	; 0x3ace <prvProcessTimerOrBlockTask+0x6>
    3ace:	00 d0       	rcall	.+0      	; 0x3ad0 <prvProcessTimerOrBlockTask+0x8>
    3ad0:	00 d0       	rcall	.+0      	; 0x3ad2 <prvProcessTimerOrBlockTask+0xa>
    3ad2:	cd b7       	in	r28, 0x3d	; 61
    3ad4:	de b7       	in	r29, 0x3e	; 62
    3ad6:	9d 83       	std	Y+5, r25	; 0x05
    3ad8:	8c 83       	std	Y+4, r24	; 0x04
    3ada:	6e 83       	std	Y+6, r22	; 0x06
portTickType xTimeNow;
portBASE_TYPE xTimerListsWereSwitched;

	vTaskSuspendAll();
    3adc:	0e 94 32 17 	call	0x2e64	; 0x2e64 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampelTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3ae0:	ce 01       	movw	r24, r28
    3ae2:	03 96       	adiw	r24, 0x03	; 3
    3ae4:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <prvSampleTimeNow>
    3ae8:	9a 83       	std	Y+2, r25	; 0x02
    3aea:	89 83       	std	Y+1, r24	; 0x01
		if( xTimerListsWereSwitched == pdFALSE )
    3aec:	8b 81       	ldd	r24, Y+3	; 0x03
    3aee:	88 23       	and	r24, r24
    3af0:	49 f5       	brne	.+82     	; 0x3b44 <prvProcessTimerOrBlockTask+0x7c>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    3af2:	8e 81       	ldd	r24, Y+6	; 0x06
    3af4:	88 23       	and	r24, r24
    3af6:	89 f4       	brne	.+34     	; 0x3b1a <prvProcessTimerOrBlockTask+0x52>
    3af8:	2c 81       	ldd	r18, Y+4	; 0x04
    3afa:	3d 81       	ldd	r19, Y+5	; 0x05
    3afc:	89 81       	ldd	r24, Y+1	; 0x01
    3afe:	9a 81       	ldd	r25, Y+2	; 0x02
    3b00:	82 17       	cp	r24, r18
    3b02:	93 07       	cpc	r25, r19
    3b04:	50 f0       	brcs	.+20     	; 0x3b1a <prvProcessTimerOrBlockTask+0x52>
			{
				xTaskResumeAll();
    3b06:	0e 94 3e 17 	call	0x2e7c	; 0x2e7c <xTaskResumeAll>
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
    3b0a:	8c 81       	ldd	r24, Y+4	; 0x04
    3b0c:	9d 81       	ldd	r25, Y+5	; 0x05
    3b0e:	29 81       	ldd	r18, Y+1	; 0x01
    3b10:	3a 81       	ldd	r19, Y+2	; 0x02
    3b12:	b9 01       	movw	r22, r18
    3b14:	0e 94 f1 1c 	call	0x39e2	; 0x39e2 <prvProcessExpiredTimer>
    3b18:	17 c0       	rjmp	.+46     	; 0x3b48 <prvProcessTimerOrBlockTask+0x80>
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
    3b1a:	40 91 0a 07 	lds	r20, 0x070A
    3b1e:	50 91 0b 07 	lds	r21, 0x070B
    3b22:	2c 81       	ldd	r18, Y+4	; 0x04
    3b24:	3d 81       	ldd	r19, Y+5	; 0x05
    3b26:	89 81       	ldd	r24, Y+1	; 0x01
    3b28:	9a 81       	ldd	r25, Y+2	; 0x02
    3b2a:	28 1b       	sub	r18, r24
    3b2c:	39 0b       	sbc	r19, r25
    3b2e:	ca 01       	movw	r24, r20
    3b30:	b9 01       	movw	r22, r18
    3b32:	0e 94 10 13 	call	0x2620	; 0x2620 <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
    3b36:	0e 94 3e 17 	call	0x2e7c	; 0x2e7c <xTaskResumeAll>
    3b3a:	88 23       	and	r24, r24
    3b3c:	29 f4       	brne	.+10     	; 0x3b48 <prvProcessTimerOrBlockTask+0x80>
				{
					/* Yield to wait for either a command to arrive, or the block time
					to expire.  If a command arrived between the critical section being
					exited and this yield then the yield will not cause the task
					to block. */
					portYIELD_WITHIN_API();
    3b3e:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <vPortYield>
    3b42:	02 c0       	rjmp	.+4      	; 0x3b48 <prvProcessTimerOrBlockTask+0x80>
				}
			}
		}
		else
		{
			xTaskResumeAll();
    3b44:	0e 94 3e 17 	call	0x2e7c	; 0x2e7c <xTaskResumeAll>
		}
	}
}
    3b48:	26 96       	adiw	r28, 0x06	; 6
    3b4a:	0f b6       	in	r0, 0x3f	; 63
    3b4c:	f8 94       	cli
    3b4e:	de bf       	out	0x3e, r29	; 62
    3b50:	0f be       	out	0x3f, r0	; 63
    3b52:	cd bf       	out	0x3d, r28	; 61
    3b54:	cf 91       	pop	r28
    3b56:	df 91       	pop	r29
    3b58:	08 95       	ret

00003b5a <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

static portTickType prvGetNextExpireTime( portBASE_TYPE *pxListWasEmpty )
{
    3b5a:	df 93       	push	r29
    3b5c:	cf 93       	push	r28
    3b5e:	00 d0       	rcall	.+0      	; 0x3b60 <prvGetNextExpireTime+0x6>
    3b60:	00 d0       	rcall	.+0      	; 0x3b62 <prvGetNextExpireTime+0x8>
    3b62:	0f 92       	push	r0
    3b64:	cd b7       	in	r28, 0x3d	; 61
    3b66:	de b7       	in	r29, 0x3e	; 62
    3b68:	9c 83       	std	Y+4, r25	; 0x04
    3b6a:	8b 83       	std	Y+3, r24	; 0x03
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    3b6c:	e0 91 20 07 	lds	r30, 0x0720
    3b70:	f0 91 21 07 	lds	r31, 0x0721
    3b74:	80 81       	ld	r24, Z
    3b76:	1d 82       	std	Y+5, r1	; 0x05
    3b78:	88 23       	and	r24, r24
    3b7a:	11 f4       	brne	.+4      	; 0x3b80 <prvGetNextExpireTime+0x26>
    3b7c:	81 e0       	ldi	r24, 0x01	; 1
    3b7e:	8d 83       	std	Y+5, r24	; 0x05
    3b80:	eb 81       	ldd	r30, Y+3	; 0x03
    3b82:	fc 81       	ldd	r31, Y+4	; 0x04
    3b84:	8d 81       	ldd	r24, Y+5	; 0x05
    3b86:	80 83       	st	Z, r24
	if( *pxListWasEmpty == pdFALSE )
    3b88:	eb 81       	ldd	r30, Y+3	; 0x03
    3b8a:	fc 81       	ldd	r31, Y+4	; 0x04
    3b8c:	80 81       	ld	r24, Z
    3b8e:	88 23       	and	r24, r24
    3b90:	61 f4       	brne	.+24     	; 0x3baa <prvGetNextExpireTime+0x50>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    3b92:	e0 91 20 07 	lds	r30, 0x0720
    3b96:	f0 91 21 07 	lds	r31, 0x0721
    3b9a:	05 80       	ldd	r0, Z+5	; 0x05
    3b9c:	f6 81       	ldd	r31, Z+6	; 0x06
    3b9e:	e0 2d       	mov	r30, r0
    3ba0:	80 81       	ld	r24, Z
    3ba2:	91 81       	ldd	r25, Z+1	; 0x01
    3ba4:	9a 83       	std	Y+2, r25	; 0x02
    3ba6:	89 83       	std	Y+1, r24	; 0x01
    3ba8:	02 c0       	rjmp	.+4      	; 0x3bae <prvGetNextExpireTime+0x54>
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( portTickType ) 0U;
    3baa:	1a 82       	std	Y+2, r1	; 0x02
    3bac:	19 82       	std	Y+1, r1	; 0x01
	}

	return xNextExpireTime;
    3bae:	89 81       	ldd	r24, Y+1	; 0x01
    3bb0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3bb2:	0f 90       	pop	r0
    3bb4:	0f 90       	pop	r0
    3bb6:	0f 90       	pop	r0
    3bb8:	0f 90       	pop	r0
    3bba:	0f 90       	pop	r0
    3bbc:	cf 91       	pop	r28
    3bbe:	df 91       	pop	r29
    3bc0:	08 95       	ret

00003bc2 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
    3bc2:	df 93       	push	r29
    3bc4:	cf 93       	push	r28
    3bc6:	00 d0       	rcall	.+0      	; 0x3bc8 <prvSampleTimeNow+0x6>
    3bc8:	00 d0       	rcall	.+0      	; 0x3bca <prvSampleTimeNow+0x8>
    3bca:	cd b7       	in	r28, 0x3d	; 61
    3bcc:	de b7       	in	r29, 0x3e	; 62
    3bce:	9c 83       	std	Y+4, r25	; 0x04
    3bd0:	8b 83       	std	Y+3, r24	; 0x03
portTickType xTimeNow;
static portTickType xLastTime = ( portTickType ) 0U;

	xTimeNow = xTaskGetTickCount();
    3bd2:	0e 94 c6 17 	call	0x2f8c	; 0x2f8c <xTaskGetTickCount>
    3bd6:	9a 83       	std	Y+2, r25	; 0x02
    3bd8:	89 83       	std	Y+1, r24	; 0x01

	if( xTimeNow < xLastTime )
    3bda:	20 91 0c 07 	lds	r18, 0x070C
    3bde:	30 91 0d 07 	lds	r19, 0x070D
    3be2:	89 81       	ldd	r24, Y+1	; 0x01
    3be4:	9a 81       	ldd	r25, Y+2	; 0x02
    3be6:	82 17       	cp	r24, r18
    3be8:	93 07       	cpc	r25, r19
    3bea:	58 f4       	brcc	.+22     	; 0x3c02 <prvSampleTimeNow+0x40>
	{
		prvSwitchTimerLists( xLastTime );
    3bec:	80 91 0c 07 	lds	r24, 0x070C
    3bf0:	90 91 0d 07 	lds	r25, 0x070D
    3bf4:	0e 94 35 1f 	call	0x3e6a	; 0x3e6a <prvSwitchTimerLists>
		*pxTimerListsWereSwitched = pdTRUE;
    3bf8:	eb 81       	ldd	r30, Y+3	; 0x03
    3bfa:	fc 81       	ldd	r31, Y+4	; 0x04
    3bfc:	81 e0       	ldi	r24, 0x01	; 1
    3bfe:	80 83       	st	Z, r24
    3c00:	03 c0       	rjmp	.+6      	; 0x3c08 <prvSampleTimeNow+0x46>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    3c02:	eb 81       	ldd	r30, Y+3	; 0x03
    3c04:	fc 81       	ldd	r31, Y+4	; 0x04
    3c06:	10 82       	st	Z, r1
	}

	xLastTime = xTimeNow;
    3c08:	89 81       	ldd	r24, Y+1	; 0x01
    3c0a:	9a 81       	ldd	r25, Y+2	; 0x02
    3c0c:	90 93 0d 07 	sts	0x070D, r25
    3c10:	80 93 0c 07 	sts	0x070C, r24

	return xTimeNow;
    3c14:	89 81       	ldd	r24, Y+1	; 0x01
    3c16:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3c18:	0f 90       	pop	r0
    3c1a:	0f 90       	pop	r0
    3c1c:	0f 90       	pop	r0
    3c1e:	0f 90       	pop	r0
    3c20:	cf 91       	pop	r28
    3c22:	df 91       	pop	r29
    3c24:	08 95       	ret

00003c26 <prvInsertTimerInActiveList>:
/*-----------------------------------------------------------*/

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
    3c26:	df 93       	push	r29
    3c28:	cf 93       	push	r28
    3c2a:	cd b7       	in	r28, 0x3d	; 61
    3c2c:	de b7       	in	r29, 0x3e	; 62
    3c2e:	29 97       	sbiw	r28, 0x09	; 9
    3c30:	0f b6       	in	r0, 0x3f	; 63
    3c32:	f8 94       	cli
    3c34:	de bf       	out	0x3e, r29	; 62
    3c36:	0f be       	out	0x3f, r0	; 63
    3c38:	cd bf       	out	0x3d, r28	; 61
    3c3a:	9b 83       	std	Y+3, r25	; 0x03
    3c3c:	8a 83       	std	Y+2, r24	; 0x02
    3c3e:	7d 83       	std	Y+5, r23	; 0x05
    3c40:	6c 83       	std	Y+4, r22	; 0x04
    3c42:	5f 83       	std	Y+7, r21	; 0x07
    3c44:	4e 83       	std	Y+6, r20	; 0x06
    3c46:	39 87       	std	Y+9, r19	; 0x09
    3c48:	28 87       	std	Y+8, r18	; 0x08
portBASE_TYPE xProcessTimerNow = pdFALSE;
    3c4a:	19 82       	std	Y+1, r1	; 0x01

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    3c4c:	ea 81       	ldd	r30, Y+2	; 0x02
    3c4e:	fb 81       	ldd	r31, Y+3	; 0x03
    3c50:	8c 81       	ldd	r24, Y+4	; 0x04
    3c52:	9d 81       	ldd	r25, Y+5	; 0x05
    3c54:	93 83       	std	Z+3, r25	; 0x03
    3c56:	82 83       	std	Z+2, r24	; 0x02
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    3c58:	ea 81       	ldd	r30, Y+2	; 0x02
    3c5a:	fb 81       	ldd	r31, Y+3	; 0x03
    3c5c:	8a 81       	ldd	r24, Y+2	; 0x02
    3c5e:	9b 81       	ldd	r25, Y+3	; 0x03
    3c60:	91 87       	std	Z+9, r25	; 0x09
    3c62:	80 87       	std	Z+8, r24	; 0x08

	if( xNextExpiryTime <= xTimeNow )
    3c64:	2c 81       	ldd	r18, Y+4	; 0x04
    3c66:	3d 81       	ldd	r19, Y+5	; 0x05
    3c68:	8e 81       	ldd	r24, Y+6	; 0x06
    3c6a:	9f 81       	ldd	r25, Y+7	; 0x07
    3c6c:	82 17       	cp	r24, r18
    3c6e:	93 07       	cpc	r25, r19
    3c70:	e0 f0       	brcs	.+56     	; 0x3caa <prvInsertTimerInActiveList+0x84>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( portTickType ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks )
    3c72:	2e 81       	ldd	r18, Y+6	; 0x06
    3c74:	3f 81       	ldd	r19, Y+7	; 0x07
    3c76:	88 85       	ldd	r24, Y+8	; 0x08
    3c78:	99 85       	ldd	r25, Y+9	; 0x09
    3c7a:	28 1b       	sub	r18, r24
    3c7c:	39 0b       	sbc	r19, r25
    3c7e:	ea 81       	ldd	r30, Y+2	; 0x02
    3c80:	fb 81       	ldd	r31, Y+3	; 0x03
    3c82:	84 85       	ldd	r24, Z+12	; 0x0c
    3c84:	95 85       	ldd	r25, Z+13	; 0x0d
    3c86:	28 17       	cp	r18, r24
    3c88:	39 07       	cpc	r19, r25
    3c8a:	18 f0       	brcs	.+6      	; 0x3c92 <prvInsertTimerInActiveList+0x6c>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
    3c8c:	81 e0       	ldi	r24, 0x01	; 1
    3c8e:	89 83       	std	Y+1, r24	; 0x01
    3c90:	28 c0       	rjmp	.+80     	; 0x3ce2 <prvInsertTimerInActiveList+0xbc>
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    3c92:	80 91 22 07 	lds	r24, 0x0722
    3c96:	90 91 23 07 	lds	r25, 0x0723
    3c9a:	2a 81       	ldd	r18, Y+2	; 0x02
    3c9c:	3b 81       	ldd	r19, Y+3	; 0x03
    3c9e:	2e 5f       	subi	r18, 0xFE	; 254
    3ca0:	3f 4f       	sbci	r19, 0xFF	; 255
    3ca2:	b9 01       	movw	r22, r18
    3ca4:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <vListInsert>
    3ca8:	1c c0       	rjmp	.+56     	; 0x3ce2 <prvInsertTimerInActiveList+0xbc>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    3caa:	2e 81       	ldd	r18, Y+6	; 0x06
    3cac:	3f 81       	ldd	r19, Y+7	; 0x07
    3cae:	88 85       	ldd	r24, Y+8	; 0x08
    3cb0:	99 85       	ldd	r25, Y+9	; 0x09
    3cb2:	28 17       	cp	r18, r24
    3cb4:	39 07       	cpc	r19, r25
    3cb6:	50 f4       	brcc	.+20     	; 0x3ccc <prvInsertTimerInActiveList+0xa6>
    3cb8:	2c 81       	ldd	r18, Y+4	; 0x04
    3cba:	3d 81       	ldd	r19, Y+5	; 0x05
    3cbc:	88 85       	ldd	r24, Y+8	; 0x08
    3cbe:	99 85       	ldd	r25, Y+9	; 0x09
    3cc0:	28 17       	cp	r18, r24
    3cc2:	39 07       	cpc	r19, r25
    3cc4:	18 f0       	brcs	.+6      	; 0x3ccc <prvInsertTimerInActiveList+0xa6>
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
    3cc6:	81 e0       	ldi	r24, 0x01	; 1
    3cc8:	89 83       	std	Y+1, r24	; 0x01
    3cca:	0b c0       	rjmp	.+22     	; 0x3ce2 <prvInsertTimerInActiveList+0xbc>
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    3ccc:	80 91 20 07 	lds	r24, 0x0720
    3cd0:	90 91 21 07 	lds	r25, 0x0721
    3cd4:	2a 81       	ldd	r18, Y+2	; 0x02
    3cd6:	3b 81       	ldd	r19, Y+3	; 0x03
    3cd8:	2e 5f       	subi	r18, 0xFE	; 254
    3cda:	3f 4f       	sbci	r19, 0xFF	; 255
    3cdc:	b9 01       	movw	r22, r18
    3cde:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <vListInsert>
		}
	}

	return xProcessTimerNow;
    3ce2:	89 81       	ldd	r24, Y+1	; 0x01
}
    3ce4:	29 96       	adiw	r28, 0x09	; 9
    3ce6:	0f b6       	in	r0, 0x3f	; 63
    3ce8:	f8 94       	cli
    3cea:	de bf       	out	0x3e, r29	; 62
    3cec:	0f be       	out	0x3f, r0	; 63
    3cee:	cd bf       	out	0x3d, r28	; 61
    3cf0:	cf 91       	pop	r28
    3cf2:	df 91       	pop	r29
    3cf4:	08 95       	ret

00003cf6 <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

static void	prvProcessReceivedCommands( void )
{
    3cf6:	0f 93       	push	r16
    3cf8:	1f 93       	push	r17
    3cfa:	df 93       	push	r29
    3cfc:	cf 93       	push	r28
    3cfe:	cd b7       	in	r28, 0x3d	; 61
    3d00:	de b7       	in	r29, 0x3e	; 62
    3d02:	2d 97       	sbiw	r28, 0x0d	; 13
    3d04:	0f b6       	in	r0, 0x3f	; 63
    3d06:	f8 94       	cli
    3d08:	de bf       	out	0x3e, r29	; 62
    3d0a:	0f be       	out	0x3f, r0	; 63
    3d0c:	cd bf       	out	0x3d, r28	; 61
portBASE_TYPE xTimerListsWereSwitched, xResult;
portTickType xTimeNow;

	/* In this case the xTimerListsWereSwitched parameter is not used, but it
	must be present in the function call. */
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3d0e:	ce 01       	movw	r24, r28
    3d10:	0b 96       	adiw	r24, 0x0b	; 11
    3d12:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <prvSampleTimeNow>
    3d16:	9a 83       	std	Y+2, r25	; 0x02
    3d18:	89 83       	std	Y+1, r24	; 0x01
    3d1a:	8c c0       	rjmp	.+280    	; 0x3e34 <prvProcessReceivedCommands+0x13e>

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
	{
		pxTimer = xMessage.pxTimer;
    3d1c:	89 85       	ldd	r24, Y+9	; 0x09
    3d1e:	9a 85       	ldd	r25, Y+10	; 0x0a
    3d20:	9d 83       	std	Y+5, r25	; 0x05
    3d22:	8c 83       	std	Y+4, r24	; 0x04

		/* Is the timer already in a list of active timers?  When the command
		is trmCOMMAND_PROCESS_TIMER_OVERFLOW, the timer will be NULL as the
		command is to the task rather than to an individual timer. */
		if( pxTimer != NULL )
    3d24:	8c 81       	ldd	r24, Y+4	; 0x04
    3d26:	9d 81       	ldd	r25, Y+5	; 0x05
    3d28:	00 97       	sbiw	r24, 0x00	; 0
    3d2a:	59 f0       	breq	.+22     	; 0x3d42 <prvProcessReceivedCommands+0x4c>
		{
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    3d2c:	ec 81       	ldd	r30, Y+4	; 0x04
    3d2e:	fd 81       	ldd	r31, Y+5	; 0x05
    3d30:	82 85       	ldd	r24, Z+10	; 0x0a
    3d32:	93 85       	ldd	r25, Z+11	; 0x0b
    3d34:	00 97       	sbiw	r24, 0x00	; 0
    3d36:	29 f0       	breq	.+10     	; 0x3d42 <prvProcessReceivedCommands+0x4c>
			{
				/* The timer is in a list, remove it. */
				vListRemove( &( pxTimer->xTimerListItem ) );
    3d38:	8c 81       	ldd	r24, Y+4	; 0x04
    3d3a:	9d 81       	ldd	r25, Y+5	; 0x05
    3d3c:	02 96       	adiw	r24, 0x02	; 2
    3d3e:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>
			}
		}

		traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.xMessageValue );

		switch( xMessage.xMessageID )
    3d42:	8e 81       	ldd	r24, Y+6	; 0x06
    3d44:	28 2f       	mov	r18, r24
    3d46:	30 e0       	ldi	r19, 0x00	; 0
    3d48:	3d 87       	std	Y+13, r19	; 0x0d
    3d4a:	2c 87       	std	Y+12, r18	; 0x0c
    3d4c:	8c 85       	ldd	r24, Y+12	; 0x0c
    3d4e:	9d 85       	ldd	r25, Y+13	; 0x0d
    3d50:	81 30       	cpi	r24, 0x01	; 1
    3d52:	91 05       	cpc	r25, r1
    3d54:	09 f4       	brne	.+2      	; 0x3d58 <prvProcessReceivedCommands+0x62>
    3d56:	6e c0       	rjmp	.+220    	; 0x3e34 <prvProcessReceivedCommands+0x13e>
    3d58:	2c 85       	ldd	r18, Y+12	; 0x0c
    3d5a:	3d 85       	ldd	r19, Y+13	; 0x0d
    3d5c:	22 30       	cpi	r18, 0x02	; 2
    3d5e:	31 05       	cpc	r19, r1
    3d60:	2c f4       	brge	.+10     	; 0x3d6c <prvProcessReceivedCommands+0x76>
    3d62:	8c 85       	ldd	r24, Y+12	; 0x0c
    3d64:	9d 85       	ldd	r25, Y+13	; 0x0d
    3d66:	00 97       	sbiw	r24, 0x00	; 0
    3d68:	71 f0       	breq	.+28     	; 0x3d86 <prvProcessReceivedCommands+0x90>
    3d6a:	64 c0       	rjmp	.+200    	; 0x3e34 <prvProcessReceivedCommands+0x13e>
    3d6c:	2c 85       	ldd	r18, Y+12	; 0x0c
    3d6e:	3d 85       	ldd	r19, Y+13	; 0x0d
    3d70:	22 30       	cpi	r18, 0x02	; 2
    3d72:	31 05       	cpc	r19, r1
    3d74:	09 f4       	brne	.+2      	; 0x3d78 <prvProcessReceivedCommands+0x82>
    3d76:	3f c0       	rjmp	.+126    	; 0x3df6 <prvProcessReceivedCommands+0x100>
    3d78:	8c 85       	ldd	r24, Y+12	; 0x0c
    3d7a:	9d 85       	ldd	r25, Y+13	; 0x0d
    3d7c:	83 30       	cpi	r24, 0x03	; 3
    3d7e:	91 05       	cpc	r25, r1
    3d80:	09 f4       	brne	.+2      	; 0x3d84 <prvProcessReceivedCommands+0x8e>
    3d82:	54 c0       	rjmp	.+168    	; 0x3e2c <prvProcessReceivedCommands+0x136>
    3d84:	57 c0       	rjmp	.+174    	; 0x3e34 <prvProcessReceivedCommands+0x13e>
		{
			case tmrCOMMAND_START :
				/* Start or restart a timer. */
				if( prvInsertTimerInActiveList( pxTimer,  xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.xMessageValue ) == pdTRUE )
    3d86:	2f 81       	ldd	r18, Y+7	; 0x07
    3d88:	38 85       	ldd	r19, Y+8	; 0x08
    3d8a:	ec 81       	ldd	r30, Y+4	; 0x04
    3d8c:	fd 81       	ldd	r31, Y+5	; 0x05
    3d8e:	84 85       	ldd	r24, Z+12	; 0x0c
    3d90:	95 85       	ldd	r25, Z+13	; 0x0d
    3d92:	a9 01       	movw	r20, r18
    3d94:	48 0f       	add	r20, r24
    3d96:	59 1f       	adc	r21, r25
    3d98:	ef 81       	ldd	r30, Y+7	; 0x07
    3d9a:	f8 85       	ldd	r31, Y+8	; 0x08
    3d9c:	8c 81       	ldd	r24, Y+4	; 0x04
    3d9e:	9d 81       	ldd	r25, Y+5	; 0x05
    3da0:	29 81       	ldd	r18, Y+1	; 0x01
    3da2:	3a 81       	ldd	r19, Y+2	; 0x02
    3da4:	ba 01       	movw	r22, r20
    3da6:	a9 01       	movw	r20, r18
    3da8:	9f 01       	movw	r18, r30
    3daa:	0e 94 13 1e 	call	0x3c26	; 0x3c26 <prvInsertTimerInActiveList>
    3dae:	81 30       	cpi	r24, 0x01	; 1
    3db0:	09 f0       	breq	.+2      	; 0x3db4 <prvProcessReceivedCommands+0xbe>
    3db2:	40 c0       	rjmp	.+128    	; 0x3e34 <prvProcessReceivedCommands+0x13e>
				{
					/* The timer expired before it was added to the active timer
					list.  Process it now. */
					pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
    3db4:	ec 81       	ldd	r30, Y+4	; 0x04
    3db6:	fd 81       	ldd	r31, Y+5	; 0x05
    3db8:	01 88       	ldd	r0, Z+17	; 0x11
    3dba:	f2 89       	ldd	r31, Z+18	; 0x12
    3dbc:	e0 2d       	mov	r30, r0
    3dbe:	8c 81       	ldd	r24, Y+4	; 0x04
    3dc0:	9d 81       	ldd	r25, Y+5	; 0x05
    3dc2:	09 95       	icall

					if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
    3dc4:	ec 81       	ldd	r30, Y+4	; 0x04
    3dc6:	fd 81       	ldd	r31, Y+5	; 0x05
    3dc8:	86 85       	ldd	r24, Z+14	; 0x0e
    3dca:	81 30       	cpi	r24, 0x01	; 1
    3dcc:	99 f5       	brne	.+102    	; 0x3e34 <prvProcessReceivedCommands+0x13e>
					{
						xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    3dce:	2f 81       	ldd	r18, Y+7	; 0x07
    3dd0:	38 85       	ldd	r19, Y+8	; 0x08
    3dd2:	ec 81       	ldd	r30, Y+4	; 0x04
    3dd4:	fd 81       	ldd	r31, Y+5	; 0x05
    3dd6:	84 85       	ldd	r24, Z+12	; 0x0c
    3dd8:	95 85       	ldd	r25, Z+13	; 0x0d
    3dda:	28 0f       	add	r18, r24
    3ddc:	39 1f       	adc	r19, r25
    3dde:	8c 81       	ldd	r24, Y+4	; 0x04
    3de0:	9d 81       	ldd	r25, Y+5	; 0x05
    3de2:	60 e0       	ldi	r22, 0x00	; 0
    3de4:	a9 01       	movw	r20, r18
    3de6:	20 e0       	ldi	r18, 0x00	; 0
    3de8:	30 e0       	ldi	r19, 0x00	; 0
    3dea:	00 e0       	ldi	r16, 0x00	; 0
    3dec:	10 e0       	ldi	r17, 0x00	; 0
    3dee:	0e 94 8a 1c 	call	0x3914	; 0x3914 <xTimerGenericCommand>
    3df2:	8b 83       	std	Y+3, r24	; 0x03
    3df4:	1f c0       	rjmp	.+62     	; 0x3e34 <prvProcessReceivedCommands+0x13e>
				/* The timer has already been removed from the active list.
				There is nothing to do here. */
				break;

			case tmrCOMMAND_CHANGE_PERIOD :
				pxTimer->xTimerPeriodInTicks = xMessage.xMessageValue;
    3df6:	8f 81       	ldd	r24, Y+7	; 0x07
    3df8:	98 85       	ldd	r25, Y+8	; 0x08
    3dfa:	ec 81       	ldd	r30, Y+4	; 0x04
    3dfc:	fd 81       	ldd	r31, Y+5	; 0x05
    3dfe:	95 87       	std	Z+13, r25	; 0x0d
    3e00:	84 87       	std	Z+12, r24	; 0x0c
				configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
				prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    3e02:	ec 81       	ldd	r30, Y+4	; 0x04
    3e04:	fd 81       	ldd	r31, Y+5	; 0x05
    3e06:	24 85       	ldd	r18, Z+12	; 0x0c
    3e08:	35 85       	ldd	r19, Z+13	; 0x0d
    3e0a:	89 81       	ldd	r24, Y+1	; 0x01
    3e0c:	9a 81       	ldd	r25, Y+2	; 0x02
    3e0e:	a9 01       	movw	r20, r18
    3e10:	48 0f       	add	r20, r24
    3e12:	59 1f       	adc	r21, r25
    3e14:	8c 81       	ldd	r24, Y+4	; 0x04
    3e16:	9d 81       	ldd	r25, Y+5	; 0x05
    3e18:	29 81       	ldd	r18, Y+1	; 0x01
    3e1a:	3a 81       	ldd	r19, Y+2	; 0x02
    3e1c:	e9 81       	ldd	r30, Y+1	; 0x01
    3e1e:	fa 81       	ldd	r31, Y+2	; 0x02
    3e20:	ba 01       	movw	r22, r20
    3e22:	a9 01       	movw	r20, r18
    3e24:	9f 01       	movw	r18, r30
    3e26:	0e 94 13 1e 	call	0x3c26	; 0x3c26 <prvInsertTimerInActiveList>
    3e2a:	04 c0       	rjmp	.+8      	; 0x3e34 <prvProcessReceivedCommands+0x13e>
				break;

			case tmrCOMMAND_DELETE :
				/* The timer has already been removed from the active list,
				just free up the memory. */
				vPortFree( pxTimer );
    3e2c:	8c 81       	ldd	r24, Y+4	; 0x04
    3e2e:	9d 81       	ldd	r25, Y+5	; 0x05
    3e30:	0e 94 35 0a 	call	0x146a	; 0x146a <vPortFree>

	/* In this case the xTimerListsWereSwitched parameter is not used, but it
	must be present in the function call. */
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
    3e34:	80 91 0a 07 	lds	r24, 0x070A
    3e38:	90 91 0b 07 	lds	r25, 0x070B
    3e3c:	9e 01       	movw	r18, r28
    3e3e:	2a 5f       	subi	r18, 0xFA	; 250
    3e40:	3f 4f       	sbci	r19, 0xFF	; 255
    3e42:	b9 01       	movw	r22, r18
    3e44:	40 e0       	ldi	r20, 0x00	; 0
    3e46:	50 e0       	ldi	r21, 0x00	; 0
    3e48:	20 e0       	ldi	r18, 0x00	; 0
    3e4a:	0e 94 23 10 	call	0x2046	; 0x2046 <xQueueGenericReceive>
    3e4e:	88 23       	and	r24, r24
    3e50:	09 f0       	breq	.+2      	; 0x3e54 <prvProcessReceivedCommands+0x15e>
    3e52:	64 cf       	rjmp	.-312    	; 0x3d1c <prvProcessReceivedCommands+0x26>
			default	:
				/* Don't expect to get here. */
				break;
		}
	}
}
    3e54:	2d 96       	adiw	r28, 0x0d	; 13
    3e56:	0f b6       	in	r0, 0x3f	; 63
    3e58:	f8 94       	cli
    3e5a:	de bf       	out	0x3e, r29	; 62
    3e5c:	0f be       	out	0x3f, r0	; 63
    3e5e:	cd bf       	out	0x3d, r28	; 61
    3e60:	cf 91       	pop	r28
    3e62:	df 91       	pop	r29
    3e64:	1f 91       	pop	r17
    3e66:	0f 91       	pop	r16
    3e68:	08 95       	ret

00003e6a <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( portTickType xLastTime )
{
    3e6a:	0f 93       	push	r16
    3e6c:	1f 93       	push	r17
    3e6e:	df 93       	push	r29
    3e70:	cf 93       	push	r28
    3e72:	cd b7       	in	r28, 0x3d	; 61
    3e74:	de b7       	in	r29, 0x3e	; 62
    3e76:	2b 97       	sbiw	r28, 0x0b	; 11
    3e78:	0f b6       	in	r0, 0x3f	; 63
    3e7a:	f8 94       	cli
    3e7c:	de bf       	out	0x3e, r29	; 62
    3e7e:	0f be       	out	0x3f, r0	; 63
    3e80:	cd bf       	out	0x3d, r28	; 61
    3e82:	9b 87       	std	Y+11, r25	; 0x0b
    3e84:	8a 87       	std	Y+10, r24	; 0x0a
    3e86:	60 c0       	rjmp	.+192    	; 0x3f48 <prvSwitchTimerLists+0xde>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    3e88:	e0 91 20 07 	lds	r30, 0x0720
    3e8c:	f0 91 21 07 	lds	r31, 0x0721
    3e90:	05 80       	ldd	r0, Z+5	; 0x05
    3e92:	f6 81       	ldd	r31, Z+6	; 0x06
    3e94:	e0 2d       	mov	r30, r0
    3e96:	80 81       	ld	r24, Z
    3e98:	91 81       	ldd	r25, Z+1	; 0x01
    3e9a:	99 87       	std	Y+9, r25	; 0x09
    3e9c:	88 87       	std	Y+8, r24	; 0x08

		/* Remove the timer from the list. */
		pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    3e9e:	e0 91 20 07 	lds	r30, 0x0720
    3ea2:	f0 91 21 07 	lds	r31, 0x0721
    3ea6:	05 80       	ldd	r0, Z+5	; 0x05
    3ea8:	f6 81       	ldd	r31, Z+6	; 0x06
    3eaa:	e0 2d       	mov	r30, r0
    3eac:	86 81       	ldd	r24, Z+6	; 0x06
    3eae:	97 81       	ldd	r25, Z+7	; 0x07
    3eb0:	9b 83       	std	Y+3, r25	; 0x03
    3eb2:	8a 83       	std	Y+2, r24	; 0x02
		vListRemove( &( pxTimer->xTimerListItem ) );
    3eb4:	8a 81       	ldd	r24, Y+2	; 0x02
    3eb6:	9b 81       	ldd	r25, Y+3	; 0x03
    3eb8:	02 96       	adiw	r24, 0x02	; 2
    3eba:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
    3ebe:	ea 81       	ldd	r30, Y+2	; 0x02
    3ec0:	fb 81       	ldd	r31, Y+3	; 0x03
    3ec2:	01 88       	ldd	r0, Z+17	; 0x11
    3ec4:	f2 89       	ldd	r31, Z+18	; 0x12
    3ec6:	e0 2d       	mov	r30, r0
    3ec8:	8a 81       	ldd	r24, Y+2	; 0x02
    3eca:	9b 81       	ldd	r25, Y+3	; 0x03
    3ecc:	09 95       	icall

		if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
    3ece:	ea 81       	ldd	r30, Y+2	; 0x02
    3ed0:	fb 81       	ldd	r31, Y+3	; 0x03
    3ed2:	86 85       	ldd	r24, Z+14	; 0x0e
    3ed4:	81 30       	cpi	r24, 0x01	; 1
    3ed6:	c1 f5       	brne	.+112    	; 0x3f48 <prvSwitchTimerLists+0xde>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    3ed8:	ea 81       	ldd	r30, Y+2	; 0x02
    3eda:	fb 81       	ldd	r31, Y+3	; 0x03
    3edc:	24 85       	ldd	r18, Z+12	; 0x0c
    3ede:	35 85       	ldd	r19, Z+13	; 0x0d
    3ee0:	88 85       	ldd	r24, Y+8	; 0x08
    3ee2:	99 85       	ldd	r25, Y+9	; 0x09
    3ee4:	82 0f       	add	r24, r18
    3ee6:	93 1f       	adc	r25, r19
    3ee8:	9f 83       	std	Y+7, r25	; 0x07
    3eea:	8e 83       	std	Y+6, r24	; 0x06
			if( xReloadTime > xNextExpireTime )
    3eec:	2e 81       	ldd	r18, Y+6	; 0x06
    3eee:	3f 81       	ldd	r19, Y+7	; 0x07
    3ef0:	88 85       	ldd	r24, Y+8	; 0x08
    3ef2:	99 85       	ldd	r25, Y+9	; 0x09
    3ef4:	82 17       	cp	r24, r18
    3ef6:	93 07       	cpc	r25, r19
    3ef8:	d0 f4       	brcc	.+52     	; 0x3f2e <prvSwitchTimerLists+0xc4>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    3efa:	ea 81       	ldd	r30, Y+2	; 0x02
    3efc:	fb 81       	ldd	r31, Y+3	; 0x03
    3efe:	8e 81       	ldd	r24, Y+6	; 0x06
    3f00:	9f 81       	ldd	r25, Y+7	; 0x07
    3f02:	93 83       	std	Z+3, r25	; 0x03
    3f04:	82 83       	std	Z+2, r24	; 0x02
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    3f06:	ea 81       	ldd	r30, Y+2	; 0x02
    3f08:	fb 81       	ldd	r31, Y+3	; 0x03
    3f0a:	8a 81       	ldd	r24, Y+2	; 0x02
    3f0c:	9b 81       	ldd	r25, Y+3	; 0x03
    3f0e:	91 87       	std	Z+9, r25	; 0x09
    3f10:	80 87       	std	Z+8, r24	; 0x08
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    3f12:	40 91 20 07 	lds	r20, 0x0720
    3f16:	50 91 21 07 	lds	r21, 0x0721
    3f1a:	8a 81       	ldd	r24, Y+2	; 0x02
    3f1c:	9b 81       	ldd	r25, Y+3	; 0x03
    3f1e:	9c 01       	movw	r18, r24
    3f20:	2e 5f       	subi	r18, 0xFE	; 254
    3f22:	3f 4f       	sbci	r19, 0xFF	; 255
    3f24:	ca 01       	movw	r24, r20
    3f26:	b9 01       	movw	r22, r18
    3f28:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <vListInsert>
    3f2c:	0d c0       	rjmp	.+26     	; 0x3f48 <prvSwitchTimerLists+0xde>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
    3f2e:	8a 81       	ldd	r24, Y+2	; 0x02
    3f30:	9b 81       	ldd	r25, Y+3	; 0x03
    3f32:	28 85       	ldd	r18, Y+8	; 0x08
    3f34:	39 85       	ldd	r19, Y+9	; 0x09
    3f36:	60 e0       	ldi	r22, 0x00	; 0
    3f38:	a9 01       	movw	r20, r18
    3f3a:	20 e0       	ldi	r18, 0x00	; 0
    3f3c:	30 e0       	ldi	r19, 0x00	; 0
    3f3e:	00 e0       	ldi	r16, 0x00	; 0
    3f40:	10 e0       	ldi	r17, 0x00	; 0
    3f42:	0e 94 8a 1c 	call	0x3914	; 0x3914 <xTimerGenericCommand>
    3f46:	89 83       	std	Y+1, r24	; 0x01

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    3f48:	e0 91 20 07 	lds	r30, 0x0720
    3f4c:	f0 91 21 07 	lds	r31, 0x0721
    3f50:	80 81       	ld	r24, Z
    3f52:	88 23       	and	r24, r24
    3f54:	09 f0       	breq	.+2      	; 0x3f58 <prvSwitchTimerLists+0xee>
    3f56:	98 cf       	rjmp	.-208    	; 0x3e88 <prvSwitchTimerLists+0x1e>
				( void ) xResult;
			}
		}
	}

	pxTemp = pxCurrentTimerList;
    3f58:	80 91 20 07 	lds	r24, 0x0720
    3f5c:	90 91 21 07 	lds	r25, 0x0721
    3f60:	9d 83       	std	Y+5, r25	; 0x05
    3f62:	8c 83       	std	Y+4, r24	; 0x04
	pxCurrentTimerList = pxOverflowTimerList;
    3f64:	80 91 22 07 	lds	r24, 0x0722
    3f68:	90 91 23 07 	lds	r25, 0x0723
    3f6c:	90 93 21 07 	sts	0x0721, r25
    3f70:	80 93 20 07 	sts	0x0720, r24
	pxOverflowTimerList = pxTemp;
    3f74:	8c 81       	ldd	r24, Y+4	; 0x04
    3f76:	9d 81       	ldd	r25, Y+5	; 0x05
    3f78:	90 93 23 07 	sts	0x0723, r25
    3f7c:	80 93 22 07 	sts	0x0722, r24
}
    3f80:	2b 96       	adiw	r28, 0x0b	; 11
    3f82:	0f b6       	in	r0, 0x3f	; 63
    3f84:	f8 94       	cli
    3f86:	de bf       	out	0x3e, r29	; 62
    3f88:	0f be       	out	0x3f, r0	; 63
    3f8a:	cd bf       	out	0x3d, r28	; 61
    3f8c:	cf 91       	pop	r28
    3f8e:	df 91       	pop	r29
    3f90:	1f 91       	pop	r17
    3f92:	0f 91       	pop	r16
    3f94:	08 95       	ret

00003f96 <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
    3f96:	df 93       	push	r29
    3f98:	cf 93       	push	r28
    3f9a:	cd b7       	in	r28, 0x3d	; 61
    3f9c:	de b7       	in	r29, 0x3e	; 62
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
    3f9e:	0f b6       	in	r0, 0x3f	; 63
    3fa0:	f8 94       	cli
    3fa2:	0f 92       	push	r0
	{
		if( xTimerQueue == NULL )
    3fa4:	80 91 0a 07 	lds	r24, 0x070A
    3fa8:	90 91 0b 07 	lds	r25, 0x070B
    3fac:	00 97       	sbiw	r24, 0x00	; 0
    3fae:	e1 f4       	brne	.+56     	; 0x3fe8 <prvCheckForValidListAndQueue+0x52>
		{
			vListInitialise( &xActiveTimerList1 );
    3fb0:	8e e0       	ldi	r24, 0x0E	; 14
    3fb2:	97 e0       	ldi	r25, 0x07	; 7
    3fb4:	0e 94 5b 0a 	call	0x14b6	; 0x14b6 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
    3fb8:	87 e1       	ldi	r24, 0x17	; 23
    3fba:	97 e0       	ldi	r25, 0x07	; 7
    3fbc:	0e 94 5b 0a 	call	0x14b6	; 0x14b6 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
    3fc0:	8e e0       	ldi	r24, 0x0E	; 14
    3fc2:	97 e0       	ldi	r25, 0x07	; 7
    3fc4:	90 93 21 07 	sts	0x0721, r25
    3fc8:	80 93 20 07 	sts	0x0720, r24
			pxOverflowTimerList = &xActiveTimerList2;
    3fcc:	87 e1       	ldi	r24, 0x17	; 23
    3fce:	97 e0       	ldi	r25, 0x07	; 7
    3fd0:	90 93 23 07 	sts	0x0723, r25
    3fd4:	80 93 22 07 	sts	0x0722, r24
			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_MESSAGE ) );
    3fd8:	8a e0       	ldi	r24, 0x0A	; 10
    3fda:	65 e0       	ldi	r22, 0x05	; 5
    3fdc:	0e 94 8f 0e 	call	0x1d1e	; 0x1d1e <xQueueCreate>
    3fe0:	90 93 0b 07 	sts	0x070B, r25
    3fe4:	80 93 0a 07 	sts	0x070A, r24
		}
	}
	taskEXIT_CRITICAL();
    3fe8:	0f 90       	pop	r0
    3fea:	0f be       	out	0x3f, r0	; 63
}
    3fec:	cf 91       	pop	r28
    3fee:	df 91       	pop	r29
    3ff0:	08 95       	ret

00003ff2 <xTimerIsTimerActive>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerIsTimerActive( xTimerHandle xTimer )
{
    3ff2:	df 93       	push	r29
    3ff4:	cf 93       	push	r28
    3ff6:	00 d0       	rcall	.+0      	; 0x3ff8 <xTimerIsTimerActive+0x6>
    3ff8:	00 d0       	rcall	.+0      	; 0x3ffa <xTimerIsTimerActive+0x8>
    3ffa:	0f 92       	push	r0
    3ffc:	cd b7       	in	r28, 0x3d	; 61
    3ffe:	de b7       	in	r29, 0x3e	; 62
    4000:	9d 83       	std	Y+5, r25	; 0x05
    4002:	8c 83       	std	Y+4, r24	; 0x04
portBASE_TYPE xTimerIsInActiveList;
xTIMER *pxTimer = ( xTIMER * ) xTimer;
    4004:	8c 81       	ldd	r24, Y+4	; 0x04
    4006:	9d 81       	ldd	r25, Y+5	; 0x05
    4008:	9a 83       	std	Y+2, r25	; 0x02
    400a:	89 83       	std	Y+1, r24	; 0x01

	/* Is the timer in the list of active timers? */
	taskENTER_CRITICAL();
    400c:	0f b6       	in	r0, 0x3f	; 63
    400e:	f8 94       	cli
    4010:	0f 92       	push	r0
	{
		/* Checking to see if it is in the NULL list in effect checks to see if
		it is referenced from either the current or the overflow timer lists in
		one go, but the logic has to be reversed, hence the '!'. */
		xTimerIsInActiveList = !( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) );
    4012:	e9 81       	ldd	r30, Y+1	; 0x01
    4014:	fa 81       	ldd	r31, Y+2	; 0x02
    4016:	82 85       	ldd	r24, Z+10	; 0x0a
    4018:	93 85       	ldd	r25, Z+11	; 0x0b
    401a:	1b 82       	std	Y+3, r1	; 0x03
    401c:	00 97       	sbiw	r24, 0x00	; 0
    401e:	11 f0       	breq	.+4      	; 0x4024 <xTimerIsTimerActive+0x32>
    4020:	81 e0       	ldi	r24, 0x01	; 1
    4022:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    4024:	0f 90       	pop	r0
    4026:	0f be       	out	0x3f, r0	; 63

	return xTimerIsInActiveList;
    4028:	8b 81       	ldd	r24, Y+3	; 0x03
}
    402a:	0f 90       	pop	r0
    402c:	0f 90       	pop	r0
    402e:	0f 90       	pop	r0
    4030:	0f 90       	pop	r0
    4032:	0f 90       	pop	r0
    4034:	cf 91       	pop	r28
    4036:	df 91       	pop	r29
    4038:	08 95       	ret

0000403a <pvTimerGetTimerID>:
/*-----------------------------------------------------------*/

void *pvTimerGetTimerID( xTimerHandle xTimer )
{
    403a:	df 93       	push	r29
    403c:	cf 93       	push	r28
    403e:	00 d0       	rcall	.+0      	; 0x4040 <pvTimerGetTimerID+0x6>
    4040:	00 d0       	rcall	.+0      	; 0x4042 <pvTimerGetTimerID+0x8>
    4042:	cd b7       	in	r28, 0x3d	; 61
    4044:	de b7       	in	r29, 0x3e	; 62
    4046:	9c 83       	std	Y+4, r25	; 0x04
    4048:	8b 83       	std	Y+3, r24	; 0x03
xTIMER *pxTimer = ( xTIMER * ) xTimer;
    404a:	8b 81       	ldd	r24, Y+3	; 0x03
    404c:	9c 81       	ldd	r25, Y+4	; 0x04
    404e:	9a 83       	std	Y+2, r25	; 0x02
    4050:	89 83       	std	Y+1, r24	; 0x01

	return pxTimer->pvTimerID;
    4052:	e9 81       	ldd	r30, Y+1	; 0x01
    4054:	fa 81       	ldd	r31, Y+2	; 0x02
    4056:	87 85       	ldd	r24, Z+15	; 0x0f
    4058:	90 89       	ldd	r25, Z+16	; 0x10
}
    405a:	0f 90       	pop	r0
    405c:	0f 90       	pop	r0
    405e:	0f 90       	pop	r0
    4060:	0f 90       	pop	r0
    4062:	cf 91       	pop	r28
    4064:	df 91       	pop	r29
    4066:	08 95       	ret

00004068 <task1>:
int num=60;
int mode = 0;
int avgTemp = 0;

void task1()
{
    4068:	0f 93       	push	r16
    406a:	1f 93       	push	r17
    406c:	df 93       	push	r29
    406e:	cf 93       	push	r28
    4070:	cd b7       	in	r28, 0x3d	; 61
    4072:	de b7       	in	r29, 0x3e	; 62
	while (1)
		{

			if (BUTTON_udtbuttonStatus(BUTTON1)==PRESSED)
    4074:	81 e0       	ldi	r24, 0x01	; 1
    4076:	0e 94 a8 2b 	call	0x5750	; 0x5750 <BUTTON_udtbuttonStatus>
    407a:	81 30       	cpi	r24, 0x01	; 1
    407c:	09 f0       	breq	.+2      	; 0x4080 <task1+0x18>
    407e:	4c c0       	rjmp	.+152    	; 0x4118 <task1+0xb0>
			{
				if (mode==0)
    4080:	80 91 30 07 	lds	r24, 0x0730
    4084:	90 91 31 07 	lds	r25, 0x0731
    4088:	00 97       	sbiw	r24, 0x00	; 0
    408a:	d9 f4       	brne	.+54     	; 0x40c2 <task1+0x5a>
				{
					vTaskDelay(250);
    408c:	8a ef       	ldi	r24, 0xFA	; 250
    408e:	90 e0       	ldi	r25, 0x00	; 0
    4090:	0e 94 a8 14 	call	0x2950	; 0x2950 <vTaskDelay>
					mode=1;
    4094:	81 e0       	ldi	r24, 0x01	; 1
    4096:	90 e0       	ldi	r25, 0x00	; 0
    4098:	90 93 31 07 	sts	0x0731, r25
    409c:	80 93 30 07 	sts	0x0730, r24
					xTimerReset(timer1handler,0);
    40a0:	00 91 2e 07 	lds	r16, 0x072E
    40a4:	10 91 2f 07 	lds	r17, 0x072F
    40a8:	0e 94 c6 17 	call	0x2f8c	; 0x2f8c <xTaskGetTickCount>
    40ac:	9c 01       	movw	r18, r24
    40ae:	c8 01       	movw	r24, r16
    40b0:	60 e0       	ldi	r22, 0x00	; 0
    40b2:	a9 01       	movw	r20, r18
    40b4:	20 e0       	ldi	r18, 0x00	; 0
    40b6:	30 e0       	ldi	r19, 0x00	; 0
    40b8:	00 e0       	ldi	r16, 0x00	; 0
    40ba:	10 e0       	ldi	r17, 0x00	; 0
    40bc:	0e 94 8a 1c 	call	0x3914	; 0x3914 <xTimerGenericCommand>
    40c0:	2b c0       	rjmp	.+86     	; 0x4118 <task1+0xb0>
				}
				else if (mode==1)
    40c2:	80 91 30 07 	lds	r24, 0x0730
    40c6:	90 91 31 07 	lds	r25, 0x0731
    40ca:	81 30       	cpi	r24, 0x01	; 1
    40cc:	91 05       	cpc	r25, r1
    40ce:	21 f5       	brne	.+72     	; 0x4118 <task1+0xb0>
				{
					vTaskDelay(250);
    40d0:	8a ef       	ldi	r24, 0xFA	; 250
    40d2:	90 e0       	ldi	r25, 0x00	; 0
    40d4:	0e 94 a8 14 	call	0x2950	; 0x2950 <vTaskDelay>
					if (num>25)
    40d8:	80 91 a1 01 	lds	r24, 0x01A1
    40dc:	90 91 a2 01 	lds	r25, 0x01A2
    40e0:	8a 31       	cpi	r24, 0x1A	; 26
    40e2:	91 05       	cpc	r25, r1
    40e4:	4c f0       	brlt	.+18     	; 0x40f8 <task1+0x90>
					{
						num=num-5;
    40e6:	80 91 a1 01 	lds	r24, 0x01A1
    40ea:	90 91 a2 01 	lds	r25, 0x01A2
    40ee:	05 97       	sbiw	r24, 0x05	; 5
    40f0:	90 93 a2 01 	sts	0x01A2, r25
    40f4:	80 93 a1 01 	sts	0x01A1, r24
						// H_AT24C16A_Void_EEPROMWrite(num,5,145);
					}
					xTimerReset(timer1handler,0);
    40f8:	00 91 2e 07 	lds	r16, 0x072E
    40fc:	10 91 2f 07 	lds	r17, 0x072F
    4100:	0e 94 c6 17 	call	0x2f8c	; 0x2f8c <xTaskGetTickCount>
    4104:	9c 01       	movw	r18, r24
    4106:	c8 01       	movw	r24, r16
    4108:	60 e0       	ldi	r22, 0x00	; 0
    410a:	a9 01       	movw	r20, r18
    410c:	20 e0       	ldi	r18, 0x00	; 0
    410e:	30 e0       	ldi	r19, 0x00	; 0
    4110:	00 e0       	ldi	r16, 0x00	; 0
    4112:	10 e0       	ldi	r17, 0x00	; 0
    4114:	0e 94 8a 1c 	call	0x3914	; 0x3914 <xTimerGenericCommand>
				}
			}
			vTaskDelay(100);
    4118:	84 e6       	ldi	r24, 0x64	; 100
    411a:	90 e0       	ldi	r25, 0x00	; 0
    411c:	0e 94 a8 14 	call	0x2950	; 0x2950 <vTaskDelay>
    4120:	a9 cf       	rjmp	.-174    	; 0x4074 <task1+0xc>

00004122 <task2>:
		}
}
void task2()
{
    4122:	0f 93       	push	r16
    4124:	1f 93       	push	r17
    4126:	df 93       	push	r29
    4128:	cf 93       	push	r28
    412a:	cd b7       	in	r28, 0x3d	; 61
    412c:	de b7       	in	r29, 0x3e	; 62
	while (1)
	{
		if (BUTTON_udtbuttonStatus(BUTTON0)==PRESSED)
    412e:	80 e0       	ldi	r24, 0x00	; 0
    4130:	0e 94 a8 2b 	call	0x5750	; 0x5750 <BUTTON_udtbuttonStatus>
    4134:	81 30       	cpi	r24, 0x01	; 1
    4136:	09 f0       	breq	.+2      	; 0x413a <task2+0x18>
    4138:	4c c0       	rjmp	.+152    	; 0x41d2 <task2+0xb0>
		{
			if (mode==0)
    413a:	80 91 30 07 	lds	r24, 0x0730
    413e:	90 91 31 07 	lds	r25, 0x0731
    4142:	00 97       	sbiw	r24, 0x00	; 0
    4144:	d9 f4       	brne	.+54     	; 0x417c <task2+0x5a>
			{
				vTaskDelay(250);
    4146:	8a ef       	ldi	r24, 0xFA	; 250
    4148:	90 e0       	ldi	r25, 0x00	; 0
    414a:	0e 94 a8 14 	call	0x2950	; 0x2950 <vTaskDelay>
				mode=1;
    414e:	81 e0       	ldi	r24, 0x01	; 1
    4150:	90 e0       	ldi	r25, 0x00	; 0
    4152:	90 93 31 07 	sts	0x0731, r25
    4156:	80 93 30 07 	sts	0x0730, r24
				xTimerReset(timer1handler,0);
    415a:	00 91 2e 07 	lds	r16, 0x072E
    415e:	10 91 2f 07 	lds	r17, 0x072F
    4162:	0e 94 c6 17 	call	0x2f8c	; 0x2f8c <xTaskGetTickCount>
    4166:	9c 01       	movw	r18, r24
    4168:	c8 01       	movw	r24, r16
    416a:	60 e0       	ldi	r22, 0x00	; 0
    416c:	a9 01       	movw	r20, r18
    416e:	20 e0       	ldi	r18, 0x00	; 0
    4170:	30 e0       	ldi	r19, 0x00	; 0
    4172:	00 e0       	ldi	r16, 0x00	; 0
    4174:	10 e0       	ldi	r17, 0x00	; 0
    4176:	0e 94 8a 1c 	call	0x3914	; 0x3914 <xTimerGenericCommand>
    417a:	2b c0       	rjmp	.+86     	; 0x41d2 <task2+0xb0>
			}
			else if (mode==1)
    417c:	80 91 30 07 	lds	r24, 0x0730
    4180:	90 91 31 07 	lds	r25, 0x0731
    4184:	81 30       	cpi	r24, 0x01	; 1
    4186:	91 05       	cpc	r25, r1
    4188:	21 f5       	brne	.+72     	; 0x41d2 <task2+0xb0>
			{
				vTaskDelay(250);
    418a:	8a ef       	ldi	r24, 0xFA	; 250
    418c:	90 e0       	ldi	r25, 0x00	; 0
    418e:	0e 94 a8 14 	call	0x2950	; 0x2950 <vTaskDelay>
				if (num<75)
    4192:	80 91 a1 01 	lds	r24, 0x01A1
    4196:	90 91 a2 01 	lds	r25, 0x01A2
    419a:	8b 34       	cpi	r24, 0x4B	; 75
    419c:	91 05       	cpc	r25, r1
    419e:	4c f4       	brge	.+18     	; 0x41b2 <task2+0x90>
				{
					num=num+5;
    41a0:	80 91 a1 01 	lds	r24, 0x01A1
    41a4:	90 91 a2 01 	lds	r25, 0x01A2
    41a8:	05 96       	adiw	r24, 0x05	; 5
    41aa:	90 93 a2 01 	sts	0x01A2, r25
    41ae:	80 93 a1 01 	sts	0x01A1, r24
					// H_AT24C16A_Void_EEPROMWrite(num,5,145);
				}
				xTimerReset(timer1handler,0);
    41b2:	00 91 2e 07 	lds	r16, 0x072E
    41b6:	10 91 2f 07 	lds	r17, 0x072F
    41ba:	0e 94 c6 17 	call	0x2f8c	; 0x2f8c <xTaskGetTickCount>
    41be:	9c 01       	movw	r18, r24
    41c0:	c8 01       	movw	r24, r16
    41c2:	60 e0       	ldi	r22, 0x00	; 0
    41c4:	a9 01       	movw	r20, r18
    41c6:	20 e0       	ldi	r18, 0x00	; 0
    41c8:	30 e0       	ldi	r19, 0x00	; 0
    41ca:	00 e0       	ldi	r16, 0x00	; 0
    41cc:	10 e0       	ldi	r17, 0x00	; 0
    41ce:	0e 94 8a 1c 	call	0x3914	; 0x3914 <xTimerGenericCommand>
			}
		}
		vTaskDelay(100);
    41d2:	84 e6       	ldi	r24, 0x64	; 100
    41d4:	90 e0       	ldi	r25, 0x00	; 0
    41d6:	0e 94 a8 14 	call	0x2950	; 0x2950 <vTaskDelay>
    41da:	a9 cf       	rjmp	.-174    	; 0x412e <task2+0xc>

000041dc <task3>:
	}
}
void task3()
{
    41dc:	df 93       	push	r29
    41de:	cf 93       	push	r28
    41e0:	cd b7       	in	r28, 0x3d	; 61
    41e2:	de b7       	in	r29, 0x3e	; 62
		while (1)
		{
			if (mode == 1)
    41e4:	80 91 30 07 	lds	r24, 0x0730
    41e8:	90 91 31 07 	lds	r25, 0x0731
    41ec:	81 30       	cpi	r24, 0x01	; 1
    41ee:	91 05       	cpc	r25, r1
    41f0:	79 f4       	brne	.+30     	; 0x4210 <task3+0x34>
			{
				SSD_vidDelayDisplay(num,1000);
    41f2:	80 91 a1 01 	lds	r24, 0x01A1
    41f6:	90 91 a2 01 	lds	r25, 0x01A2
    41fa:	68 ee       	ldi	r22, 0xE8	; 232
    41fc:	73 e0       	ldi	r23, 0x03	; 3
    41fe:	0e 94 0d 23 	call	0x461a	; 0x461a <SSD_vidDelayDisplay>
				SSD_vidDisableSSD();
    4202:	0e 94 fc 22 	call	0x45f8	; 0x45f8 <SSD_vidDisableSSD>
				vTaskDelay(1000);
    4206:	88 ee       	ldi	r24, 0xE8	; 232
    4208:	93 e0       	ldi	r25, 0x03	; 3
    420a:	0e 94 a8 14 	call	0x2950	; 0x2950 <vTaskDelay>
    420e:	ea cf       	rjmp	.-44     	; 0x41e4 <task3+0x8>
			}
			else if (mode==0)
    4210:	80 91 30 07 	lds	r24, 0x0730
    4214:	90 91 31 07 	lds	r25, 0x0731
    4218:	00 97       	sbiw	r24, 0x00	; 0
    421a:	21 f7       	brne	.-56     	; 0x41e4 <task3+0x8>
			{
				SSD_viddispNum(avgTemp);
    421c:	80 91 32 07 	lds	r24, 0x0732
    4220:	90 91 33 07 	lds	r25, 0x0733
    4224:	0e 94 b8 22 	call	0x4570	; 0x4570 <SSD_viddispNum>
    4228:	dd cf       	rjmp	.-70     	; 0x41e4 <task3+0x8>

0000422a <task4>:
			}
		}
}

void task4()
{
    422a:	df 93       	push	r29
    422c:	cf 93       	push	r28
    422e:	cd b7       	in	r28, 0x3d	; 61
    4230:	de b7       	in	r29, 0x3e	; 62
	while (1)
	{
		if (avgTemp<(num-5))
    4232:	80 91 a1 01 	lds	r24, 0x01A1
    4236:	90 91 a2 01 	lds	r25, 0x01A2
    423a:	9c 01       	movw	r18, r24
    423c:	25 50       	subi	r18, 0x05	; 5
    423e:	30 40       	sbci	r19, 0x00	; 0
    4240:	80 91 32 07 	lds	r24, 0x0732
    4244:	90 91 33 07 	lds	r25, 0x0733
    4248:	82 17       	cp	r24, r18
    424a:	93 07       	cpc	r25, r19
    424c:	84 f4       	brge	.+32     	; 0x426e <task4+0x44>
		{
			RELAY_vidrelayOn();
    424e:	0e 94 5e 23 	call	0x46bc	; 0x46bc <RELAY_vidrelayOn>
			LED_vidledOn(LED0);
    4252:	80 e0       	ldi	r24, 0x00	; 0
    4254:	0e 94 e4 23 	call	0x47c8	; 0x47c8 <LED_vidledOn>
			LED_vidledOff(LED1);
    4258:	81 e0       	ldi	r24, 0x01	; 1
    425a:	0e 94 15 24 	call	0x482a	; 0x482a <LED_vidledOff>
			vTaskDelay(1000);
    425e:	88 ee       	ldi	r24, 0xE8	; 232
    4260:	93 e0       	ldi	r25, 0x03	; 3
    4262:	0e 94 a8 14 	call	0x2950	; 0x2950 <vTaskDelay>
			LED_vidledOff(LED0);
    4266:	80 e0       	ldi	r24, 0x00	; 0
    4268:	0e 94 15 24 	call	0x482a	; 0x482a <LED_vidledOff>
    426c:	16 c0       	rjmp	.+44     	; 0x429a <task4+0x70>
		}
		else if (avgTemp>(num+5))
    426e:	80 91 a1 01 	lds	r24, 0x01A1
    4272:	90 91 a2 01 	lds	r25, 0x01A2
    4276:	9c 01       	movw	r18, r24
    4278:	2b 5f       	subi	r18, 0xFB	; 251
    427a:	3f 4f       	sbci	r19, 0xFF	; 255
    427c:	80 91 32 07 	lds	r24, 0x0732
    4280:	90 91 33 07 	lds	r25, 0x0733
    4284:	28 17       	cp	r18, r24
    4286:	39 07       	cpc	r19, r25
    4288:	44 f4       	brge	.+16     	; 0x429a <task4+0x70>
		{
			RELAY_vidrelayOff();
    428a:	0e 94 6a 23 	call	0x46d4	; 0x46d4 <RELAY_vidrelayOff>
			LED_vidledOff(LED0);
    428e:	80 e0       	ldi	r24, 0x00	; 0
    4290:	0e 94 15 24 	call	0x482a	; 0x482a <LED_vidledOff>
			LED_vidledOn(LED1);
    4294:	81 e0       	ldi	r24, 0x01	; 1
    4296:	0e 94 e4 23 	call	0x47c8	; 0x47c8 <LED_vidledOn>
		}
		vTaskDelay(1000);
    429a:	88 ee       	ldi	r24, 0xE8	; 232
    429c:	93 e0       	ldi	r25, 0x03	; 3
    429e:	0e 94 a8 14 	call	0x2950	; 0x2950 <vTaskDelay>
    42a2:	c7 cf       	rjmp	.-114    	; 0x4232 <task4+0x8>

000042a4 <task5>:
	}
}
int task5(void)
{
    42a4:	0f 93       	push	r16
    42a6:	1f 93       	push	r17
    42a8:	df 93       	push	r29
    42aa:	cf 93       	push	r28
    42ac:	cd b7       	in	r28, 0x3d	; 61
    42ae:	de b7       	in	r29, 0x3e	; 62
    42b0:	2d 97       	sbiw	r28, 0x0d	; 13
    42b2:	0f b6       	in	r0, 0x3f	; 63
    42b4:	f8 94       	cli
    42b6:	de bf       	out	0x3e, r29	; 62
    42b8:	0f be       	out	0x3f, r0	; 63
    42ba:	cd bf       	out	0x3d, r28	; 61
	u16 temp;
	u8 tempArr[10] = {};
    42bc:	8a e0       	ldi	r24, 0x0A	; 10
    42be:	fe 01       	movw	r30, r28
    42c0:	34 96       	adiw	r30, 0x04	; 4
    42c2:	df 01       	movw	r26, r30
    42c4:	98 2f       	mov	r25, r24
    42c6:	1d 92       	st	X+, r1
    42c8:	9a 95       	dec	r25
    42ca:	e9 f7       	brne	.-6      	; 0x42c6 <task5+0x22>

	while (1)
	{
		temp = 0;
    42cc:	1b 82       	std	Y+3, r1	; 0x03
    42ce:	1a 82       	std	Y+2, r1	; 0x02
		for (u8 i = 0;i < 10;i++)
    42d0:	19 82       	std	Y+1, r1	; 0x01
    42d2:	2c c0       	rjmp	.+88     	; 0x432c <task5+0x88>
		{
			tempArr[i] = H_LM35_Void_LM35Read();
    42d4:	89 81       	ldd	r24, Y+1	; 0x01
    42d6:	08 2f       	mov	r16, r24
    42d8:	10 e0       	ldi	r17, 0x00	; 0
    42da:	0e 94 7f 23 	call	0x46fe	; 0x46fe <H_LM35_Void_LM35Read>
    42de:	dc 01       	movw	r26, r24
    42e0:	cb 01       	movw	r24, r22
    42e2:	bc 01       	movw	r22, r24
    42e4:	cd 01       	movw	r24, r26
    42e6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    42ea:	dc 01       	movw	r26, r24
    42ec:	cb 01       	movw	r24, r22
    42ee:	28 2f       	mov	r18, r24
    42f0:	ce 01       	movw	r24, r28
    42f2:	04 96       	adiw	r24, 0x04	; 4
    42f4:	fc 01       	movw	r30, r24
    42f6:	e0 0f       	add	r30, r16
    42f8:	f1 1f       	adc	r31, r17
    42fa:	20 83       	st	Z, r18
			temp = temp + tempArr[i];
    42fc:	89 81       	ldd	r24, Y+1	; 0x01
    42fe:	28 2f       	mov	r18, r24
    4300:	30 e0       	ldi	r19, 0x00	; 0
    4302:	ce 01       	movw	r24, r28
    4304:	04 96       	adiw	r24, 0x04	; 4
    4306:	fc 01       	movw	r30, r24
    4308:	e2 0f       	add	r30, r18
    430a:	f3 1f       	adc	r31, r19
    430c:	80 81       	ld	r24, Z
    430e:	28 2f       	mov	r18, r24
    4310:	30 e0       	ldi	r19, 0x00	; 0
    4312:	8a 81       	ldd	r24, Y+2	; 0x02
    4314:	9b 81       	ldd	r25, Y+3	; 0x03
    4316:	82 0f       	add	r24, r18
    4318:	93 1f       	adc	r25, r19
    431a:	9b 83       	std	Y+3, r25	; 0x03
    431c:	8a 83       	std	Y+2, r24	; 0x02
			vTaskDelay(100);
    431e:	84 e6       	ldi	r24, 0x64	; 100
    4320:	90 e0       	ldi	r25, 0x00	; 0
    4322:	0e 94 a8 14 	call	0x2950	; 0x2950 <vTaskDelay>
	u8 tempArr[10] = {};

	while (1)
	{
		temp = 0;
		for (u8 i = 0;i < 10;i++)
    4326:	89 81       	ldd	r24, Y+1	; 0x01
    4328:	8f 5f       	subi	r24, 0xFF	; 255
    432a:	89 83       	std	Y+1, r24	; 0x01
    432c:	89 81       	ldd	r24, Y+1	; 0x01
    432e:	8a 30       	cpi	r24, 0x0A	; 10
    4330:	88 f2       	brcs	.-94     	; 0x42d4 <task5+0x30>
		{
			tempArr[i] = H_LM35_Void_LM35Read();
			temp = temp + tempArr[i];
			vTaskDelay(100);
		}
		avgTemp = temp/10;
    4332:	8a 81       	ldd	r24, Y+2	; 0x02
    4334:	9b 81       	ldd	r25, Y+3	; 0x03
    4336:	2a e0       	ldi	r18, 0x0A	; 10
    4338:	30 e0       	ldi	r19, 0x00	; 0
    433a:	b9 01       	movw	r22, r18
    433c:	0e 94 08 34 	call	0x6810	; 0x6810 <__udivmodhi4>
    4340:	cb 01       	movw	r24, r22
    4342:	90 93 33 07 	sts	0x0733, r25
    4346:	80 93 32 07 	sts	0x0732, r24
		temp=0;
    434a:	1b 82       	std	Y+3, r1	; 0x03
    434c:	1a 82       	std	Y+2, r1	; 0x02
    434e:	be cf       	rjmp	.-132    	; 0x42cc <task5+0x28>

00004350 <vTimerCallback>:

}


 void vTimerCallback( xTimerHandle xTimer )
 {
    4350:	df 93       	push	r29
    4352:	cf 93       	push	r28
    4354:	00 d0       	rcall	.+0      	; 0x4356 <vTimerCallback+0x6>
    4356:	cd b7       	in	r28, 0x3d	; 61
    4358:	de b7       	in	r29, 0x3e	; 62
    435a:	9a 83       	std	Y+2, r25	; 0x02
    435c:	89 83       	std	Y+1, r24	; 0x01
	 mode=0;
    435e:	10 92 31 07 	sts	0x0731, r1
    4362:	10 92 30 07 	sts	0x0730, r1
 }
    4366:	0f 90       	pop	r0
    4368:	0f 90       	pop	r0
    436a:	cf 91       	pop	r28
    436c:	df 91       	pop	r29
    436e:	08 95       	ret

00004370 <main>:



int main(void)
{
    4370:	af 92       	push	r10
    4372:	bf 92       	push	r11
    4374:	cf 92       	push	r12
    4376:	df 92       	push	r13
    4378:	ef 92       	push	r14
    437a:	ff 92       	push	r15
    437c:	0f 93       	push	r16
    437e:	1f 93       	push	r17
    4380:	df 93       	push	r29
    4382:	cf 93       	push	r28
    4384:	cd b7       	in	r28, 0x3d	; 61
    4386:	de b7       	in	r29, 0x3e	; 62
	// H_AT24C16A_Void_EEPROMInit();
	// M_I2C_Void_I2CInit();
	RELAY_vidrelayInit();
    4388:	0e 94 52 23 	call	0x46a4	; 0x46a4 <RELAY_vidrelayInit>
	SSD_vidssdInit();
    438c:	0e 94 93 22 	call	0x4526	; 0x4526 <SSD_vidssdInit>
	LED_vidledInit();
    4390:	0e 94 ce 23 	call	0x479c	; 0x479c <LED_vidledInit>
	BUTTON_vidbuttonInit();
    4394:	0e 94 92 2b 	call	0x5724	; 0x5724 <BUTTON_vidbuttonInit>
	ADC_Init();
    4398:	0e 94 89 33 	call	0x6712	; 0x6712 <ADC_Init>
	// num = H_AT24C16A_Void_EEPROMRead(5,145);


	task1handler=xTaskCreate(task1,"task1",85,NULL,2,task1handler);
    439c:	24 e3       	ldi	r18, 0x34	; 52
    439e:	30 e2       	ldi	r19, 0x20	; 32
    43a0:	4d e6       	ldi	r20, 0x6D	; 109
    43a2:	50 e0       	ldi	r21, 0x00	; 0
    43a4:	80 91 24 07 	lds	r24, 0x0724
    43a8:	90 91 25 07 	lds	r25, 0x0725
    43ac:	fc 01       	movw	r30, r24
    43ae:	c9 01       	movw	r24, r18
    43b0:	ba 01       	movw	r22, r20
    43b2:	45 e5       	ldi	r20, 0x55	; 85
    43b4:	50 e0       	ldi	r21, 0x00	; 0
    43b6:	20 e0       	ldi	r18, 0x00	; 0
    43b8:	30 e0       	ldi	r19, 0x00	; 0
    43ba:	02 e0       	ldi	r16, 0x02	; 2
    43bc:	7f 01       	movw	r14, r30
    43be:	cc 24       	eor	r12, r12
    43c0:	dd 24       	eor	r13, r13
    43c2:	aa 24       	eor	r10, r10
    43c4:	bb 24       	eor	r11, r11
    43c6:	0e 94 47 13 	call	0x268e	; 0x268e <xTaskGenericCreate>
    43ca:	99 27       	eor	r25, r25
    43cc:	87 fd       	sbrc	r24, 7
    43ce:	90 95       	com	r25
    43d0:	90 93 25 07 	sts	0x0725, r25
    43d4:	80 93 24 07 	sts	0x0724, r24
	task2handler=xTaskCreate(task2,"task2",85,NULL,2,task2handler);
    43d8:	21 e9       	ldi	r18, 0x91	; 145
    43da:	30 e2       	ldi	r19, 0x20	; 32
    43dc:	43 e7       	ldi	r20, 0x73	; 115
    43de:	50 e0       	ldi	r21, 0x00	; 0
    43e0:	80 91 26 07 	lds	r24, 0x0726
    43e4:	90 91 27 07 	lds	r25, 0x0727
    43e8:	fc 01       	movw	r30, r24
    43ea:	c9 01       	movw	r24, r18
    43ec:	ba 01       	movw	r22, r20
    43ee:	45 e5       	ldi	r20, 0x55	; 85
    43f0:	50 e0       	ldi	r21, 0x00	; 0
    43f2:	20 e0       	ldi	r18, 0x00	; 0
    43f4:	30 e0       	ldi	r19, 0x00	; 0
    43f6:	02 e0       	ldi	r16, 0x02	; 2
    43f8:	7f 01       	movw	r14, r30
    43fa:	cc 24       	eor	r12, r12
    43fc:	dd 24       	eor	r13, r13
    43fe:	aa 24       	eor	r10, r10
    4400:	bb 24       	eor	r11, r11
    4402:	0e 94 47 13 	call	0x268e	; 0x268e <xTaskGenericCreate>
    4406:	99 27       	eor	r25, r25
    4408:	87 fd       	sbrc	r24, 7
    440a:	90 95       	com	r25
    440c:	90 93 27 07 	sts	0x0727, r25
    4410:	80 93 26 07 	sts	0x0726, r24
	task3handler=xTaskCreate(task3,"task3",85,NULL,4,task3handler);
    4414:	2e ee       	ldi	r18, 0xEE	; 238
    4416:	30 e2       	ldi	r19, 0x20	; 32
    4418:	49 e7       	ldi	r20, 0x79	; 121
    441a:	50 e0       	ldi	r21, 0x00	; 0
    441c:	80 91 28 07 	lds	r24, 0x0728
    4420:	90 91 29 07 	lds	r25, 0x0729
    4424:	fc 01       	movw	r30, r24
    4426:	c9 01       	movw	r24, r18
    4428:	ba 01       	movw	r22, r20
    442a:	45 e5       	ldi	r20, 0x55	; 85
    442c:	50 e0       	ldi	r21, 0x00	; 0
    442e:	20 e0       	ldi	r18, 0x00	; 0
    4430:	30 e0       	ldi	r19, 0x00	; 0
    4432:	04 e0       	ldi	r16, 0x04	; 4
    4434:	7f 01       	movw	r14, r30
    4436:	cc 24       	eor	r12, r12
    4438:	dd 24       	eor	r13, r13
    443a:	aa 24       	eor	r10, r10
    443c:	bb 24       	eor	r11, r11
    443e:	0e 94 47 13 	call	0x268e	; 0x268e <xTaskGenericCreate>
    4442:	99 27       	eor	r25, r25
    4444:	87 fd       	sbrc	r24, 7
    4446:	90 95       	com	r25
    4448:	90 93 29 07 	sts	0x0729, r25
    444c:	80 93 28 07 	sts	0x0728, r24
	task4handler=xTaskCreate(task4,"task4",85,NULL,1,task4handler);
    4450:	25 e1       	ldi	r18, 0x15	; 21
    4452:	31 e2       	ldi	r19, 0x21	; 33
    4454:	4f e7       	ldi	r20, 0x7F	; 127
    4456:	50 e0       	ldi	r21, 0x00	; 0
    4458:	80 91 2a 07 	lds	r24, 0x072A
    445c:	90 91 2b 07 	lds	r25, 0x072B
    4460:	fc 01       	movw	r30, r24
    4462:	c9 01       	movw	r24, r18
    4464:	ba 01       	movw	r22, r20
    4466:	45 e5       	ldi	r20, 0x55	; 85
    4468:	50 e0       	ldi	r21, 0x00	; 0
    446a:	20 e0       	ldi	r18, 0x00	; 0
    446c:	30 e0       	ldi	r19, 0x00	; 0
    446e:	01 e0       	ldi	r16, 0x01	; 1
    4470:	7f 01       	movw	r14, r30
    4472:	cc 24       	eor	r12, r12
    4474:	dd 24       	eor	r13, r13
    4476:	aa 24       	eor	r10, r10
    4478:	bb 24       	eor	r11, r11
    447a:	0e 94 47 13 	call	0x268e	; 0x268e <xTaskGenericCreate>
    447e:	99 27       	eor	r25, r25
    4480:	87 fd       	sbrc	r24, 7
    4482:	90 95       	com	r25
    4484:	90 93 2b 07 	sts	0x072B, r25
    4488:	80 93 2a 07 	sts	0x072A, r24
	task5handler=xTaskCreate(task5,"task5",85,NULL,5,task5handler);
    448c:	22 e5       	ldi	r18, 0x52	; 82
    448e:	31 e2       	ldi	r19, 0x21	; 33
    4490:	45 e8       	ldi	r20, 0x85	; 133
    4492:	50 e0       	ldi	r21, 0x00	; 0
    4494:	80 91 2c 07 	lds	r24, 0x072C
    4498:	90 91 2d 07 	lds	r25, 0x072D
    449c:	fc 01       	movw	r30, r24
    449e:	c9 01       	movw	r24, r18
    44a0:	ba 01       	movw	r22, r20
    44a2:	45 e5       	ldi	r20, 0x55	; 85
    44a4:	50 e0       	ldi	r21, 0x00	; 0
    44a6:	20 e0       	ldi	r18, 0x00	; 0
    44a8:	30 e0       	ldi	r19, 0x00	; 0
    44aa:	05 e0       	ldi	r16, 0x05	; 5
    44ac:	7f 01       	movw	r14, r30
    44ae:	cc 24       	eor	r12, r12
    44b0:	dd 24       	eor	r13, r13
    44b2:	aa 24       	eor	r10, r10
    44b4:	bb 24       	eor	r11, r11
    44b6:	0e 94 47 13 	call	0x268e	; 0x268e <xTaskGenericCreate>
    44ba:	99 27       	eor	r25, r25
    44bc:	87 fd       	sbrc	r24, 7
    44be:	90 95       	com	r25
    44c0:	90 93 2d 07 	sts	0x072D, r25
    44c4:	80 93 2c 07 	sts	0x072C, r24
	timer1handler = xTimerCreate("Timer",5000,pdFALSE,( void * ) 1,vTimerCallback);
    44c8:	8b e8       	ldi	r24, 0x8B	; 139
    44ca:	90 e0       	ldi	r25, 0x00	; 0
    44cc:	e8 ea       	ldi	r30, 0xA8	; 168
    44ce:	f1 e2       	ldi	r31, 0x21	; 33
    44d0:	68 e8       	ldi	r22, 0x88	; 136
    44d2:	73 e1       	ldi	r23, 0x13	; 19
    44d4:	40 e0       	ldi	r20, 0x00	; 0
    44d6:	21 e0       	ldi	r18, 0x01	; 1
    44d8:	30 e0       	ldi	r19, 0x00	; 0
    44da:	8f 01       	movw	r16, r30
    44dc:	0e 94 34 1c 	call	0x3868	; 0x3868 <xTimerCreate>
    44e0:	90 93 2f 07 	sts	0x072F, r25
    44e4:	80 93 2e 07 	sts	0x072E, r24
	xTimerStart(timer1handler,0);
    44e8:	00 91 2e 07 	lds	r16, 0x072E
    44ec:	10 91 2f 07 	lds	r17, 0x072F
    44f0:	0e 94 c6 17 	call	0x2f8c	; 0x2f8c <xTaskGetTickCount>
    44f4:	9c 01       	movw	r18, r24
    44f6:	c8 01       	movw	r24, r16
    44f8:	60 e0       	ldi	r22, 0x00	; 0
    44fa:	a9 01       	movw	r20, r18
    44fc:	20 e0       	ldi	r18, 0x00	; 0
    44fe:	30 e0       	ldi	r19, 0x00	; 0
    4500:	00 e0       	ldi	r16, 0x00	; 0
    4502:	10 e0       	ldi	r17, 0x00	; 0
    4504:	0e 94 8a 1c 	call	0x3914	; 0x3914 <xTimerGenericCommand>


	vTaskStartScheduler();
    4508:	0e 94 e9 16 	call	0x2dd2	; 0x2dd2 <vTaskStartScheduler>
    450c:	80 e0       	ldi	r24, 0x00	; 0
    450e:	90 e0       	ldi	r25, 0x00	; 0
}
    4510:	cf 91       	pop	r28
    4512:	df 91       	pop	r29
    4514:	1f 91       	pop	r17
    4516:	0f 91       	pop	r16
    4518:	ff 90       	pop	r15
    451a:	ef 90       	pop	r14
    451c:	df 90       	pop	r13
    451e:	cf 90       	pop	r12
    4520:	bf 90       	pop	r11
    4522:	af 90       	pop	r10
    4524:	08 95       	ret

00004526 <SSD_vidssdInit>:
#include "FreeRTOS.h"
#include "FreeRTOSConfig.h"
#include <util/delay.h>

void SSD_vidssdInit(void)
{
    4526:	df 93       	push	r29
    4528:	cf 93       	push	r28
    452a:	cd b7       	in	r28, 0x3d	; 61
    452c:	de b7       	in	r29, 0x3e	; 62
	Dio_vidconfigChannel(DIO_PORTB,DIO_PIN1,DIO_OUTPUT);
    452e:	81 e0       	ldi	r24, 0x01	; 1
    4530:	61 e0       	ldi	r22, 0x01	; 1
    4532:	41 e0       	ldi	r20, 0x01	; 1
    4534:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTB,DIO_PIN2,DIO_OUTPUT);
    4538:	81 e0       	ldi	r24, 0x01	; 1
    453a:	62 e0       	ldi	r22, 0x02	; 2
    453c:	41 e0       	ldi	r20, 0x01	; 1
    453e:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>

	Dio_vidconfigChannel(DIO_PORTA,DIO_PIN4,DIO_OUTPUT);
    4542:	80 e0       	ldi	r24, 0x00	; 0
    4544:	64 e0       	ldi	r22, 0x04	; 4
    4546:	41 e0       	ldi	r20, 0x01	; 1
    4548:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTA,DIO_PIN5,DIO_OUTPUT);
    454c:	80 e0       	ldi	r24, 0x00	; 0
    454e:	65 e0       	ldi	r22, 0x05	; 5
    4550:	41 e0       	ldi	r20, 0x01	; 1
    4552:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTA,DIO_PIN6,DIO_OUTPUT);
    4556:	80 e0       	ldi	r24, 0x00	; 0
    4558:	66 e0       	ldi	r22, 0x06	; 6
    455a:	41 e0       	ldi	r20, 0x01	; 1
    455c:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTA,DIO_PIN7,DIO_OUTPUT);
    4560:	80 e0       	ldi	r24, 0x00	; 0
    4562:	67 e0       	ldi	r22, 0x07	; 7
    4564:	41 e0       	ldi	r20, 0x01	; 1
    4566:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>
}
    456a:	cf 91       	pop	r28
    456c:	df 91       	pop	r29
    456e:	08 95       	ret

00004570 <SSD_viddispNum>:
void SSD_viddispNum(u8 num)
{
    4570:	df 93       	push	r29
    4572:	cf 93       	push	r28
    4574:	00 d0       	rcall	.+0      	; 0x4576 <SSD_viddispNum+0x6>
    4576:	0f 92       	push	r0
    4578:	cd b7       	in	r28, 0x3d	; 61
    457a:	de b7       	in	r29, 0x3e	; 62
    457c:	8b 83       	std	Y+3, r24	; 0x03
	u8 loc_firstDigit =  (num/10)<<4;
    457e:	8b 81       	ldd	r24, Y+3	; 0x03
    4580:	9a e0       	ldi	r25, 0x0A	; 10
    4582:	69 2f       	mov	r22, r25
    4584:	0e 94 fc 33 	call	0x67f8	; 0x67f8 <__udivmodqi4>
    4588:	82 95       	swap	r24
    458a:	80 7f       	andi	r24, 0xF0	; 240
    458c:	8a 83       	std	Y+2, r24	; 0x02
	u8 loc_secondDigit = (num%10)<<4;
    458e:	8b 81       	ldd	r24, Y+3	; 0x03
    4590:	9a e0       	ldi	r25, 0x0A	; 10
    4592:	69 2f       	mov	r22, r25
    4594:	0e 94 fc 33 	call	0x67f8	; 0x67f8 <__udivmodqi4>
    4598:	89 2f       	mov	r24, r25
    459a:	82 95       	swap	r24
    459c:	80 7f       	andi	r24, 0xF0	; 240
    459e:	89 83       	std	Y+1, r24	; 0x01

	/* Enable SSD1 */
	Dio_vidwriteChannel(DIO_PORTB,DIO_PIN1,DIO_HIGH);
    45a0:	81 e0       	ldi	r24, 0x01	; 1
    45a2:	61 e0       	ldi	r22, 0x01	; 1
    45a4:	41 e0       	ldi	r20, 0x01	; 1
    45a6:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
	/* Disable SSD2 */
	Dio_vidwriteChannel(DIO_PORTB,DIO_PIN2,DIO_LOW);
    45aa:	81 e0       	ldi	r24, 0x01	; 1
    45ac:	62 e0       	ldi	r22, 0x02	; 2
    45ae:	40 e0       	ldi	r20, 0x00	; 0
    45b0:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
	/* Write first digit */
	Dio_vidwriteChannelGroup(DIO_PORTA,loc_secondDigit,SSD_MASK);
    45b4:	80 e0       	ldi	r24, 0x00	; 0
    45b6:	69 81       	ldd	r22, Y+1	; 0x01
    45b8:	4f e0       	ldi	r20, 0x0F	; 15
    45ba:	0e 94 2d 33 	call	0x665a	; 0x665a <Dio_vidwriteChannelGroup>

	vTaskDelay(10);
    45be:	8a e0       	ldi	r24, 0x0A	; 10
    45c0:	90 e0       	ldi	r25, 0x00	; 0
    45c2:	0e 94 a8 14 	call	0x2950	; 0x2950 <vTaskDelay>

	/* Enable SSD2 */
	Dio_vidwriteChannel(DIO_PORTB,DIO_PIN2,DIO_HIGH);
    45c6:	81 e0       	ldi	r24, 0x01	; 1
    45c8:	62 e0       	ldi	r22, 0x02	; 2
    45ca:	41 e0       	ldi	r20, 0x01	; 1
    45cc:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
	/* Disable SSD1 */
	Dio_vidwriteChannel(DIO_PORTB,DIO_PIN1,DIO_LOW);
    45d0:	81 e0       	ldi	r24, 0x01	; 1
    45d2:	61 e0       	ldi	r22, 0x01	; 1
    45d4:	40 e0       	ldi	r20, 0x00	; 0
    45d6:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
	/* Write second digit */
	Dio_vidwriteChannelGroup(DIO_PORTA,loc_firstDigit,SSD_MASK);
    45da:	80 e0       	ldi	r24, 0x00	; 0
    45dc:	6a 81       	ldd	r22, Y+2	; 0x02
    45de:	4f e0       	ldi	r20, 0x0F	; 15
    45e0:	0e 94 2d 33 	call	0x665a	; 0x665a <Dio_vidwriteChannelGroup>

	vTaskDelay(10);
    45e4:	8a e0       	ldi	r24, 0x0A	; 10
    45e6:	90 e0       	ldi	r25, 0x00	; 0
    45e8:	0e 94 a8 14 	call	0x2950	; 0x2950 <vTaskDelay>
}
    45ec:	0f 90       	pop	r0
    45ee:	0f 90       	pop	r0
    45f0:	0f 90       	pop	r0
    45f2:	cf 91       	pop	r28
    45f4:	df 91       	pop	r29
    45f6:	08 95       	ret

000045f8 <SSD_vidDisableSSD>:

void SSD_vidDisableSSD(void)
{
    45f8:	df 93       	push	r29
    45fa:	cf 93       	push	r28
    45fc:	cd b7       	in	r28, 0x3d	; 61
    45fe:	de b7       	in	r29, 0x3e	; 62
	Dio_vidwriteChannel(DIO_PORTB,DIO_PIN2,DIO_LOW);
    4600:	81 e0       	ldi	r24, 0x01	; 1
    4602:	62 e0       	ldi	r22, 0x02	; 2
    4604:	40 e0       	ldi	r20, 0x00	; 0
    4606:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
	Dio_vidwriteChannel(DIO_PORTB,DIO_PIN1,DIO_LOW);
    460a:	81 e0       	ldi	r24, 0x01	; 1
    460c:	61 e0       	ldi	r22, 0x01	; 1
    460e:	40 e0       	ldi	r20, 0x00	; 0
    4610:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
}
    4614:	cf 91       	pop	r28
    4616:	df 91       	pop	r29
    4618:	08 95       	ret

0000461a <SSD_vidDelayDisplay>:

void SSD_vidDelayDisplay(u8 num,u16 delay)
{
    461a:	df 93       	push	r29
    461c:	cf 93       	push	r28
    461e:	cd b7       	in	r28, 0x3d	; 61
    4620:	de b7       	in	r29, 0x3e	; 62
    4622:	27 97       	sbiw	r28, 0x07	; 7
    4624:	0f b6       	in	r0, 0x3f	; 63
    4626:	f8 94       	cli
    4628:	de bf       	out	0x3e, r29	; 62
    462a:	0f be       	out	0x3f, r0	; 63
    462c:	cd bf       	out	0x3d, r28	; 61
    462e:	8d 83       	std	Y+5, r24	; 0x05
    4630:	7f 83       	std	Y+7, r23	; 0x07
    4632:	6e 83       	std	Y+6, r22	; 0x06
	u16 counter;
	u16 real_delay = delay*0.049;
    4634:	8e 81       	ldd	r24, Y+6	; 0x06
    4636:	9f 81       	ldd	r25, Y+7	; 0x07
    4638:	cc 01       	movw	r24, r24
    463a:	a0 e0       	ldi	r26, 0x00	; 0
    463c:	b0 e0       	ldi	r27, 0x00	; 0
    463e:	bc 01       	movw	r22, r24
    4640:	cd 01       	movw	r24, r26
    4642:	0e 94 a9 04 	call	0x952	; 0x952 <__floatunsisf>
    4646:	dc 01       	movw	r26, r24
    4648:	cb 01       	movw	r24, r22
    464a:	bc 01       	movw	r22, r24
    464c:	cd 01       	movw	r24, r26
    464e:	29 e3       	ldi	r18, 0x39	; 57
    4650:	34 eb       	ldi	r19, 0xB4	; 180
    4652:	48 e4       	ldi	r20, 0x48	; 72
    4654:	5d e3       	ldi	r21, 0x3D	; 61
    4656:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    465a:	dc 01       	movw	r26, r24
    465c:	cb 01       	movw	r24, r22
    465e:	bc 01       	movw	r22, r24
    4660:	cd 01       	movw	r24, r26
    4662:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4666:	dc 01       	movw	r26, r24
    4668:	cb 01       	movw	r24, r22
    466a:	9a 83       	std	Y+2, r25	; 0x02
    466c:	89 83       	std	Y+1, r24	; 0x01
	for (counter = 0; counter < real_delay;counter++)
    466e:	1c 82       	std	Y+4, r1	; 0x04
    4670:	1b 82       	std	Y+3, r1	; 0x03
    4672:	08 c0       	rjmp	.+16     	; 0x4684 <SSD_vidDelayDisplay+0x6a>
	{
		SSD_viddispNum(num);
    4674:	8d 81       	ldd	r24, Y+5	; 0x05
    4676:	0e 94 b8 22 	call	0x4570	; 0x4570 <SSD_viddispNum>

void SSD_vidDelayDisplay(u8 num,u16 delay)
{
	u16 counter;
	u16 real_delay = delay*0.049;
	for (counter = 0; counter < real_delay;counter++)
    467a:	8b 81       	ldd	r24, Y+3	; 0x03
    467c:	9c 81       	ldd	r25, Y+4	; 0x04
    467e:	01 96       	adiw	r24, 0x01	; 1
    4680:	9c 83       	std	Y+4, r25	; 0x04
    4682:	8b 83       	std	Y+3, r24	; 0x03
    4684:	2b 81       	ldd	r18, Y+3	; 0x03
    4686:	3c 81       	ldd	r19, Y+4	; 0x04
    4688:	89 81       	ldd	r24, Y+1	; 0x01
    468a:	9a 81       	ldd	r25, Y+2	; 0x02
    468c:	28 17       	cp	r18, r24
    468e:	39 07       	cpc	r19, r25
    4690:	88 f3       	brcs	.-30     	; 0x4674 <SSD_vidDelayDisplay+0x5a>
	{
		SSD_viddispNum(num);
	}
}
    4692:	27 96       	adiw	r28, 0x07	; 7
    4694:	0f b6       	in	r0, 0x3f	; 63
    4696:	f8 94       	cli
    4698:	de bf       	out	0x3e, r29	; 62
    469a:	0f be       	out	0x3f, r0	; 63
    469c:	cd bf       	out	0x3d, r28	; 61
    469e:	cf 91       	pop	r28
    46a0:	df 91       	pop	r29
    46a2:	08 95       	ret

000046a4 <RELAY_vidrelayInit>:
 *      Author: Khaled
 */
#include "RELAY.h"

void RELAY_vidrelayInit(void)
{
    46a4:	df 93       	push	r29
    46a6:	cf 93       	push	r28
    46a8:	cd b7       	in	r28, 0x3d	; 61
    46aa:	de b7       	in	r29, 0x3e	; 62
	Dio_vidconfigChannel(DIO_PORTA,DIO_PIN2,DIO_OUTPUT);
    46ac:	80 e0       	ldi	r24, 0x00	; 0
    46ae:	62 e0       	ldi	r22, 0x02	; 2
    46b0:	41 e0       	ldi	r20, 0x01	; 1
    46b2:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>
}
    46b6:	cf 91       	pop	r28
    46b8:	df 91       	pop	r29
    46ba:	08 95       	ret

000046bc <RELAY_vidrelayOn>:

void RELAY_vidrelayOn(void)
{
    46bc:	df 93       	push	r29
    46be:	cf 93       	push	r28
    46c0:	cd b7       	in	r28, 0x3d	; 61
    46c2:	de b7       	in	r29, 0x3e	; 62
	Dio_vidwriteChannel(DIO_PORTA,DIO_PIN2,DIO_HIGH);
    46c4:	80 e0       	ldi	r24, 0x00	; 0
    46c6:	62 e0       	ldi	r22, 0x02	; 2
    46c8:	41 e0       	ldi	r20, 0x01	; 1
    46ca:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
}
    46ce:	cf 91       	pop	r28
    46d0:	df 91       	pop	r29
    46d2:	08 95       	ret

000046d4 <RELAY_vidrelayOff>:

void RELAY_vidrelayOff(void)
{
    46d4:	df 93       	push	r29
    46d6:	cf 93       	push	r28
    46d8:	cd b7       	in	r28, 0x3d	; 61
    46da:	de b7       	in	r29, 0x3e	; 62
	Dio_vidwriteChannel(DIO_PORTA,DIO_PIN2,DIO_LOW);
    46dc:	80 e0       	ldi	r24, 0x00	; 0
    46de:	62 e0       	ldi	r22, 0x02	; 2
    46e0:	40 e0       	ldi	r20, 0x00	; 0
    46e2:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
}
    46e6:	cf 91       	pop	r28
    46e8:	df 91       	pop	r29
    46ea:	08 95       	ret

000046ec <Lm35_Init>:
 */
#include "LM35.h"
#include "ADC.h"

void Lm35_Init(void)
{
    46ec:	df 93       	push	r29
    46ee:	cf 93       	push	r28
    46f0:	cd b7       	in	r28, 0x3d	; 61
    46f2:	de b7       	in	r29, 0x3e	; 62
	ADC_Init();
    46f4:	0e 94 89 33 	call	0x6712	; 0x6712 <ADC_Init>
}
    46f8:	cf 91       	pop	r28
    46fa:	df 91       	pop	r29
    46fc:	08 95       	ret

000046fe <H_LM35_Void_LM35Read>:
f64  H_LM35_Void_LM35Read(void)
{
    46fe:	df 93       	push	r29
    4700:	cf 93       	push	r28
    4702:	cd b7       	in	r28, 0x3d	; 61
    4704:	de b7       	in	r29, 0x3e	; 62
    4706:	28 97       	sbiw	r28, 0x08	; 8
    4708:	0f b6       	in	r0, 0x3f	; 63
    470a:	f8 94       	cli
    470c:	de bf       	out	0x3e, r29	; 62
    470e:	0f be       	out	0x3f, r0	; 63
    4710:	cd bf       	out	0x3d, r28	; 61
	 f64 Local_U16_AdcValue = ADC_Read(ADC_CHNL0);
    4712:	80 e0       	ldi	r24, 0x00	; 0
    4714:	0e 94 9b 33 	call	0x6736	; 0x6736 <ADC_Read>
    4718:	cc 01       	movw	r24, r24
    471a:	a0 e0       	ldi	r26, 0x00	; 0
    471c:	b0 e0       	ldi	r27, 0x00	; 0
    471e:	bc 01       	movw	r22, r24
    4720:	cd 01       	movw	r24, r26
    4722:	0e 94 a9 04 	call	0x952	; 0x952 <__floatunsisf>
    4726:	dc 01       	movw	r26, r24
    4728:	cb 01       	movw	r24, r22
    472a:	8d 83       	std	Y+5, r24	; 0x05
    472c:	9e 83       	std	Y+6, r25	; 0x06
    472e:	af 83       	std	Y+7, r26	; 0x07
    4730:	b8 87       	std	Y+8, r27	; 0x08
	 f64 temp = ((u32)Local_U16_AdcValue * 500) / 1023;
    4732:	6d 81       	ldd	r22, Y+5	; 0x05
    4734:	7e 81       	ldd	r23, Y+6	; 0x06
    4736:	8f 81       	ldd	r24, Y+7	; 0x07
    4738:	98 85       	ldd	r25, Y+8	; 0x08
    473a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    473e:	dc 01       	movw	r26, r24
    4740:	cb 01       	movw	r24, r22
    4742:	24 ef       	ldi	r18, 0xF4	; 244
    4744:	31 e0       	ldi	r19, 0x01	; 1
    4746:	40 e0       	ldi	r20, 0x00	; 0
    4748:	50 e0       	ldi	r21, 0x00	; 0
    474a:	bc 01       	movw	r22, r24
    474c:	cd 01       	movw	r24, r26
    474e:	0e 94 dd 33 	call	0x67ba	; 0x67ba <__mulsi3>
    4752:	dc 01       	movw	r26, r24
    4754:	cb 01       	movw	r24, r22
    4756:	2f ef       	ldi	r18, 0xFF	; 255
    4758:	33 e0       	ldi	r19, 0x03	; 3
    475a:	40 e0       	ldi	r20, 0x00	; 0
    475c:	50 e0       	ldi	r21, 0x00	; 0
    475e:	bc 01       	movw	r22, r24
    4760:	cd 01       	movw	r24, r26
    4762:	0e 94 1c 34 	call	0x6838	; 0x6838 <__udivmodsi4>
    4766:	da 01       	movw	r26, r20
    4768:	c9 01       	movw	r24, r18
    476a:	bc 01       	movw	r22, r24
    476c:	cd 01       	movw	r24, r26
    476e:	0e 94 a9 04 	call	0x952	; 0x952 <__floatunsisf>
    4772:	dc 01       	movw	r26, r24
    4774:	cb 01       	movw	r24, r22
    4776:	89 83       	std	Y+1, r24	; 0x01
    4778:	9a 83       	std	Y+2, r25	; 0x02
    477a:	ab 83       	std	Y+3, r26	; 0x03
    477c:	bc 83       	std	Y+4, r27	; 0x04
	 return temp;
    477e:	89 81       	ldd	r24, Y+1	; 0x01
    4780:	9a 81       	ldd	r25, Y+2	; 0x02
    4782:	ab 81       	ldd	r26, Y+3	; 0x03
    4784:	bc 81       	ldd	r27, Y+4	; 0x04
}
    4786:	bc 01       	movw	r22, r24
    4788:	cd 01       	movw	r24, r26
    478a:	28 96       	adiw	r28, 0x08	; 8
    478c:	0f b6       	in	r0, 0x3f	; 63
    478e:	f8 94       	cli
    4790:	de bf       	out	0x3e, r29	; 62
    4792:	0f be       	out	0x3f, r0	; 63
    4794:	cd bf       	out	0x3d, r28	; 61
    4796:	cf 91       	pop	r28
    4798:	df 91       	pop	r29
    479a:	08 95       	ret

0000479c <LED_vidledInit>:
 */
#include "LED.h"
#include "Dio.h"

void LED_vidledInit(void)
{
    479c:	df 93       	push	r29
    479e:	cf 93       	push	r28
    47a0:	cd b7       	in	r28, 0x3d	; 61
    47a2:	de b7       	in	r29, 0x3e	; 62
	Dio_vidconfigChannel(DIO_PORTC,DIO_PIN7,DIO_OUTPUT);
    47a4:	82 e0       	ldi	r24, 0x02	; 2
    47a6:	67 e0       	ldi	r22, 0x07	; 7
    47a8:	41 e0       	ldi	r20, 0x01	; 1
    47aa:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTC,DIO_PIN2,DIO_OUTPUT);
    47ae:	82 e0       	ldi	r24, 0x02	; 2
    47b0:	62 e0       	ldi	r22, 0x02	; 2
    47b2:	41 e0       	ldi	r20, 0x01	; 1
    47b4:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTD,DIO_PIN3,DIO_OUTPUT);
    47b8:	83 e0       	ldi	r24, 0x03	; 3
    47ba:	63 e0       	ldi	r22, 0x03	; 3
    47bc:	41 e0       	ldi	r20, 0x01	; 1
    47be:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>
}
    47c2:	cf 91       	pop	r28
    47c4:	df 91       	pop	r29
    47c6:	08 95       	ret

000047c8 <LED_vidledOn>:

void LED_vidledOn(led_ledId_t led)
{
    47c8:	df 93       	push	r29
    47ca:	cf 93       	push	r28
    47cc:	00 d0       	rcall	.+0      	; 0x47ce <LED_vidledOn+0x6>
    47ce:	0f 92       	push	r0
    47d0:	cd b7       	in	r28, 0x3d	; 61
    47d2:	de b7       	in	r29, 0x3e	; 62
    47d4:	89 83       	std	Y+1, r24	; 0x01
	switch(led)
    47d6:	89 81       	ldd	r24, Y+1	; 0x01
    47d8:	28 2f       	mov	r18, r24
    47da:	30 e0       	ldi	r19, 0x00	; 0
    47dc:	3b 83       	std	Y+3, r19	; 0x03
    47de:	2a 83       	std	Y+2, r18	; 0x02
    47e0:	8a 81       	ldd	r24, Y+2	; 0x02
    47e2:	9b 81       	ldd	r25, Y+3	; 0x03
    47e4:	81 30       	cpi	r24, 0x01	; 1
    47e6:	91 05       	cpc	r25, r1
    47e8:	79 f0       	breq	.+30     	; 0x4808 <LED_vidledOn+0x40>
    47ea:	2a 81       	ldd	r18, Y+2	; 0x02
    47ec:	3b 81       	ldd	r19, Y+3	; 0x03
    47ee:	22 30       	cpi	r18, 0x02	; 2
    47f0:	31 05       	cpc	r19, r1
    47f2:	81 f0       	breq	.+32     	; 0x4814 <LED_vidledOn+0x4c>
    47f4:	8a 81       	ldd	r24, Y+2	; 0x02
    47f6:	9b 81       	ldd	r25, Y+3	; 0x03
    47f8:	00 97       	sbiw	r24, 0x00	; 0
    47fa:	89 f4       	brne	.+34     	; 0x481e <LED_vidledOn+0x56>
	{
	case LED0:
	{
		Dio_vidwriteChannel(DIO_PORTC,DIO_PIN2,DIO_HIGH);
    47fc:	82 e0       	ldi	r24, 0x02	; 2
    47fe:	62 e0       	ldi	r22, 0x02	; 2
    4800:	41 e0       	ldi	r20, 0x01	; 1
    4802:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
    4806:	0b c0       	rjmp	.+22     	; 0x481e <LED_vidledOn+0x56>
		break;
	}
	case LED1:
	{
		Dio_vidwriteChannel(DIO_PORTC,DIO_PIN7,DIO_HIGH);
    4808:	82 e0       	ldi	r24, 0x02	; 2
    480a:	67 e0       	ldi	r22, 0x07	; 7
    480c:	41 e0       	ldi	r20, 0x01	; 1
    480e:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
    4812:	05 c0       	rjmp	.+10     	; 0x481e <LED_vidledOn+0x56>
		break;
	}
	case LED2:
	{
		Dio_vidwriteChannel(DIO_PORTD,DIO_PIN3,DIO_HIGH);
    4814:	83 e0       	ldi	r24, 0x03	; 3
    4816:	63 e0       	ldi	r22, 0x03	; 3
    4818:	41 e0       	ldi	r20, 0x01	; 1
    481a:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
		break;
	}
	}
}
    481e:	0f 90       	pop	r0
    4820:	0f 90       	pop	r0
    4822:	0f 90       	pop	r0
    4824:	cf 91       	pop	r28
    4826:	df 91       	pop	r29
    4828:	08 95       	ret

0000482a <LED_vidledOff>:

void LED_vidledOff(led_ledId_t led)
{
    482a:	df 93       	push	r29
    482c:	cf 93       	push	r28
    482e:	00 d0       	rcall	.+0      	; 0x4830 <LED_vidledOff+0x6>
    4830:	0f 92       	push	r0
    4832:	cd b7       	in	r28, 0x3d	; 61
    4834:	de b7       	in	r29, 0x3e	; 62
    4836:	89 83       	std	Y+1, r24	; 0x01
	switch(led)
    4838:	89 81       	ldd	r24, Y+1	; 0x01
    483a:	28 2f       	mov	r18, r24
    483c:	30 e0       	ldi	r19, 0x00	; 0
    483e:	3b 83       	std	Y+3, r19	; 0x03
    4840:	2a 83       	std	Y+2, r18	; 0x02
    4842:	8a 81       	ldd	r24, Y+2	; 0x02
    4844:	9b 81       	ldd	r25, Y+3	; 0x03
    4846:	81 30       	cpi	r24, 0x01	; 1
    4848:	91 05       	cpc	r25, r1
    484a:	79 f0       	breq	.+30     	; 0x486a <LED_vidledOff+0x40>
    484c:	2a 81       	ldd	r18, Y+2	; 0x02
    484e:	3b 81       	ldd	r19, Y+3	; 0x03
    4850:	22 30       	cpi	r18, 0x02	; 2
    4852:	31 05       	cpc	r19, r1
    4854:	81 f0       	breq	.+32     	; 0x4876 <LED_vidledOff+0x4c>
    4856:	8a 81       	ldd	r24, Y+2	; 0x02
    4858:	9b 81       	ldd	r25, Y+3	; 0x03
    485a:	00 97       	sbiw	r24, 0x00	; 0
    485c:	89 f4       	brne	.+34     	; 0x4880 <LED_vidledOff+0x56>
	{
	case LED0:
	{
		Dio_vidwriteChannel(DIO_PORTC,DIO_PIN2,DIO_LOW);
    485e:	82 e0       	ldi	r24, 0x02	; 2
    4860:	62 e0       	ldi	r22, 0x02	; 2
    4862:	40 e0       	ldi	r20, 0x00	; 0
    4864:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
    4868:	0b c0       	rjmp	.+22     	; 0x4880 <LED_vidledOff+0x56>
		break;
	}
	case LED1:
	{
		Dio_vidwriteChannel(DIO_PORTC,DIO_PIN7,DIO_LOW);
    486a:	82 e0       	ldi	r24, 0x02	; 2
    486c:	67 e0       	ldi	r22, 0x07	; 7
    486e:	40 e0       	ldi	r20, 0x00	; 0
    4870:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
    4874:	05 c0       	rjmp	.+10     	; 0x4880 <LED_vidledOff+0x56>
		break;
	}
	case LED2:
	{
		Dio_vidwriteChannel(DIO_PORTD,DIO_PIN3,DIO_LOW);
    4876:	83 e0       	ldi	r24, 0x03	; 3
    4878:	63 e0       	ldi	r22, 0x03	; 3
    487a:	40 e0       	ldi	r20, 0x00	; 0
    487c:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
		break;
	}
	}
}
    4880:	0f 90       	pop	r0
    4882:	0f 90       	pop	r0
    4884:	0f 90       	pop	r0
    4886:	cf 91       	pop	r28
    4888:	df 91       	pop	r29
    488a:	08 95       	ret

0000488c <LED_vidledToggle>:

void LED_vidledToggle(led_ledId_t led)
{
    488c:	df 93       	push	r29
    488e:	cf 93       	push	r28
    4890:	00 d0       	rcall	.+0      	; 0x4892 <LED_vidledToggle+0x6>
    4892:	0f 92       	push	r0
    4894:	cd b7       	in	r28, 0x3d	; 61
    4896:	de b7       	in	r29, 0x3e	; 62
    4898:	89 83       	std	Y+1, r24	; 0x01
	switch(led)
    489a:	89 81       	ldd	r24, Y+1	; 0x01
    489c:	28 2f       	mov	r18, r24
    489e:	30 e0       	ldi	r19, 0x00	; 0
    48a0:	3b 83       	std	Y+3, r19	; 0x03
    48a2:	2a 83       	std	Y+2, r18	; 0x02
    48a4:	8a 81       	ldd	r24, Y+2	; 0x02
    48a6:	9b 81       	ldd	r25, Y+3	; 0x03
    48a8:	81 30       	cpi	r24, 0x01	; 1
    48aa:	91 05       	cpc	r25, r1
    48ac:	71 f0       	breq	.+28     	; 0x48ca <LED_vidledToggle+0x3e>
    48ae:	2a 81       	ldd	r18, Y+2	; 0x02
    48b0:	3b 81       	ldd	r19, Y+3	; 0x03
    48b2:	22 30       	cpi	r18, 0x02	; 2
    48b4:	31 05       	cpc	r19, r1
    48b6:	71 f0       	breq	.+28     	; 0x48d4 <LED_vidledToggle+0x48>
    48b8:	8a 81       	ldd	r24, Y+2	; 0x02
    48ba:	9b 81       	ldd	r25, Y+3	; 0x03
    48bc:	00 97       	sbiw	r24, 0x00	; 0
    48be:	71 f4       	brne	.+28     	; 0x48dc <LED_vidledToggle+0x50>
	{
	case LED0:
	{
		Dio_vidflipChannel(DIO_PORTC,DIO_PIN2);
    48c0:	82 e0       	ldi	r24, 0x02	; 2
    48c2:	62 e0       	ldi	r22, 0x02	; 2
    48c4:	0e 94 b0 32 	call	0x6560	; 0x6560 <Dio_vidflipChannel>
    48c8:	09 c0       	rjmp	.+18     	; 0x48dc <LED_vidledToggle+0x50>
		break;
	}
	case LED1:
	{
		Dio_vidflipChannel(DIO_PORTC,DIO_PIN7);
    48ca:	82 e0       	ldi	r24, 0x02	; 2
    48cc:	67 e0       	ldi	r22, 0x07	; 7
    48ce:	0e 94 b0 32 	call	0x6560	; 0x6560 <Dio_vidflipChannel>
    48d2:	04 c0       	rjmp	.+8      	; 0x48dc <LED_vidledToggle+0x50>
		break;
	}
	case LED2:
	{
		Dio_vidflipChannel(DIO_PORTD,DIO_PIN3);
    48d4:	83 e0       	ldi	r24, 0x03	; 3
    48d6:	63 e0       	ldi	r22, 0x03	; 3
    48d8:	0e 94 b0 32 	call	0x6560	; 0x6560 <Dio_vidflipChannel>
		break;
	}
	}
}
    48dc:	0f 90       	pop	r0
    48de:	0f 90       	pop	r0
    48e0:	0f 90       	pop	r0
    48e2:	cf 91       	pop	r28
    48e4:	df 91       	pop	r29
    48e6:	08 95       	ret

000048e8 <LCD_vidEnablePulse>:
#include "Dio.h"
#include <util/delay.h>
#include <stdio.h>

static void LCD_vidEnablePulse(void)
{
    48e8:	df 93       	push	r29
    48ea:	cf 93       	push	r28
    48ec:	cd b7       	in	r28, 0x3d	; 61
    48ee:	de b7       	in	r29, 0x3e	; 62
    48f0:	a6 97       	sbiw	r28, 0x26	; 38
    48f2:	0f b6       	in	r0, 0x3f	; 63
    48f4:	f8 94       	cli
    48f6:	de bf       	out	0x3e, r29	; 62
    48f8:	0f be       	out	0x3f, r0	; 63
    48fa:	cd bf       	out	0x3d, r28	; 61
	/* Send Enable Pulse */
	Dio_vidwriteChannel(DIO_PORTB,DIO_PIN3,DIO_HIGH);
    48fc:	81 e0       	ldi	r24, 0x01	; 1
    48fe:	63 e0       	ldi	r22, 0x03	; 3
    4900:	41 e0       	ldi	r20, 0x01	; 1
    4902:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
    4906:	80 e0       	ldi	r24, 0x00	; 0
    4908:	90 e0       	ldi	r25, 0x00	; 0
    490a:	a0 e8       	ldi	r26, 0x80	; 128
    490c:	bf e3       	ldi	r27, 0x3F	; 63
    490e:	8b a3       	std	Y+35, r24	; 0x23
    4910:	9c a3       	std	Y+36, r25	; 0x24
    4912:	ad a3       	std	Y+37, r26	; 0x25
    4914:	be a3       	std	Y+38, r27	; 0x26
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    4916:	6b a1       	ldd	r22, Y+35	; 0x23
    4918:	7c a1       	ldd	r23, Y+36	; 0x24
    491a:	8d a1       	ldd	r24, Y+37	; 0x25
    491c:	9e a1       	ldd	r25, Y+38	; 0x26
    491e:	2b ea       	ldi	r18, 0xAB	; 171
    4920:	3a ea       	ldi	r19, 0xAA	; 170
    4922:	4a ea       	ldi	r20, 0xAA	; 170
    4924:	50 e4       	ldi	r21, 0x40	; 64
    4926:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    492a:	dc 01       	movw	r26, r24
    492c:	cb 01       	movw	r24, r22
    492e:	8f 8f       	std	Y+31, r24	; 0x1f
    4930:	98 a3       	std	Y+32, r25	; 0x20
    4932:	a9 a3       	std	Y+33, r26	; 0x21
    4934:	ba a3       	std	Y+34, r27	; 0x22
	if (__tmp < 1.0)
    4936:	6f 8d       	ldd	r22, Y+31	; 0x1f
    4938:	78 a1       	ldd	r23, Y+32	; 0x20
    493a:	89 a1       	ldd	r24, Y+33	; 0x21
    493c:	9a a1       	ldd	r25, Y+34	; 0x22
    493e:	20 e0       	ldi	r18, 0x00	; 0
    4940:	30 e0       	ldi	r19, 0x00	; 0
    4942:	40 e8       	ldi	r20, 0x80	; 128
    4944:	5f e3       	ldi	r21, 0x3F	; 63
    4946:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    494a:	88 23       	and	r24, r24
    494c:	1c f4       	brge	.+6      	; 0x4954 <LCD_vidEnablePulse+0x6c>
		__ticks = 1;
    494e:	81 e0       	ldi	r24, 0x01	; 1
    4950:	8e 8f       	std	Y+30, r24	; 0x1e
    4952:	91 c0       	rjmp	.+290    	; 0x4a76 <LCD_vidEnablePulse+0x18e>
	else if (__tmp > 255)
    4954:	6f 8d       	ldd	r22, Y+31	; 0x1f
    4956:	78 a1       	ldd	r23, Y+32	; 0x20
    4958:	89 a1       	ldd	r24, Y+33	; 0x21
    495a:	9a a1       	ldd	r25, Y+34	; 0x22
    495c:	20 e0       	ldi	r18, 0x00	; 0
    495e:	30 e0       	ldi	r19, 0x00	; 0
    4960:	4f e7       	ldi	r20, 0x7F	; 127
    4962:	53 e4       	ldi	r21, 0x43	; 67
    4964:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4968:	18 16       	cp	r1, r24
    496a:	0c f0       	brlt	.+2      	; 0x496e <LCD_vidEnablePulse+0x86>
    496c:	7b c0       	rjmp	.+246    	; 0x4a64 <LCD_vidEnablePulse+0x17c>
	{
		_delay_ms(__us / 1000.0);
    496e:	6b a1       	ldd	r22, Y+35	; 0x23
    4970:	7c a1       	ldd	r23, Y+36	; 0x24
    4972:	8d a1       	ldd	r24, Y+37	; 0x25
    4974:	9e a1       	ldd	r25, Y+38	; 0x26
    4976:	20 e0       	ldi	r18, 0x00	; 0
    4978:	30 e0       	ldi	r19, 0x00	; 0
    497a:	4a e7       	ldi	r20, 0x7A	; 122
    497c:	54 e4       	ldi	r21, 0x44	; 68
    497e:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    4982:	dc 01       	movw	r26, r24
    4984:	cb 01       	movw	r24, r22
    4986:	8a 8f       	std	Y+26, r24	; 0x1a
    4988:	9b 8f       	std	Y+27, r25	; 0x1b
    498a:	ac 8f       	std	Y+28, r26	; 0x1c
    498c:	bd 8f       	std	Y+29, r27	; 0x1d
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    498e:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4990:	7b 8d       	ldd	r23, Y+27	; 0x1b
    4992:	8c 8d       	ldd	r24, Y+28	; 0x1c
    4994:	9d 8d       	ldd	r25, Y+29	; 0x1d
    4996:	20 e0       	ldi	r18, 0x00	; 0
    4998:	30 e0       	ldi	r19, 0x00	; 0
    499a:	4a e7       	ldi	r20, 0x7A	; 122
    499c:	55 e4       	ldi	r21, 0x45	; 69
    499e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    49a2:	dc 01       	movw	r26, r24
    49a4:	cb 01       	movw	r24, r22
    49a6:	8e 8b       	std	Y+22, r24	; 0x16
    49a8:	9f 8b       	std	Y+23, r25	; 0x17
    49aa:	a8 8f       	std	Y+24, r26	; 0x18
    49ac:	b9 8f       	std	Y+25, r27	; 0x19
	if (__tmp < 1.0)
    49ae:	6e 89       	ldd	r22, Y+22	; 0x16
    49b0:	7f 89       	ldd	r23, Y+23	; 0x17
    49b2:	88 8d       	ldd	r24, Y+24	; 0x18
    49b4:	99 8d       	ldd	r25, Y+25	; 0x19
    49b6:	20 e0       	ldi	r18, 0x00	; 0
    49b8:	30 e0       	ldi	r19, 0x00	; 0
    49ba:	40 e8       	ldi	r20, 0x80	; 128
    49bc:	5f e3       	ldi	r21, 0x3F	; 63
    49be:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    49c2:	88 23       	and	r24, r24
    49c4:	2c f4       	brge	.+10     	; 0x49d0 <LCD_vidEnablePulse+0xe8>
		__ticks = 1;
    49c6:	81 e0       	ldi	r24, 0x01	; 1
    49c8:	90 e0       	ldi	r25, 0x00	; 0
    49ca:	9d 8b       	std	Y+21, r25	; 0x15
    49cc:	8c 8b       	std	Y+20, r24	; 0x14
    49ce:	3f c0       	rjmp	.+126    	; 0x4a4e <LCD_vidEnablePulse+0x166>
	else if (__tmp > 65535)
    49d0:	6e 89       	ldd	r22, Y+22	; 0x16
    49d2:	7f 89       	ldd	r23, Y+23	; 0x17
    49d4:	88 8d       	ldd	r24, Y+24	; 0x18
    49d6:	99 8d       	ldd	r25, Y+25	; 0x19
    49d8:	20 e0       	ldi	r18, 0x00	; 0
    49da:	3f ef       	ldi	r19, 0xFF	; 255
    49dc:	4f e7       	ldi	r20, 0x7F	; 127
    49de:	57 e4       	ldi	r21, 0x47	; 71
    49e0:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    49e4:	18 16       	cp	r1, r24
    49e6:	4c f5       	brge	.+82     	; 0x4a3a <LCD_vidEnablePulse+0x152>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    49e8:	6a 8d       	ldd	r22, Y+26	; 0x1a
    49ea:	7b 8d       	ldd	r23, Y+27	; 0x1b
    49ec:	8c 8d       	ldd	r24, Y+28	; 0x1c
    49ee:	9d 8d       	ldd	r25, Y+29	; 0x1d
    49f0:	20 e0       	ldi	r18, 0x00	; 0
    49f2:	30 e0       	ldi	r19, 0x00	; 0
    49f4:	40 e2       	ldi	r20, 0x20	; 32
    49f6:	51 e4       	ldi	r21, 0x41	; 65
    49f8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    49fc:	dc 01       	movw	r26, r24
    49fe:	cb 01       	movw	r24, r22
    4a00:	bc 01       	movw	r22, r24
    4a02:	cd 01       	movw	r24, r26
    4a04:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4a08:	dc 01       	movw	r26, r24
    4a0a:	cb 01       	movw	r24, r22
    4a0c:	9d 8b       	std	Y+21, r25	; 0x15
    4a0e:	8c 8b       	std	Y+20, r24	; 0x14
    4a10:	0f c0       	rjmp	.+30     	; 0x4a30 <LCD_vidEnablePulse+0x148>
    4a12:	80 e9       	ldi	r24, 0x90	; 144
    4a14:	91 e0       	ldi	r25, 0x01	; 1
    4a16:	9b 8b       	std	Y+19, r25	; 0x13
    4a18:	8a 8b       	std	Y+18, r24	; 0x12
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4a1a:	8a 89       	ldd	r24, Y+18	; 0x12
    4a1c:	9b 89       	ldd	r25, Y+19	; 0x13
    4a1e:	01 97       	sbiw	r24, 0x01	; 1
    4a20:	f1 f7       	brne	.-4      	; 0x4a1e <LCD_vidEnablePulse+0x136>
    4a22:	9b 8b       	std	Y+19, r25	; 0x13
    4a24:	8a 8b       	std	Y+18, r24	; 0x12
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4a26:	8c 89       	ldd	r24, Y+20	; 0x14
    4a28:	9d 89       	ldd	r25, Y+21	; 0x15
    4a2a:	01 97       	sbiw	r24, 0x01	; 1
    4a2c:	9d 8b       	std	Y+21, r25	; 0x15
    4a2e:	8c 8b       	std	Y+20, r24	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4a30:	8c 89       	ldd	r24, Y+20	; 0x14
    4a32:	9d 89       	ldd	r25, Y+21	; 0x15
    4a34:	00 97       	sbiw	r24, 0x00	; 0
    4a36:	69 f7       	brne	.-38     	; 0x4a12 <LCD_vidEnablePulse+0x12a>
    4a38:	24 c0       	rjmp	.+72     	; 0x4a82 <LCD_vidEnablePulse+0x19a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4a3a:	6e 89       	ldd	r22, Y+22	; 0x16
    4a3c:	7f 89       	ldd	r23, Y+23	; 0x17
    4a3e:	88 8d       	ldd	r24, Y+24	; 0x18
    4a40:	99 8d       	ldd	r25, Y+25	; 0x19
    4a42:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4a46:	dc 01       	movw	r26, r24
    4a48:	cb 01       	movw	r24, r22
    4a4a:	9d 8b       	std	Y+21, r25	; 0x15
    4a4c:	8c 8b       	std	Y+20, r24	; 0x14
    4a4e:	8c 89       	ldd	r24, Y+20	; 0x14
    4a50:	9d 89       	ldd	r25, Y+21	; 0x15
    4a52:	99 8b       	std	Y+17, r25	; 0x11
    4a54:	88 8b       	std	Y+16, r24	; 0x10
    4a56:	88 89       	ldd	r24, Y+16	; 0x10
    4a58:	99 89       	ldd	r25, Y+17	; 0x11
    4a5a:	01 97       	sbiw	r24, 0x01	; 1
    4a5c:	f1 f7       	brne	.-4      	; 0x4a5a <LCD_vidEnablePulse+0x172>
    4a5e:	99 8b       	std	Y+17, r25	; 0x11
    4a60:	88 8b       	std	Y+16, r24	; 0x10
    4a62:	0f c0       	rjmp	.+30     	; 0x4a82 <LCD_vidEnablePulse+0x19a>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4a64:	6f 8d       	ldd	r22, Y+31	; 0x1f
    4a66:	78 a1       	ldd	r23, Y+32	; 0x20
    4a68:	89 a1       	ldd	r24, Y+33	; 0x21
    4a6a:	9a a1       	ldd	r25, Y+34	; 0x22
    4a6c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4a70:	dc 01       	movw	r26, r24
    4a72:	cb 01       	movw	r24, r22
    4a74:	8e 8f       	std	Y+30, r24	; 0x1e
    4a76:	8e 8d       	ldd	r24, Y+30	; 0x1e
    4a78:	8f 87       	std	Y+15, r24	; 0x0f
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4a7a:	8f 85       	ldd	r24, Y+15	; 0x0f
    4a7c:	8a 95       	dec	r24
    4a7e:	f1 f7       	brne	.-4      	; 0x4a7c <LCD_vidEnablePulse+0x194>
    4a80:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_us(1);
	Dio_vidwriteChannel(DIO_PORTB,DIO_PIN3,DIO_LOW);
    4a82:	81 e0       	ldi	r24, 0x01	; 1
    4a84:	63 e0       	ldi	r22, 0x03	; 3
    4a86:	40 e0       	ldi	r20, 0x00	; 0
    4a88:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
    4a8c:	80 e0       	ldi	r24, 0x00	; 0
    4a8e:	90 e0       	ldi	r25, 0x00	; 0
    4a90:	a0 e0       	ldi	r26, 0x00	; 0
    4a92:	b0 e4       	ldi	r27, 0x40	; 64
    4a94:	8b 87       	std	Y+11, r24	; 0x0b
    4a96:	9c 87       	std	Y+12, r25	; 0x0c
    4a98:	ad 87       	std	Y+13, r26	; 0x0d
    4a9a:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4a9c:	6b 85       	ldd	r22, Y+11	; 0x0b
    4a9e:	7c 85       	ldd	r23, Y+12	; 0x0c
    4aa0:	8d 85       	ldd	r24, Y+13	; 0x0d
    4aa2:	9e 85       	ldd	r25, Y+14	; 0x0e
    4aa4:	20 e0       	ldi	r18, 0x00	; 0
    4aa6:	30 e0       	ldi	r19, 0x00	; 0
    4aa8:	4a e7       	ldi	r20, 0x7A	; 122
    4aaa:	55 e4       	ldi	r21, 0x45	; 69
    4aac:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4ab0:	dc 01       	movw	r26, r24
    4ab2:	cb 01       	movw	r24, r22
    4ab4:	8f 83       	std	Y+7, r24	; 0x07
    4ab6:	98 87       	std	Y+8, r25	; 0x08
    4ab8:	a9 87       	std	Y+9, r26	; 0x09
    4aba:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    4abc:	6f 81       	ldd	r22, Y+7	; 0x07
    4abe:	78 85       	ldd	r23, Y+8	; 0x08
    4ac0:	89 85       	ldd	r24, Y+9	; 0x09
    4ac2:	9a 85       	ldd	r25, Y+10	; 0x0a
    4ac4:	20 e0       	ldi	r18, 0x00	; 0
    4ac6:	30 e0       	ldi	r19, 0x00	; 0
    4ac8:	40 e8       	ldi	r20, 0x80	; 128
    4aca:	5f e3       	ldi	r21, 0x3F	; 63
    4acc:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4ad0:	88 23       	and	r24, r24
    4ad2:	2c f4       	brge	.+10     	; 0x4ade <LCD_vidEnablePulse+0x1f6>
		__ticks = 1;
    4ad4:	81 e0       	ldi	r24, 0x01	; 1
    4ad6:	90 e0       	ldi	r25, 0x00	; 0
    4ad8:	9e 83       	std	Y+6, r25	; 0x06
    4ada:	8d 83       	std	Y+5, r24	; 0x05
    4adc:	3f c0       	rjmp	.+126    	; 0x4b5c <LCD_vidEnablePulse+0x274>
	else if (__tmp > 65535)
    4ade:	6f 81       	ldd	r22, Y+7	; 0x07
    4ae0:	78 85       	ldd	r23, Y+8	; 0x08
    4ae2:	89 85       	ldd	r24, Y+9	; 0x09
    4ae4:	9a 85       	ldd	r25, Y+10	; 0x0a
    4ae6:	20 e0       	ldi	r18, 0x00	; 0
    4ae8:	3f ef       	ldi	r19, 0xFF	; 255
    4aea:	4f e7       	ldi	r20, 0x7F	; 127
    4aec:	57 e4       	ldi	r21, 0x47	; 71
    4aee:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4af2:	18 16       	cp	r1, r24
    4af4:	4c f5       	brge	.+82     	; 0x4b48 <LCD_vidEnablePulse+0x260>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4af6:	6b 85       	ldd	r22, Y+11	; 0x0b
    4af8:	7c 85       	ldd	r23, Y+12	; 0x0c
    4afa:	8d 85       	ldd	r24, Y+13	; 0x0d
    4afc:	9e 85       	ldd	r25, Y+14	; 0x0e
    4afe:	20 e0       	ldi	r18, 0x00	; 0
    4b00:	30 e0       	ldi	r19, 0x00	; 0
    4b02:	40 e2       	ldi	r20, 0x20	; 32
    4b04:	51 e4       	ldi	r21, 0x41	; 65
    4b06:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4b0a:	dc 01       	movw	r26, r24
    4b0c:	cb 01       	movw	r24, r22
    4b0e:	bc 01       	movw	r22, r24
    4b10:	cd 01       	movw	r24, r26
    4b12:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4b16:	dc 01       	movw	r26, r24
    4b18:	cb 01       	movw	r24, r22
    4b1a:	9e 83       	std	Y+6, r25	; 0x06
    4b1c:	8d 83       	std	Y+5, r24	; 0x05
    4b1e:	0f c0       	rjmp	.+30     	; 0x4b3e <LCD_vidEnablePulse+0x256>
    4b20:	80 e9       	ldi	r24, 0x90	; 144
    4b22:	91 e0       	ldi	r25, 0x01	; 1
    4b24:	9c 83       	std	Y+4, r25	; 0x04
    4b26:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4b28:	8b 81       	ldd	r24, Y+3	; 0x03
    4b2a:	9c 81       	ldd	r25, Y+4	; 0x04
    4b2c:	01 97       	sbiw	r24, 0x01	; 1
    4b2e:	f1 f7       	brne	.-4      	; 0x4b2c <LCD_vidEnablePulse+0x244>
    4b30:	9c 83       	std	Y+4, r25	; 0x04
    4b32:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4b34:	8d 81       	ldd	r24, Y+5	; 0x05
    4b36:	9e 81       	ldd	r25, Y+6	; 0x06
    4b38:	01 97       	sbiw	r24, 0x01	; 1
    4b3a:	9e 83       	std	Y+6, r25	; 0x06
    4b3c:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4b3e:	8d 81       	ldd	r24, Y+5	; 0x05
    4b40:	9e 81       	ldd	r25, Y+6	; 0x06
    4b42:	00 97       	sbiw	r24, 0x00	; 0
    4b44:	69 f7       	brne	.-38     	; 0x4b20 <LCD_vidEnablePulse+0x238>
    4b46:	14 c0       	rjmp	.+40     	; 0x4b70 <LCD_vidEnablePulse+0x288>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4b48:	6f 81       	ldd	r22, Y+7	; 0x07
    4b4a:	78 85       	ldd	r23, Y+8	; 0x08
    4b4c:	89 85       	ldd	r24, Y+9	; 0x09
    4b4e:	9a 85       	ldd	r25, Y+10	; 0x0a
    4b50:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4b54:	dc 01       	movw	r26, r24
    4b56:	cb 01       	movw	r24, r22
    4b58:	9e 83       	std	Y+6, r25	; 0x06
    4b5a:	8d 83       	std	Y+5, r24	; 0x05
    4b5c:	8d 81       	ldd	r24, Y+5	; 0x05
    4b5e:	9e 81       	ldd	r25, Y+6	; 0x06
    4b60:	9a 83       	std	Y+2, r25	; 0x02
    4b62:	89 83       	std	Y+1, r24	; 0x01
    4b64:	89 81       	ldd	r24, Y+1	; 0x01
    4b66:	9a 81       	ldd	r25, Y+2	; 0x02
    4b68:	01 97       	sbiw	r24, 0x01	; 1
    4b6a:	f1 f7       	brne	.-4      	; 0x4b68 <LCD_vidEnablePulse+0x280>
    4b6c:	9a 83       	std	Y+2, r25	; 0x02
    4b6e:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
}
    4b70:	a6 96       	adiw	r28, 0x26	; 38
    4b72:	0f b6       	in	r0, 0x3f	; 63
    4b74:	f8 94       	cli
    4b76:	de bf       	out	0x3e, r29	; 62
    4b78:	0f be       	out	0x3f, r0	; 63
    4b7a:	cd bf       	out	0x3d, r28	; 61
    4b7c:	cf 91       	pop	r28
    4b7e:	df 91       	pop	r29
    4b80:	08 95       	ret

00004b82 <LCD_vidInit>:

void LCD_vidInit(void)
{
    4b82:	df 93       	push	r29
    4b84:	cf 93       	push	r28
    4b86:	cd b7       	in	r28, 0x3d	; 61
    4b88:	de b7       	in	r29, 0x3e	; 62
    4b8a:	c2 54       	subi	r28, 0x42	; 66
    4b8c:	d0 40       	sbci	r29, 0x00	; 0
    4b8e:	0f b6       	in	r0, 0x3f	; 63
    4b90:	f8 94       	cli
    4b92:	de bf       	out	0x3e, r29	; 62
    4b94:	0f be       	out	0x3f, r0	; 63
    4b96:	cd bf       	out	0x3d, r28	; 61
	/* Configure control pins as output */
	Dio_vidconfigChannel(DIO_PORTB,DIO_PIN1,DIO_OUTPUT);
    4b98:	81 e0       	ldi	r24, 0x01	; 1
    4b9a:	61 e0       	ldi	r22, 0x01	; 1
    4b9c:	41 e0       	ldi	r20, 0x01	; 1
    4b9e:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTB,DIO_PIN2,DIO_OUTPUT);
    4ba2:	81 e0       	ldi	r24, 0x01	; 1
    4ba4:	62 e0       	ldi	r22, 0x02	; 2
    4ba6:	41 e0       	ldi	r20, 0x01	; 1
    4ba8:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTB,DIO_PIN3,DIO_OUTPUT);
    4bac:	81 e0       	ldi	r24, 0x01	; 1
    4bae:	63 e0       	ldi	r22, 0x03	; 3
    4bb0:	41 e0       	ldi	r20, 0x01	; 1
    4bb2:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>

	/* Configure data pins as output */
	Dio_vidconfigChannel(DIO_PORTA,DIO_PIN4,DIO_OUTPUT);
    4bb6:	80 e0       	ldi	r24, 0x00	; 0
    4bb8:	64 e0       	ldi	r22, 0x04	; 4
    4bba:	41 e0       	ldi	r20, 0x01	; 1
    4bbc:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTA,DIO_PIN5,DIO_OUTPUT);
    4bc0:	80 e0       	ldi	r24, 0x00	; 0
    4bc2:	65 e0       	ldi	r22, 0x05	; 5
    4bc4:	41 e0       	ldi	r20, 0x01	; 1
    4bc6:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTA,DIO_PIN6,DIO_OUTPUT);
    4bca:	80 e0       	ldi	r24, 0x00	; 0
    4bcc:	66 e0       	ldi	r22, 0x06	; 6
    4bce:	41 e0       	ldi	r20, 0x01	; 1
    4bd0:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTA,DIO_PIN7,DIO_OUTPUT);
    4bd4:	80 e0       	ldi	r24, 0x00	; 0
    4bd6:	67 e0       	ldi	r22, 0x07	; 7
    4bd8:	41 e0       	ldi	r20, 0x01	; 1
    4bda:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>

	Dio_vidwriteChannel(DIO_PORTB,DIO_PIN2,DIO_LOW);
    4bde:	81 e0       	ldi	r24, 0x01	; 1
    4be0:	62 e0       	ldi	r22, 0x02	; 2
    4be2:	40 e0       	ldi	r20, 0x00	; 0
    4be4:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
    4be8:	80 e0       	ldi	r24, 0x00	; 0
    4bea:	90 e0       	ldi	r25, 0x00	; 0
    4bec:	a0 e7       	ldi	r26, 0x70	; 112
    4bee:	b1 e4       	ldi	r27, 0x41	; 65
    4bf0:	89 ab       	std	Y+49, r24	; 0x31
    4bf2:	9a ab       	std	Y+50, r25	; 0x32
    4bf4:	ab ab       	std	Y+51, r26	; 0x33
    4bf6:	bc ab       	std	Y+52, r27	; 0x34
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4bf8:	69 a9       	ldd	r22, Y+49	; 0x31
    4bfa:	7a a9       	ldd	r23, Y+50	; 0x32
    4bfc:	8b a9       	ldd	r24, Y+51	; 0x33
    4bfe:	9c a9       	ldd	r25, Y+52	; 0x34
    4c00:	20 e0       	ldi	r18, 0x00	; 0
    4c02:	30 e0       	ldi	r19, 0x00	; 0
    4c04:	4a e7       	ldi	r20, 0x7A	; 122
    4c06:	55 e4       	ldi	r21, 0x45	; 69
    4c08:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4c0c:	dc 01       	movw	r26, r24
    4c0e:	cb 01       	movw	r24, r22
    4c10:	8d a7       	std	Y+45, r24	; 0x2d
    4c12:	9e a7       	std	Y+46, r25	; 0x2e
    4c14:	af a7       	std	Y+47, r26	; 0x2f
    4c16:	b8 ab       	std	Y+48, r27	; 0x30
	if (__tmp < 1.0)
    4c18:	6d a5       	ldd	r22, Y+45	; 0x2d
    4c1a:	7e a5       	ldd	r23, Y+46	; 0x2e
    4c1c:	8f a5       	ldd	r24, Y+47	; 0x2f
    4c1e:	98 a9       	ldd	r25, Y+48	; 0x30
    4c20:	20 e0       	ldi	r18, 0x00	; 0
    4c22:	30 e0       	ldi	r19, 0x00	; 0
    4c24:	40 e8       	ldi	r20, 0x80	; 128
    4c26:	5f e3       	ldi	r21, 0x3F	; 63
    4c28:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4c2c:	88 23       	and	r24, r24
    4c2e:	2c f4       	brge	.+10     	; 0x4c3a <LCD_vidInit+0xb8>
		__ticks = 1;
    4c30:	81 e0       	ldi	r24, 0x01	; 1
    4c32:	90 e0       	ldi	r25, 0x00	; 0
    4c34:	9c a7       	std	Y+44, r25	; 0x2c
    4c36:	8b a7       	std	Y+43, r24	; 0x2b
    4c38:	3f c0       	rjmp	.+126    	; 0x4cb8 <LCD_vidInit+0x136>
	else if (__tmp > 65535)
    4c3a:	6d a5       	ldd	r22, Y+45	; 0x2d
    4c3c:	7e a5       	ldd	r23, Y+46	; 0x2e
    4c3e:	8f a5       	ldd	r24, Y+47	; 0x2f
    4c40:	98 a9       	ldd	r25, Y+48	; 0x30
    4c42:	20 e0       	ldi	r18, 0x00	; 0
    4c44:	3f ef       	ldi	r19, 0xFF	; 255
    4c46:	4f e7       	ldi	r20, 0x7F	; 127
    4c48:	57 e4       	ldi	r21, 0x47	; 71
    4c4a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4c4e:	18 16       	cp	r1, r24
    4c50:	4c f5       	brge	.+82     	; 0x4ca4 <LCD_vidInit+0x122>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4c52:	69 a9       	ldd	r22, Y+49	; 0x31
    4c54:	7a a9       	ldd	r23, Y+50	; 0x32
    4c56:	8b a9       	ldd	r24, Y+51	; 0x33
    4c58:	9c a9       	ldd	r25, Y+52	; 0x34
    4c5a:	20 e0       	ldi	r18, 0x00	; 0
    4c5c:	30 e0       	ldi	r19, 0x00	; 0
    4c5e:	40 e2       	ldi	r20, 0x20	; 32
    4c60:	51 e4       	ldi	r21, 0x41	; 65
    4c62:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4c66:	dc 01       	movw	r26, r24
    4c68:	cb 01       	movw	r24, r22
    4c6a:	bc 01       	movw	r22, r24
    4c6c:	cd 01       	movw	r24, r26
    4c6e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4c72:	dc 01       	movw	r26, r24
    4c74:	cb 01       	movw	r24, r22
    4c76:	9c a7       	std	Y+44, r25	; 0x2c
    4c78:	8b a7       	std	Y+43, r24	; 0x2b
    4c7a:	0f c0       	rjmp	.+30     	; 0x4c9a <LCD_vidInit+0x118>
    4c7c:	80 e9       	ldi	r24, 0x90	; 144
    4c7e:	91 e0       	ldi	r25, 0x01	; 1
    4c80:	9a a7       	std	Y+42, r25	; 0x2a
    4c82:	89 a7       	std	Y+41, r24	; 0x29
    4c84:	89 a5       	ldd	r24, Y+41	; 0x29
    4c86:	9a a5       	ldd	r25, Y+42	; 0x2a
    4c88:	01 97       	sbiw	r24, 0x01	; 1
    4c8a:	f1 f7       	brne	.-4      	; 0x4c88 <LCD_vidInit+0x106>
    4c8c:	9a a7       	std	Y+42, r25	; 0x2a
    4c8e:	89 a7       	std	Y+41, r24	; 0x29
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4c90:	8b a5       	ldd	r24, Y+43	; 0x2b
    4c92:	9c a5       	ldd	r25, Y+44	; 0x2c
    4c94:	01 97       	sbiw	r24, 0x01	; 1
    4c96:	9c a7       	std	Y+44, r25	; 0x2c
    4c98:	8b a7       	std	Y+43, r24	; 0x2b
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4c9a:	8b a5       	ldd	r24, Y+43	; 0x2b
    4c9c:	9c a5       	ldd	r25, Y+44	; 0x2c
    4c9e:	00 97       	sbiw	r24, 0x00	; 0
    4ca0:	69 f7       	brne	.-38     	; 0x4c7c <LCD_vidInit+0xfa>
    4ca2:	14 c0       	rjmp	.+40     	; 0x4ccc <LCD_vidInit+0x14a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4ca4:	6d a5       	ldd	r22, Y+45	; 0x2d
    4ca6:	7e a5       	ldd	r23, Y+46	; 0x2e
    4ca8:	8f a5       	ldd	r24, Y+47	; 0x2f
    4caa:	98 a9       	ldd	r25, Y+48	; 0x30
    4cac:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4cb0:	dc 01       	movw	r26, r24
    4cb2:	cb 01       	movw	r24, r22
    4cb4:	9c a7       	std	Y+44, r25	; 0x2c
    4cb6:	8b a7       	std	Y+43, r24	; 0x2b
    4cb8:	8b a5       	ldd	r24, Y+43	; 0x2b
    4cba:	9c a5       	ldd	r25, Y+44	; 0x2c
    4cbc:	98 a7       	std	Y+40, r25	; 0x28
    4cbe:	8f a3       	std	Y+39, r24	; 0x27
    4cc0:	8f a1       	ldd	r24, Y+39	; 0x27
    4cc2:	98 a5       	ldd	r25, Y+40	; 0x28
    4cc4:	01 97       	sbiw	r24, 0x01	; 1
    4cc6:	f1 f7       	brne	.-4      	; 0x4cc4 <LCD_vidInit+0x142>
    4cc8:	98 a7       	std	Y+40, r25	; 0x28
    4cca:	8f a3       	std	Y+39, r24	; 0x27

	_delay_ms(15);
	LCD_vidCmd(0x03);
    4ccc:	83 e0       	ldi	r24, 0x03	; 3
    4cce:	0e 94 3d 28 	call	0x507a	; 0x507a <LCD_vidCmd>
    4cd2:	80 e0       	ldi	r24, 0x00	; 0
    4cd4:	90 e0       	ldi	r25, 0x00	; 0
    4cd6:	a0 ea       	ldi	r26, 0xA0	; 160
    4cd8:	b0 e4       	ldi	r27, 0x40	; 64
    4cda:	8b a3       	std	Y+35, r24	; 0x23
    4cdc:	9c a3       	std	Y+36, r25	; 0x24
    4cde:	ad a3       	std	Y+37, r26	; 0x25
    4ce0:	be a3       	std	Y+38, r27	; 0x26
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4ce2:	6b a1       	ldd	r22, Y+35	; 0x23
    4ce4:	7c a1       	ldd	r23, Y+36	; 0x24
    4ce6:	8d a1       	ldd	r24, Y+37	; 0x25
    4ce8:	9e a1       	ldd	r25, Y+38	; 0x26
    4cea:	20 e0       	ldi	r18, 0x00	; 0
    4cec:	30 e0       	ldi	r19, 0x00	; 0
    4cee:	4a e7       	ldi	r20, 0x7A	; 122
    4cf0:	55 e4       	ldi	r21, 0x45	; 69
    4cf2:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4cf6:	dc 01       	movw	r26, r24
    4cf8:	cb 01       	movw	r24, r22
    4cfa:	8f 8f       	std	Y+31, r24	; 0x1f
    4cfc:	98 a3       	std	Y+32, r25	; 0x20
    4cfe:	a9 a3       	std	Y+33, r26	; 0x21
    4d00:	ba a3       	std	Y+34, r27	; 0x22
	if (__tmp < 1.0)
    4d02:	6f 8d       	ldd	r22, Y+31	; 0x1f
    4d04:	78 a1       	ldd	r23, Y+32	; 0x20
    4d06:	89 a1       	ldd	r24, Y+33	; 0x21
    4d08:	9a a1       	ldd	r25, Y+34	; 0x22
    4d0a:	20 e0       	ldi	r18, 0x00	; 0
    4d0c:	30 e0       	ldi	r19, 0x00	; 0
    4d0e:	40 e8       	ldi	r20, 0x80	; 128
    4d10:	5f e3       	ldi	r21, 0x3F	; 63
    4d12:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4d16:	88 23       	and	r24, r24
    4d18:	2c f4       	brge	.+10     	; 0x4d24 <LCD_vidInit+0x1a2>
		__ticks = 1;
    4d1a:	81 e0       	ldi	r24, 0x01	; 1
    4d1c:	90 e0       	ldi	r25, 0x00	; 0
    4d1e:	9e 8f       	std	Y+30, r25	; 0x1e
    4d20:	8d 8f       	std	Y+29, r24	; 0x1d
    4d22:	3f c0       	rjmp	.+126    	; 0x4da2 <LCD_vidInit+0x220>
	else if (__tmp > 65535)
    4d24:	6f 8d       	ldd	r22, Y+31	; 0x1f
    4d26:	78 a1       	ldd	r23, Y+32	; 0x20
    4d28:	89 a1       	ldd	r24, Y+33	; 0x21
    4d2a:	9a a1       	ldd	r25, Y+34	; 0x22
    4d2c:	20 e0       	ldi	r18, 0x00	; 0
    4d2e:	3f ef       	ldi	r19, 0xFF	; 255
    4d30:	4f e7       	ldi	r20, 0x7F	; 127
    4d32:	57 e4       	ldi	r21, 0x47	; 71
    4d34:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4d38:	18 16       	cp	r1, r24
    4d3a:	4c f5       	brge	.+82     	; 0x4d8e <LCD_vidInit+0x20c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4d3c:	6b a1       	ldd	r22, Y+35	; 0x23
    4d3e:	7c a1       	ldd	r23, Y+36	; 0x24
    4d40:	8d a1       	ldd	r24, Y+37	; 0x25
    4d42:	9e a1       	ldd	r25, Y+38	; 0x26
    4d44:	20 e0       	ldi	r18, 0x00	; 0
    4d46:	30 e0       	ldi	r19, 0x00	; 0
    4d48:	40 e2       	ldi	r20, 0x20	; 32
    4d4a:	51 e4       	ldi	r21, 0x41	; 65
    4d4c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4d50:	dc 01       	movw	r26, r24
    4d52:	cb 01       	movw	r24, r22
    4d54:	bc 01       	movw	r22, r24
    4d56:	cd 01       	movw	r24, r26
    4d58:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4d5c:	dc 01       	movw	r26, r24
    4d5e:	cb 01       	movw	r24, r22
    4d60:	9e 8f       	std	Y+30, r25	; 0x1e
    4d62:	8d 8f       	std	Y+29, r24	; 0x1d
    4d64:	0f c0       	rjmp	.+30     	; 0x4d84 <LCD_vidInit+0x202>
    4d66:	80 e9       	ldi	r24, 0x90	; 144
    4d68:	91 e0       	ldi	r25, 0x01	; 1
    4d6a:	9c 8f       	std	Y+28, r25	; 0x1c
    4d6c:	8b 8f       	std	Y+27, r24	; 0x1b
    4d6e:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4d70:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4d72:	01 97       	sbiw	r24, 0x01	; 1
    4d74:	f1 f7       	brne	.-4      	; 0x4d72 <LCD_vidInit+0x1f0>
    4d76:	9c 8f       	std	Y+28, r25	; 0x1c
    4d78:	8b 8f       	std	Y+27, r24	; 0x1b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4d7a:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4d7c:	9e 8d       	ldd	r25, Y+30	; 0x1e
    4d7e:	01 97       	sbiw	r24, 0x01	; 1
    4d80:	9e 8f       	std	Y+30, r25	; 0x1e
    4d82:	8d 8f       	std	Y+29, r24	; 0x1d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4d84:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4d86:	9e 8d       	ldd	r25, Y+30	; 0x1e
    4d88:	00 97       	sbiw	r24, 0x00	; 0
    4d8a:	69 f7       	brne	.-38     	; 0x4d66 <LCD_vidInit+0x1e4>
    4d8c:	14 c0       	rjmp	.+40     	; 0x4db6 <LCD_vidInit+0x234>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4d8e:	6f 8d       	ldd	r22, Y+31	; 0x1f
    4d90:	78 a1       	ldd	r23, Y+32	; 0x20
    4d92:	89 a1       	ldd	r24, Y+33	; 0x21
    4d94:	9a a1       	ldd	r25, Y+34	; 0x22
    4d96:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4d9a:	dc 01       	movw	r26, r24
    4d9c:	cb 01       	movw	r24, r22
    4d9e:	9e 8f       	std	Y+30, r25	; 0x1e
    4da0:	8d 8f       	std	Y+29, r24	; 0x1d
    4da2:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4da4:	9e 8d       	ldd	r25, Y+30	; 0x1e
    4da6:	9a 8f       	std	Y+26, r25	; 0x1a
    4da8:	89 8f       	std	Y+25, r24	; 0x19
    4daa:	89 8d       	ldd	r24, Y+25	; 0x19
    4dac:	9a 8d       	ldd	r25, Y+26	; 0x1a
    4dae:	01 97       	sbiw	r24, 0x01	; 1
    4db0:	f1 f7       	brne	.-4      	; 0x4dae <LCD_vidInit+0x22c>
    4db2:	9a 8f       	std	Y+26, r25	; 0x1a
    4db4:	89 8f       	std	Y+25, r24	; 0x19
	_delay_ms(5);
	LCD_vidCmd(0x03);
    4db6:	83 e0       	ldi	r24, 0x03	; 3
    4db8:	0e 94 3d 28 	call	0x507a	; 0x507a <LCD_vidCmd>
    4dbc:	80 e0       	ldi	r24, 0x00	; 0
    4dbe:	90 e0       	ldi	r25, 0x00	; 0
    4dc0:	a8 ec       	ldi	r26, 0xC8	; 200
    4dc2:	b2 e4       	ldi	r27, 0x42	; 66
    4dc4:	8d 8b       	std	Y+21, r24	; 0x15
    4dc6:	9e 8b       	std	Y+22, r25	; 0x16
    4dc8:	af 8b       	std	Y+23, r26	; 0x17
    4dca:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    4dcc:	6d 89       	ldd	r22, Y+21	; 0x15
    4dce:	7e 89       	ldd	r23, Y+22	; 0x16
    4dd0:	8f 89       	ldd	r24, Y+23	; 0x17
    4dd2:	98 8d       	ldd	r25, Y+24	; 0x18
    4dd4:	2b ea       	ldi	r18, 0xAB	; 171
    4dd6:	3a ea       	ldi	r19, 0xAA	; 170
    4dd8:	4a ea       	ldi	r20, 0xAA	; 170
    4dda:	50 e4       	ldi	r21, 0x40	; 64
    4ddc:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4de0:	dc 01       	movw	r26, r24
    4de2:	cb 01       	movw	r24, r22
    4de4:	89 8b       	std	Y+17, r24	; 0x11
    4de6:	9a 8b       	std	Y+18, r25	; 0x12
    4de8:	ab 8b       	std	Y+19, r26	; 0x13
    4dea:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    4dec:	69 89       	ldd	r22, Y+17	; 0x11
    4dee:	7a 89       	ldd	r23, Y+18	; 0x12
    4df0:	8b 89       	ldd	r24, Y+19	; 0x13
    4df2:	9c 89       	ldd	r25, Y+20	; 0x14
    4df4:	20 e0       	ldi	r18, 0x00	; 0
    4df6:	30 e0       	ldi	r19, 0x00	; 0
    4df8:	40 e8       	ldi	r20, 0x80	; 128
    4dfa:	5f e3       	ldi	r21, 0x3F	; 63
    4dfc:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4e00:	88 23       	and	r24, r24
    4e02:	1c f4       	brge	.+6      	; 0x4e0a <LCD_vidInit+0x288>
		__ticks = 1;
    4e04:	81 e0       	ldi	r24, 0x01	; 1
    4e06:	88 8b       	std	Y+16, r24	; 0x10
    4e08:	91 c0       	rjmp	.+290    	; 0x4f2c <LCD_vidInit+0x3aa>
	else if (__tmp > 255)
    4e0a:	69 89       	ldd	r22, Y+17	; 0x11
    4e0c:	7a 89       	ldd	r23, Y+18	; 0x12
    4e0e:	8b 89       	ldd	r24, Y+19	; 0x13
    4e10:	9c 89       	ldd	r25, Y+20	; 0x14
    4e12:	20 e0       	ldi	r18, 0x00	; 0
    4e14:	30 e0       	ldi	r19, 0x00	; 0
    4e16:	4f e7       	ldi	r20, 0x7F	; 127
    4e18:	53 e4       	ldi	r21, 0x43	; 67
    4e1a:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4e1e:	18 16       	cp	r1, r24
    4e20:	0c f0       	brlt	.+2      	; 0x4e24 <LCD_vidInit+0x2a2>
    4e22:	7b c0       	rjmp	.+246    	; 0x4f1a <LCD_vidInit+0x398>
	{
		_delay_ms(__us / 1000.0);
    4e24:	6d 89       	ldd	r22, Y+21	; 0x15
    4e26:	7e 89       	ldd	r23, Y+22	; 0x16
    4e28:	8f 89       	ldd	r24, Y+23	; 0x17
    4e2a:	98 8d       	ldd	r25, Y+24	; 0x18
    4e2c:	20 e0       	ldi	r18, 0x00	; 0
    4e2e:	30 e0       	ldi	r19, 0x00	; 0
    4e30:	4a e7       	ldi	r20, 0x7A	; 122
    4e32:	54 e4       	ldi	r21, 0x44	; 68
    4e34:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    4e38:	dc 01       	movw	r26, r24
    4e3a:	cb 01       	movw	r24, r22
    4e3c:	8c 87       	std	Y+12, r24	; 0x0c
    4e3e:	9d 87       	std	Y+13, r25	; 0x0d
    4e40:	ae 87       	std	Y+14, r26	; 0x0e
    4e42:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4e44:	6c 85       	ldd	r22, Y+12	; 0x0c
    4e46:	7d 85       	ldd	r23, Y+13	; 0x0d
    4e48:	8e 85       	ldd	r24, Y+14	; 0x0e
    4e4a:	9f 85       	ldd	r25, Y+15	; 0x0f
    4e4c:	20 e0       	ldi	r18, 0x00	; 0
    4e4e:	30 e0       	ldi	r19, 0x00	; 0
    4e50:	4a e7       	ldi	r20, 0x7A	; 122
    4e52:	55 e4       	ldi	r21, 0x45	; 69
    4e54:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4e58:	dc 01       	movw	r26, r24
    4e5a:	cb 01       	movw	r24, r22
    4e5c:	88 87       	std	Y+8, r24	; 0x08
    4e5e:	99 87       	std	Y+9, r25	; 0x09
    4e60:	aa 87       	std	Y+10, r26	; 0x0a
    4e62:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    4e64:	68 85       	ldd	r22, Y+8	; 0x08
    4e66:	79 85       	ldd	r23, Y+9	; 0x09
    4e68:	8a 85       	ldd	r24, Y+10	; 0x0a
    4e6a:	9b 85       	ldd	r25, Y+11	; 0x0b
    4e6c:	20 e0       	ldi	r18, 0x00	; 0
    4e6e:	30 e0       	ldi	r19, 0x00	; 0
    4e70:	40 e8       	ldi	r20, 0x80	; 128
    4e72:	5f e3       	ldi	r21, 0x3F	; 63
    4e74:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4e78:	88 23       	and	r24, r24
    4e7a:	2c f4       	brge	.+10     	; 0x4e86 <LCD_vidInit+0x304>
		__ticks = 1;
    4e7c:	81 e0       	ldi	r24, 0x01	; 1
    4e7e:	90 e0       	ldi	r25, 0x00	; 0
    4e80:	9f 83       	std	Y+7, r25	; 0x07
    4e82:	8e 83       	std	Y+6, r24	; 0x06
    4e84:	3f c0       	rjmp	.+126    	; 0x4f04 <LCD_vidInit+0x382>
	else if (__tmp > 65535)
    4e86:	68 85       	ldd	r22, Y+8	; 0x08
    4e88:	79 85       	ldd	r23, Y+9	; 0x09
    4e8a:	8a 85       	ldd	r24, Y+10	; 0x0a
    4e8c:	9b 85       	ldd	r25, Y+11	; 0x0b
    4e8e:	20 e0       	ldi	r18, 0x00	; 0
    4e90:	3f ef       	ldi	r19, 0xFF	; 255
    4e92:	4f e7       	ldi	r20, 0x7F	; 127
    4e94:	57 e4       	ldi	r21, 0x47	; 71
    4e96:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4e9a:	18 16       	cp	r1, r24
    4e9c:	4c f5       	brge	.+82     	; 0x4ef0 <LCD_vidInit+0x36e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4e9e:	6c 85       	ldd	r22, Y+12	; 0x0c
    4ea0:	7d 85       	ldd	r23, Y+13	; 0x0d
    4ea2:	8e 85       	ldd	r24, Y+14	; 0x0e
    4ea4:	9f 85       	ldd	r25, Y+15	; 0x0f
    4ea6:	20 e0       	ldi	r18, 0x00	; 0
    4ea8:	30 e0       	ldi	r19, 0x00	; 0
    4eaa:	40 e2       	ldi	r20, 0x20	; 32
    4eac:	51 e4       	ldi	r21, 0x41	; 65
    4eae:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4eb2:	dc 01       	movw	r26, r24
    4eb4:	cb 01       	movw	r24, r22
    4eb6:	bc 01       	movw	r22, r24
    4eb8:	cd 01       	movw	r24, r26
    4eba:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4ebe:	dc 01       	movw	r26, r24
    4ec0:	cb 01       	movw	r24, r22
    4ec2:	9f 83       	std	Y+7, r25	; 0x07
    4ec4:	8e 83       	std	Y+6, r24	; 0x06
    4ec6:	0f c0       	rjmp	.+30     	; 0x4ee6 <LCD_vidInit+0x364>
    4ec8:	80 e9       	ldi	r24, 0x90	; 144
    4eca:	91 e0       	ldi	r25, 0x01	; 1
    4ecc:	9d 83       	std	Y+5, r25	; 0x05
    4ece:	8c 83       	std	Y+4, r24	; 0x04
    4ed0:	8c 81       	ldd	r24, Y+4	; 0x04
    4ed2:	9d 81       	ldd	r25, Y+5	; 0x05
    4ed4:	01 97       	sbiw	r24, 0x01	; 1
    4ed6:	f1 f7       	brne	.-4      	; 0x4ed4 <LCD_vidInit+0x352>
    4ed8:	9d 83       	std	Y+5, r25	; 0x05
    4eda:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4edc:	8e 81       	ldd	r24, Y+6	; 0x06
    4ede:	9f 81       	ldd	r25, Y+7	; 0x07
    4ee0:	01 97       	sbiw	r24, 0x01	; 1
    4ee2:	9f 83       	std	Y+7, r25	; 0x07
    4ee4:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4ee6:	8e 81       	ldd	r24, Y+6	; 0x06
    4ee8:	9f 81       	ldd	r25, Y+7	; 0x07
    4eea:	00 97       	sbiw	r24, 0x00	; 0
    4eec:	69 f7       	brne	.-38     	; 0x4ec8 <LCD_vidInit+0x346>
    4eee:	24 c0       	rjmp	.+72     	; 0x4f38 <LCD_vidInit+0x3b6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4ef0:	68 85       	ldd	r22, Y+8	; 0x08
    4ef2:	79 85       	ldd	r23, Y+9	; 0x09
    4ef4:	8a 85       	ldd	r24, Y+10	; 0x0a
    4ef6:	9b 85       	ldd	r25, Y+11	; 0x0b
    4ef8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4efc:	dc 01       	movw	r26, r24
    4efe:	cb 01       	movw	r24, r22
    4f00:	9f 83       	std	Y+7, r25	; 0x07
    4f02:	8e 83       	std	Y+6, r24	; 0x06
    4f04:	8e 81       	ldd	r24, Y+6	; 0x06
    4f06:	9f 81       	ldd	r25, Y+7	; 0x07
    4f08:	9b 83       	std	Y+3, r25	; 0x03
    4f0a:	8a 83       	std	Y+2, r24	; 0x02
    4f0c:	8a 81       	ldd	r24, Y+2	; 0x02
    4f0e:	9b 81       	ldd	r25, Y+3	; 0x03
    4f10:	01 97       	sbiw	r24, 0x01	; 1
    4f12:	f1 f7       	brne	.-4      	; 0x4f10 <LCD_vidInit+0x38e>
    4f14:	9b 83       	std	Y+3, r25	; 0x03
    4f16:	8a 83       	std	Y+2, r24	; 0x02
    4f18:	0f c0       	rjmp	.+30     	; 0x4f38 <LCD_vidInit+0x3b6>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4f1a:	69 89       	ldd	r22, Y+17	; 0x11
    4f1c:	7a 89       	ldd	r23, Y+18	; 0x12
    4f1e:	8b 89       	ldd	r24, Y+19	; 0x13
    4f20:	9c 89       	ldd	r25, Y+20	; 0x14
    4f22:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4f26:	dc 01       	movw	r26, r24
    4f28:	cb 01       	movw	r24, r22
    4f2a:	88 8b       	std	Y+16, r24	; 0x10
    4f2c:	88 89       	ldd	r24, Y+16	; 0x10
    4f2e:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4f30:	89 81       	ldd	r24, Y+1	; 0x01
    4f32:	8a 95       	dec	r24
    4f34:	f1 f7       	brne	.-4      	; 0x4f32 <LCD_vidInit+0x3b0>
    4f36:	89 83       	std	Y+1, r24	; 0x01
	_delay_us(100);
	LCD_vidCmd(0x03);
    4f38:	83 e0       	ldi	r24, 0x03	; 3
    4f3a:	0e 94 3d 28 	call	0x507a	; 0x507a <LCD_vidCmd>
	LCD_vidCmd(0x02);
    4f3e:	82 e0       	ldi	r24, 0x02	; 2
    4f40:	0e 94 3d 28 	call	0x507a	; 0x507a <LCD_vidCmd>
	LCD_vidCmd(LCD_4BIT_MODE);
    4f44:	88 e2       	ldi	r24, 0x28	; 40
    4f46:	0e 94 3d 28 	call	0x507a	; 0x507a <LCD_vidCmd>
	  0b11111,
	  0b10001,
	  0b11111,
	  0b10101,
	  0b11011
	};
    4f4a:	ce 01       	movw	r24, r28
    4f4c:	c6 96       	adiw	r24, 0x36	; 54
    4f4e:	9f af       	std	Y+63, r25	; 0x3f
    4f50:	8e af       	std	Y+62, r24	; 0x3e
    4f52:	e3 eb       	ldi	r30, 0xB3	; 179
    4f54:	f1 e0       	ldi	r31, 0x01	; 1
    4f56:	22 96       	adiw	r28, 0x02	; 2
    4f58:	ff af       	std	Y+63, r31	; 0x3f
    4f5a:	ee af       	std	Y+62, r30	; 0x3e
    4f5c:	22 97       	sbiw	r28, 0x02	; 2
    4f5e:	f8 e0       	ldi	r31, 0x08	; 8
    4f60:	23 96       	adiw	r28, 0x03	; 3
    4f62:	ff af       	std	Y+63, r31	; 0x3f
    4f64:	23 97       	sbiw	r28, 0x03	; 3
    4f66:	22 96       	adiw	r28, 0x02	; 2
    4f68:	ee ad       	ldd	r30, Y+62	; 0x3e
    4f6a:	ff ad       	ldd	r31, Y+63	; 0x3f
    4f6c:	22 97       	sbiw	r28, 0x02	; 2
    4f6e:	00 80       	ld	r0, Z
    4f70:	22 96       	adiw	r28, 0x02	; 2
    4f72:	8e ad       	ldd	r24, Y+62	; 0x3e
    4f74:	9f ad       	ldd	r25, Y+63	; 0x3f
    4f76:	22 97       	sbiw	r28, 0x02	; 2
    4f78:	01 96       	adiw	r24, 0x01	; 1
    4f7a:	22 96       	adiw	r28, 0x02	; 2
    4f7c:	9f af       	std	Y+63, r25	; 0x3f
    4f7e:	8e af       	std	Y+62, r24	; 0x3e
    4f80:	22 97       	sbiw	r28, 0x02	; 2
    4f82:	ee ad       	ldd	r30, Y+62	; 0x3e
    4f84:	ff ad       	ldd	r31, Y+63	; 0x3f
    4f86:	00 82       	st	Z, r0
    4f88:	8e ad       	ldd	r24, Y+62	; 0x3e
    4f8a:	9f ad       	ldd	r25, Y+63	; 0x3f
    4f8c:	01 96       	adiw	r24, 0x01	; 1
    4f8e:	9f af       	std	Y+63, r25	; 0x3f
    4f90:	8e af       	std	Y+62, r24	; 0x3e
    4f92:	23 96       	adiw	r28, 0x03	; 3
    4f94:	9f ad       	ldd	r25, Y+63	; 0x3f
    4f96:	23 97       	sbiw	r28, 0x03	; 3
    4f98:	91 50       	subi	r25, 0x01	; 1
    4f9a:	23 96       	adiw	r28, 0x03	; 3
    4f9c:	9f af       	std	Y+63, r25	; 0x3f
    4f9e:	23 97       	sbiw	r28, 0x03	; 3
    4fa0:	23 96       	adiw	r28, 0x03	; 3
    4fa2:	ef ad       	ldd	r30, Y+63	; 0x3f
    4fa4:	23 97       	sbiw	r28, 0x03	; 3
    4fa6:	ee 23       	and	r30, r30
    4fa8:	f1 f6       	brne	.-68     	; 0x4f66 <LCD_vidInit+0x3e4>

	u8 counter;

	for (counter = 0; counter<8;counter++)
    4faa:	1d aa       	std	Y+53, r1	; 0x35
    4fac:	12 c0       	rjmp	.+36     	; 0x4fd2 <LCD_vidInit+0x450>
	{

		LCD_vidCmd(LCD_CGRAM_START_ADDRESS + counter);
    4fae:	8d a9       	ldd	r24, Y+53	; 0x35
    4fb0:	80 5c       	subi	r24, 0xC0	; 192
    4fb2:	0e 94 3d 28 	call	0x507a	; 0x507a <LCD_vidCmd>
		LCD_vidDisplayChar(customChar[counter]);
    4fb6:	8d a9       	ldd	r24, Y+53	; 0x35
    4fb8:	28 2f       	mov	r18, r24
    4fba:	30 e0       	ldi	r19, 0x00	; 0
    4fbc:	ce 01       	movw	r24, r28
    4fbe:	c6 96       	adiw	r24, 0x36	; 54
    4fc0:	fc 01       	movw	r30, r24
    4fc2:	e2 0f       	add	r30, r18
    4fc4:	f3 1f       	adc	r31, r19
    4fc6:	80 81       	ld	r24, Z
    4fc8:	0e 94 fa 27 	call	0x4ff4	; 0x4ff4 <LCD_vidDisplayChar>
	  0b11011
	};

	u8 counter;

	for (counter = 0; counter<8;counter++)
    4fcc:	8d a9       	ldd	r24, Y+53	; 0x35
    4fce:	8f 5f       	subi	r24, 0xFF	; 255
    4fd0:	8d ab       	std	Y+53, r24	; 0x35
    4fd2:	8d a9       	ldd	r24, Y+53	; 0x35
    4fd4:	88 30       	cpi	r24, 0x08	; 8
    4fd6:	58 f3       	brcs	.-42     	; 0x4fae <LCD_vidInit+0x42c>
	{

		LCD_vidCmd(LCD_CGRAM_START_ADDRESS + counter);
		LCD_vidDisplayChar(customChar[counter]);
	}
	LCD_vidRowColumn(0,0);
    4fd8:	80 e0       	ldi	r24, 0x00	; 0
    4fda:	60 e0       	ldi	r22, 0x00	; 0
    4fdc:	0e 94 64 28 	call	0x50c8	; 0x50c8 <LCD_vidRowColumn>
}
    4fe0:	ce 5b       	subi	r28, 0xBE	; 190
    4fe2:	df 4f       	sbci	r29, 0xFF	; 255
    4fe4:	0f b6       	in	r0, 0x3f	; 63
    4fe6:	f8 94       	cli
    4fe8:	de bf       	out	0x3e, r29	; 62
    4fea:	0f be       	out	0x3f, r0	; 63
    4fec:	cd bf       	out	0x3d, r28	; 61
    4fee:	cf 91       	pop	r28
    4ff0:	df 91       	pop	r29
    4ff2:	08 95       	ret

00004ff4 <LCD_vidDisplayChar>:

void LCD_vidDisplayChar(u8 chr)
{
    4ff4:	df 93       	push	r29
    4ff6:	cf 93       	push	r28
    4ff8:	00 d0       	rcall	.+0      	; 0x4ffa <LCD_vidDisplayChar+0x6>
    4ffa:	0f 92       	push	r0
    4ffc:	cd b7       	in	r28, 0x3d	; 61
    4ffe:	de b7       	in	r29, 0x3e	; 62
    5000:	8b 83       	std	Y+3, r24	; 0x03
	u8 loc_MSB = (chr & ~LCD_MASK);
    5002:	8b 81       	ldd	r24, Y+3	; 0x03
    5004:	80 7f       	andi	r24, 0xF0	; 240
    5006:	8a 83       	std	Y+2, r24	; 0x02
	u8 loc_LSB = (chr << 4);
    5008:	8b 81       	ldd	r24, Y+3	; 0x03
    500a:	82 95       	swap	r24
    500c:	80 7f       	andi	r24, 0xF0	; 240
    500e:	89 83       	std	Y+1, r24	; 0x01

	/* RS = 1 */
	Dio_vidwriteChannel(DIO_PORTB,DIO_PIN1,DIO_HIGH);
    5010:	81 e0       	ldi	r24, 0x01	; 1
    5012:	61 e0       	ldi	r22, 0x01	; 1
    5014:	41 e0       	ldi	r20, 0x01	; 1
    5016:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
	/* Write MSB to LCD */
	Dio_vidwriteChannelGroup(DIO_PORTA,loc_MSB,LCD_MASK);
    501a:	80 e0       	ldi	r24, 0x00	; 0
    501c:	6a 81       	ldd	r22, Y+2	; 0x02
    501e:	4f e0       	ldi	r20, 0x0F	; 15
    5020:	0e 94 2d 33 	call	0x665a	; 0x665a <Dio_vidwriteChannelGroup>
	/* Send Enable Pulse */
	LCD_vidEnablePulse();
    5024:	0e 94 74 24 	call	0x48e8	; 0x48e8 <LCD_vidEnablePulse>


	/* Write LSB to LCD */
	Dio_vidwriteChannelGroup(DIO_PORTA,loc_LSB,LCD_MASK);
    5028:	80 e0       	ldi	r24, 0x00	; 0
    502a:	69 81       	ldd	r22, Y+1	; 0x01
    502c:	4f e0       	ldi	r20, 0x0F	; 15
    502e:	0e 94 2d 33 	call	0x665a	; 0x665a <Dio_vidwriteChannelGroup>
	/* Send Enable Pulse */
	LCD_vidEnablePulse();
    5032:	0e 94 74 24 	call	0x48e8	; 0x48e8 <LCD_vidEnablePulse>
}
    5036:	0f 90       	pop	r0
    5038:	0f 90       	pop	r0
    503a:	0f 90       	pop	r0
    503c:	cf 91       	pop	r28
    503e:	df 91       	pop	r29
    5040:	08 95       	ret

00005042 <LCD_vidDisplayWord>:

void LCD_vidDisplayWord(u8 *word)
{
    5042:	df 93       	push	r29
    5044:	cf 93       	push	r28
    5046:	00 d0       	rcall	.+0      	; 0x5048 <LCD_vidDisplayWord+0x6>
    5048:	cd b7       	in	r28, 0x3d	; 61
    504a:	de b7       	in	r29, 0x3e	; 62
    504c:	9a 83       	std	Y+2, r25	; 0x02
    504e:	89 83       	std	Y+1, r24	; 0x01
    5050:	0a c0       	rjmp	.+20     	; 0x5066 <LCD_vidDisplayWord+0x24>
	while (*word != '\0')
	{
		LCD_vidDisplayChar(*word);
    5052:	e9 81       	ldd	r30, Y+1	; 0x01
    5054:	fa 81       	ldd	r31, Y+2	; 0x02
    5056:	80 81       	ld	r24, Z
    5058:	0e 94 fa 27 	call	0x4ff4	; 0x4ff4 <LCD_vidDisplayChar>
		word++;
    505c:	89 81       	ldd	r24, Y+1	; 0x01
    505e:	9a 81       	ldd	r25, Y+2	; 0x02
    5060:	01 96       	adiw	r24, 0x01	; 1
    5062:	9a 83       	std	Y+2, r25	; 0x02
    5064:	89 83       	std	Y+1, r24	; 0x01
	LCD_vidEnablePulse();
}

void LCD_vidDisplayWord(u8 *word)
{
	while (*word != '\0')
    5066:	e9 81       	ldd	r30, Y+1	; 0x01
    5068:	fa 81       	ldd	r31, Y+2	; 0x02
    506a:	80 81       	ld	r24, Z
    506c:	88 23       	and	r24, r24
    506e:	89 f7       	brne	.-30     	; 0x5052 <LCD_vidDisplayWord+0x10>
	{
		LCD_vidDisplayChar(*word);
		word++;
	}
}
    5070:	0f 90       	pop	r0
    5072:	0f 90       	pop	r0
    5074:	cf 91       	pop	r28
    5076:	df 91       	pop	r29
    5078:	08 95       	ret

0000507a <LCD_vidCmd>:

void LCD_vidCmd(lcd_Cmd_t cmd)
{
    507a:	df 93       	push	r29
    507c:	cf 93       	push	r28
    507e:	00 d0       	rcall	.+0      	; 0x5080 <LCD_vidCmd+0x6>
    5080:	0f 92       	push	r0
    5082:	cd b7       	in	r28, 0x3d	; 61
    5084:	de b7       	in	r29, 0x3e	; 62
    5086:	8b 83       	std	Y+3, r24	; 0x03
	u8 loc_MSB = (cmd & ~LCD_MASK);
    5088:	8b 81       	ldd	r24, Y+3	; 0x03
    508a:	80 7f       	andi	r24, 0xF0	; 240
    508c:	8a 83       	std	Y+2, r24	; 0x02
	u8 loc_LSB = (cmd << 4);
    508e:	8b 81       	ldd	r24, Y+3	; 0x03
    5090:	82 95       	swap	r24
    5092:	80 7f       	andi	r24, 0xF0	; 240
    5094:	89 83       	std	Y+1, r24	; 0x01

	Dio_vidwriteChannel(DIO_PORTB,DIO_PIN1,DIO_LOW);
    5096:	81 e0       	ldi	r24, 0x01	; 1
    5098:	61 e0       	ldi	r22, 0x01	; 1
    509a:	40 e0       	ldi	r20, 0x00	; 0
    509c:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>

	/* Write MSB to LCD */
	Dio_vidwriteChannelGroup(DIO_PORTA,loc_MSB,LCD_MASK);
    50a0:	80 e0       	ldi	r24, 0x00	; 0
    50a2:	6a 81       	ldd	r22, Y+2	; 0x02
    50a4:	4f e0       	ldi	r20, 0x0F	; 15
    50a6:	0e 94 2d 33 	call	0x665a	; 0x665a <Dio_vidwriteChannelGroup>
	/* Send Enable Pulse */
	LCD_vidEnablePulse();
    50aa:	0e 94 74 24 	call	0x48e8	; 0x48e8 <LCD_vidEnablePulse>


	/* Write LSB to LCD */
	Dio_vidwriteChannelGroup(DIO_PORTA,loc_LSB,LCD_MASK);
    50ae:	80 e0       	ldi	r24, 0x00	; 0
    50b0:	69 81       	ldd	r22, Y+1	; 0x01
    50b2:	4f e0       	ldi	r20, 0x0F	; 15
    50b4:	0e 94 2d 33 	call	0x665a	; 0x665a <Dio_vidwriteChannelGroup>
	/* Send Enable Pulse */
	LCD_vidEnablePulse();
    50b8:	0e 94 74 24 	call	0x48e8	; 0x48e8 <LCD_vidEnablePulse>
}
    50bc:	0f 90       	pop	r0
    50be:	0f 90       	pop	r0
    50c0:	0f 90       	pop	r0
    50c2:	cf 91       	pop	r28
    50c4:	df 91       	pop	r29
    50c6:	08 95       	ret

000050c8 <LCD_vidRowColumn>:

void LCD_vidRowColumn(u8 row,u8 column)
{
    50c8:	df 93       	push	r29
    50ca:	cf 93       	push	r28
    50cc:	00 d0       	rcall	.+0      	; 0x50ce <LCD_vidRowColumn+0x6>
    50ce:	00 d0       	rcall	.+0      	; 0x50d0 <LCD_vidRowColumn+0x8>
    50d0:	cd b7       	in	r28, 0x3d	; 61
    50d2:	de b7       	in	r29, 0x3e	; 62
    50d4:	89 83       	std	Y+1, r24	; 0x01
    50d6:	6a 83       	std	Y+2, r22	; 0x02
	switch (row)
    50d8:	89 81       	ldd	r24, Y+1	; 0x01
    50da:	28 2f       	mov	r18, r24
    50dc:	30 e0       	ldi	r19, 0x00	; 0
    50de:	3c 83       	std	Y+4, r19	; 0x04
    50e0:	2b 83       	std	Y+3, r18	; 0x03
    50e2:	8b 81       	ldd	r24, Y+3	; 0x03
    50e4:	9c 81       	ldd	r25, Y+4	; 0x04
    50e6:	00 97       	sbiw	r24, 0x00	; 0
    50e8:	31 f0       	breq	.+12     	; 0x50f6 <LCD_vidRowColumn+0x2e>
    50ea:	2b 81       	ldd	r18, Y+3	; 0x03
    50ec:	3c 81       	ldd	r19, Y+4	; 0x04
    50ee:	21 30       	cpi	r18, 0x01	; 1
    50f0:	31 05       	cpc	r19, r1
    50f2:	31 f0       	breq	.+12     	; 0x5100 <LCD_vidRowColumn+0x38>
    50f4:	09 c0       	rjmp	.+18     	; 0x5108 <LCD_vidRowColumn+0x40>
	{
	case 0:
	{
		LCD_vidCmd(0x80 + column);
    50f6:	8a 81       	ldd	r24, Y+2	; 0x02
    50f8:	80 58       	subi	r24, 0x80	; 128
    50fa:	0e 94 3d 28 	call	0x507a	; 0x507a <LCD_vidCmd>
    50fe:	04 c0       	rjmp	.+8      	; 0x5108 <LCD_vidRowColumn+0x40>
		break;
	}
	case 1:
	{
		LCD_vidCmd(0xC0 + column);
    5100:	8a 81       	ldd	r24, Y+2	; 0x02
    5102:	80 54       	subi	r24, 0x40	; 64
    5104:	0e 94 3d 28 	call	0x507a	; 0x507a <LCD_vidCmd>
		break;
	}
	}
}
    5108:	0f 90       	pop	r0
    510a:	0f 90       	pop	r0
    510c:	0f 90       	pop	r0
    510e:	0f 90       	pop	r0
    5110:	cf 91       	pop	r28
    5112:	df 91       	pop	r29
    5114:	08 95       	ret

00005116 <LCD_vidDisplayInt>:

void LCD_vidDisplayInt(u32 num)
{
    5116:	df 93       	push	r29
    5118:	cf 93       	push	r28
    511a:	cd b7       	in	r28, 0x3d	; 61
    511c:	de b7       	in	r29, 0x3e	; 62
    511e:	2e 97       	sbiw	r28, 0x0e	; 14
    5120:	0f b6       	in	r0, 0x3f	; 63
    5122:	f8 94       	cli
    5124:	de bf       	out	0x3e, r29	; 62
    5126:	0f be       	out	0x3f, r0	; 63
    5128:	cd bf       	out	0x3d, r28	; 61
    512a:	6b 87       	std	Y+11, r22	; 0x0b
    512c:	7c 87       	std	Y+12, r23	; 0x0c
    512e:	8d 87       	std	Y+13, r24	; 0x0d
    5130:	9e 87       	std	Y+14, r25	; 0x0e
	u8 buffer[10];
	sprintf(buffer,"%d",num);
    5132:	8d b7       	in	r24, 0x3d	; 61
    5134:	9e b7       	in	r25, 0x3e	; 62
    5136:	08 97       	sbiw	r24, 0x08	; 8
    5138:	0f b6       	in	r0, 0x3f	; 63
    513a:	f8 94       	cli
    513c:	9e bf       	out	0x3e, r25	; 62
    513e:	0f be       	out	0x3f, r0	; 63
    5140:	8d bf       	out	0x3d, r24	; 61
    5142:	ed b7       	in	r30, 0x3d	; 61
    5144:	fe b7       	in	r31, 0x3e	; 62
    5146:	31 96       	adiw	r30, 0x01	; 1
    5148:	ce 01       	movw	r24, r28
    514a:	01 96       	adiw	r24, 0x01	; 1
    514c:	91 83       	std	Z+1, r25	; 0x01
    514e:	80 83       	st	Z, r24
    5150:	81 e9       	ldi	r24, 0x91	; 145
    5152:	90 e0       	ldi	r25, 0x00	; 0
    5154:	93 83       	std	Z+3, r25	; 0x03
    5156:	82 83       	std	Z+2, r24	; 0x02
    5158:	8b 85       	ldd	r24, Y+11	; 0x0b
    515a:	9c 85       	ldd	r25, Y+12	; 0x0c
    515c:	ad 85       	ldd	r26, Y+13	; 0x0d
    515e:	be 85       	ldd	r27, Y+14	; 0x0e
    5160:	84 83       	std	Z+4, r24	; 0x04
    5162:	95 83       	std	Z+5, r25	; 0x05
    5164:	a6 83       	std	Z+6, r26	; 0x06
    5166:	b7 83       	std	Z+7, r27	; 0x07
    5168:	0e 94 94 34 	call	0x6928	; 0x6928 <sprintf>
    516c:	8d b7       	in	r24, 0x3d	; 61
    516e:	9e b7       	in	r25, 0x3e	; 62
    5170:	08 96       	adiw	r24, 0x08	; 8
    5172:	0f b6       	in	r0, 0x3f	; 63
    5174:	f8 94       	cli
    5176:	9e bf       	out	0x3e, r25	; 62
    5178:	0f be       	out	0x3f, r0	; 63
    517a:	8d bf       	out	0x3d, r24	; 61
	LCD_vidDisplayWord(buffer);
    517c:	ce 01       	movw	r24, r28
    517e:	01 96       	adiw	r24, 0x01	; 1
    5180:	0e 94 21 28 	call	0x5042	; 0x5042 <LCD_vidDisplayWord>
}
    5184:	2e 96       	adiw	r28, 0x0e	; 14
    5186:	0f b6       	in	r0, 0x3f	; 63
    5188:	f8 94       	cli
    518a:	de bf       	out	0x3e, r29	; 62
    518c:	0f be       	out	0x3f, r0	; 63
    518e:	cd bf       	out	0x3d, r28	; 61
    5190:	cf 91       	pop	r28
    5192:	df 91       	pop	r29
    5194:	08 95       	ret

00005196 <LCD_vidDisplayFloat>:

void LCD_vidDisplayFloat(f64 num)
{
    5196:	df 93       	push	r29
    5198:	cf 93       	push	r28
    519a:	cd b7       	in	r28, 0x3d	; 61
    519c:	de b7       	in	r29, 0x3e	; 62
    519e:	ac 97       	sbiw	r28, 0x2c	; 44
    51a0:	0f b6       	in	r0, 0x3f	; 63
    51a2:	f8 94       	cli
    51a4:	de bf       	out	0x3e, r29	; 62
    51a6:	0f be       	out	0x3f, r0	; 63
    51a8:	cd bf       	out	0x3d, r28	; 61
    51aa:	69 a7       	std	Y+41, r22	; 0x29
    51ac:	7a a7       	std	Y+42, r23	; 0x2a
    51ae:	8b a7       	std	Y+43, r24	; 0x2b
    51b0:	9c a7       	std	Y+44, r25	; 0x2c
	f64 buffer[10];
	sprintf(buffer,"%f",num);
    51b2:	ce 01       	movw	r24, r28
    51b4:	01 96       	adiw	r24, 0x01	; 1
    51b6:	2d b7       	in	r18, 0x3d	; 61
    51b8:	3e b7       	in	r19, 0x3e	; 62
    51ba:	28 50       	subi	r18, 0x08	; 8
    51bc:	30 40       	sbci	r19, 0x00	; 0
    51be:	0f b6       	in	r0, 0x3f	; 63
    51c0:	f8 94       	cli
    51c2:	3e bf       	out	0x3e, r19	; 62
    51c4:	0f be       	out	0x3f, r0	; 63
    51c6:	2d bf       	out	0x3d, r18	; 61
    51c8:	ed b7       	in	r30, 0x3d	; 61
    51ca:	fe b7       	in	r31, 0x3e	; 62
    51cc:	31 96       	adiw	r30, 0x01	; 1
    51ce:	91 83       	std	Z+1, r25	; 0x01
    51d0:	80 83       	st	Z, r24
    51d2:	84 e9       	ldi	r24, 0x94	; 148
    51d4:	90 e0       	ldi	r25, 0x00	; 0
    51d6:	93 83       	std	Z+3, r25	; 0x03
    51d8:	82 83       	std	Z+2, r24	; 0x02
    51da:	89 a5       	ldd	r24, Y+41	; 0x29
    51dc:	9a a5       	ldd	r25, Y+42	; 0x2a
    51de:	ab a5       	ldd	r26, Y+43	; 0x2b
    51e0:	bc a5       	ldd	r27, Y+44	; 0x2c
    51e2:	84 83       	std	Z+4, r24	; 0x04
    51e4:	95 83       	std	Z+5, r25	; 0x05
    51e6:	a6 83       	std	Z+6, r26	; 0x06
    51e8:	b7 83       	std	Z+7, r27	; 0x07
    51ea:	0e 94 94 34 	call	0x6928	; 0x6928 <sprintf>
    51ee:	8d b7       	in	r24, 0x3d	; 61
    51f0:	9e b7       	in	r25, 0x3e	; 62
    51f2:	08 96       	adiw	r24, 0x08	; 8
    51f4:	0f b6       	in	r0, 0x3f	; 63
    51f6:	f8 94       	cli
    51f8:	9e bf       	out	0x3e, r25	; 62
    51fa:	0f be       	out	0x3f, r0	; 63
    51fc:	8d bf       	out	0x3d, r24	; 61
	LCD_vidDisplayWord(buffer);
    51fe:	ce 01       	movw	r24, r28
    5200:	01 96       	adiw	r24, 0x01	; 1
    5202:	0e 94 21 28 	call	0x5042	; 0x5042 <LCD_vidDisplayWord>
}
    5206:	ac 96       	adiw	r28, 0x2c	; 44
    5208:	0f b6       	in	r0, 0x3f	; 63
    520a:	f8 94       	cli
    520c:	de bf       	out	0x3e, r29	; 62
    520e:	0f be       	out	0x3f, r0	; 63
    5210:	cd bf       	out	0x3d, r28	; 61
    5212:	cf 91       	pop	r28
    5214:	df 91       	pop	r29
    5216:	08 95       	ret

00005218 <KEYPAD_vidInit>:
		{'7','8','9','C'},
	    {'*','0','#','D'}
};

void KEYPAD_vidInit(void)
{
    5218:	df 93       	push	r29
    521a:	cf 93       	push	r28
    521c:	cd b7       	in	r28, 0x3d	; 61
    521e:	de b7       	in	r29, 0x3e	; 62
	/* Configure Rows Pins as input */
	Dio_vidconfigChannel(DIO_PORTD,DIO_PIN6,DIO_INPUT);
    5220:	83 e0       	ldi	r24, 0x03	; 3
    5222:	66 e0       	ldi	r22, 0x06	; 6
    5224:	40 e0       	ldi	r20, 0x00	; 0
    5226:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTD,DIO_PIN3,DIO_INPUT);
    522a:	83 e0       	ldi	r24, 0x03	; 3
    522c:	63 e0       	ldi	r22, 0x03	; 3
    522e:	40 e0       	ldi	r20, 0x00	; 0
    5230:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTC,DIO_PIN2,DIO_INPUT);
    5234:	82 e0       	ldi	r24, 0x02	; 2
    5236:	62 e0       	ldi	r22, 0x02	; 2
    5238:	40 e0       	ldi	r20, 0x00	; 0
    523a:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTC,DIO_PIN3,DIO_INPUT);
    523e:	82 e0       	ldi	r24, 0x02	; 2
    5240:	63 e0       	ldi	r22, 0x03	; 3
    5242:	40 e0       	ldi	r20, 0x00	; 0
    5244:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>


	/* Configure Columns pins as output */
	Dio_vidconfigChannel(DIO_PORTC,DIO_PIN4,DIO_OUTPUT);
    5248:	82 e0       	ldi	r24, 0x02	; 2
    524a:	64 e0       	ldi	r22, 0x04	; 4
    524c:	41 e0       	ldi	r20, 0x01	; 1
    524e:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTC,DIO_PIN5,DIO_OUTPUT);
    5252:	82 e0       	ldi	r24, 0x02	; 2
    5254:	65 e0       	ldi	r22, 0x05	; 5
    5256:	41 e0       	ldi	r20, 0x01	; 1
    5258:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTC,DIO_PIN6,DIO_OUTPUT);
    525c:	82 e0       	ldi	r24, 0x02	; 2
    525e:	66 e0       	ldi	r22, 0x06	; 6
    5260:	41 e0       	ldi	r20, 0x01	; 1
    5262:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTC,DIO_PIN7,DIO_OUTPUT);
    5266:	82 e0       	ldi	r24, 0x02	; 2
    5268:	67 e0       	ldi	r22, 0x07	; 7
    526a:	41 e0       	ldi	r20, 0x01	; 1
    526c:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>


	/* Initialize output Columns as High */
	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN4,DIO_HIGH);
    5270:	82 e0       	ldi	r24, 0x02	; 2
    5272:	64 e0       	ldi	r22, 0x04	; 4
    5274:	41 e0       	ldi	r20, 0x01	; 1
    5276:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN5,DIO_HIGH);
    527a:	82 e0       	ldi	r24, 0x02	; 2
    527c:	65 e0       	ldi	r22, 0x05	; 5
    527e:	41 e0       	ldi	r20, 0x01	; 1
    5280:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN6,DIO_HIGH);
    5284:	82 e0       	ldi	r24, 0x02	; 2
    5286:	66 e0       	ldi	r22, 0x06	; 6
    5288:	41 e0       	ldi	r20, 0x01	; 1
    528a:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN7,DIO_HIGH);
    528e:	82 e0       	ldi	r24, 0x02	; 2
    5290:	67 e0       	ldi	r22, 0x07	; 7
    5292:	41 e0       	ldi	r20, 0x01	; 1
    5294:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
}
    5298:	cf 91       	pop	r28
    529a:	df 91       	pop	r29
    529c:	08 95       	ret

0000529e <KEYPAD_udtGetRow>:

kp_row_t KEYPAD_udtGetRow(void)
{
    529e:	df 93       	push	r29
    52a0:	cf 93       	push	r28
    52a2:	0f 92       	push	r0
    52a4:	cd b7       	in	r28, 0x3d	; 61
    52a6:	de b7       	in	r29, 0x3e	; 62
	kp_row_t loc_row = KP_NOROW;
    52a8:	84 e0       	ldi	r24, 0x04	; 4
    52aa:	89 83       	std	Y+1, r24	; 0x01

	if (Dio_udtreadChannel(DIO_PORTD,DIO_PIN6) == DIO_HIGH)
    52ac:	83 e0       	ldi	r24, 0x03	; 3
    52ae:	66 e0       	ldi	r22, 0x06	; 6
    52b0:	0e 94 1c 32 	call	0x6438	; 0x6438 <Dio_udtreadChannel>
    52b4:	81 30       	cpi	r24, 0x01	; 1
    52b6:	11 f4       	brne	.+4      	; 0x52bc <KEYPAD_udtGetRow+0x1e>
	{
		loc_row = KP_ROW0;
    52b8:	19 82       	std	Y+1, r1	; 0x01
    52ba:	1a c0       	rjmp	.+52     	; 0x52f0 <KEYPAD_udtGetRow+0x52>
	}
	else if (Dio_udtreadChannel(DIO_PORTD,DIO_PIN3) == DIO_HIGH)
    52bc:	83 e0       	ldi	r24, 0x03	; 3
    52be:	63 e0       	ldi	r22, 0x03	; 3
    52c0:	0e 94 1c 32 	call	0x6438	; 0x6438 <Dio_udtreadChannel>
    52c4:	81 30       	cpi	r24, 0x01	; 1
    52c6:	19 f4       	brne	.+6      	; 0x52ce <KEYPAD_udtGetRow+0x30>
	{
		loc_row = KP_ROW1;
    52c8:	81 e0       	ldi	r24, 0x01	; 1
    52ca:	89 83       	std	Y+1, r24	; 0x01
    52cc:	11 c0       	rjmp	.+34     	; 0x52f0 <KEYPAD_udtGetRow+0x52>
	}
	else if (Dio_udtreadChannel(DIO_PORTC,DIO_PIN2) == DIO_HIGH)
    52ce:	82 e0       	ldi	r24, 0x02	; 2
    52d0:	62 e0       	ldi	r22, 0x02	; 2
    52d2:	0e 94 1c 32 	call	0x6438	; 0x6438 <Dio_udtreadChannel>
    52d6:	81 30       	cpi	r24, 0x01	; 1
    52d8:	19 f4       	brne	.+6      	; 0x52e0 <KEYPAD_udtGetRow+0x42>
	{
		loc_row = KP_ROW2;
    52da:	82 e0       	ldi	r24, 0x02	; 2
    52dc:	89 83       	std	Y+1, r24	; 0x01
    52de:	08 c0       	rjmp	.+16     	; 0x52f0 <KEYPAD_udtGetRow+0x52>
	}
	else if (Dio_udtreadChannel(DIO_PORTC,DIO_PIN3) == DIO_HIGH)
    52e0:	82 e0       	ldi	r24, 0x02	; 2
    52e2:	63 e0       	ldi	r22, 0x03	; 3
    52e4:	0e 94 1c 32 	call	0x6438	; 0x6438 <Dio_udtreadChannel>
    52e8:	81 30       	cpi	r24, 0x01	; 1
    52ea:	11 f4       	brne	.+4      	; 0x52f0 <KEYPAD_udtGetRow+0x52>
	{
		loc_row = KP_ROW3;
    52ec:	83 e0       	ldi	r24, 0x03	; 3
    52ee:	89 83       	std	Y+1, r24	; 0x01
	}
	return loc_row;
    52f0:	89 81       	ldd	r24, Y+1	; 0x01
}
    52f2:	0f 90       	pop	r0
    52f4:	cf 91       	pop	r28
    52f6:	df 91       	pop	r29
    52f8:	08 95       	ret

000052fa <KEYPAD_udtGetColumn>:

kp_col_t KEYPAD_udtGetColumn(kp_row_t current_row)
{
    52fa:	df 93       	push	r29
    52fc:	cf 93       	push	r28
    52fe:	00 d0       	rcall	.+0      	; 0x5300 <KEYPAD_udtGetColumn+0x6>
    5300:	cd b7       	in	r28, 0x3d	; 61
    5302:	de b7       	in	r29, 0x3e	; 62
    5304:	89 83       	std	Y+1, r24	; 0x01
	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN4,DIO_HIGH);
    5306:	82 e0       	ldi	r24, 0x02	; 2
    5308:	64 e0       	ldi	r22, 0x04	; 4
    530a:	41 e0       	ldi	r20, 0x01	; 1
    530c:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN5,DIO_LOW);
    5310:	82 e0       	ldi	r24, 0x02	; 2
    5312:	65 e0       	ldi	r22, 0x05	; 5
    5314:	40 e0       	ldi	r20, 0x00	; 0
    5316:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN6,DIO_LOW);
    531a:	82 e0       	ldi	r24, 0x02	; 2
    531c:	66 e0       	ldi	r22, 0x06	; 6
    531e:	40 e0       	ldi	r20, 0x00	; 0
    5320:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN7,DIO_LOW);
    5324:	82 e0       	ldi	r24, 0x02	; 2
    5326:	67 e0       	ldi	r22, 0x07	; 7
    5328:	40 e0       	ldi	r20, 0x00	; 0
    532a:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>


	if (KEYPAD_udtGetRow() == current_row)
    532e:	0e 94 4f 29 	call	0x529e	; 0x529e <KEYPAD_udtGetRow>
    5332:	98 2f       	mov	r25, r24
    5334:	89 81       	ldd	r24, Y+1	; 0x01
    5336:	98 17       	cp	r25, r24
    5338:	11 f4       	brne	.+4      	; 0x533e <KEYPAD_udtGetColumn+0x44>
	{
		return KP_COLUMN0;
    533a:	1a 82       	std	Y+2, r1	; 0x02
    533c:	59 c0       	rjmp	.+178    	; 0x53f0 <KEYPAD_udtGetColumn+0xf6>
	}

	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN4,DIO_LOW);
    533e:	82 e0       	ldi	r24, 0x02	; 2
    5340:	64 e0       	ldi	r22, 0x04	; 4
    5342:	40 e0       	ldi	r20, 0x00	; 0
    5344:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN5,DIO_HIGH);
    5348:	82 e0       	ldi	r24, 0x02	; 2
    534a:	65 e0       	ldi	r22, 0x05	; 5
    534c:	41 e0       	ldi	r20, 0x01	; 1
    534e:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN6,DIO_LOW);
    5352:	82 e0       	ldi	r24, 0x02	; 2
    5354:	66 e0       	ldi	r22, 0x06	; 6
    5356:	40 e0       	ldi	r20, 0x00	; 0
    5358:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN7,DIO_LOW);
    535c:	82 e0       	ldi	r24, 0x02	; 2
    535e:	67 e0       	ldi	r22, 0x07	; 7
    5360:	40 e0       	ldi	r20, 0x00	; 0
    5362:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>


	if (KEYPAD_udtGetRow() == current_row)
    5366:	0e 94 4f 29 	call	0x529e	; 0x529e <KEYPAD_udtGetRow>
    536a:	98 2f       	mov	r25, r24
    536c:	89 81       	ldd	r24, Y+1	; 0x01
    536e:	98 17       	cp	r25, r24
    5370:	19 f4       	brne	.+6      	; 0x5378 <KEYPAD_udtGetColumn+0x7e>
	{
		return KP_COLUMN1;
    5372:	81 e0       	ldi	r24, 0x01	; 1
    5374:	8a 83       	std	Y+2, r24	; 0x02
    5376:	3c c0       	rjmp	.+120    	; 0x53f0 <KEYPAD_udtGetColumn+0xf6>
	}

	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN4,DIO_LOW);
    5378:	82 e0       	ldi	r24, 0x02	; 2
    537a:	64 e0       	ldi	r22, 0x04	; 4
    537c:	40 e0       	ldi	r20, 0x00	; 0
    537e:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN5,DIO_LOW);
    5382:	82 e0       	ldi	r24, 0x02	; 2
    5384:	65 e0       	ldi	r22, 0x05	; 5
    5386:	40 e0       	ldi	r20, 0x00	; 0
    5388:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN6,DIO_HIGH);
    538c:	82 e0       	ldi	r24, 0x02	; 2
    538e:	66 e0       	ldi	r22, 0x06	; 6
    5390:	41 e0       	ldi	r20, 0x01	; 1
    5392:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN7,DIO_LOW);
    5396:	82 e0       	ldi	r24, 0x02	; 2
    5398:	67 e0       	ldi	r22, 0x07	; 7
    539a:	40 e0       	ldi	r20, 0x00	; 0
    539c:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>


	if (KEYPAD_udtGetRow() == current_row)
    53a0:	0e 94 4f 29 	call	0x529e	; 0x529e <KEYPAD_udtGetRow>
    53a4:	98 2f       	mov	r25, r24
    53a6:	89 81       	ldd	r24, Y+1	; 0x01
    53a8:	98 17       	cp	r25, r24
    53aa:	19 f4       	brne	.+6      	; 0x53b2 <KEYPAD_udtGetColumn+0xb8>
	{
		return KP_COLUMN2;
    53ac:	82 e0       	ldi	r24, 0x02	; 2
    53ae:	8a 83       	std	Y+2, r24	; 0x02
    53b0:	1f c0       	rjmp	.+62     	; 0x53f0 <KEYPAD_udtGetColumn+0xf6>
	}

	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN4,DIO_LOW);
    53b2:	82 e0       	ldi	r24, 0x02	; 2
    53b4:	64 e0       	ldi	r22, 0x04	; 4
    53b6:	40 e0       	ldi	r20, 0x00	; 0
    53b8:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN5,DIO_LOW);
    53bc:	82 e0       	ldi	r24, 0x02	; 2
    53be:	65 e0       	ldi	r22, 0x05	; 5
    53c0:	40 e0       	ldi	r20, 0x00	; 0
    53c2:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN6,DIO_LOW);
    53c6:	82 e0       	ldi	r24, 0x02	; 2
    53c8:	66 e0       	ldi	r22, 0x06	; 6
    53ca:	40 e0       	ldi	r20, 0x00	; 0
    53cc:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN7,DIO_HIGH);
    53d0:	82 e0       	ldi	r24, 0x02	; 2
    53d2:	67 e0       	ldi	r22, 0x07	; 7
    53d4:	41 e0       	ldi	r20, 0x01	; 1
    53d6:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>


	if (KEYPAD_udtGetRow() == current_row)
    53da:	0e 94 4f 29 	call	0x529e	; 0x529e <KEYPAD_udtGetRow>
    53de:	98 2f       	mov	r25, r24
    53e0:	89 81       	ldd	r24, Y+1	; 0x01
    53e2:	98 17       	cp	r25, r24
    53e4:	19 f4       	brne	.+6      	; 0x53ec <KEYPAD_udtGetColumn+0xf2>
	{
		return KP_COLUMN3;
    53e6:	83 e0       	ldi	r24, 0x03	; 3
    53e8:	8a 83       	std	Y+2, r24	; 0x02
    53ea:	02 c0       	rjmp	.+4      	; 0x53f0 <KEYPAD_udtGetColumn+0xf6>
	}
	return KP_NOCOLUMN;
    53ec:	84 e0       	ldi	r24, 0x04	; 4
    53ee:	8a 83       	std	Y+2, r24	; 0x02
    53f0:	8a 81       	ldd	r24, Y+2	; 0x02
}
    53f2:	0f 90       	pop	r0
    53f4:	0f 90       	pop	r0
    53f6:	cf 91       	pop	r28
    53f8:	df 91       	pop	r29
    53fa:	08 95       	ret

000053fc <KEYPAD_udtIsPressed>:

boolean KEYPAD_udtIsPressed()
{
    53fc:	df 93       	push	r29
    53fe:	cf 93       	push	r28
    5400:	0f 92       	push	r0
    5402:	cd b7       	in	r28, 0x3d	; 61
    5404:	de b7       	in	r29, 0x3e	; 62
	if (
    5406:	83 e0       	ldi	r24, 0x03	; 3
    5408:	66 e0       	ldi	r22, 0x06	; 6
    540a:	0e 94 1c 32 	call	0x6438	; 0x6438 <Dio_udtreadChannel>
    540e:	81 30       	cpi	r24, 0x01	; 1
    5410:	91 f0       	breq	.+36     	; 0x5436 <KEYPAD_udtIsPressed+0x3a>
    5412:	83 e0       	ldi	r24, 0x03	; 3
    5414:	63 e0       	ldi	r22, 0x03	; 3
    5416:	0e 94 1c 32 	call	0x6438	; 0x6438 <Dio_udtreadChannel>
    541a:	81 30       	cpi	r24, 0x01	; 1
    541c:	61 f0       	breq	.+24     	; 0x5436 <KEYPAD_udtIsPressed+0x3a>
    541e:	82 e0       	ldi	r24, 0x02	; 2
    5420:	62 e0       	ldi	r22, 0x02	; 2
    5422:	0e 94 1c 32 	call	0x6438	; 0x6438 <Dio_udtreadChannel>
    5426:	81 30       	cpi	r24, 0x01	; 1
    5428:	31 f0       	breq	.+12     	; 0x5436 <KEYPAD_udtIsPressed+0x3a>
    542a:	82 e0       	ldi	r24, 0x02	; 2
    542c:	63 e0       	ldi	r22, 0x03	; 3
    542e:	0e 94 1c 32 	call	0x6438	; 0x6438 <Dio_udtreadChannel>
    5432:	81 30       	cpi	r24, 0x01	; 1
    5434:	19 f4       	brne	.+6      	; 0x543c <KEYPAD_udtIsPressed+0x40>
			(Dio_udtreadChannel(DIO_PORTC,DIO_PIN2) == DIO_HIGH) ||
			(Dio_udtreadChannel(DIO_PORTC,DIO_PIN3) == DIO_HIGH)
		)

	{
		return TRUE;
    5436:	81 e0       	ldi	r24, 0x01	; 1
    5438:	89 83       	std	Y+1, r24	; 0x01
    543a:	01 c0       	rjmp	.+2      	; 0x543e <KEYPAD_udtIsPressed+0x42>
	}
	else
	{
		return FALSE;
    543c:	19 82       	std	Y+1, r1	; 0x01
    543e:	89 81       	ldd	r24, Y+1	; 0x01
	}
}
    5440:	0f 90       	pop	r0
    5442:	cf 91       	pop	r28
    5444:	df 91       	pop	r29
    5446:	08 95       	ret

00005448 <KEYPAD_u8GetKeyPressed>:

u8 KEYPAD_u8GetKeyPressed(void)
{
    5448:	df 93       	push	r29
    544a:	cf 93       	push	r28
    544c:	00 d0       	rcall	.+0      	; 0x544e <KEYPAD_u8GetKeyPressed+0x6>
    544e:	0f 92       	push	r0
    5450:	cd b7       	in	r28, 0x3d	; 61
    5452:	de b7       	in	r29, 0x3e	; 62
	kp_row_t loc_row = KP_NOROW;
    5454:	84 e0       	ldi	r24, 0x04	; 4
    5456:	8b 83       	std	Y+3, r24	; 0x03
	kp_col_t loc_column = KP_NOCOLUMN;
    5458:	84 e0       	ldi	r24, 0x04	; 4
    545a:	8a 83       	std	Y+2, r24	; 0x02
	u8 loc_button = 0xFF;
    545c:	8f ef       	ldi	r24, 0xFF	; 255
    545e:	89 83       	std	Y+1, r24	; 0x01

	KEYPAD_vidInit();
    5460:	0e 94 0c 29 	call	0x5218	; 0x5218 <KEYPAD_vidInit>

	if (KEYPAD_udtIsPressed() == TRUE)
    5464:	0e 94 fe 29 	call	0x53fc	; 0x53fc <KEYPAD_udtIsPressed>
    5468:	81 30       	cpi	r24, 0x01	; 1
    546a:	c9 f4       	brne	.+50     	; 0x549e <KEYPAD_u8GetKeyPressed+0x56>
	{
		loc_row = KEYPAD_udtGetRow();
    546c:	0e 94 4f 29 	call	0x529e	; 0x529e <KEYPAD_udtGetRow>
    5470:	8b 83       	std	Y+3, r24	; 0x03
		loc_column = KEYPAD_udtGetColumn(loc_row);
    5472:	8b 81       	ldd	r24, Y+3	; 0x03
    5474:	0e 94 7d 29 	call	0x52fa	; 0x52fa <KEYPAD_udtGetColumn>
    5478:	8a 83       	std	Y+2, r24	; 0x02
		loc_button = Keypad_Layout[loc_row][loc_column];
    547a:	8b 81       	ldd	r24, Y+3	; 0x03
    547c:	48 2f       	mov	r20, r24
    547e:	50 e0       	ldi	r21, 0x00	; 0
    5480:	8a 81       	ldd	r24, Y+2	; 0x02
    5482:	28 2f       	mov	r18, r24
    5484:	30 e0       	ldi	r19, 0x00	; 0
    5486:	ca 01       	movw	r24, r20
    5488:	88 0f       	add	r24, r24
    548a:	99 1f       	adc	r25, r25
    548c:	88 0f       	add	r24, r24
    548e:	99 1f       	adc	r25, r25
    5490:	82 0f       	add	r24, r18
    5492:	93 1f       	adc	r25, r19
    5494:	fc 01       	movw	r30, r24
    5496:	ed 55       	subi	r30, 0x5D	; 93
    5498:	fe 4f       	sbci	r31, 0xFE	; 254
    549a:	80 81       	ld	r24, Z
    549c:	89 83       	std	Y+1, r24	; 0x01
	}
	return loc_button;
    549e:	89 81       	ldd	r24, Y+1	; 0x01
}
    54a0:	0f 90       	pop	r0
    54a2:	0f 90       	pop	r0
    54a4:	0f 90       	pop	r0
    54a6:	cf 91       	pop	r28
    54a8:	df 91       	pop	r29
    54aa:	08 95       	ret

000054ac <M_I2C_Void_I2CInit>:
#define TWCR_REG                *(volatile u8*)0x56
#define TWDR_REG                *(volatile u8*)0x23
#define TWSR_REG                *(volatile u8*)0x21

void M_I2C_Void_I2CInit(void)
{
    54ac:	df 93       	push	r29
    54ae:	cf 93       	push	r28
    54b0:	cd b7       	in	r28, 0x3d	; 61
    54b2:	de b7       	in	r29, 0x3e	; 62
	#if   I2C_MODE   ==   I2C_MASTER_MODE
	/* TO SELECT F_SCL -> 400 KHZ */
	TWBR_REG = 12;
    54b4:	e0 e2       	ldi	r30, 0x20	; 32
    54b6:	f0 e0       	ldi	r31, 0x00	; 0
    54b8:	8c e0       	ldi	r24, 0x0C	; 12
    54ba:	80 83       	st	Z, r24
	#elif I2C_MODE   ==   I2C_SLAVE_MODE
	TWAR_REG = (SLAVE_ADDRESS << 1 ) | GENERAL_CALL_RESPONSE ;
	#endif
	/* TO ENABLE I2C CIRCUIT */
	Set_Bit(TWCR_REG,TWEN_BIT);
    54bc:	a6 e5       	ldi	r26, 0x56	; 86
    54be:	b0 e0       	ldi	r27, 0x00	; 0
    54c0:	e6 e5       	ldi	r30, 0x56	; 86
    54c2:	f0 e0       	ldi	r31, 0x00	; 0
    54c4:	80 81       	ld	r24, Z
    54c6:	84 60       	ori	r24, 0x04	; 4
    54c8:	8c 93       	st	X, r24
}
    54ca:	cf 91       	pop	r28
    54cc:	df 91       	pop	r29
    54ce:	08 95       	ret

000054d0 <M_I2C_Void_I2CStartCondition>:
void M_I2C_Void_I2CStartCondition(void)
{
    54d0:	df 93       	push	r29
    54d2:	cf 93       	push	r28
    54d4:	cd b7       	in	r28, 0x3d	; 61
    54d6:	de b7       	in	r29, 0x3e	; 62
	Set_Bit(TWCR_REG,TWSTA_BIT);  /* TO MAKE A START CONDITION */
    54d8:	a6 e5       	ldi	r26, 0x56	; 86
    54da:	b0 e0       	ldi	r27, 0x00	; 0
    54dc:	e6 e5       	ldi	r30, 0x56	; 86
    54de:	f0 e0       	ldi	r31, 0x00	; 0
    54e0:	80 81       	ld	r24, Z
    54e2:	80 62       	ori	r24, 0x20	; 32
    54e4:	8c 93       	st	X, r24
	Set_Bit(TWCR_REG,TWINT_BIT);  /* TO CLEAR THE FLAG */
    54e6:	a6 e5       	ldi	r26, 0x56	; 86
    54e8:	b0 e0       	ldi	r27, 0x00	; 0
    54ea:	e6 e5       	ldi	r30, 0x56	; 86
    54ec:	f0 e0       	ldi	r31, 0x00	; 0
    54ee:	80 81       	ld	r24, Z
    54f0:	80 68       	ori	r24, 0x80	; 128
    54f2:	8c 93       	st	X, r24
	while(Get_Bit(TWCR_REG,TWINT_BIT) == I2C_STILL_PROCESSING);
    54f4:	e6 e5       	ldi	r30, 0x56	; 86
    54f6:	f0 e0       	ldi	r31, 0x00	; 0
    54f8:	80 81       	ld	r24, Z
    54fa:	88 23       	and	r24, r24
    54fc:	dc f7       	brge	.-10     	; 0x54f4 <M_I2C_Void_I2CStartCondition+0x24>
	while((TWSR_REG & 0xF8) != START_CONDITION_HAS_BEEN_TRANSMITTED);
    54fe:	e1 e2       	ldi	r30, 0x21	; 33
    5500:	f0 e0       	ldi	r31, 0x00	; 0
    5502:	80 81       	ld	r24, Z
    5504:	88 2f       	mov	r24, r24
    5506:	90 e0       	ldi	r25, 0x00	; 0
    5508:	88 7f       	andi	r24, 0xF8	; 248
    550a:	90 70       	andi	r25, 0x00	; 0
    550c:	88 30       	cpi	r24, 0x08	; 8
    550e:	91 05       	cpc	r25, r1
    5510:	b1 f7       	brne	.-20     	; 0x54fe <M_I2C_Void_I2CStartCondition+0x2e>
}
    5512:	cf 91       	pop	r28
    5514:	df 91       	pop	r29
    5516:	08 95       	ret

00005518 <M_I2C_Void_I2CStopCondition>:
void M_I2C_Void_I2CStopCondition(void)
{
    5518:	df 93       	push	r29
    551a:	cf 93       	push	r28
    551c:	cd b7       	in	r28, 0x3d	; 61
    551e:	de b7       	in	r29, 0x3e	; 62
	Set_Bit(TWCR_REG,TWSTO_BIT);  /* TO MAKE A STOP CONDITION */
    5520:	a6 e5       	ldi	r26, 0x56	; 86
    5522:	b0 e0       	ldi	r27, 0x00	; 0
    5524:	e6 e5       	ldi	r30, 0x56	; 86
    5526:	f0 e0       	ldi	r31, 0x00	; 0
    5528:	80 81       	ld	r24, Z
    552a:	80 61       	ori	r24, 0x10	; 16
    552c:	8c 93       	st	X, r24
	Set_Bit(TWCR_REG,TWINT_BIT);  /* TO CLEAR THE FLAG */
    552e:	a6 e5       	ldi	r26, 0x56	; 86
    5530:	b0 e0       	ldi	r27, 0x00	; 0
    5532:	e6 e5       	ldi	r30, 0x56	; 86
    5534:	f0 e0       	ldi	r31, 0x00	; 0
    5536:	80 81       	ld	r24, Z
    5538:	80 68       	ori	r24, 0x80	; 128
    553a:	8c 93       	st	X, r24
	//while(GET_BIT(TWCR_REG,TWINT_BIT) == I2C_STILL_PROCESSING);
}
    553c:	cf 91       	pop	r28
    553e:	df 91       	pop	r29
    5540:	08 95       	ret

00005542 <M_I2C_Void_I2CRepeatedStart>:
void M_I2C_Void_I2CRepeatedStart(void)
{
    5542:	df 93       	push	r29
    5544:	cf 93       	push	r28
    5546:	cd b7       	in	r28, 0x3d	; 61
    5548:	de b7       	in	r29, 0x3e	; 62
	Set_Bit(TWCR_REG,TWSTA_BIT);  /* TO CLEAR STA BIT ACCORDING TO TABLE */
    554a:	a6 e5       	ldi	r26, 0x56	; 86
    554c:	b0 e0       	ldi	r27, 0x00	; 0
    554e:	e6 e5       	ldi	r30, 0x56	; 86
    5550:	f0 e0       	ldi	r31, 0x00	; 0
    5552:	80 81       	ld	r24, Z
    5554:	80 62       	ori	r24, 0x20	; 32
    5556:	8c 93       	st	X, r24
	Set_Bit(TWCR_REG,TWINT_BIT);  /* TO CLEAR THE FLAG */
    5558:	a6 e5       	ldi	r26, 0x56	; 86
    555a:	b0 e0       	ldi	r27, 0x00	; 0
    555c:	e6 e5       	ldi	r30, 0x56	; 86
    555e:	f0 e0       	ldi	r31, 0x00	; 0
    5560:	80 81       	ld	r24, Z
    5562:	80 68       	ori	r24, 0x80	; 128
    5564:	8c 93       	st	X, r24
	while(Get_Bit(TWCR_REG,TWINT_BIT) == I2C_STILL_PROCESSING);
    5566:	e6 e5       	ldi	r30, 0x56	; 86
    5568:	f0 e0       	ldi	r31, 0x00	; 0
    556a:	80 81       	ld	r24, Z
    556c:	88 23       	and	r24, r24
    556e:	dc f7       	brge	.-10     	; 0x5566 <M_I2C_Void_I2CRepeatedStart+0x24>
	while((TWSR_REG & 0xF8) != REPEATED_START_CONDITION_HAS_BEEN_TRANSMITTED);
    5570:	e1 e2       	ldi	r30, 0x21	; 33
    5572:	f0 e0       	ldi	r31, 0x00	; 0
    5574:	80 81       	ld	r24, Z
    5576:	88 2f       	mov	r24, r24
    5578:	90 e0       	ldi	r25, 0x00	; 0
    557a:	88 7f       	andi	r24, 0xF8	; 248
    557c:	90 70       	andi	r25, 0x00	; 0
    557e:	80 31       	cpi	r24, 0x10	; 16
    5580:	91 05       	cpc	r25, r1
    5582:	b1 f7       	brne	.-20     	; 0x5570 <M_I2C_Void_I2CRepeatedStart+0x2e>
}
    5584:	cf 91       	pop	r28
    5586:	df 91       	pop	r29
    5588:	08 95       	ret

0000558a <M_I2C_Void_I2CSendSlaveAddressWrite>:
void M_I2C_Void_I2CSendSlaveAddressWrite(u8 Copy_U8_Address)
{
    558a:	df 93       	push	r29
    558c:	cf 93       	push	r28
    558e:	0f 92       	push	r0
    5590:	cd b7       	in	r28, 0x3d	; 61
    5592:	de b7       	in	r29, 0x3e	; 62
    5594:	89 83       	std	Y+1, r24	; 0x01
	TWDR_REG = Copy_U8_Address << 1;
    5596:	e3 e2       	ldi	r30, 0x23	; 35
    5598:	f0 e0       	ldi	r31, 0x00	; 0
    559a:	89 81       	ldd	r24, Y+1	; 0x01
    559c:	88 0f       	add	r24, r24
    559e:	80 83       	st	Z, r24

	Set_Bit(TWCR_REG,TWINT_BIT);  /* TO CLEAR THE FLAG */
    55a0:	a6 e5       	ldi	r26, 0x56	; 86
    55a2:	b0 e0       	ldi	r27, 0x00	; 0
    55a4:	e6 e5       	ldi	r30, 0x56	; 86
    55a6:	f0 e0       	ldi	r31, 0x00	; 0
    55a8:	80 81       	ld	r24, Z
    55aa:	80 68       	ori	r24, 0x80	; 128
    55ac:	8c 93       	st	X, r24
	while(Get_Bit(TWCR_REG,TWINT_BIT) == I2C_STILL_PROCESSING);
    55ae:	e6 e5       	ldi	r30, 0x56	; 86
    55b0:	f0 e0       	ldi	r31, 0x00	; 0
    55b2:	80 81       	ld	r24, Z
    55b4:	88 23       	and	r24, r24
    55b6:	dc f7       	brge	.-10     	; 0x55ae <M_I2C_Void_I2CSendSlaveAddressWrite+0x24>

	//while((TWSR_REG*  & 0xF8) != SLAVE_ADDRESS_W_TRANSMITTED_ACK_REC);

}
    55b8:	0f 90       	pop	r0
    55ba:	cf 91       	pop	r28
    55bc:	df 91       	pop	r29
    55be:	08 95       	ret

000055c0 <M_I2C_Void_I2CSendSlaveAddressRead>:
void M_I2C_Void_I2CSendSlaveAddressRead(u8 Copy_U8_Address)
{
    55c0:	df 93       	push	r29
    55c2:	cf 93       	push	r28
    55c4:	0f 92       	push	r0
    55c6:	cd b7       	in	r28, 0x3d	; 61
    55c8:	de b7       	in	r29, 0x3e	; 62
    55ca:	89 83       	std	Y+1, r24	; 0x01
	TWDR_REG = (Copy_U8_Address << 1) | 1;
    55cc:	e3 e2       	ldi	r30, 0x23	; 35
    55ce:	f0 e0       	ldi	r31, 0x00	; 0
    55d0:	89 81       	ldd	r24, Y+1	; 0x01
    55d2:	88 2f       	mov	r24, r24
    55d4:	90 e0       	ldi	r25, 0x00	; 0
    55d6:	88 0f       	add	r24, r24
    55d8:	99 1f       	adc	r25, r25
    55da:	81 60       	ori	r24, 0x01	; 1
    55dc:	80 83       	st	Z, r24

	Set_Bit(TWCR_REG,TWINT_BIT);  /* TO CLEAR THE FLAG */
    55de:	a6 e5       	ldi	r26, 0x56	; 86
    55e0:	b0 e0       	ldi	r27, 0x00	; 0
    55e2:	e6 e5       	ldi	r30, 0x56	; 86
    55e4:	f0 e0       	ldi	r31, 0x00	; 0
    55e6:	80 81       	ld	r24, Z
    55e8:	80 68       	ori	r24, 0x80	; 128
    55ea:	8c 93       	st	X, r24
	while(Get_Bit(TWCR_REG,TWINT_BIT) == I2C_STILL_PROCESSING);
    55ec:	e6 e5       	ldi	r30, 0x56	; 86
    55ee:	f0 e0       	ldi	r31, 0x00	; 0
    55f0:	80 81       	ld	r24, Z
    55f2:	88 23       	and	r24, r24
    55f4:	dc f7       	brge	.-10     	; 0x55ec <M_I2C_Void_I2CSendSlaveAddressRead+0x2c>
	//while((TWSR_REG & 0xF8) != SLAVE_ADDRESS_R_TRANSMITTED_ACK_REC);

}
    55f6:	0f 90       	pop	r0
    55f8:	cf 91       	pop	r28
    55fa:	df 91       	pop	r29
    55fc:	08 95       	ret

000055fe <M_I2C_Void_I2CSendByte>:
#include "Led.h"
void M_I2C_Void_I2CSendByte(u8 Copy_U8_Data)
{
    55fe:	df 93       	push	r29
    5600:	cf 93       	push	r28
    5602:	0f 92       	push	r0
    5604:	cd b7       	in	r28, 0x3d	; 61
    5606:	de b7       	in	r29, 0x3e	; 62
    5608:	89 83       	std	Y+1, r24	; 0x01
	TWDR_REG = Copy_U8_Data;
    560a:	e3 e2       	ldi	r30, 0x23	; 35
    560c:	f0 e0       	ldi	r31, 0x00	; 0
    560e:	89 81       	ldd	r24, Y+1	; 0x01
    5610:	80 83       	st	Z, r24
	Clear_Bit(TWCR_REG,TWSTA_BIT);  /* TO CLEAR STA BIT ACCORDING TO TABLE */
    5612:	a6 e5       	ldi	r26, 0x56	; 86
    5614:	b0 e0       	ldi	r27, 0x00	; 0
    5616:	e6 e5       	ldi	r30, 0x56	; 86
    5618:	f0 e0       	ldi	r31, 0x00	; 0
    561a:	80 81       	ld	r24, Z
    561c:	8f 7d       	andi	r24, 0xDF	; 223
    561e:	8c 93       	st	X, r24
	Set_Bit(TWCR_REG,TWINT_BIT);  /* TO CLEAR THE FLAG */
    5620:	a6 e5       	ldi	r26, 0x56	; 86
    5622:	b0 e0       	ldi	r27, 0x00	; 0
    5624:	e6 e5       	ldi	r30, 0x56	; 86
    5626:	f0 e0       	ldi	r31, 0x00	; 0
    5628:	80 81       	ld	r24, Z
    562a:	80 68       	ori	r24, 0x80	; 128
    562c:	8c 93       	st	X, r24
	while(Get_Bit(TWCR_REG,TWINT_BIT) == I2C_STILL_PROCESSING);
    562e:	e6 e5       	ldi	r30, 0x56	; 86
    5630:	f0 e0       	ldi	r31, 0x00	; 0
    5632:	80 81       	ld	r24, Z
    5634:	88 23       	and	r24, r24
    5636:	dc f7       	brge	.-10     	; 0x562e <M_I2C_Void_I2CSendByte+0x30>
	while((TWSR_REG & 0xF8) != BYTE_TRANSMITTED_ACK_REC);
    5638:	e1 e2       	ldi	r30, 0x21	; 33
    563a:	f0 e0       	ldi	r31, 0x00	; 0
    563c:	80 81       	ld	r24, Z
    563e:	88 2f       	mov	r24, r24
    5640:	90 e0       	ldi	r25, 0x00	; 0
    5642:	88 7f       	andi	r24, 0xF8	; 248
    5644:	90 70       	andi	r25, 0x00	; 0
    5646:	88 32       	cpi	r24, 0x28	; 40
    5648:	91 05       	cpc	r25, r1
    564a:	b1 f7       	brne	.-20     	; 0x5638 <M_I2C_Void_I2CSendByte+0x3a>
}
    564c:	0f 90       	pop	r0
    564e:	cf 91       	pop	r28
    5650:	df 91       	pop	r29
    5652:	08 95       	ret

00005654 <M_I2C_Void_I2CReadByte>:
u8   M_I2C_Void_I2CReadByte(void)
{
    5654:	df 93       	push	r29
    5656:	cf 93       	push	r28
    5658:	0f 92       	push	r0
    565a:	cd b7       	in	r28, 0x3d	; 61
    565c:	de b7       	in	r29, 0x3e	; 62
	u8 Local_U8_Data = TWDR_REG;
    565e:	e3 e2       	ldi	r30, 0x23	; 35
    5660:	f0 e0       	ldi	r31, 0x00	; 0
    5662:	80 81       	ld	r24, Z
    5664:	89 83       	std	Y+1, r24	; 0x01
	Clear_Bit(TWCR_REG,TWSTA_BIT);  /* TO CLEAR STA BIT ACCORDING TO TABLE */
    5666:	a6 e5       	ldi	r26, 0x56	; 86
    5668:	b0 e0       	ldi	r27, 0x00	; 0
    566a:	e6 e5       	ldi	r30, 0x56	; 86
    566c:	f0 e0       	ldi	r31, 0x00	; 0
    566e:	80 81       	ld	r24, Z
    5670:	8f 7d       	andi	r24, 0xDF	; 223
    5672:	8c 93       	st	X, r24
	Set_Bit(TWCR_REG,6);
    5674:	a6 e5       	ldi	r26, 0x56	; 86
    5676:	b0 e0       	ldi	r27, 0x00	; 0
    5678:	e6 e5       	ldi	r30, 0x56	; 86
    567a:	f0 e0       	ldi	r31, 0x00	; 0
    567c:	80 81       	ld	r24, Z
    567e:	80 64       	ori	r24, 0x40	; 64
    5680:	8c 93       	st	X, r24
	Clear_Bit(TWCR_REG,TWSTO_BIT);  /* TO CLEAR STO BIT ACCORDING TO TABLE */
    5682:	a6 e5       	ldi	r26, 0x56	; 86
    5684:	b0 e0       	ldi	r27, 0x00	; 0
    5686:	e6 e5       	ldi	r30, 0x56	; 86
    5688:	f0 e0       	ldi	r31, 0x00	; 0
    568a:	80 81       	ld	r24, Z
    568c:	8f 7e       	andi	r24, 0xEF	; 239
    568e:	8c 93       	st	X, r24
	Set_Bit(TWCR_REG,TWINT_BIT);  /* TO CLEAR THE FLAG */
    5690:	a6 e5       	ldi	r26, 0x56	; 86
    5692:	b0 e0       	ldi	r27, 0x00	; 0
    5694:	e6 e5       	ldi	r30, 0x56	; 86
    5696:	f0 e0       	ldi	r31, 0x00	; 0
    5698:	80 81       	ld	r24, Z
    569a:	80 68       	ori	r24, 0x80	; 128
    569c:	8c 93       	st	X, r24
	while(Get_Bit(TWCR_REG,TWINT_BIT) == I2C_STILL_PROCESSING);
    569e:	e6 e5       	ldi	r30, 0x56	; 86
    56a0:	f0 e0       	ldi	r31, 0x00	; 0
    56a2:	80 81       	ld	r24, Z
    56a4:	88 23       	and	r24, r24
    56a6:	dc f7       	brge	.-10     	; 0x569e <M_I2C_Void_I2CReadByte+0x4a>
	while((TWSR_REG & 0xF8) != BYTE_REC_ACK_TRANSMITTED);
    56a8:	e1 e2       	ldi	r30, 0x21	; 33
    56aa:	f0 e0       	ldi	r31, 0x00	; 0
    56ac:	80 81       	ld	r24, Z
    56ae:	88 2f       	mov	r24, r24
    56b0:	90 e0       	ldi	r25, 0x00	; 0
    56b2:	88 7f       	andi	r24, 0xF8	; 248
    56b4:	90 70       	andi	r25, 0x00	; 0
    56b6:	80 35       	cpi	r24, 0x50	; 80
    56b8:	91 05       	cpc	r25, r1
    56ba:	b1 f7       	brne	.-20     	; 0x56a8 <M_I2C_Void_I2CReadByte+0x54>
	return Local_U8_Data;
    56bc:	89 81       	ldd	r24, Y+1	; 0x01
}
    56be:	0f 90       	pop	r0
    56c0:	cf 91       	pop	r28
    56c2:	df 91       	pop	r29
    56c4:	08 95       	ret

000056c6 <BUZZER_vidbuzzerInit>:
 */

#include "BUZZER.h"

void BUZZER_vidbuzzerInit(void)
{
    56c6:	df 93       	push	r29
    56c8:	cf 93       	push	r28
    56ca:	cd b7       	in	r28, 0x3d	; 61
    56cc:	de b7       	in	r29, 0x3e	; 62
	Dio_vidconfigChannel(DIO_PORTA,DIO_PIN3,DIO_OUTPUT);
    56ce:	80 e0       	ldi	r24, 0x00	; 0
    56d0:	63 e0       	ldi	r22, 0x03	; 3
    56d2:	41 e0       	ldi	r20, 0x01	; 1
    56d4:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>
}
    56d8:	cf 91       	pop	r28
    56da:	df 91       	pop	r29
    56dc:	08 95       	ret

000056de <BUZZER_vidbuzzerOn>:

void BUZZER_vidbuzzerOn(void)
{
    56de:	df 93       	push	r29
    56e0:	cf 93       	push	r28
    56e2:	cd b7       	in	r28, 0x3d	; 61
    56e4:	de b7       	in	r29, 0x3e	; 62
	Dio_vidwriteChannel(DIO_PORTA,DIO_PIN3,DIO_HIGH);
    56e6:	80 e0       	ldi	r24, 0x00	; 0
    56e8:	63 e0       	ldi	r22, 0x03	; 3
    56ea:	41 e0       	ldi	r20, 0x01	; 1
    56ec:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
}
    56f0:	cf 91       	pop	r28
    56f2:	df 91       	pop	r29
    56f4:	08 95       	ret

000056f6 <BUZZER_vidbuzzerOff>:

void BUZZER_vidbuzzerOff(void)
{
    56f6:	df 93       	push	r29
    56f8:	cf 93       	push	r28
    56fa:	cd b7       	in	r28, 0x3d	; 61
    56fc:	de b7       	in	r29, 0x3e	; 62
	Dio_vidwriteChannel(DIO_PORTA,DIO_PIN3,DIO_LOW);
    56fe:	80 e0       	ldi	r24, 0x00	; 0
    5700:	63 e0       	ldi	r22, 0x03	; 3
    5702:	40 e0       	ldi	r20, 0x00	; 0
    5704:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
}
    5708:	cf 91       	pop	r28
    570a:	df 91       	pop	r29
    570c:	08 95       	ret

0000570e <BUZZER_vidbuzzerToggle>:

void BUZZER_vidbuzzerToggle(void)
{
    570e:	df 93       	push	r29
    5710:	cf 93       	push	r28
    5712:	cd b7       	in	r28, 0x3d	; 61
    5714:	de b7       	in	r29, 0x3e	; 62
	Dio_vidflipChannel(DIO_PORTA,DIO_PIN3);
    5716:	80 e0       	ldi	r24, 0x00	; 0
    5718:	63 e0       	ldi	r22, 0x03	; 3
    571a:	0e 94 b0 32 	call	0x6560	; 0x6560 <Dio_vidflipChannel>
}
    571e:	cf 91       	pop	r28
    5720:	df 91       	pop	r29
    5722:	08 95       	ret

00005724 <BUTTON_vidbuttonInit>:
 *      Author: Khaled
 */
#include "BUTTON.h"

void BUTTON_vidbuttonInit(void)
{
    5724:	df 93       	push	r29
    5726:	cf 93       	push	r28
    5728:	cd b7       	in	r28, 0x3d	; 61
    572a:	de b7       	in	r29, 0x3e	; 62
	Dio_vidconfigChannel(DIO_PORTB,DIO_PIN0,DIO_INPUT);
    572c:	81 e0       	ldi	r24, 0x01	; 1
    572e:	60 e0       	ldi	r22, 0x00	; 0
    5730:	40 e0       	ldi	r20, 0x00	; 0
    5732:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTD,DIO_PIN6,DIO_INPUT);
    5736:	83 e0       	ldi	r24, 0x03	; 3
    5738:	66 e0       	ldi	r22, 0x06	; 6
    573a:	40 e0       	ldi	r20, 0x00	; 0
    573c:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTD,DIO_PIN2,DIO_INPUT);
    5740:	83 e0       	ldi	r24, 0x03	; 3
    5742:	62 e0       	ldi	r22, 0x02	; 2
    5744:	40 e0       	ldi	r20, 0x00	; 0
    5746:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>
}
    574a:	cf 91       	pop	r28
    574c:	df 91       	pop	r29
    574e:	08 95       	ret

00005750 <BUTTON_udtbuttonStatus>:

button_butStatus_t BUTTON_udtbuttonStatus(button_buttonId_t button)
{
    5750:	df 93       	push	r29
    5752:	cf 93       	push	r28
    5754:	00 d0       	rcall	.+0      	; 0x5756 <BUTTON_udtbuttonStatus+0x6>
    5756:	00 d0       	rcall	.+0      	; 0x5758 <BUTTON_udtbuttonStatus+0x8>
    5758:	cd b7       	in	r28, 0x3d	; 61
    575a:	de b7       	in	r29, 0x3e	; 62
    575c:	89 83       	std	Y+1, r24	; 0x01
	switch(button)
    575e:	89 81       	ldd	r24, Y+1	; 0x01
    5760:	28 2f       	mov	r18, r24
    5762:	30 e0       	ldi	r19, 0x00	; 0
    5764:	3c 83       	std	Y+4, r19	; 0x04
    5766:	2b 83       	std	Y+3, r18	; 0x03
    5768:	8b 81       	ldd	r24, Y+3	; 0x03
    576a:	9c 81       	ldd	r25, Y+4	; 0x04
    576c:	81 30       	cpi	r24, 0x01	; 1
    576e:	91 05       	cpc	r25, r1
    5770:	a1 f0       	breq	.+40     	; 0x579a <BUTTON_udtbuttonStatus+0x4a>
    5772:	2b 81       	ldd	r18, Y+3	; 0x03
    5774:	3c 81       	ldd	r19, Y+4	; 0x04
    5776:	22 30       	cpi	r18, 0x02	; 2
    5778:	31 05       	cpc	r19, r1
    577a:	d1 f0       	breq	.+52     	; 0x57b0 <BUTTON_udtbuttonStatus+0x60>
    577c:	8b 81       	ldd	r24, Y+3	; 0x03
    577e:	9c 81       	ldd	r25, Y+4	; 0x04
    5780:	00 97       	sbiw	r24, 0x00	; 0
    5782:	09 f5       	brne	.+66     	; 0x57c6 <BUTTON_udtbuttonStatus+0x76>
	{
	case BUTTON0:
	{
		if (Dio_udtreadChannel(DIO_PORTB,DIO_PIN0) == 1)
    5784:	81 e0       	ldi	r24, 0x01	; 1
    5786:	60 e0       	ldi	r22, 0x00	; 0
    5788:	0e 94 1c 32 	call	0x6438	; 0x6438 <Dio_udtreadChannel>
    578c:	81 30       	cpi	r24, 0x01	; 1
    578e:	19 f4       	brne	.+6      	; 0x5796 <BUTTON_udtbuttonStatus+0x46>
		{
			return PRESSED;
    5790:	91 e0       	ldi	r25, 0x01	; 1
    5792:	9a 83       	std	Y+2, r25	; 0x02
    5794:	19 c0       	rjmp	.+50     	; 0x57c8 <BUTTON_udtbuttonStatus+0x78>
		}
		else
		{
			return RELEASED;
    5796:	1a 82       	std	Y+2, r1	; 0x02
    5798:	17 c0       	rjmp	.+46     	; 0x57c8 <BUTTON_udtbuttonStatus+0x78>
		}
	}
	case BUTTON1:
	{
		if (Dio_udtreadChannel(DIO_PORTD,DIO_PIN6) == 1)
    579a:	83 e0       	ldi	r24, 0x03	; 3
    579c:	66 e0       	ldi	r22, 0x06	; 6
    579e:	0e 94 1c 32 	call	0x6438	; 0x6438 <Dio_udtreadChannel>
    57a2:	81 30       	cpi	r24, 0x01	; 1
    57a4:	19 f4       	brne	.+6      	; 0x57ac <BUTTON_udtbuttonStatus+0x5c>
		{
			return PRESSED;
    57a6:	21 e0       	ldi	r18, 0x01	; 1
    57a8:	2a 83       	std	Y+2, r18	; 0x02
    57aa:	0e c0       	rjmp	.+28     	; 0x57c8 <BUTTON_udtbuttonStatus+0x78>
		}
		else
		{
			return RELEASED;
    57ac:	1a 82       	std	Y+2, r1	; 0x02
    57ae:	0c c0       	rjmp	.+24     	; 0x57c8 <BUTTON_udtbuttonStatus+0x78>
		}
	}
	case BUTTON2:
	{
		if (Dio_udtreadChannel(DIO_PORTD,DIO_PIN2)== 1)
    57b0:	83 e0       	ldi	r24, 0x03	; 3
    57b2:	62 e0       	ldi	r22, 0x02	; 2
    57b4:	0e 94 1c 32 	call	0x6438	; 0x6438 <Dio_udtreadChannel>
    57b8:	81 30       	cpi	r24, 0x01	; 1
    57ba:	19 f4       	brne	.+6      	; 0x57c2 <BUTTON_udtbuttonStatus+0x72>
		{
			return PRESSED;
    57bc:	31 e0       	ldi	r19, 0x01	; 1
    57be:	3a 83       	std	Y+2, r19	; 0x02
    57c0:	03 c0       	rjmp	.+6      	; 0x57c8 <BUTTON_udtbuttonStatus+0x78>
		}
		else
		{
			return RELEASED;
    57c2:	1a 82       	std	Y+2, r1	; 0x02
    57c4:	01 c0       	rjmp	.+2      	; 0x57c8 <BUTTON_udtbuttonStatus+0x78>
		}
	}
	}
	return RELEASED;
    57c6:	1a 82       	std	Y+2, r1	; 0x02
    57c8:	8a 81       	ldd	r24, Y+2	; 0x02
}
    57ca:	0f 90       	pop	r0
    57cc:	0f 90       	pop	r0
    57ce:	0f 90       	pop	r0
    57d0:	0f 90       	pop	r0
    57d2:	cf 91       	pop	r28
    57d4:	df 91       	pop	r29
    57d6:	08 95       	ret

000057d8 <USART_Init>:
 *      Author: Khaled
 */
#include "UART.h"

void USART_Init(u32 baud)
{
    57d8:	df 93       	push	r29
    57da:	cf 93       	push	r28
    57dc:	cd b7       	in	r28, 0x3d	; 61
    57de:	de b7       	in	r29, 0x3e	; 62
    57e0:	28 97       	sbiw	r28, 0x08	; 8
    57e2:	0f b6       	in	r0, 0x3f	; 63
    57e4:	f8 94       	cli
    57e6:	de bf       	out	0x3e, r29	; 62
    57e8:	0f be       	out	0x3f, r0	; 63
    57ea:	cd bf       	out	0x3d, r28	; 61
    57ec:	6d 83       	std	Y+5, r22	; 0x05
    57ee:	7e 83       	std	Y+6, r23	; 0x06
    57f0:	8f 83       	std	Y+7, r24	; 0x07
    57f2:	98 87       	std	Y+8, r25	; 0x08
	u32 loc_UBBR_val = ((F_OSC/(16*baud))-1);
    57f4:	8d 81       	ldd	r24, Y+5	; 0x05
    57f6:	9e 81       	ldd	r25, Y+6	; 0x06
    57f8:	af 81       	ldd	r26, Y+7	; 0x07
    57fa:	b8 85       	ldd	r27, Y+8	; 0x08
    57fc:	88 0f       	add	r24, r24
    57fe:	99 1f       	adc	r25, r25
    5800:	aa 1f       	adc	r26, r26
    5802:	bb 1f       	adc	r27, r27
    5804:	88 0f       	add	r24, r24
    5806:	99 1f       	adc	r25, r25
    5808:	aa 1f       	adc	r26, r26
    580a:	bb 1f       	adc	r27, r27
    580c:	88 0f       	add	r24, r24
    580e:	99 1f       	adc	r25, r25
    5810:	aa 1f       	adc	r26, r26
    5812:	bb 1f       	adc	r27, r27
    5814:	88 0f       	add	r24, r24
    5816:	99 1f       	adc	r25, r25
    5818:	aa 1f       	adc	r26, r26
    581a:	bb 1f       	adc	r27, r27
    581c:	9c 01       	movw	r18, r24
    581e:	ad 01       	movw	r20, r26
    5820:	80 e0       	ldi	r24, 0x00	; 0
    5822:	94 e2       	ldi	r25, 0x24	; 36
    5824:	a4 ef       	ldi	r26, 0xF4	; 244
    5826:	b0 e0       	ldi	r27, 0x00	; 0
    5828:	bc 01       	movw	r22, r24
    582a:	cd 01       	movw	r24, r26
    582c:	0e 94 1c 34 	call	0x6838	; 0x6838 <__udivmodsi4>
    5830:	da 01       	movw	r26, r20
    5832:	c9 01       	movw	r24, r18
    5834:	01 97       	sbiw	r24, 0x01	; 1
    5836:	a1 09       	sbc	r26, r1
    5838:	b1 09       	sbc	r27, r1
    583a:	89 83       	std	Y+1, r24	; 0x01
    583c:	9a 83       	std	Y+2, r25	; 0x02
    583e:	ab 83       	std	Y+3, r26	; 0x03
    5840:	bc 83       	std	Y+4, r27	; 0x04
	/* Set baud rate */
	UART_UBRRH_REG = loc_UBBR_val>>8;
    5842:	e0 e4       	ldi	r30, 0x40	; 64
    5844:	f0 e0       	ldi	r31, 0x00	; 0
    5846:	89 81       	ldd	r24, Y+1	; 0x01
    5848:	9a 81       	ldd	r25, Y+2	; 0x02
    584a:	ab 81       	ldd	r26, Y+3	; 0x03
    584c:	bc 81       	ldd	r27, Y+4	; 0x04
    584e:	89 2f       	mov	r24, r25
    5850:	9a 2f       	mov	r25, r26
    5852:	ab 2f       	mov	r26, r27
    5854:	bb 27       	eor	r27, r27
    5856:	80 83       	st	Z, r24
	UART_UBRRL_REG = loc_UBBR_val;
    5858:	e9 e2       	ldi	r30, 0x29	; 41
    585a:	f0 e0       	ldi	r31, 0x00	; 0
    585c:	89 81       	ldd	r24, Y+1	; 0x01
    585e:	80 83       	st	Z, r24
	/* Enable receiver and transmitter */
	UART_UCSRB_REG = (1<<UART_RXEN_BIT)|(1<<UART_TXEN_BIT);
    5860:	ea e2       	ldi	r30, 0x2A	; 42
    5862:	f0 e0       	ldi	r31, 0x00	; 0
    5864:	88 e1       	ldi	r24, 0x18	; 24
    5866:	80 83       	st	Z, r24
	/* Set frame format: 8data, 2stop bit */
	UART_UCSRC_REG = (1<<UART_URSEL_BIT)|(1<<UART_USBS_BIT)|(3<<UART_UCSZ0_BIT);
    5868:	e0 e4       	ldi	r30, 0x40	; 64
    586a:	f0 e0       	ldi	r31, 0x00	; 0
    586c:	8e e8       	ldi	r24, 0x8E	; 142
    586e:	80 83       	st	Z, r24
}
    5870:	28 96       	adiw	r28, 0x08	; 8
    5872:	0f b6       	in	r0, 0x3f	; 63
    5874:	f8 94       	cli
    5876:	de bf       	out	0x3e, r29	; 62
    5878:	0f be       	out	0x3f, r0	; 63
    587a:	cd bf       	out	0x3d, r28	; 61
    587c:	cf 91       	pop	r28
    587e:	df 91       	pop	r29
    5880:	08 95       	ret

00005882 <USART_TransmitChr>:
void USART_TransmitChr(u8 data)
{
    5882:	df 93       	push	r29
    5884:	cf 93       	push	r28
    5886:	0f 92       	push	r0
    5888:	cd b7       	in	r28, 0x3d	; 61
    588a:	de b7       	in	r29, 0x3e	; 62
    588c:	89 83       	std	Y+1, r24	; 0x01
	while(CHECK_BIT(UART_UCSRA_REG,UART_UDRE_BIT) == 0)
    588e:	eb e2       	ldi	r30, 0x2B	; 43
    5890:	f0 e0       	ldi	r31, 0x00	; 0
    5892:	80 81       	ld	r24, Z
    5894:	82 95       	swap	r24
    5896:	86 95       	lsr	r24
    5898:	87 70       	andi	r24, 0x07	; 7
    589a:	88 2f       	mov	r24, r24
    589c:	90 e0       	ldi	r25, 0x00	; 0
    589e:	81 70       	andi	r24, 0x01	; 1
    58a0:	90 70       	andi	r25, 0x00	; 0
    58a2:	00 97       	sbiw	r24, 0x00	; 0
    58a4:	a1 f3       	breq	.-24     	; 0x588e <USART_TransmitChr+0xc>
	{
		;
	}
	UART_UDR_REG = data;
    58a6:	ec e2       	ldi	r30, 0x2C	; 44
    58a8:	f0 e0       	ldi	r31, 0x00	; 0
    58aa:	89 81       	ldd	r24, Y+1	; 0x01
    58ac:	80 83       	st	Z, r24
}
    58ae:	0f 90       	pop	r0
    58b0:	cf 91       	pop	r28
    58b2:	df 91       	pop	r29
    58b4:	08 95       	ret

000058b6 <USART_TransmitStr>:
void USART_TransmitStr(u8 *str)
{
    58b6:	df 93       	push	r29
    58b8:	cf 93       	push	r28
    58ba:	00 d0       	rcall	.+0      	; 0x58bc <USART_TransmitStr+0x6>
    58bc:	cd b7       	in	r28, 0x3d	; 61
    58be:	de b7       	in	r29, 0x3e	; 62
    58c0:	9a 83       	std	Y+2, r25	; 0x02
    58c2:	89 83       	std	Y+1, r24	; 0x01
    58c4:	0a c0       	rjmp	.+20     	; 0x58da <USART_TransmitStr+0x24>
	while (*str != '\0')
	{
		USART_TransmitChr(*str);
    58c6:	e9 81       	ldd	r30, Y+1	; 0x01
    58c8:	fa 81       	ldd	r31, Y+2	; 0x02
    58ca:	80 81       	ld	r24, Z
    58cc:	0e 94 41 2c 	call	0x5882	; 0x5882 <USART_TransmitChr>
		str++;
    58d0:	89 81       	ldd	r24, Y+1	; 0x01
    58d2:	9a 81       	ldd	r25, Y+2	; 0x02
    58d4:	01 96       	adiw	r24, 0x01	; 1
    58d6:	9a 83       	std	Y+2, r25	; 0x02
    58d8:	89 83       	std	Y+1, r24	; 0x01
	}
	UART_UDR_REG = data;
}
void USART_TransmitStr(u8 *str)
{
	while (*str != '\0')
    58da:	e9 81       	ldd	r30, Y+1	; 0x01
    58dc:	fa 81       	ldd	r31, Y+2	; 0x02
    58de:	80 81       	ld	r24, Z
    58e0:	88 23       	and	r24, r24
    58e2:	89 f7       	brne	.-30     	; 0x58c6 <USART_TransmitStr+0x10>
	{
		USART_TransmitChr(*str);
		str++;
	}
}
    58e4:	0f 90       	pop	r0
    58e6:	0f 90       	pop	r0
    58e8:	cf 91       	pop	r28
    58ea:	df 91       	pop	r29
    58ec:	08 95       	ret

000058ee <USART_Recieve_Block>:
u8 USART_Recieve_Block(void)
{
    58ee:	df 93       	push	r29
    58f0:	cf 93       	push	r28
    58f2:	cd b7       	in	r28, 0x3d	; 61
    58f4:	de b7       	in	r29, 0x3e	; 62
	while (CHECK_BIT(UART_UCSRA_REG,UART_RXC_BIT) == 0)
    58f6:	eb e2       	ldi	r30, 0x2B	; 43
    58f8:	f0 e0       	ldi	r31, 0x00	; 0
    58fa:	80 81       	ld	r24, Z
    58fc:	88 23       	and	r24, r24
    58fe:	dc f7       	brge	.-10     	; 0x58f6 <USART_Recieve_Block+0x8>
	{
		;
	}
	return UART_UDR_REG;
    5900:	ec e2       	ldi	r30, 0x2C	; 44
    5902:	f0 e0       	ldi	r31, 0x00	; 0
    5904:	80 81       	ld	r24, Z
}
    5906:	cf 91       	pop	r28
    5908:	df 91       	pop	r29
    590a:	08 95       	ret

0000590c <USART_Recieve_NonBlock>:
u8 USART_Recieve_NonBlock(void)
{
    590c:	df 93       	push	r29
    590e:	cf 93       	push	r28
    5910:	0f 92       	push	r0
    5912:	cd b7       	in	r28, 0x3d	; 61
    5914:	de b7       	in	r29, 0x3e	; 62
	if (CHECK_BIT(UART_UCSRA_REG,UART_RXC_BIT) == 1)
    5916:	eb e2       	ldi	r30, 0x2B	; 43
    5918:	f0 e0       	ldi	r31, 0x00	; 0
    591a:	80 81       	ld	r24, Z
    591c:	88 1f       	adc	r24, r24
    591e:	88 27       	eor	r24, r24
    5920:	88 1f       	adc	r24, r24
    5922:	81 30       	cpi	r24, 0x01	; 1
    5924:	29 f4       	brne	.+10     	; 0x5930 <USART_Recieve_NonBlock+0x24>
	{
		return UART_UDR_REG;
    5926:	ec e2       	ldi	r30, 0x2C	; 44
    5928:	f0 e0       	ldi	r31, 0x00	; 0
    592a:	80 81       	ld	r24, Z
    592c:	89 83       	std	Y+1, r24	; 0x01
    592e:	01 c0       	rjmp	.+2      	; 0x5932 <USART_Recieve_NonBlock+0x26>
	}
	else
	{
		return 0;
    5930:	19 82       	std	Y+1, r1	; 0x01
    5932:	89 81       	ldd	r24, Y+1	; 0x01
	}
}
    5934:	0f 90       	pop	r0
    5936:	cf 91       	pop	r28
    5938:	df 91       	pop	r29
    593a:	08 95       	ret

0000593c <USART_RecieveInterruptEnable>:
void USART_RecieveInterruptEnable(void)
{
    593c:	df 93       	push	r29
    593e:	cf 93       	push	r28
    5940:	cd b7       	in	r28, 0x3d	; 61
    5942:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(UART_UCSRB_REG,UART_RXC_INT_BIT);
    5944:	aa e2       	ldi	r26, 0x2A	; 42
    5946:	b0 e0       	ldi	r27, 0x00	; 0
    5948:	ea e2       	ldi	r30, 0x2A	; 42
    594a:	f0 e0       	ldi	r31, 0x00	; 0
    594c:	80 81       	ld	r24, Z
    594e:	80 68       	ori	r24, 0x80	; 128
    5950:	8c 93       	st	X, r24
}
    5952:	cf 91       	pop	r28
    5954:	df 91       	pop	r29
    5956:	08 95       	ret

00005958 <SPI_vidMasterInit>:
 *      Author: Khaled
 */
#include "SPI.h"

void SPI_vidMasterInit(void)
{
    5958:	df 93       	push	r29
    595a:	cf 93       	push	r28
    595c:	cd b7       	in	r28, 0x3d	; 61
    595e:	de b7       	in	r29, 0x3e	; 62
	/*	configure SPI MOSI Pin as output	*/
	Dio_vidconfigChannel(DIO_PORTB, DIO_PIN5, DIO_OUTPUT);
    5960:	81 e0       	ldi	r24, 0x01	; 1
    5962:	65 e0       	ldi	r22, 0x05	; 5
    5964:	41 e0       	ldi	r20, 0x01	; 1
    5966:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>
	/*	configure SPI SS Pin as output	*/
	Dio_vidconfigChannel(DIO_PORTB, DIO_PIN4, DIO_OUTPUT);
    596a:	81 e0       	ldi	r24, 0x01	; 1
    596c:	64 e0       	ldi	r22, 0x04	; 4
    596e:	41 e0       	ldi	r20, 0x01	; 1
    5970:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>
	/*	configure SPI SCK Pin as output	*/
	Dio_vidconfigChannel(DIO_PORTB, DIO_PIN7, DIO_OUTPUT);
    5974:	81 e0       	ldi	r24, 0x01	; 1
    5976:	67 e0       	ldi	r22, 0x07	; 7
    5978:	41 e0       	ldi	r20, 0x01	; 1
    597a:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>
	/*	configure SPI MISO Pin as input	*/
	Dio_vidconfigChannel(DIO_PORTB, DIO_PIN6, DIO_INPUT);
    597e:	81 e0       	ldi	r24, 0x01	; 1
    5980:	66 e0       	ldi	r22, 0x06	; 6
    5982:	40 e0       	ldi	r20, 0x00	; 0
    5984:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>
	/*	initialize SPI SS pin with HIGH (No slave selected) */
	Dio_vidwriteChannel(DIO_PORTB, DIO_PIN4, DIO_HIGH);
    5988:	81 e0       	ldi	r24, 0x01	; 1
    598a:	64 e0       	ldi	r22, 0x04	; 4
    598c:	41 e0       	ldi	r20, 0x01	; 1
    598e:	0e 94 39 31 	call	0x6272	; 0x6272 <Dio_vidwriteChannel>
	/*	enable SPI Module	*/
	SET_BIT(SPI_SPCR_REG,SPI_SPE_BIT);
    5992:	ad e2       	ldi	r26, 0x2D	; 45
    5994:	b0 e0       	ldi	r27, 0x00	; 0
    5996:	ed e2       	ldi	r30, 0x2D	; 45
    5998:	f0 e0       	ldi	r31, 0x00	; 0
    599a:	80 81       	ld	r24, Z
    599c:	80 64       	ori	r24, 0x40	; 64
    599e:	8c 93       	st	X, r24
	/*	enable SPI Module in Master mode	*/
	SET_BIT(SPI_SPCR_REG,SPI_MSTR_BIT);
    59a0:	ad e2       	ldi	r26, 0x2D	; 45
    59a2:	b0 e0       	ldi	r27, 0x00	; 0
    59a4:	ed e2       	ldi	r30, 0x2D	; 45
    59a6:	f0 e0       	ldi	r31, 0x00	; 0
    59a8:	80 81       	ld	r24, Z
    59aa:	80 61       	ori	r24, 0x10	; 16
    59ac:	8c 93       	st	X, r24
	/*	set SCK frequency by F_CPU/16	*/
	/*	Set SPI Speed	1MHZ*/
	SPI_SPCR_REG |= SPI_SCK_FREQ_FCPU_DIV_16;
    59ae:	ad e2       	ldi	r26, 0x2D	; 45
    59b0:	b0 e0       	ldi	r27, 0x00	; 0
    59b2:	ed e2       	ldi	r30, 0x2D	; 45
    59b4:	f0 e0       	ldi	r31, 0x00	; 0
    59b6:	80 81       	ld	r24, Z
    59b8:	81 60       	ori	r24, 0x01	; 1
    59ba:	8c 93       	st	X, r24
}
    59bc:	cf 91       	pop	r28
    59be:	df 91       	pop	r29
    59c0:	08 95       	ret

000059c2 <SPI_vidSlaveInit>:

void SPI_vidSlaveInit(void)
{
    59c2:	df 93       	push	r29
    59c4:	cf 93       	push	r28
    59c6:	cd b7       	in	r28, 0x3d	; 61
    59c8:	de b7       	in	r29, 0x3e	; 62
	/*	configure SPI MOSI Pin as input	*/
	Dio_vidconfigChannel(DIO_PORTB, DIO_PIN5, DIO_INPUT);
    59ca:	81 e0       	ldi	r24, 0x01	; 1
    59cc:	65 e0       	ldi	r22, 0x05	; 5
    59ce:	40 e0       	ldi	r20, 0x00	; 0
    59d0:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>
	/*	configure SPI SS Pin as input	*/
	Dio_vidconfigChannel(DIO_PORTB, DIO_PIN4, DIO_INPUT);
    59d4:	81 e0       	ldi	r24, 0x01	; 1
    59d6:	64 e0       	ldi	r22, 0x04	; 4
    59d8:	40 e0       	ldi	r20, 0x00	; 0
    59da:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>
	/*	configure SPI SCK Pin as input	*/
	Dio_vidconfigChannel(DIO_PORTB, DIO_PIN7, DIO_INPUT);
    59de:	81 e0       	ldi	r24, 0x01	; 1
    59e0:	67 e0       	ldi	r22, 0x07	; 7
    59e2:	40 e0       	ldi	r20, 0x00	; 0
    59e4:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>
	/*	configure SPI MISO Pin as output	*/
	Dio_vidconfigChannel(DIO_PORTB, DIO_PIN6, DIO_OUTPUT);
    59e8:	81 e0       	ldi	r24, 0x01	; 1
    59ea:	66 e0       	ldi	r22, 0x06	; 6
    59ec:	41 e0       	ldi	r20, 0x01	; 1
    59ee:	0e 94 56 30 	call	0x60ac	; 0x60ac <Dio_vidconfigChannel>
	/*	enable SPI Module	*/
	SET_BIT(SPI_SPCR_REG,SPI_SPE_BIT);
    59f2:	ad e2       	ldi	r26, 0x2D	; 45
    59f4:	b0 e0       	ldi	r27, 0x00	; 0
    59f6:	ed e2       	ldi	r30, 0x2D	; 45
    59f8:	f0 e0       	ldi	r31, 0x00	; 0
    59fa:	80 81       	ld	r24, Z
    59fc:	80 64       	ori	r24, 0x40	; 64
    59fe:	8c 93       	st	X, r24
	/*	enable SPI Module in Slave mode	*/
	CLEAR_BIT(SPI_SPCR_REG,SPI_MSTR_BIT);
    5a00:	ad e2       	ldi	r26, 0x2D	; 45
    5a02:	b0 e0       	ldi	r27, 0x00	; 0
    5a04:	ed e2       	ldi	r30, 0x2D	; 45
    5a06:	f0 e0       	ldi	r31, 0x00	; 0
    5a08:	80 81       	ld	r24, Z
    5a0a:	8f 7e       	andi	r24, 0xEF	; 239
    5a0c:	8c 93       	st	X, r24
}
    5a0e:	cf 91       	pop	r28
    5a10:	df 91       	pop	r29
    5a12:	08 95       	ret

00005a14 <SPI_MasterWrite>:

void SPI_MasterWrite(u8 data)
{
    5a14:	df 93       	push	r29
    5a16:	cf 93       	push	r28
    5a18:	00 d0       	rcall	.+0      	; 0x5a1a <SPI_MasterWrite+0x6>
    5a1a:	cd b7       	in	r28, 0x3d	; 61
    5a1c:	de b7       	in	r29, 0x3e	; 62
    5a1e:	8a 83       	std	Y+2, r24	; 0x02
	u8 loc_flush_byte;
	/*	load SPI data register with a byte to send	*/
	SPI_SPDR_REG = data;
    5a20:	ef e2       	ldi	r30, 0x2F	; 47
    5a22:	f0 e0       	ldi	r31, 0x00	; 0
    5a24:	8a 81       	ldd	r24, Y+2	; 0x02
    5a26:	80 83       	st	Z, r24
	/*	wait until byte sent	*/
	while(CHECK_BIT(SPI_SPSR_REG,SPI_SPIF_BIT) == 0)
    5a28:	ee e2       	ldi	r30, 0x2E	; 46
    5a2a:	f0 e0       	ldi	r31, 0x00	; 0
    5a2c:	80 81       	ld	r24, Z
    5a2e:	88 23       	and	r24, r24
    5a30:	dc f7       	brge	.-10     	; 0x5a28 <SPI_MasterWrite+0x14>
	{
		;
	}
		/*	flush the data register	*/
	loc_flush_byte = SPI_SPDR_REG;
    5a32:	ef e2       	ldi	r30, 0x2F	; 47
    5a34:	f0 e0       	ldi	r31, 0x00	; 0
    5a36:	80 81       	ld	r24, Z
    5a38:	89 83       	std	Y+1, r24	; 0x01
}
    5a3a:	0f 90       	pop	r0
    5a3c:	0f 90       	pop	r0
    5a3e:	cf 91       	pop	r28
    5a40:	df 91       	pop	r29
    5a42:	08 95       	ret

00005a44 <SPI_u8MasterRead>:

u8 SPI_u8MasterRead(void)
{
    5a44:	df 93       	push	r29
    5a46:	cf 93       	push	r28
    5a48:	0f 92       	push	r0
    5a4a:	cd b7       	in	r28, 0x3d	; 61
    5a4c:	de b7       	in	r29, 0x3e	; 62
	u8 loc_dummy_byte=0xFF;
    5a4e:	8f ef       	ldi	r24, 0xFF	; 255
    5a50:	89 83       	std	Y+1, r24	; 0x01
	/*	load SPI data register with a byte to send	*/
	SPI_SPDR_REG = loc_dummy_byte;
    5a52:	ef e2       	ldi	r30, 0x2F	; 47
    5a54:	f0 e0       	ldi	r31, 0x00	; 0
    5a56:	89 81       	ldd	r24, Y+1	; 0x01
    5a58:	80 83       	st	Z, r24
	/*	wait until byte received	*/
	while(CHECK_BIT(SPI_SPSR_REG,SPI_SPIF_BIT) == 0)
    5a5a:	ee e2       	ldi	r30, 0x2E	; 46
    5a5c:	f0 e0       	ldi	r31, 0x00	; 0
    5a5e:	80 81       	ld	r24, Z
    5a60:	88 23       	and	r24, r24
    5a62:	dc f7       	brge	.-10     	; 0x5a5a <SPI_u8MasterRead+0x16>
	{
		;
	}
		/*	read the data register	*/
	return SPI_SPDR_REG;
    5a64:	ef e2       	ldi	r30, 0x2F	; 47
    5a66:	f0 e0       	ldi	r31, 0x00	; 0
    5a68:	80 81       	ld	r24, Z
}
    5a6a:	0f 90       	pop	r0
    5a6c:	cf 91       	pop	r28
    5a6e:	df 91       	pop	r29
    5a70:	08 95       	ret

00005a72 <SPI_u8MasterTranseve>:

u8 SPI_u8MasterTranseve(u8 data)
{
    5a72:	df 93       	push	r29
    5a74:	cf 93       	push	r28
    5a76:	0f 92       	push	r0
    5a78:	cd b7       	in	r28, 0x3d	; 61
    5a7a:	de b7       	in	r29, 0x3e	; 62
    5a7c:	89 83       	std	Y+1, r24	; 0x01
	/*	load SPI data register with a byte to send	*/
	SPI_SPDR_REG = data;
    5a7e:	ef e2       	ldi	r30, 0x2F	; 47
    5a80:	f0 e0       	ldi	r31, 0x00	; 0
    5a82:	89 81       	ldd	r24, Y+1	; 0x01
    5a84:	80 83       	st	Z, r24
	/*	wait until byte sent	*/
	while(CHECK_BIT(SPI_SPSR_REG,SPI_SPIF_BIT) == 0)
    5a86:	ee e2       	ldi	r30, 0x2E	; 46
    5a88:	f0 e0       	ldi	r31, 0x00	; 0
    5a8a:	80 81       	ld	r24, Z
    5a8c:	88 23       	and	r24, r24
    5a8e:	dc f7       	brge	.-10     	; 0x5a86 <SPI_u8MasterTranseve+0x14>
	{
		;
	}
	/*	flush the data register	*/
	return SPI_SPDR_REG;
    5a90:	ef e2       	ldi	r30, 0x2F	; 47
    5a92:	f0 e0       	ldi	r31, 0x00	; 0
    5a94:	80 81       	ld	r24, Z
}
    5a96:	0f 90       	pop	r0
    5a98:	cf 91       	pop	r28
    5a9a:	df 91       	pop	r29
    5a9c:	08 95       	ret

00005a9e <SPI_u8SlaveRead>:

u8 SPI_u8SlaveRead(void)
{
    5a9e:	df 93       	push	r29
    5aa0:	cf 93       	push	r28
    5aa2:	cd b7       	in	r28, 0x3d	; 61
    5aa4:	de b7       	in	r29, 0x3e	; 62
	/*	wait until byte received	*/
	while(CHECK_BIT(SPI_SPSR_REG,SPI_SPIF_BIT) == 0)
    5aa6:	ee e2       	ldi	r30, 0x2E	; 46
    5aa8:	f0 e0       	ldi	r31, 0x00	; 0
    5aaa:	80 81       	ld	r24, Z
    5aac:	88 23       	and	r24, r24
    5aae:	dc f7       	brge	.-10     	; 0x5aa6 <SPI_u8SlaveRead+0x8>
	{
		;
	}
		/*	read the data register	*/
	return SPI_SPDR_REG;
    5ab0:	ef e2       	ldi	r30, 0x2F	; 47
    5ab2:	f0 e0       	ldi	r31, 0x00	; 0
    5ab4:	80 81       	ld	r24, Z
}
    5ab6:	cf 91       	pop	r28
    5ab8:	df 91       	pop	r29
    5aba:	08 95       	ret

00005abc <SPI_vidSlaveWrite>:

void SPI_vidSlaveWrite(u8 data)
{
    5abc:	df 93       	push	r29
    5abe:	cf 93       	push	r28
    5ac0:	0f 92       	push	r0
    5ac2:	cd b7       	in	r28, 0x3d	; 61
    5ac4:	de b7       	in	r29, 0x3e	; 62
    5ac6:	89 83       	std	Y+1, r24	; 0x01
	SPI_SPDR_REG = data;
    5ac8:	ef e2       	ldi	r30, 0x2F	; 47
    5aca:	f0 e0       	ldi	r31, 0x00	; 0
    5acc:	89 81       	ldd	r24, Y+1	; 0x01
    5ace:	80 83       	st	Z, r24
}
    5ad0:	0f 90       	pop	r0
    5ad2:	cf 91       	pop	r28
    5ad4:	df 91       	pop	r29
    5ad6:	08 95       	ret

00005ad8 <GINT_vidEnableAllInterrupt>:
 */
#include "Gint.h"
#include "Bit_Math.h"

void GINT_vidEnableAllInterrupt(void)
{
    5ad8:	df 93       	push	r29
    5ada:	cf 93       	push	r28
    5adc:	cd b7       	in	r28, 0x3d	; 61
    5ade:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(GINT_SREG_REG,7);
    5ae0:	af e5       	ldi	r26, 0x5F	; 95
    5ae2:	b0 e0       	ldi	r27, 0x00	; 0
    5ae4:	ef e5       	ldi	r30, 0x5F	; 95
    5ae6:	f0 e0       	ldi	r31, 0x00	; 0
    5ae8:	80 81       	ld	r24, Z
    5aea:	80 68       	ori	r24, 0x80	; 128
    5aec:	8c 93       	st	X, r24
}
    5aee:	cf 91       	pop	r28
    5af0:	df 91       	pop	r29
    5af2:	08 95       	ret

00005af4 <GINT_vidDisableAllInterrupt>:
void GINT_vidDisableAllInterrupt(void)
{
    5af4:	df 93       	push	r29
    5af6:	cf 93       	push	r28
    5af8:	cd b7       	in	r28, 0x3d	; 61
    5afa:	de b7       	in	r29, 0x3e	; 62
	CLEAR_BIT(GINT_SREG_REG,7);
    5afc:	af e5       	ldi	r26, 0x5F	; 95
    5afe:	b0 e0       	ldi	r27, 0x00	; 0
    5b00:	ef e5       	ldi	r30, 0x5F	; 95
    5b02:	f0 e0       	ldi	r31, 0x00	; 0
    5b04:	80 81       	ld	r24, Z
    5b06:	8f 77       	andi	r24, 0x7F	; 127
    5b08:	8c 93       	st	X, r24
}
    5b0a:	cf 91       	pop	r28
    5b0c:	df 91       	pop	r29
    5b0e:	08 95       	ret

00005b10 <EXTINT_vidEnableExtInterrupt>:
 */
#include "Extint.h"
#include "Bit_Math.h"

void EXTINT_vidEnableExtInterrupt(extint_interrupt_t interrupt,extint_edge_t edge)
{
    5b10:	df 93       	push	r29
    5b12:	cf 93       	push	r28
    5b14:	cd b7       	in	r28, 0x3d	; 61
    5b16:	de b7       	in	r29, 0x3e	; 62
    5b18:	2a 97       	sbiw	r28, 0x0a	; 10
    5b1a:	0f b6       	in	r0, 0x3f	; 63
    5b1c:	f8 94       	cli
    5b1e:	de bf       	out	0x3e, r29	; 62
    5b20:	0f be       	out	0x3f, r0	; 63
    5b22:	cd bf       	out	0x3d, r28	; 61
    5b24:	89 83       	std	Y+1, r24	; 0x01
    5b26:	6a 83       	std	Y+2, r22	; 0x02
	switch (interrupt)
    5b28:	89 81       	ldd	r24, Y+1	; 0x01
    5b2a:	28 2f       	mov	r18, r24
    5b2c:	30 e0       	ldi	r19, 0x00	; 0
    5b2e:	3a 87       	std	Y+10, r19	; 0x0a
    5b30:	29 87       	std	Y+9, r18	; 0x09
    5b32:	89 85       	ldd	r24, Y+9	; 0x09
    5b34:	9a 85       	ldd	r25, Y+10	; 0x0a
    5b36:	81 30       	cpi	r24, 0x01	; 1
    5b38:	91 05       	cpc	r25, r1
    5b3a:	09 f4       	brne	.+2      	; 0x5b3e <EXTINT_vidEnableExtInterrupt+0x2e>
    5b3c:	6d c0       	rjmp	.+218    	; 0x5c18 <EXTINT_vidEnableExtInterrupt+0x108>
    5b3e:	29 85       	ldd	r18, Y+9	; 0x09
    5b40:	3a 85       	ldd	r19, Y+10	; 0x0a
    5b42:	22 30       	cpi	r18, 0x02	; 2
    5b44:	31 05       	cpc	r19, r1
    5b46:	09 f4       	brne	.+2      	; 0x5b4a <EXTINT_vidEnableExtInterrupt+0x3a>
    5b48:	c9 c0       	rjmp	.+402    	; 0x5cdc <EXTINT_vidEnableExtInterrupt+0x1cc>
    5b4a:	89 85       	ldd	r24, Y+9	; 0x09
    5b4c:	9a 85       	ldd	r25, Y+10	; 0x0a
    5b4e:	00 97       	sbiw	r24, 0x00	; 0
    5b50:	09 f0       	breq	.+2      	; 0x5b54 <EXTINT_vidEnableExtInterrupt+0x44>
    5b52:	e9 c0       	rjmp	.+466    	; 0x5d26 <EXTINT_vidEnableExtInterrupt+0x216>
	{
	case EXT_INT0:
	{
		switch (edge)
    5b54:	8a 81       	ldd	r24, Y+2	; 0x02
    5b56:	28 2f       	mov	r18, r24
    5b58:	30 e0       	ldi	r19, 0x00	; 0
    5b5a:	38 87       	std	Y+8, r19	; 0x08
    5b5c:	2f 83       	std	Y+7, r18	; 0x07
    5b5e:	8f 81       	ldd	r24, Y+7	; 0x07
    5b60:	98 85       	ldd	r25, Y+8	; 0x08
    5b62:	81 30       	cpi	r24, 0x01	; 1
    5b64:	91 05       	cpc	r25, r1
    5b66:	21 f1       	breq	.+72     	; 0x5bb0 <EXTINT_vidEnableExtInterrupt+0xa0>
    5b68:	2f 81       	ldd	r18, Y+7	; 0x07
    5b6a:	38 85       	ldd	r19, Y+8	; 0x08
    5b6c:	22 30       	cpi	r18, 0x02	; 2
    5b6e:	31 05       	cpc	r19, r1
    5b70:	2c f4       	brge	.+10     	; 0x5b7c <EXTINT_vidEnableExtInterrupt+0x6c>
    5b72:	8f 81       	ldd	r24, Y+7	; 0x07
    5b74:	98 85       	ldd	r25, Y+8	; 0x08
    5b76:	00 97       	sbiw	r24, 0x00	; 0
    5b78:	61 f0       	breq	.+24     	; 0x5b92 <EXTINT_vidEnableExtInterrupt+0x82>
    5b7a:	46 c0       	rjmp	.+140    	; 0x5c08 <EXTINT_vidEnableExtInterrupt+0xf8>
    5b7c:	2f 81       	ldd	r18, Y+7	; 0x07
    5b7e:	38 85       	ldd	r19, Y+8	; 0x08
    5b80:	22 30       	cpi	r18, 0x02	; 2
    5b82:	31 05       	cpc	r19, r1
    5b84:	21 f1       	breq	.+72     	; 0x5bce <EXTINT_vidEnableExtInterrupt+0xbe>
    5b86:	8f 81       	ldd	r24, Y+7	; 0x07
    5b88:	98 85       	ldd	r25, Y+8	; 0x08
    5b8a:	83 30       	cpi	r24, 0x03	; 3
    5b8c:	91 05       	cpc	r25, r1
    5b8e:	71 f1       	breq	.+92     	; 0x5bec <EXTINT_vidEnableExtInterrupt+0xdc>
    5b90:	3b c0       	rjmp	.+118    	; 0x5c08 <EXTINT_vidEnableExtInterrupt+0xf8>
		{
		case RISING_EDGE:
		{
			SET_BIT(EXTINT_MCUCR_REG,1);
    5b92:	a5 e5       	ldi	r26, 0x55	; 85
    5b94:	b0 e0       	ldi	r27, 0x00	; 0
    5b96:	e5 e5       	ldi	r30, 0x55	; 85
    5b98:	f0 e0       	ldi	r31, 0x00	; 0
    5b9a:	80 81       	ld	r24, Z
    5b9c:	82 60       	ori	r24, 0x02	; 2
    5b9e:	8c 93       	st	X, r24
			SET_BIT(EXTINT_MCUCR_REG,0);
    5ba0:	a5 e5       	ldi	r26, 0x55	; 85
    5ba2:	b0 e0       	ldi	r27, 0x00	; 0
    5ba4:	e5 e5       	ldi	r30, 0x55	; 85
    5ba6:	f0 e0       	ldi	r31, 0x00	; 0
    5ba8:	80 81       	ld	r24, Z
    5baa:	81 60       	ori	r24, 0x01	; 1
    5bac:	8c 93       	st	X, r24
    5bae:	2c c0       	rjmp	.+88     	; 0x5c08 <EXTINT_vidEnableExtInterrupt+0xf8>
			break;
		}
		case FALLING_EDGE:
		{
			SET_BIT(EXTINT_MCUCR_REG,1);
    5bb0:	a5 e5       	ldi	r26, 0x55	; 85
    5bb2:	b0 e0       	ldi	r27, 0x00	; 0
    5bb4:	e5 e5       	ldi	r30, 0x55	; 85
    5bb6:	f0 e0       	ldi	r31, 0x00	; 0
    5bb8:	80 81       	ld	r24, Z
    5bba:	82 60       	ori	r24, 0x02	; 2
    5bbc:	8c 93       	st	X, r24
			CLEAR_BIT(EXTINT_MCUCR_REG,0);
    5bbe:	a5 e5       	ldi	r26, 0x55	; 85
    5bc0:	b0 e0       	ldi	r27, 0x00	; 0
    5bc2:	e5 e5       	ldi	r30, 0x55	; 85
    5bc4:	f0 e0       	ldi	r31, 0x00	; 0
    5bc6:	80 81       	ld	r24, Z
    5bc8:	8e 7f       	andi	r24, 0xFE	; 254
    5bca:	8c 93       	st	X, r24
    5bcc:	1d c0       	rjmp	.+58     	; 0x5c08 <EXTINT_vidEnableExtInterrupt+0xf8>
			break;
		}
		case LOW_VALUE:
		{
			CLEAR_BIT(EXTINT_MCUCR_REG,1);
    5bce:	a5 e5       	ldi	r26, 0x55	; 85
    5bd0:	b0 e0       	ldi	r27, 0x00	; 0
    5bd2:	e5 e5       	ldi	r30, 0x55	; 85
    5bd4:	f0 e0       	ldi	r31, 0x00	; 0
    5bd6:	80 81       	ld	r24, Z
    5bd8:	8d 7f       	andi	r24, 0xFD	; 253
    5bda:	8c 93       	st	X, r24
			CLEAR_BIT(EXTINT_MCUCR_REG,0);
    5bdc:	a5 e5       	ldi	r26, 0x55	; 85
    5bde:	b0 e0       	ldi	r27, 0x00	; 0
    5be0:	e5 e5       	ldi	r30, 0x55	; 85
    5be2:	f0 e0       	ldi	r31, 0x00	; 0
    5be4:	80 81       	ld	r24, Z
    5be6:	8e 7f       	andi	r24, 0xFE	; 254
    5be8:	8c 93       	st	X, r24
    5bea:	0e c0       	rjmp	.+28     	; 0x5c08 <EXTINT_vidEnableExtInterrupt+0xf8>
			break;
		}
		case BOTH_EDGES:
		{
			CLEAR_BIT(EXTINT_MCUCR_REG,1);
    5bec:	a5 e5       	ldi	r26, 0x55	; 85
    5bee:	b0 e0       	ldi	r27, 0x00	; 0
    5bf0:	e5 e5       	ldi	r30, 0x55	; 85
    5bf2:	f0 e0       	ldi	r31, 0x00	; 0
    5bf4:	80 81       	ld	r24, Z
    5bf6:	8d 7f       	andi	r24, 0xFD	; 253
    5bf8:	8c 93       	st	X, r24
			SET_BIT(EXTINT_MCUCR_REG,0);
    5bfa:	a5 e5       	ldi	r26, 0x55	; 85
    5bfc:	b0 e0       	ldi	r27, 0x00	; 0
    5bfe:	e5 e5       	ldi	r30, 0x55	; 85
    5c00:	f0 e0       	ldi	r31, 0x00	; 0
    5c02:	80 81       	ld	r24, Z
    5c04:	81 60       	ori	r24, 0x01	; 1
    5c06:	8c 93       	st	X, r24
			break;
		}
		}
		SET_BIT(EXTINT_GICR_REG,6);
    5c08:	ab e5       	ldi	r26, 0x5B	; 91
    5c0a:	b0 e0       	ldi	r27, 0x00	; 0
    5c0c:	eb e5       	ldi	r30, 0x5B	; 91
    5c0e:	f0 e0       	ldi	r31, 0x00	; 0
    5c10:	80 81       	ld	r24, Z
    5c12:	80 64       	ori	r24, 0x40	; 64
    5c14:	8c 93       	st	X, r24
    5c16:	87 c0       	rjmp	.+270    	; 0x5d26 <EXTINT_vidEnableExtInterrupt+0x216>
		break;
	}
	case EXT_INT1:
	{
		switch (edge)
    5c18:	8a 81       	ldd	r24, Y+2	; 0x02
    5c1a:	28 2f       	mov	r18, r24
    5c1c:	30 e0       	ldi	r19, 0x00	; 0
    5c1e:	3e 83       	std	Y+6, r19	; 0x06
    5c20:	2d 83       	std	Y+5, r18	; 0x05
    5c22:	8d 81       	ldd	r24, Y+5	; 0x05
    5c24:	9e 81       	ldd	r25, Y+6	; 0x06
    5c26:	81 30       	cpi	r24, 0x01	; 1
    5c28:	91 05       	cpc	r25, r1
    5c2a:	21 f1       	breq	.+72     	; 0x5c74 <EXTINT_vidEnableExtInterrupt+0x164>
    5c2c:	2d 81       	ldd	r18, Y+5	; 0x05
    5c2e:	3e 81       	ldd	r19, Y+6	; 0x06
    5c30:	22 30       	cpi	r18, 0x02	; 2
    5c32:	31 05       	cpc	r19, r1
    5c34:	2c f4       	brge	.+10     	; 0x5c40 <EXTINT_vidEnableExtInterrupt+0x130>
    5c36:	8d 81       	ldd	r24, Y+5	; 0x05
    5c38:	9e 81       	ldd	r25, Y+6	; 0x06
    5c3a:	00 97       	sbiw	r24, 0x00	; 0
    5c3c:	61 f0       	breq	.+24     	; 0x5c56 <EXTINT_vidEnableExtInterrupt+0x146>
    5c3e:	46 c0       	rjmp	.+140    	; 0x5ccc <EXTINT_vidEnableExtInterrupt+0x1bc>
    5c40:	2d 81       	ldd	r18, Y+5	; 0x05
    5c42:	3e 81       	ldd	r19, Y+6	; 0x06
    5c44:	22 30       	cpi	r18, 0x02	; 2
    5c46:	31 05       	cpc	r19, r1
    5c48:	21 f1       	breq	.+72     	; 0x5c92 <EXTINT_vidEnableExtInterrupt+0x182>
    5c4a:	8d 81       	ldd	r24, Y+5	; 0x05
    5c4c:	9e 81       	ldd	r25, Y+6	; 0x06
    5c4e:	83 30       	cpi	r24, 0x03	; 3
    5c50:	91 05       	cpc	r25, r1
    5c52:	71 f1       	breq	.+92     	; 0x5cb0 <EXTINT_vidEnableExtInterrupt+0x1a0>
    5c54:	3b c0       	rjmp	.+118    	; 0x5ccc <EXTINT_vidEnableExtInterrupt+0x1bc>
		{
		case RISING_EDGE:
		{
			SET_BIT(EXTINT_MCUCR_REG,1);
    5c56:	a5 e5       	ldi	r26, 0x55	; 85
    5c58:	b0 e0       	ldi	r27, 0x00	; 0
    5c5a:	e5 e5       	ldi	r30, 0x55	; 85
    5c5c:	f0 e0       	ldi	r31, 0x00	; 0
    5c5e:	80 81       	ld	r24, Z
    5c60:	82 60       	ori	r24, 0x02	; 2
    5c62:	8c 93       	st	X, r24
			SET_BIT(EXTINT_MCUCR_REG,0);
    5c64:	a5 e5       	ldi	r26, 0x55	; 85
    5c66:	b0 e0       	ldi	r27, 0x00	; 0
    5c68:	e5 e5       	ldi	r30, 0x55	; 85
    5c6a:	f0 e0       	ldi	r31, 0x00	; 0
    5c6c:	80 81       	ld	r24, Z
    5c6e:	81 60       	ori	r24, 0x01	; 1
    5c70:	8c 93       	st	X, r24
    5c72:	2c c0       	rjmp	.+88     	; 0x5ccc <EXTINT_vidEnableExtInterrupt+0x1bc>
			break;
		}
		case FALLING_EDGE:
		{
			SET_BIT(EXTINT_MCUCR_REG,1);
    5c74:	a5 e5       	ldi	r26, 0x55	; 85
    5c76:	b0 e0       	ldi	r27, 0x00	; 0
    5c78:	e5 e5       	ldi	r30, 0x55	; 85
    5c7a:	f0 e0       	ldi	r31, 0x00	; 0
    5c7c:	80 81       	ld	r24, Z
    5c7e:	82 60       	ori	r24, 0x02	; 2
    5c80:	8c 93       	st	X, r24
			CLEAR_BIT(EXTINT_MCUCR_REG,0);
    5c82:	a5 e5       	ldi	r26, 0x55	; 85
    5c84:	b0 e0       	ldi	r27, 0x00	; 0
    5c86:	e5 e5       	ldi	r30, 0x55	; 85
    5c88:	f0 e0       	ldi	r31, 0x00	; 0
    5c8a:	80 81       	ld	r24, Z
    5c8c:	8e 7f       	andi	r24, 0xFE	; 254
    5c8e:	8c 93       	st	X, r24
    5c90:	1d c0       	rjmp	.+58     	; 0x5ccc <EXTINT_vidEnableExtInterrupt+0x1bc>
			break;
		}
		case LOW_VALUE:
		{
			CLEAR_BIT(EXTINT_MCUCR_REG,0);
    5c92:	a5 e5       	ldi	r26, 0x55	; 85
    5c94:	b0 e0       	ldi	r27, 0x00	; 0
    5c96:	e5 e5       	ldi	r30, 0x55	; 85
    5c98:	f0 e0       	ldi	r31, 0x00	; 0
    5c9a:	80 81       	ld	r24, Z
    5c9c:	8e 7f       	andi	r24, 0xFE	; 254
    5c9e:	8c 93       	st	X, r24
			CLEAR_BIT(EXTINT_MCUCR_REG,1);
    5ca0:	a5 e5       	ldi	r26, 0x55	; 85
    5ca2:	b0 e0       	ldi	r27, 0x00	; 0
    5ca4:	e5 e5       	ldi	r30, 0x55	; 85
    5ca6:	f0 e0       	ldi	r31, 0x00	; 0
    5ca8:	80 81       	ld	r24, Z
    5caa:	8d 7f       	andi	r24, 0xFD	; 253
    5cac:	8c 93       	st	X, r24
    5cae:	0e c0       	rjmp	.+28     	; 0x5ccc <EXTINT_vidEnableExtInterrupt+0x1bc>
			break;
		}
		case BOTH_EDGES:
		{
			CLEAR_BIT(EXTINT_MCUCR_REG,1);
    5cb0:	a5 e5       	ldi	r26, 0x55	; 85
    5cb2:	b0 e0       	ldi	r27, 0x00	; 0
    5cb4:	e5 e5       	ldi	r30, 0x55	; 85
    5cb6:	f0 e0       	ldi	r31, 0x00	; 0
    5cb8:	80 81       	ld	r24, Z
    5cba:	8d 7f       	andi	r24, 0xFD	; 253
    5cbc:	8c 93       	st	X, r24
			SET_BIT(EXTINT_MCUCR_REG,0);
    5cbe:	a5 e5       	ldi	r26, 0x55	; 85
    5cc0:	b0 e0       	ldi	r27, 0x00	; 0
    5cc2:	e5 e5       	ldi	r30, 0x55	; 85
    5cc4:	f0 e0       	ldi	r31, 0x00	; 0
    5cc6:	80 81       	ld	r24, Z
    5cc8:	81 60       	ori	r24, 0x01	; 1
    5cca:	8c 93       	st	X, r24
			break;
		}
		}
		SET_BIT(EXTINT_GICR_REG,7);
    5ccc:	ab e5       	ldi	r26, 0x5B	; 91
    5cce:	b0 e0       	ldi	r27, 0x00	; 0
    5cd0:	eb e5       	ldi	r30, 0x5B	; 91
    5cd2:	f0 e0       	ldi	r31, 0x00	; 0
    5cd4:	80 81       	ld	r24, Z
    5cd6:	80 68       	ori	r24, 0x80	; 128
    5cd8:	8c 93       	st	X, r24
    5cda:	25 c0       	rjmp	.+74     	; 0x5d26 <EXTINT_vidEnableExtInterrupt+0x216>
		break;
	}
	case EXT_INT2:
	{
		switch(edge)
    5cdc:	8a 81       	ldd	r24, Y+2	; 0x02
    5cde:	28 2f       	mov	r18, r24
    5ce0:	30 e0       	ldi	r19, 0x00	; 0
    5ce2:	3c 83       	std	Y+4, r19	; 0x04
    5ce4:	2b 83       	std	Y+3, r18	; 0x03
    5ce6:	8b 81       	ldd	r24, Y+3	; 0x03
    5ce8:	9c 81       	ldd	r25, Y+4	; 0x04
    5cea:	00 97       	sbiw	r24, 0x00	; 0
    5cec:	31 f0       	breq	.+12     	; 0x5cfa <EXTINT_vidEnableExtInterrupt+0x1ea>
    5cee:	2b 81       	ldd	r18, Y+3	; 0x03
    5cf0:	3c 81       	ldd	r19, Y+4	; 0x04
    5cf2:	21 30       	cpi	r18, 0x01	; 1
    5cf4:	31 05       	cpc	r19, r1
    5cf6:	49 f0       	breq	.+18     	; 0x5d0a <EXTINT_vidEnableExtInterrupt+0x1fa>
    5cf8:	0f c0       	rjmp	.+30     	; 0x5d18 <EXTINT_vidEnableExtInterrupt+0x208>
		{
		case RISING_EDGE:
		{
			SET_BIT(EXTINT_MCUCSR_REG,6);
    5cfa:	a4 e5       	ldi	r26, 0x54	; 84
    5cfc:	b0 e0       	ldi	r27, 0x00	; 0
    5cfe:	e4 e5       	ldi	r30, 0x54	; 84
    5d00:	f0 e0       	ldi	r31, 0x00	; 0
    5d02:	80 81       	ld	r24, Z
    5d04:	80 64       	ori	r24, 0x40	; 64
    5d06:	8c 93       	st	X, r24
    5d08:	07 c0       	rjmp	.+14     	; 0x5d18 <EXTINT_vidEnableExtInterrupt+0x208>
			break;
		}
		case FALLING_EDGE:
		{
			CLEAR_BIT(EXTINT_MCUCSR_REG,6);
    5d0a:	a4 e5       	ldi	r26, 0x54	; 84
    5d0c:	b0 e0       	ldi	r27, 0x00	; 0
    5d0e:	e4 e5       	ldi	r30, 0x54	; 84
    5d10:	f0 e0       	ldi	r31, 0x00	; 0
    5d12:	80 81       	ld	r24, Z
    5d14:	8f 7b       	andi	r24, 0xBF	; 191
    5d16:	8c 93       	st	X, r24
		case LOW_VALUE:
		{
			break;
		}
		}
		SET_BIT(EXTINT_GICR_REG,5);
    5d18:	ab e5       	ldi	r26, 0x5B	; 91
    5d1a:	b0 e0       	ldi	r27, 0x00	; 0
    5d1c:	eb e5       	ldi	r30, 0x5B	; 91
    5d1e:	f0 e0       	ldi	r31, 0x00	; 0
    5d20:	80 81       	ld	r24, Z
    5d22:	80 62       	ori	r24, 0x20	; 32
    5d24:	8c 93       	st	X, r24
		break;
	}
	}
}
    5d26:	2a 96       	adiw	r28, 0x0a	; 10
    5d28:	0f b6       	in	r0, 0x3f	; 63
    5d2a:	f8 94       	cli
    5d2c:	de bf       	out	0x3e, r29	; 62
    5d2e:	0f be       	out	0x3f, r0	; 63
    5d30:	cd bf       	out	0x3d, r28	; 61
    5d32:	cf 91       	pop	r28
    5d34:	df 91       	pop	r29
    5d36:	08 95       	ret

00005d38 <H_AT24C16A_Void_EEPROMInit>:
	return Local_u8_Data;
}*/


void H_AT24C16A_Void_EEPROMInit(void)
{
    5d38:	df 93       	push	r29
    5d3a:	cf 93       	push	r28
    5d3c:	cd b7       	in	r28, 0x3d	; 61
    5d3e:	de b7       	in	r29, 0x3e	; 62
    5d40:	2e 97       	sbiw	r28, 0x0e	; 14
    5d42:	0f b6       	in	r0, 0x3f	; 63
    5d44:	f8 94       	cli
    5d46:	de bf       	out	0x3e, r29	; 62
    5d48:	0f be       	out	0x3f, r0	; 63
    5d4a:	cd bf       	out	0x3d, r28	; 61
	M_I2C_Void_I2CInit();
    5d4c:	0e 94 56 2a 	call	0x54ac	; 0x54ac <M_I2C_Void_I2CInit>
    5d50:	80 e0       	ldi	r24, 0x00	; 0
    5d52:	90 e0       	ldi	r25, 0x00	; 0
    5d54:	aa e7       	ldi	r26, 0x7A	; 122
    5d56:	b4 e4       	ldi	r27, 0x44	; 68
    5d58:	8b 87       	std	Y+11, r24	; 0x0b
    5d5a:	9c 87       	std	Y+12, r25	; 0x0c
    5d5c:	ad 87       	std	Y+13, r26	; 0x0d
    5d5e:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5d60:	6b 85       	ldd	r22, Y+11	; 0x0b
    5d62:	7c 85       	ldd	r23, Y+12	; 0x0c
    5d64:	8d 85       	ldd	r24, Y+13	; 0x0d
    5d66:	9e 85       	ldd	r25, Y+14	; 0x0e
    5d68:	20 e0       	ldi	r18, 0x00	; 0
    5d6a:	30 e0       	ldi	r19, 0x00	; 0
    5d6c:	4a e7       	ldi	r20, 0x7A	; 122
    5d6e:	55 e4       	ldi	r21, 0x45	; 69
    5d70:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5d74:	dc 01       	movw	r26, r24
    5d76:	cb 01       	movw	r24, r22
    5d78:	8f 83       	std	Y+7, r24	; 0x07
    5d7a:	98 87       	std	Y+8, r25	; 0x08
    5d7c:	a9 87       	std	Y+9, r26	; 0x09
    5d7e:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    5d80:	6f 81       	ldd	r22, Y+7	; 0x07
    5d82:	78 85       	ldd	r23, Y+8	; 0x08
    5d84:	89 85       	ldd	r24, Y+9	; 0x09
    5d86:	9a 85       	ldd	r25, Y+10	; 0x0a
    5d88:	20 e0       	ldi	r18, 0x00	; 0
    5d8a:	30 e0       	ldi	r19, 0x00	; 0
    5d8c:	40 e8       	ldi	r20, 0x80	; 128
    5d8e:	5f e3       	ldi	r21, 0x3F	; 63
    5d90:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    5d94:	88 23       	and	r24, r24
    5d96:	2c f4       	brge	.+10     	; 0x5da2 <H_AT24C16A_Void_EEPROMInit+0x6a>
		__ticks = 1;
    5d98:	81 e0       	ldi	r24, 0x01	; 1
    5d9a:	90 e0       	ldi	r25, 0x00	; 0
    5d9c:	9e 83       	std	Y+6, r25	; 0x06
    5d9e:	8d 83       	std	Y+5, r24	; 0x05
    5da0:	3f c0       	rjmp	.+126    	; 0x5e20 <H_AT24C16A_Void_EEPROMInit+0xe8>
	else if (__tmp > 65535)
    5da2:	6f 81       	ldd	r22, Y+7	; 0x07
    5da4:	78 85       	ldd	r23, Y+8	; 0x08
    5da6:	89 85       	ldd	r24, Y+9	; 0x09
    5da8:	9a 85       	ldd	r25, Y+10	; 0x0a
    5daa:	20 e0       	ldi	r18, 0x00	; 0
    5dac:	3f ef       	ldi	r19, 0xFF	; 255
    5dae:	4f e7       	ldi	r20, 0x7F	; 127
    5db0:	57 e4       	ldi	r21, 0x47	; 71
    5db2:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    5db6:	18 16       	cp	r1, r24
    5db8:	4c f5       	brge	.+82     	; 0x5e0c <H_AT24C16A_Void_EEPROMInit+0xd4>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5dba:	6b 85       	ldd	r22, Y+11	; 0x0b
    5dbc:	7c 85       	ldd	r23, Y+12	; 0x0c
    5dbe:	8d 85       	ldd	r24, Y+13	; 0x0d
    5dc0:	9e 85       	ldd	r25, Y+14	; 0x0e
    5dc2:	20 e0       	ldi	r18, 0x00	; 0
    5dc4:	30 e0       	ldi	r19, 0x00	; 0
    5dc6:	40 e2       	ldi	r20, 0x20	; 32
    5dc8:	51 e4       	ldi	r21, 0x41	; 65
    5dca:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5dce:	dc 01       	movw	r26, r24
    5dd0:	cb 01       	movw	r24, r22
    5dd2:	bc 01       	movw	r22, r24
    5dd4:	cd 01       	movw	r24, r26
    5dd6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5dda:	dc 01       	movw	r26, r24
    5ddc:	cb 01       	movw	r24, r22
    5dde:	9e 83       	std	Y+6, r25	; 0x06
    5de0:	8d 83       	std	Y+5, r24	; 0x05
    5de2:	0f c0       	rjmp	.+30     	; 0x5e02 <H_AT24C16A_Void_EEPROMInit+0xca>
    5de4:	80 e9       	ldi	r24, 0x90	; 144
    5de6:	91 e0       	ldi	r25, 0x01	; 1
    5de8:	9c 83       	std	Y+4, r25	; 0x04
    5dea:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    5dec:	8b 81       	ldd	r24, Y+3	; 0x03
    5dee:	9c 81       	ldd	r25, Y+4	; 0x04
    5df0:	01 97       	sbiw	r24, 0x01	; 1
    5df2:	f1 f7       	brne	.-4      	; 0x5df0 <H_AT24C16A_Void_EEPROMInit+0xb8>
    5df4:	9c 83       	std	Y+4, r25	; 0x04
    5df6:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5df8:	8d 81       	ldd	r24, Y+5	; 0x05
    5dfa:	9e 81       	ldd	r25, Y+6	; 0x06
    5dfc:	01 97       	sbiw	r24, 0x01	; 1
    5dfe:	9e 83       	std	Y+6, r25	; 0x06
    5e00:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5e02:	8d 81       	ldd	r24, Y+5	; 0x05
    5e04:	9e 81       	ldd	r25, Y+6	; 0x06
    5e06:	00 97       	sbiw	r24, 0x00	; 0
    5e08:	69 f7       	brne	.-38     	; 0x5de4 <H_AT24C16A_Void_EEPROMInit+0xac>
    5e0a:	14 c0       	rjmp	.+40     	; 0x5e34 <H_AT24C16A_Void_EEPROMInit+0xfc>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5e0c:	6f 81       	ldd	r22, Y+7	; 0x07
    5e0e:	78 85       	ldd	r23, Y+8	; 0x08
    5e10:	89 85       	ldd	r24, Y+9	; 0x09
    5e12:	9a 85       	ldd	r25, Y+10	; 0x0a
    5e14:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5e18:	dc 01       	movw	r26, r24
    5e1a:	cb 01       	movw	r24, r22
    5e1c:	9e 83       	std	Y+6, r25	; 0x06
    5e1e:	8d 83       	std	Y+5, r24	; 0x05
    5e20:	8d 81       	ldd	r24, Y+5	; 0x05
    5e22:	9e 81       	ldd	r25, Y+6	; 0x06
    5e24:	9a 83       	std	Y+2, r25	; 0x02
    5e26:	89 83       	std	Y+1, r24	; 0x01
    5e28:	89 81       	ldd	r24, Y+1	; 0x01
    5e2a:	9a 81       	ldd	r25, Y+2	; 0x02
    5e2c:	01 97       	sbiw	r24, 0x01	; 1
    5e2e:	f1 f7       	brne	.-4      	; 0x5e2c <H_AT24C16A_Void_EEPROMInit+0xf4>
    5e30:	9a 83       	std	Y+2, r25	; 0x02
    5e32:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(1000);
}
    5e34:	2e 96       	adiw	r28, 0x0e	; 14
    5e36:	0f b6       	in	r0, 0x3f	; 63
    5e38:	f8 94       	cli
    5e3a:	de bf       	out	0x3e, r29	; 62
    5e3c:	0f be       	out	0x3f, r0	; 63
    5e3e:	cd bf       	out	0x3d, r28	; 61
    5e40:	cf 91       	pop	r28
    5e42:	df 91       	pop	r29
    5e44:	08 95       	ret

00005e46 <H_AT24C16A_Void_EEPROMWrite>:
void H_AT24C16A_Void_EEPROMWrite(u8 Copy_U8_Page,u8 Copy_U8_Byte,u8 Copy_U8_Data)
{
    5e46:	df 93       	push	r29
    5e48:	cf 93       	push	r28
    5e4a:	cd b7       	in	r28, 0x3d	; 61
    5e4c:	de b7       	in	r29, 0x3e	; 62
    5e4e:	61 97       	sbiw	r28, 0x11	; 17
    5e50:	0f b6       	in	r0, 0x3f	; 63
    5e52:	f8 94       	cli
    5e54:	de bf       	out	0x3e, r29	; 62
    5e56:	0f be       	out	0x3f, r0	; 63
    5e58:	cd bf       	out	0x3d, r28	; 61
    5e5a:	8f 87       	std	Y+15, r24	; 0x0f
    5e5c:	68 8b       	std	Y+16, r22	; 0x10
    5e5e:	49 8b       	std	Y+17, r20	; 0x11
	M_I2C_Void_I2CStartCondition();
    5e60:	0e 94 68 2a 	call	0x54d0	; 0x54d0 <M_I2C_Void_I2CStartCondition>

	M_I2C_Void_I2CSendSlaveAddressWrite(0x50 | Copy_U8_Page);
    5e64:	8f 85       	ldd	r24, Y+15	; 0x0f
    5e66:	80 65       	ori	r24, 0x50	; 80
    5e68:	0e 94 c5 2a 	call	0x558a	; 0x558a <M_I2C_Void_I2CSendSlaveAddressWrite>
	M_I2C_Void_I2CSendByte(Copy_U8_Byte);
    5e6c:	88 89       	ldd	r24, Y+16	; 0x10
    5e6e:	0e 94 ff 2a 	call	0x55fe	; 0x55fe <M_I2C_Void_I2CSendByte>
	M_I2C_Void_I2CSendByte(Copy_U8_Data);
    5e72:	89 89       	ldd	r24, Y+17	; 0x11
    5e74:	0e 94 ff 2a 	call	0x55fe	; 0x55fe <M_I2C_Void_I2CSendByte>
	M_I2C_Void_I2CStopCondition();
    5e78:	0e 94 8c 2a 	call	0x5518	; 0x5518 <M_I2C_Void_I2CStopCondition>
    5e7c:	80 e0       	ldi	r24, 0x00	; 0
    5e7e:	90 e0       	ldi	r25, 0x00	; 0
    5e80:	aa ef       	ldi	r26, 0xFA	; 250
    5e82:	b3 e4       	ldi	r27, 0x43	; 67
    5e84:	8b 87       	std	Y+11, r24	; 0x0b
    5e86:	9c 87       	std	Y+12, r25	; 0x0c
    5e88:	ad 87       	std	Y+13, r26	; 0x0d
    5e8a:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5e8c:	6b 85       	ldd	r22, Y+11	; 0x0b
    5e8e:	7c 85       	ldd	r23, Y+12	; 0x0c
    5e90:	8d 85       	ldd	r24, Y+13	; 0x0d
    5e92:	9e 85       	ldd	r25, Y+14	; 0x0e
    5e94:	20 e0       	ldi	r18, 0x00	; 0
    5e96:	30 e0       	ldi	r19, 0x00	; 0
    5e98:	4a e7       	ldi	r20, 0x7A	; 122
    5e9a:	55 e4       	ldi	r21, 0x45	; 69
    5e9c:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5ea0:	dc 01       	movw	r26, r24
    5ea2:	cb 01       	movw	r24, r22
    5ea4:	8f 83       	std	Y+7, r24	; 0x07
    5ea6:	98 87       	std	Y+8, r25	; 0x08
    5ea8:	a9 87       	std	Y+9, r26	; 0x09
    5eaa:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    5eac:	6f 81       	ldd	r22, Y+7	; 0x07
    5eae:	78 85       	ldd	r23, Y+8	; 0x08
    5eb0:	89 85       	ldd	r24, Y+9	; 0x09
    5eb2:	9a 85       	ldd	r25, Y+10	; 0x0a
    5eb4:	20 e0       	ldi	r18, 0x00	; 0
    5eb6:	30 e0       	ldi	r19, 0x00	; 0
    5eb8:	40 e8       	ldi	r20, 0x80	; 128
    5eba:	5f e3       	ldi	r21, 0x3F	; 63
    5ebc:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    5ec0:	88 23       	and	r24, r24
    5ec2:	2c f4       	brge	.+10     	; 0x5ece <H_AT24C16A_Void_EEPROMWrite+0x88>
		__ticks = 1;
    5ec4:	81 e0       	ldi	r24, 0x01	; 1
    5ec6:	90 e0       	ldi	r25, 0x00	; 0
    5ec8:	9e 83       	std	Y+6, r25	; 0x06
    5eca:	8d 83       	std	Y+5, r24	; 0x05
    5ecc:	3f c0       	rjmp	.+126    	; 0x5f4c <H_AT24C16A_Void_EEPROMWrite+0x106>
	else if (__tmp > 65535)
    5ece:	6f 81       	ldd	r22, Y+7	; 0x07
    5ed0:	78 85       	ldd	r23, Y+8	; 0x08
    5ed2:	89 85       	ldd	r24, Y+9	; 0x09
    5ed4:	9a 85       	ldd	r25, Y+10	; 0x0a
    5ed6:	20 e0       	ldi	r18, 0x00	; 0
    5ed8:	3f ef       	ldi	r19, 0xFF	; 255
    5eda:	4f e7       	ldi	r20, 0x7F	; 127
    5edc:	57 e4       	ldi	r21, 0x47	; 71
    5ede:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    5ee2:	18 16       	cp	r1, r24
    5ee4:	4c f5       	brge	.+82     	; 0x5f38 <H_AT24C16A_Void_EEPROMWrite+0xf2>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    5ee6:	6b 85       	ldd	r22, Y+11	; 0x0b
    5ee8:	7c 85       	ldd	r23, Y+12	; 0x0c
    5eea:	8d 85       	ldd	r24, Y+13	; 0x0d
    5eec:	9e 85       	ldd	r25, Y+14	; 0x0e
    5eee:	20 e0       	ldi	r18, 0x00	; 0
    5ef0:	30 e0       	ldi	r19, 0x00	; 0
    5ef2:	40 e2       	ldi	r20, 0x20	; 32
    5ef4:	51 e4       	ldi	r21, 0x41	; 65
    5ef6:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5efa:	dc 01       	movw	r26, r24
    5efc:	cb 01       	movw	r24, r22
    5efe:	bc 01       	movw	r22, r24
    5f00:	cd 01       	movw	r24, r26
    5f02:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5f06:	dc 01       	movw	r26, r24
    5f08:	cb 01       	movw	r24, r22
    5f0a:	9e 83       	std	Y+6, r25	; 0x06
    5f0c:	8d 83       	std	Y+5, r24	; 0x05
    5f0e:	0f c0       	rjmp	.+30     	; 0x5f2e <H_AT24C16A_Void_EEPROMWrite+0xe8>
    5f10:	80 e9       	ldi	r24, 0x90	; 144
    5f12:	91 e0       	ldi	r25, 0x01	; 1
    5f14:	9c 83       	std	Y+4, r25	; 0x04
    5f16:	8b 83       	std	Y+3, r24	; 0x03
    5f18:	8b 81       	ldd	r24, Y+3	; 0x03
    5f1a:	9c 81       	ldd	r25, Y+4	; 0x04
    5f1c:	01 97       	sbiw	r24, 0x01	; 1
    5f1e:	f1 f7       	brne	.-4      	; 0x5f1c <H_AT24C16A_Void_EEPROMWrite+0xd6>
    5f20:	9c 83       	std	Y+4, r25	; 0x04
    5f22:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    5f24:	8d 81       	ldd	r24, Y+5	; 0x05
    5f26:	9e 81       	ldd	r25, Y+6	; 0x06
    5f28:	01 97       	sbiw	r24, 0x01	; 1
    5f2a:	9e 83       	std	Y+6, r25	; 0x06
    5f2c:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    5f2e:	8d 81       	ldd	r24, Y+5	; 0x05
    5f30:	9e 81       	ldd	r25, Y+6	; 0x06
    5f32:	00 97       	sbiw	r24, 0x00	; 0
    5f34:	69 f7       	brne	.-38     	; 0x5f10 <H_AT24C16A_Void_EEPROMWrite+0xca>
    5f36:	14 c0       	rjmp	.+40     	; 0x5f60 <H_AT24C16A_Void_EEPROMWrite+0x11a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    5f38:	6f 81       	ldd	r22, Y+7	; 0x07
    5f3a:	78 85       	ldd	r23, Y+8	; 0x08
    5f3c:	89 85       	ldd	r24, Y+9	; 0x09
    5f3e:	9a 85       	ldd	r25, Y+10	; 0x0a
    5f40:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    5f44:	dc 01       	movw	r26, r24
    5f46:	cb 01       	movw	r24, r22
    5f48:	9e 83       	std	Y+6, r25	; 0x06
    5f4a:	8d 83       	std	Y+5, r24	; 0x05
    5f4c:	8d 81       	ldd	r24, Y+5	; 0x05
    5f4e:	9e 81       	ldd	r25, Y+6	; 0x06
    5f50:	9a 83       	std	Y+2, r25	; 0x02
    5f52:	89 83       	std	Y+1, r24	; 0x01
    5f54:	89 81       	ldd	r24, Y+1	; 0x01
    5f56:	9a 81       	ldd	r25, Y+2	; 0x02
    5f58:	01 97       	sbiw	r24, 0x01	; 1
    5f5a:	f1 f7       	brne	.-4      	; 0x5f58 <H_AT24C16A_Void_EEPROMWrite+0x112>
    5f5c:	9a 83       	std	Y+2, r25	; 0x02
    5f5e:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(500);
}
    5f60:	61 96       	adiw	r28, 0x11	; 17
    5f62:	0f b6       	in	r0, 0x3f	; 63
    5f64:	f8 94       	cli
    5f66:	de bf       	out	0x3e, r29	; 62
    5f68:	0f be       	out	0x3f, r0	; 63
    5f6a:	cd bf       	out	0x3d, r28	; 61
    5f6c:	cf 91       	pop	r28
    5f6e:	df 91       	pop	r29
    5f70:	08 95       	ret

00005f72 <H_AT24C16A_Void_EEPROMRead>:
u8   H_AT24C16A_Void_EEPROMRead(u8 Copy_U8_Page,u8 Copy_U8_Byte)
{
    5f72:	df 93       	push	r29
    5f74:	cf 93       	push	r28
    5f76:	cd b7       	in	r28, 0x3d	; 61
    5f78:	de b7       	in	r29, 0x3e	; 62
    5f7a:	61 97       	sbiw	r28, 0x11	; 17
    5f7c:	0f b6       	in	r0, 0x3f	; 63
    5f7e:	f8 94       	cli
    5f80:	de bf       	out	0x3e, r29	; 62
    5f82:	0f be       	out	0x3f, r0	; 63
    5f84:	cd bf       	out	0x3d, r28	; 61
    5f86:	88 8b       	std	Y+16, r24	; 0x10
    5f88:	69 8b       	std	Y+17, r22	; 0x11
	u8 Local_U8_Reading = 0;
    5f8a:	1f 86       	std	Y+15, r1	; 0x0f
	M_I2C_Void_I2CStartCondition();
    5f8c:	0e 94 68 2a 	call	0x54d0	; 0x54d0 <M_I2C_Void_I2CStartCondition>

	M_I2C_Void_I2CSendSlaveAddressWrite(0x50 | Copy_U8_Page);
    5f90:	88 89       	ldd	r24, Y+16	; 0x10
    5f92:	80 65       	ori	r24, 0x50	; 80
    5f94:	0e 94 c5 2a 	call	0x558a	; 0x558a <M_I2C_Void_I2CSendSlaveAddressWrite>

	M_I2C_Void_I2CSendByte(Copy_U8_Byte);
    5f98:	89 89       	ldd	r24, Y+17	; 0x11
    5f9a:	0e 94 ff 2a 	call	0x55fe	; 0x55fe <M_I2C_Void_I2CSendByte>
	M_I2C_Void_I2CRepeatedStart();
    5f9e:	0e 94 a1 2a 	call	0x5542	; 0x5542 <M_I2C_Void_I2CRepeatedStart>
	M_I2C_Void_I2CSendSlaveAddressRead(0x50 | Copy_U8_Page);
    5fa2:	88 89       	ldd	r24, Y+16	; 0x10
    5fa4:	80 65       	ori	r24, 0x50	; 80
    5fa6:	0e 94 e0 2a 	call	0x55c0	; 0x55c0 <M_I2C_Void_I2CSendSlaveAddressRead>
	Local_U8_Reading = M_I2C_Void_I2CReadByte();
    5faa:	0e 94 2a 2b 	call	0x5654	; 0x5654 <M_I2C_Void_I2CReadByte>
    5fae:	8f 87       	std	Y+15, r24	; 0x0f
	M_I2C_Void_I2CStopCondition();
    5fb0:	0e 94 8c 2a 	call	0x5518	; 0x5518 <M_I2C_Void_I2CStopCondition>
    5fb4:	80 e0       	ldi	r24, 0x00	; 0
    5fb6:	90 e0       	ldi	r25, 0x00	; 0
    5fb8:	aa ef       	ldi	r26, 0xFA	; 250
    5fba:	b3 e4       	ldi	r27, 0x43	; 67
    5fbc:	8b 87       	std	Y+11, r24	; 0x0b
    5fbe:	9c 87       	std	Y+12, r25	; 0x0c
    5fc0:	ad 87       	std	Y+13, r26	; 0x0d
    5fc2:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    5fc4:	6b 85       	ldd	r22, Y+11	; 0x0b
    5fc6:	7c 85       	ldd	r23, Y+12	; 0x0c
    5fc8:	8d 85       	ldd	r24, Y+13	; 0x0d
    5fca:	9e 85       	ldd	r25, Y+14	; 0x0e
    5fcc:	20 e0       	ldi	r18, 0x00	; 0
    5fce:	30 e0       	ldi	r19, 0x00	; 0
    5fd0:	4a e7       	ldi	r20, 0x7A	; 122
    5fd2:	55 e4       	ldi	r21, 0x45	; 69
    5fd4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    5fd8:	dc 01       	movw	r26, r24
    5fda:	cb 01       	movw	r24, r22
    5fdc:	8f 83       	std	Y+7, r24	; 0x07
    5fde:	98 87       	std	Y+8, r25	; 0x08
    5fe0:	a9 87       	std	Y+9, r26	; 0x09
    5fe2:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    5fe4:	6f 81       	ldd	r22, Y+7	; 0x07
    5fe6:	78 85       	ldd	r23, Y+8	; 0x08
    5fe8:	89 85       	ldd	r24, Y+9	; 0x09
    5fea:	9a 85       	ldd	r25, Y+10	; 0x0a
    5fec:	20 e0       	ldi	r18, 0x00	; 0
    5fee:	30 e0       	ldi	r19, 0x00	; 0
    5ff0:	40 e8       	ldi	r20, 0x80	; 128
    5ff2:	5f e3       	ldi	r21, 0x3F	; 63
    5ff4:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    5ff8:	88 23       	and	r24, r24
    5ffa:	2c f4       	brge	.+10     	; 0x6006 <H_AT24C16A_Void_EEPROMRead+0x94>
		__ticks = 1;
    5ffc:	81 e0       	ldi	r24, 0x01	; 1
    5ffe:	90 e0       	ldi	r25, 0x00	; 0
    6000:	9e 83       	std	Y+6, r25	; 0x06
    6002:	8d 83       	std	Y+5, r24	; 0x05
    6004:	3f c0       	rjmp	.+126    	; 0x6084 <H_AT24C16A_Void_EEPROMRead+0x112>
	else if (__tmp > 65535)
    6006:	6f 81       	ldd	r22, Y+7	; 0x07
    6008:	78 85       	ldd	r23, Y+8	; 0x08
    600a:	89 85       	ldd	r24, Y+9	; 0x09
    600c:	9a 85       	ldd	r25, Y+10	; 0x0a
    600e:	20 e0       	ldi	r18, 0x00	; 0
    6010:	3f ef       	ldi	r19, 0xFF	; 255
    6012:	4f e7       	ldi	r20, 0x7F	; 127
    6014:	57 e4       	ldi	r21, 0x47	; 71
    6016:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    601a:	18 16       	cp	r1, r24
    601c:	4c f5       	brge	.+82     	; 0x6070 <H_AT24C16A_Void_EEPROMRead+0xfe>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    601e:	6b 85       	ldd	r22, Y+11	; 0x0b
    6020:	7c 85       	ldd	r23, Y+12	; 0x0c
    6022:	8d 85       	ldd	r24, Y+13	; 0x0d
    6024:	9e 85       	ldd	r25, Y+14	; 0x0e
    6026:	20 e0       	ldi	r18, 0x00	; 0
    6028:	30 e0       	ldi	r19, 0x00	; 0
    602a:	40 e2       	ldi	r20, 0x20	; 32
    602c:	51 e4       	ldi	r21, 0x41	; 65
    602e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    6032:	dc 01       	movw	r26, r24
    6034:	cb 01       	movw	r24, r22
    6036:	bc 01       	movw	r22, r24
    6038:	cd 01       	movw	r24, r26
    603a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    603e:	dc 01       	movw	r26, r24
    6040:	cb 01       	movw	r24, r22
    6042:	9e 83       	std	Y+6, r25	; 0x06
    6044:	8d 83       	std	Y+5, r24	; 0x05
    6046:	0f c0       	rjmp	.+30     	; 0x6066 <H_AT24C16A_Void_EEPROMRead+0xf4>
    6048:	80 e9       	ldi	r24, 0x90	; 144
    604a:	91 e0       	ldi	r25, 0x01	; 1
    604c:	9c 83       	std	Y+4, r25	; 0x04
    604e:	8b 83       	std	Y+3, r24	; 0x03
    6050:	8b 81       	ldd	r24, Y+3	; 0x03
    6052:	9c 81       	ldd	r25, Y+4	; 0x04
    6054:	01 97       	sbiw	r24, 0x01	; 1
    6056:	f1 f7       	brne	.-4      	; 0x6054 <H_AT24C16A_Void_EEPROMRead+0xe2>
    6058:	9c 83       	std	Y+4, r25	; 0x04
    605a:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    605c:	8d 81       	ldd	r24, Y+5	; 0x05
    605e:	9e 81       	ldd	r25, Y+6	; 0x06
    6060:	01 97       	sbiw	r24, 0x01	; 1
    6062:	9e 83       	std	Y+6, r25	; 0x06
    6064:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    6066:	8d 81       	ldd	r24, Y+5	; 0x05
    6068:	9e 81       	ldd	r25, Y+6	; 0x06
    606a:	00 97       	sbiw	r24, 0x00	; 0
    606c:	69 f7       	brne	.-38     	; 0x6048 <H_AT24C16A_Void_EEPROMRead+0xd6>
    606e:	14 c0       	rjmp	.+40     	; 0x6098 <H_AT24C16A_Void_EEPROMRead+0x126>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    6070:	6f 81       	ldd	r22, Y+7	; 0x07
    6072:	78 85       	ldd	r23, Y+8	; 0x08
    6074:	89 85       	ldd	r24, Y+9	; 0x09
    6076:	9a 85       	ldd	r25, Y+10	; 0x0a
    6078:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    607c:	dc 01       	movw	r26, r24
    607e:	cb 01       	movw	r24, r22
    6080:	9e 83       	std	Y+6, r25	; 0x06
    6082:	8d 83       	std	Y+5, r24	; 0x05
    6084:	8d 81       	ldd	r24, Y+5	; 0x05
    6086:	9e 81       	ldd	r25, Y+6	; 0x06
    6088:	9a 83       	std	Y+2, r25	; 0x02
    608a:	89 83       	std	Y+1, r24	; 0x01
    608c:	89 81       	ldd	r24, Y+1	; 0x01
    608e:	9a 81       	ldd	r25, Y+2	; 0x02
    6090:	01 97       	sbiw	r24, 0x01	; 1
    6092:	f1 f7       	brne	.-4      	; 0x6090 <H_AT24C16A_Void_EEPROMRead+0x11e>
    6094:	9a 83       	std	Y+2, r25	; 0x02
    6096:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(500);
	return Local_U8_Reading;
    6098:	8f 85       	ldd	r24, Y+15	; 0x0f
}
    609a:	61 96       	adiw	r28, 0x11	; 17
    609c:	0f b6       	in	r0, 0x3f	; 63
    609e:	f8 94       	cli
    60a0:	de bf       	out	0x3e, r29	; 62
    60a2:	0f be       	out	0x3f, r0	; 63
    60a4:	cd bf       	out	0x3d, r28	; 61
    60a6:	cf 91       	pop	r28
    60a8:	df 91       	pop	r29
    60aa:	08 95       	ret

000060ac <Dio_vidconfigChannel>:
 */
#include "Dio.h"
#include "Bit_Math.h"

void Dio_vidconfigChannel(dio_port_t port,dio_pin_t pin,dio_dir_t dir)
{
    60ac:	df 93       	push	r29
    60ae:	cf 93       	push	r28
    60b0:	00 d0       	rcall	.+0      	; 0x60b2 <Dio_vidconfigChannel+0x6>
    60b2:	00 d0       	rcall	.+0      	; 0x60b4 <Dio_vidconfigChannel+0x8>
    60b4:	0f 92       	push	r0
    60b6:	cd b7       	in	r28, 0x3d	; 61
    60b8:	de b7       	in	r29, 0x3e	; 62
    60ba:	89 83       	std	Y+1, r24	; 0x01
    60bc:	6a 83       	std	Y+2, r22	; 0x02
    60be:	4b 83       	std	Y+3, r20	; 0x03
	switch (port)
    60c0:	89 81       	ldd	r24, Y+1	; 0x01
    60c2:	28 2f       	mov	r18, r24
    60c4:	30 e0       	ldi	r19, 0x00	; 0
    60c6:	3d 83       	std	Y+5, r19	; 0x05
    60c8:	2c 83       	std	Y+4, r18	; 0x04
    60ca:	8c 81       	ldd	r24, Y+4	; 0x04
    60cc:	9d 81       	ldd	r25, Y+5	; 0x05
    60ce:	81 30       	cpi	r24, 0x01	; 1
    60d0:	91 05       	cpc	r25, r1
    60d2:	09 f4       	brne	.+2      	; 0x60d6 <Dio_vidconfigChannel+0x2a>
    60d4:	43 c0       	rjmp	.+134    	; 0x615c <Dio_vidconfigChannel+0xb0>
    60d6:	2c 81       	ldd	r18, Y+4	; 0x04
    60d8:	3d 81       	ldd	r19, Y+5	; 0x05
    60da:	22 30       	cpi	r18, 0x02	; 2
    60dc:	31 05       	cpc	r19, r1
    60de:	2c f4       	brge	.+10     	; 0x60ea <Dio_vidconfigChannel+0x3e>
    60e0:	8c 81       	ldd	r24, Y+4	; 0x04
    60e2:	9d 81       	ldd	r25, Y+5	; 0x05
    60e4:	00 97       	sbiw	r24, 0x00	; 0
    60e6:	71 f0       	breq	.+28     	; 0x6104 <Dio_vidconfigChannel+0x58>
    60e8:	bc c0       	rjmp	.+376    	; 0x6262 <Dio_vidconfigChannel+0x1b6>
    60ea:	2c 81       	ldd	r18, Y+4	; 0x04
    60ec:	3d 81       	ldd	r19, Y+5	; 0x05
    60ee:	22 30       	cpi	r18, 0x02	; 2
    60f0:	31 05       	cpc	r19, r1
    60f2:	09 f4       	brne	.+2      	; 0x60f6 <Dio_vidconfigChannel+0x4a>
    60f4:	5f c0       	rjmp	.+190    	; 0x61b4 <Dio_vidconfigChannel+0x108>
    60f6:	8c 81       	ldd	r24, Y+4	; 0x04
    60f8:	9d 81       	ldd	r25, Y+5	; 0x05
    60fa:	83 30       	cpi	r24, 0x03	; 3
    60fc:	91 05       	cpc	r25, r1
    60fe:	09 f4       	brne	.+2      	; 0x6102 <Dio_vidconfigChannel+0x56>
    6100:	85 c0       	rjmp	.+266    	; 0x620c <Dio_vidconfigChannel+0x160>
    6102:	af c0       	rjmp	.+350    	; 0x6262 <Dio_vidconfigChannel+0x1b6>
	{
	case DIO_PORTA:
	{
		if(dir == DIO_INPUT)
    6104:	8b 81       	ldd	r24, Y+3	; 0x03
    6106:	88 23       	and	r24, r24
    6108:	a9 f4       	brne	.+42     	; 0x6134 <Dio_vidconfigChannel+0x88>
		{
			CLEAR_BIT(DIO_DDRA_REG,pin);
    610a:	aa e3       	ldi	r26, 0x3A	; 58
    610c:	b0 e0       	ldi	r27, 0x00	; 0
    610e:	ea e3       	ldi	r30, 0x3A	; 58
    6110:	f0 e0       	ldi	r31, 0x00	; 0
    6112:	80 81       	ld	r24, Z
    6114:	48 2f       	mov	r20, r24
    6116:	8a 81       	ldd	r24, Y+2	; 0x02
    6118:	28 2f       	mov	r18, r24
    611a:	30 e0       	ldi	r19, 0x00	; 0
    611c:	81 e0       	ldi	r24, 0x01	; 1
    611e:	90 e0       	ldi	r25, 0x00	; 0
    6120:	02 2e       	mov	r0, r18
    6122:	02 c0       	rjmp	.+4      	; 0x6128 <Dio_vidconfigChannel+0x7c>
    6124:	88 0f       	add	r24, r24
    6126:	99 1f       	adc	r25, r25
    6128:	0a 94       	dec	r0
    612a:	e2 f7       	brpl	.-8      	; 0x6124 <Dio_vidconfigChannel+0x78>
    612c:	80 95       	com	r24
    612e:	84 23       	and	r24, r20
    6130:	8c 93       	st	X, r24
    6132:	97 c0       	rjmp	.+302    	; 0x6262 <Dio_vidconfigChannel+0x1b6>
		}
		else
		{
			SET_BIT(DIO_DDRA_REG,pin);
    6134:	aa e3       	ldi	r26, 0x3A	; 58
    6136:	b0 e0       	ldi	r27, 0x00	; 0
    6138:	ea e3       	ldi	r30, 0x3A	; 58
    613a:	f0 e0       	ldi	r31, 0x00	; 0
    613c:	80 81       	ld	r24, Z
    613e:	48 2f       	mov	r20, r24
    6140:	8a 81       	ldd	r24, Y+2	; 0x02
    6142:	28 2f       	mov	r18, r24
    6144:	30 e0       	ldi	r19, 0x00	; 0
    6146:	81 e0       	ldi	r24, 0x01	; 1
    6148:	90 e0       	ldi	r25, 0x00	; 0
    614a:	02 2e       	mov	r0, r18
    614c:	02 c0       	rjmp	.+4      	; 0x6152 <Dio_vidconfigChannel+0xa6>
    614e:	88 0f       	add	r24, r24
    6150:	99 1f       	adc	r25, r25
    6152:	0a 94       	dec	r0
    6154:	e2 f7       	brpl	.-8      	; 0x614e <Dio_vidconfigChannel+0xa2>
    6156:	84 2b       	or	r24, r20
    6158:	8c 93       	st	X, r24
    615a:	83 c0       	rjmp	.+262    	; 0x6262 <Dio_vidconfigChannel+0x1b6>
		}
		break;
	}
	case DIO_PORTB:
	{
		if(dir == DIO_INPUT)
    615c:	8b 81       	ldd	r24, Y+3	; 0x03
    615e:	88 23       	and	r24, r24
    6160:	a9 f4       	brne	.+42     	; 0x618c <Dio_vidconfigChannel+0xe0>
		{
			CLEAR_BIT(DIO_DDRB_REG,pin);
    6162:	a7 e3       	ldi	r26, 0x37	; 55
    6164:	b0 e0       	ldi	r27, 0x00	; 0
    6166:	e7 e3       	ldi	r30, 0x37	; 55
    6168:	f0 e0       	ldi	r31, 0x00	; 0
    616a:	80 81       	ld	r24, Z
    616c:	48 2f       	mov	r20, r24
    616e:	8a 81       	ldd	r24, Y+2	; 0x02
    6170:	28 2f       	mov	r18, r24
    6172:	30 e0       	ldi	r19, 0x00	; 0
    6174:	81 e0       	ldi	r24, 0x01	; 1
    6176:	90 e0       	ldi	r25, 0x00	; 0
    6178:	02 2e       	mov	r0, r18
    617a:	02 c0       	rjmp	.+4      	; 0x6180 <Dio_vidconfigChannel+0xd4>
    617c:	88 0f       	add	r24, r24
    617e:	99 1f       	adc	r25, r25
    6180:	0a 94       	dec	r0
    6182:	e2 f7       	brpl	.-8      	; 0x617c <Dio_vidconfigChannel+0xd0>
    6184:	80 95       	com	r24
    6186:	84 23       	and	r24, r20
    6188:	8c 93       	st	X, r24
    618a:	6b c0       	rjmp	.+214    	; 0x6262 <Dio_vidconfigChannel+0x1b6>
		}
		else
		{
			SET_BIT(DIO_DDRB_REG,pin);
    618c:	a7 e3       	ldi	r26, 0x37	; 55
    618e:	b0 e0       	ldi	r27, 0x00	; 0
    6190:	e7 e3       	ldi	r30, 0x37	; 55
    6192:	f0 e0       	ldi	r31, 0x00	; 0
    6194:	80 81       	ld	r24, Z
    6196:	48 2f       	mov	r20, r24
    6198:	8a 81       	ldd	r24, Y+2	; 0x02
    619a:	28 2f       	mov	r18, r24
    619c:	30 e0       	ldi	r19, 0x00	; 0
    619e:	81 e0       	ldi	r24, 0x01	; 1
    61a0:	90 e0       	ldi	r25, 0x00	; 0
    61a2:	02 2e       	mov	r0, r18
    61a4:	02 c0       	rjmp	.+4      	; 0x61aa <Dio_vidconfigChannel+0xfe>
    61a6:	88 0f       	add	r24, r24
    61a8:	99 1f       	adc	r25, r25
    61aa:	0a 94       	dec	r0
    61ac:	e2 f7       	brpl	.-8      	; 0x61a6 <Dio_vidconfigChannel+0xfa>
    61ae:	84 2b       	or	r24, r20
    61b0:	8c 93       	st	X, r24
    61b2:	57 c0       	rjmp	.+174    	; 0x6262 <Dio_vidconfigChannel+0x1b6>
		}
		break;
	}
	case DIO_PORTC:
	{
		if(dir == DIO_INPUT)
    61b4:	8b 81       	ldd	r24, Y+3	; 0x03
    61b6:	88 23       	and	r24, r24
    61b8:	a9 f4       	brne	.+42     	; 0x61e4 <Dio_vidconfigChannel+0x138>
		{
			CLEAR_BIT(DIO_DDRC_REG,pin);
    61ba:	a4 e3       	ldi	r26, 0x34	; 52
    61bc:	b0 e0       	ldi	r27, 0x00	; 0
    61be:	e4 e3       	ldi	r30, 0x34	; 52
    61c0:	f0 e0       	ldi	r31, 0x00	; 0
    61c2:	80 81       	ld	r24, Z
    61c4:	48 2f       	mov	r20, r24
    61c6:	8a 81       	ldd	r24, Y+2	; 0x02
    61c8:	28 2f       	mov	r18, r24
    61ca:	30 e0       	ldi	r19, 0x00	; 0
    61cc:	81 e0       	ldi	r24, 0x01	; 1
    61ce:	90 e0       	ldi	r25, 0x00	; 0
    61d0:	02 2e       	mov	r0, r18
    61d2:	02 c0       	rjmp	.+4      	; 0x61d8 <Dio_vidconfigChannel+0x12c>
    61d4:	88 0f       	add	r24, r24
    61d6:	99 1f       	adc	r25, r25
    61d8:	0a 94       	dec	r0
    61da:	e2 f7       	brpl	.-8      	; 0x61d4 <Dio_vidconfigChannel+0x128>
    61dc:	80 95       	com	r24
    61de:	84 23       	and	r24, r20
    61e0:	8c 93       	st	X, r24
    61e2:	3f c0       	rjmp	.+126    	; 0x6262 <Dio_vidconfigChannel+0x1b6>
		}
		else
		{
			SET_BIT(DIO_DDRC_REG,pin);
    61e4:	a4 e3       	ldi	r26, 0x34	; 52
    61e6:	b0 e0       	ldi	r27, 0x00	; 0
    61e8:	e4 e3       	ldi	r30, 0x34	; 52
    61ea:	f0 e0       	ldi	r31, 0x00	; 0
    61ec:	80 81       	ld	r24, Z
    61ee:	48 2f       	mov	r20, r24
    61f0:	8a 81       	ldd	r24, Y+2	; 0x02
    61f2:	28 2f       	mov	r18, r24
    61f4:	30 e0       	ldi	r19, 0x00	; 0
    61f6:	81 e0       	ldi	r24, 0x01	; 1
    61f8:	90 e0       	ldi	r25, 0x00	; 0
    61fa:	02 2e       	mov	r0, r18
    61fc:	02 c0       	rjmp	.+4      	; 0x6202 <Dio_vidconfigChannel+0x156>
    61fe:	88 0f       	add	r24, r24
    6200:	99 1f       	adc	r25, r25
    6202:	0a 94       	dec	r0
    6204:	e2 f7       	brpl	.-8      	; 0x61fe <Dio_vidconfigChannel+0x152>
    6206:	84 2b       	or	r24, r20
    6208:	8c 93       	st	X, r24
    620a:	2b c0       	rjmp	.+86     	; 0x6262 <Dio_vidconfigChannel+0x1b6>
		}
		break;
	}
	case DIO_PORTD:
	{
		if(dir == DIO_INPUT)
    620c:	8b 81       	ldd	r24, Y+3	; 0x03
    620e:	88 23       	and	r24, r24
    6210:	a9 f4       	brne	.+42     	; 0x623c <Dio_vidconfigChannel+0x190>
		{
			CLEAR_BIT(DIO_DDRD_REG,pin);
    6212:	a1 e3       	ldi	r26, 0x31	; 49
    6214:	b0 e0       	ldi	r27, 0x00	; 0
    6216:	e1 e3       	ldi	r30, 0x31	; 49
    6218:	f0 e0       	ldi	r31, 0x00	; 0
    621a:	80 81       	ld	r24, Z
    621c:	48 2f       	mov	r20, r24
    621e:	8a 81       	ldd	r24, Y+2	; 0x02
    6220:	28 2f       	mov	r18, r24
    6222:	30 e0       	ldi	r19, 0x00	; 0
    6224:	81 e0       	ldi	r24, 0x01	; 1
    6226:	90 e0       	ldi	r25, 0x00	; 0
    6228:	02 2e       	mov	r0, r18
    622a:	02 c0       	rjmp	.+4      	; 0x6230 <Dio_vidconfigChannel+0x184>
    622c:	88 0f       	add	r24, r24
    622e:	99 1f       	adc	r25, r25
    6230:	0a 94       	dec	r0
    6232:	e2 f7       	brpl	.-8      	; 0x622c <Dio_vidconfigChannel+0x180>
    6234:	80 95       	com	r24
    6236:	84 23       	and	r24, r20
    6238:	8c 93       	st	X, r24
    623a:	13 c0       	rjmp	.+38     	; 0x6262 <Dio_vidconfigChannel+0x1b6>
		}
		else
		{
			SET_BIT(DIO_DDRD_REG,pin);
    623c:	a1 e3       	ldi	r26, 0x31	; 49
    623e:	b0 e0       	ldi	r27, 0x00	; 0
    6240:	e1 e3       	ldi	r30, 0x31	; 49
    6242:	f0 e0       	ldi	r31, 0x00	; 0
    6244:	80 81       	ld	r24, Z
    6246:	48 2f       	mov	r20, r24
    6248:	8a 81       	ldd	r24, Y+2	; 0x02
    624a:	28 2f       	mov	r18, r24
    624c:	30 e0       	ldi	r19, 0x00	; 0
    624e:	81 e0       	ldi	r24, 0x01	; 1
    6250:	90 e0       	ldi	r25, 0x00	; 0
    6252:	02 2e       	mov	r0, r18
    6254:	02 c0       	rjmp	.+4      	; 0x625a <Dio_vidconfigChannel+0x1ae>
    6256:	88 0f       	add	r24, r24
    6258:	99 1f       	adc	r25, r25
    625a:	0a 94       	dec	r0
    625c:	e2 f7       	brpl	.-8      	; 0x6256 <Dio_vidconfigChannel+0x1aa>
    625e:	84 2b       	or	r24, r20
    6260:	8c 93       	st	X, r24
		}
		break;
	}
  }
}
    6262:	0f 90       	pop	r0
    6264:	0f 90       	pop	r0
    6266:	0f 90       	pop	r0
    6268:	0f 90       	pop	r0
    626a:	0f 90       	pop	r0
    626c:	cf 91       	pop	r28
    626e:	df 91       	pop	r29
    6270:	08 95       	ret

00006272 <Dio_vidwriteChannel>:

void Dio_vidwriteChannel(dio_port_t port,dio_pin_t pin,dio_level_t level)
{
    6272:	df 93       	push	r29
    6274:	cf 93       	push	r28
    6276:	00 d0       	rcall	.+0      	; 0x6278 <Dio_vidwriteChannel+0x6>
    6278:	00 d0       	rcall	.+0      	; 0x627a <Dio_vidwriteChannel+0x8>
    627a:	0f 92       	push	r0
    627c:	cd b7       	in	r28, 0x3d	; 61
    627e:	de b7       	in	r29, 0x3e	; 62
    6280:	89 83       	std	Y+1, r24	; 0x01
    6282:	6a 83       	std	Y+2, r22	; 0x02
    6284:	4b 83       	std	Y+3, r20	; 0x03
	switch(port)
    6286:	89 81       	ldd	r24, Y+1	; 0x01
    6288:	28 2f       	mov	r18, r24
    628a:	30 e0       	ldi	r19, 0x00	; 0
    628c:	3d 83       	std	Y+5, r19	; 0x05
    628e:	2c 83       	std	Y+4, r18	; 0x04
    6290:	8c 81       	ldd	r24, Y+4	; 0x04
    6292:	9d 81       	ldd	r25, Y+5	; 0x05
    6294:	81 30       	cpi	r24, 0x01	; 1
    6296:	91 05       	cpc	r25, r1
    6298:	09 f4       	brne	.+2      	; 0x629c <Dio_vidwriteChannel+0x2a>
    629a:	43 c0       	rjmp	.+134    	; 0x6322 <Dio_vidwriteChannel+0xb0>
    629c:	2c 81       	ldd	r18, Y+4	; 0x04
    629e:	3d 81       	ldd	r19, Y+5	; 0x05
    62a0:	22 30       	cpi	r18, 0x02	; 2
    62a2:	31 05       	cpc	r19, r1
    62a4:	2c f4       	brge	.+10     	; 0x62b0 <Dio_vidwriteChannel+0x3e>
    62a6:	8c 81       	ldd	r24, Y+4	; 0x04
    62a8:	9d 81       	ldd	r25, Y+5	; 0x05
    62aa:	00 97       	sbiw	r24, 0x00	; 0
    62ac:	71 f0       	breq	.+28     	; 0x62ca <Dio_vidwriteChannel+0x58>
    62ae:	bc c0       	rjmp	.+376    	; 0x6428 <Dio_vidwriteChannel+0x1b6>
    62b0:	2c 81       	ldd	r18, Y+4	; 0x04
    62b2:	3d 81       	ldd	r19, Y+5	; 0x05
    62b4:	22 30       	cpi	r18, 0x02	; 2
    62b6:	31 05       	cpc	r19, r1
    62b8:	09 f4       	brne	.+2      	; 0x62bc <Dio_vidwriteChannel+0x4a>
    62ba:	5f c0       	rjmp	.+190    	; 0x637a <Dio_vidwriteChannel+0x108>
    62bc:	8c 81       	ldd	r24, Y+4	; 0x04
    62be:	9d 81       	ldd	r25, Y+5	; 0x05
    62c0:	83 30       	cpi	r24, 0x03	; 3
    62c2:	91 05       	cpc	r25, r1
    62c4:	09 f4       	brne	.+2      	; 0x62c8 <Dio_vidwriteChannel+0x56>
    62c6:	85 c0       	rjmp	.+266    	; 0x63d2 <Dio_vidwriteChannel+0x160>
    62c8:	af c0       	rjmp	.+350    	; 0x6428 <Dio_vidwriteChannel+0x1b6>
	{
	case DIO_PORTA:
	{
		if (level == DIO_HIGH)
    62ca:	8b 81       	ldd	r24, Y+3	; 0x03
    62cc:	81 30       	cpi	r24, 0x01	; 1
    62ce:	a1 f4       	brne	.+40     	; 0x62f8 <Dio_vidwriteChannel+0x86>
		{
			SET_BIT(DIO_PORTA_REG,pin);
    62d0:	ab e3       	ldi	r26, 0x3B	; 59
    62d2:	b0 e0       	ldi	r27, 0x00	; 0
    62d4:	eb e3       	ldi	r30, 0x3B	; 59
    62d6:	f0 e0       	ldi	r31, 0x00	; 0
    62d8:	80 81       	ld	r24, Z
    62da:	48 2f       	mov	r20, r24
    62dc:	8a 81       	ldd	r24, Y+2	; 0x02
    62de:	28 2f       	mov	r18, r24
    62e0:	30 e0       	ldi	r19, 0x00	; 0
    62e2:	81 e0       	ldi	r24, 0x01	; 1
    62e4:	90 e0       	ldi	r25, 0x00	; 0
    62e6:	02 2e       	mov	r0, r18
    62e8:	02 c0       	rjmp	.+4      	; 0x62ee <Dio_vidwriteChannel+0x7c>
    62ea:	88 0f       	add	r24, r24
    62ec:	99 1f       	adc	r25, r25
    62ee:	0a 94       	dec	r0
    62f0:	e2 f7       	brpl	.-8      	; 0x62ea <Dio_vidwriteChannel+0x78>
    62f2:	84 2b       	or	r24, r20
    62f4:	8c 93       	st	X, r24
    62f6:	98 c0       	rjmp	.+304    	; 0x6428 <Dio_vidwriteChannel+0x1b6>
		}
		else
		{
			CLEAR_BIT(DIO_PORTA_REG,pin);
    62f8:	ab e3       	ldi	r26, 0x3B	; 59
    62fa:	b0 e0       	ldi	r27, 0x00	; 0
    62fc:	eb e3       	ldi	r30, 0x3B	; 59
    62fe:	f0 e0       	ldi	r31, 0x00	; 0
    6300:	80 81       	ld	r24, Z
    6302:	48 2f       	mov	r20, r24
    6304:	8a 81       	ldd	r24, Y+2	; 0x02
    6306:	28 2f       	mov	r18, r24
    6308:	30 e0       	ldi	r19, 0x00	; 0
    630a:	81 e0       	ldi	r24, 0x01	; 1
    630c:	90 e0       	ldi	r25, 0x00	; 0
    630e:	02 2e       	mov	r0, r18
    6310:	02 c0       	rjmp	.+4      	; 0x6316 <Dio_vidwriteChannel+0xa4>
    6312:	88 0f       	add	r24, r24
    6314:	99 1f       	adc	r25, r25
    6316:	0a 94       	dec	r0
    6318:	e2 f7       	brpl	.-8      	; 0x6312 <Dio_vidwriteChannel+0xa0>
    631a:	80 95       	com	r24
    631c:	84 23       	and	r24, r20
    631e:	8c 93       	st	X, r24
    6320:	83 c0       	rjmp	.+262    	; 0x6428 <Dio_vidwriteChannel+0x1b6>
		}
		break;
	}
	case DIO_PORTB:
	{
		if (level == DIO_HIGH)
    6322:	8b 81       	ldd	r24, Y+3	; 0x03
    6324:	81 30       	cpi	r24, 0x01	; 1
    6326:	a1 f4       	brne	.+40     	; 0x6350 <Dio_vidwriteChannel+0xde>
		{
			SET_BIT(DIO_PORTB_REG,pin);
    6328:	a8 e3       	ldi	r26, 0x38	; 56
    632a:	b0 e0       	ldi	r27, 0x00	; 0
    632c:	e8 e3       	ldi	r30, 0x38	; 56
    632e:	f0 e0       	ldi	r31, 0x00	; 0
    6330:	80 81       	ld	r24, Z
    6332:	48 2f       	mov	r20, r24
    6334:	8a 81       	ldd	r24, Y+2	; 0x02
    6336:	28 2f       	mov	r18, r24
    6338:	30 e0       	ldi	r19, 0x00	; 0
    633a:	81 e0       	ldi	r24, 0x01	; 1
    633c:	90 e0       	ldi	r25, 0x00	; 0
    633e:	02 2e       	mov	r0, r18
    6340:	02 c0       	rjmp	.+4      	; 0x6346 <Dio_vidwriteChannel+0xd4>
    6342:	88 0f       	add	r24, r24
    6344:	99 1f       	adc	r25, r25
    6346:	0a 94       	dec	r0
    6348:	e2 f7       	brpl	.-8      	; 0x6342 <Dio_vidwriteChannel+0xd0>
    634a:	84 2b       	or	r24, r20
    634c:	8c 93       	st	X, r24
    634e:	6c c0       	rjmp	.+216    	; 0x6428 <Dio_vidwriteChannel+0x1b6>
		}
		else
		{
			CLEAR_BIT(DIO_PORTB_REG,pin);
    6350:	a8 e3       	ldi	r26, 0x38	; 56
    6352:	b0 e0       	ldi	r27, 0x00	; 0
    6354:	e8 e3       	ldi	r30, 0x38	; 56
    6356:	f0 e0       	ldi	r31, 0x00	; 0
    6358:	80 81       	ld	r24, Z
    635a:	48 2f       	mov	r20, r24
    635c:	8a 81       	ldd	r24, Y+2	; 0x02
    635e:	28 2f       	mov	r18, r24
    6360:	30 e0       	ldi	r19, 0x00	; 0
    6362:	81 e0       	ldi	r24, 0x01	; 1
    6364:	90 e0       	ldi	r25, 0x00	; 0
    6366:	02 2e       	mov	r0, r18
    6368:	02 c0       	rjmp	.+4      	; 0x636e <Dio_vidwriteChannel+0xfc>
    636a:	88 0f       	add	r24, r24
    636c:	99 1f       	adc	r25, r25
    636e:	0a 94       	dec	r0
    6370:	e2 f7       	brpl	.-8      	; 0x636a <Dio_vidwriteChannel+0xf8>
    6372:	80 95       	com	r24
    6374:	84 23       	and	r24, r20
    6376:	8c 93       	st	X, r24
    6378:	57 c0       	rjmp	.+174    	; 0x6428 <Dio_vidwriteChannel+0x1b6>
		}
		break;
	}
	case DIO_PORTC:
	{
		if (level == DIO_HIGH)
    637a:	8b 81       	ldd	r24, Y+3	; 0x03
    637c:	81 30       	cpi	r24, 0x01	; 1
    637e:	a1 f4       	brne	.+40     	; 0x63a8 <Dio_vidwriteChannel+0x136>
		{
			SET_BIT(DIO_PORTC_REG,pin);
    6380:	a5 e3       	ldi	r26, 0x35	; 53
    6382:	b0 e0       	ldi	r27, 0x00	; 0
    6384:	e5 e3       	ldi	r30, 0x35	; 53
    6386:	f0 e0       	ldi	r31, 0x00	; 0
    6388:	80 81       	ld	r24, Z
    638a:	48 2f       	mov	r20, r24
    638c:	8a 81       	ldd	r24, Y+2	; 0x02
    638e:	28 2f       	mov	r18, r24
    6390:	30 e0       	ldi	r19, 0x00	; 0
    6392:	81 e0       	ldi	r24, 0x01	; 1
    6394:	90 e0       	ldi	r25, 0x00	; 0
    6396:	02 2e       	mov	r0, r18
    6398:	02 c0       	rjmp	.+4      	; 0x639e <Dio_vidwriteChannel+0x12c>
    639a:	88 0f       	add	r24, r24
    639c:	99 1f       	adc	r25, r25
    639e:	0a 94       	dec	r0
    63a0:	e2 f7       	brpl	.-8      	; 0x639a <Dio_vidwriteChannel+0x128>
    63a2:	84 2b       	or	r24, r20
    63a4:	8c 93       	st	X, r24
    63a6:	40 c0       	rjmp	.+128    	; 0x6428 <Dio_vidwriteChannel+0x1b6>
		}
		else
		{
			CLEAR_BIT(DIO_PORTC_REG,pin);
    63a8:	a5 e3       	ldi	r26, 0x35	; 53
    63aa:	b0 e0       	ldi	r27, 0x00	; 0
    63ac:	e5 e3       	ldi	r30, 0x35	; 53
    63ae:	f0 e0       	ldi	r31, 0x00	; 0
    63b0:	80 81       	ld	r24, Z
    63b2:	48 2f       	mov	r20, r24
    63b4:	8a 81       	ldd	r24, Y+2	; 0x02
    63b6:	28 2f       	mov	r18, r24
    63b8:	30 e0       	ldi	r19, 0x00	; 0
    63ba:	81 e0       	ldi	r24, 0x01	; 1
    63bc:	90 e0       	ldi	r25, 0x00	; 0
    63be:	02 2e       	mov	r0, r18
    63c0:	02 c0       	rjmp	.+4      	; 0x63c6 <Dio_vidwriteChannel+0x154>
    63c2:	88 0f       	add	r24, r24
    63c4:	99 1f       	adc	r25, r25
    63c6:	0a 94       	dec	r0
    63c8:	e2 f7       	brpl	.-8      	; 0x63c2 <Dio_vidwriteChannel+0x150>
    63ca:	80 95       	com	r24
    63cc:	84 23       	and	r24, r20
    63ce:	8c 93       	st	X, r24
    63d0:	2b c0       	rjmp	.+86     	; 0x6428 <Dio_vidwriteChannel+0x1b6>
		}
		break;
	}
	case DIO_PORTD:
	{
		if (level == DIO_HIGH)
    63d2:	8b 81       	ldd	r24, Y+3	; 0x03
    63d4:	81 30       	cpi	r24, 0x01	; 1
    63d6:	a1 f4       	brne	.+40     	; 0x6400 <Dio_vidwriteChannel+0x18e>
		{
			SET_BIT(DIO_PORTD_REG,pin);
    63d8:	a2 e3       	ldi	r26, 0x32	; 50
    63da:	b0 e0       	ldi	r27, 0x00	; 0
    63dc:	e2 e3       	ldi	r30, 0x32	; 50
    63de:	f0 e0       	ldi	r31, 0x00	; 0
    63e0:	80 81       	ld	r24, Z
    63e2:	48 2f       	mov	r20, r24
    63e4:	8a 81       	ldd	r24, Y+2	; 0x02
    63e6:	28 2f       	mov	r18, r24
    63e8:	30 e0       	ldi	r19, 0x00	; 0
    63ea:	81 e0       	ldi	r24, 0x01	; 1
    63ec:	90 e0       	ldi	r25, 0x00	; 0
    63ee:	02 2e       	mov	r0, r18
    63f0:	02 c0       	rjmp	.+4      	; 0x63f6 <Dio_vidwriteChannel+0x184>
    63f2:	88 0f       	add	r24, r24
    63f4:	99 1f       	adc	r25, r25
    63f6:	0a 94       	dec	r0
    63f8:	e2 f7       	brpl	.-8      	; 0x63f2 <Dio_vidwriteChannel+0x180>
    63fa:	84 2b       	or	r24, r20
    63fc:	8c 93       	st	X, r24
    63fe:	14 c0       	rjmp	.+40     	; 0x6428 <Dio_vidwriteChannel+0x1b6>
		}
		else
		{
			CLEAR_BIT(DIO_PORTD_REG,pin);
    6400:	a2 e3       	ldi	r26, 0x32	; 50
    6402:	b0 e0       	ldi	r27, 0x00	; 0
    6404:	e2 e3       	ldi	r30, 0x32	; 50
    6406:	f0 e0       	ldi	r31, 0x00	; 0
    6408:	80 81       	ld	r24, Z
    640a:	48 2f       	mov	r20, r24
    640c:	8a 81       	ldd	r24, Y+2	; 0x02
    640e:	28 2f       	mov	r18, r24
    6410:	30 e0       	ldi	r19, 0x00	; 0
    6412:	81 e0       	ldi	r24, 0x01	; 1
    6414:	90 e0       	ldi	r25, 0x00	; 0
    6416:	02 2e       	mov	r0, r18
    6418:	02 c0       	rjmp	.+4      	; 0x641e <Dio_vidwriteChannel+0x1ac>
    641a:	88 0f       	add	r24, r24
    641c:	99 1f       	adc	r25, r25
    641e:	0a 94       	dec	r0
    6420:	e2 f7       	brpl	.-8      	; 0x641a <Dio_vidwriteChannel+0x1a8>
    6422:	80 95       	com	r24
    6424:	84 23       	and	r24, r20
    6426:	8c 93       	st	X, r24
		}
		break;
	}
	}
}
    6428:	0f 90       	pop	r0
    642a:	0f 90       	pop	r0
    642c:	0f 90       	pop	r0
    642e:	0f 90       	pop	r0
    6430:	0f 90       	pop	r0
    6432:	cf 91       	pop	r28
    6434:	df 91       	pop	r29
    6436:	08 95       	ret

00006438 <Dio_udtreadChannel>:

dio_level_t Dio_udtreadChannel(dio_port_t port,dio_pin_t pin)
{
    6438:	df 93       	push	r29
    643a:	cf 93       	push	r28
    643c:	00 d0       	rcall	.+0      	; 0x643e <Dio_udtreadChannel+0x6>
    643e:	00 d0       	rcall	.+0      	; 0x6440 <Dio_udtreadChannel+0x8>
    6440:	0f 92       	push	r0
    6442:	cd b7       	in	r28, 0x3d	; 61
    6444:	de b7       	in	r29, 0x3e	; 62
    6446:	89 83       	std	Y+1, r24	; 0x01
    6448:	6a 83       	std	Y+2, r22	; 0x02
	switch(port)
    644a:	89 81       	ldd	r24, Y+1	; 0x01
    644c:	28 2f       	mov	r18, r24
    644e:	30 e0       	ldi	r19, 0x00	; 0
    6450:	3d 83       	std	Y+5, r19	; 0x05
    6452:	2c 83       	std	Y+4, r18	; 0x04
    6454:	4c 81       	ldd	r20, Y+4	; 0x04
    6456:	5d 81       	ldd	r21, Y+5	; 0x05
    6458:	41 30       	cpi	r20, 0x01	; 1
    645a:	51 05       	cpc	r21, r1
    645c:	79 f1       	breq	.+94     	; 0x64bc <Dio_udtreadChannel+0x84>
    645e:	8c 81       	ldd	r24, Y+4	; 0x04
    6460:	9d 81       	ldd	r25, Y+5	; 0x05
    6462:	82 30       	cpi	r24, 0x02	; 2
    6464:	91 05       	cpc	r25, r1
    6466:	34 f4       	brge	.+12     	; 0x6474 <Dio_udtreadChannel+0x3c>
    6468:	2c 81       	ldd	r18, Y+4	; 0x04
    646a:	3d 81       	ldd	r19, Y+5	; 0x05
    646c:	21 15       	cp	r18, r1
    646e:	31 05       	cpc	r19, r1
    6470:	69 f0       	breq	.+26     	; 0x648c <Dio_udtreadChannel+0x54>
    6472:	6c c0       	rjmp	.+216    	; 0x654c <Dio_udtreadChannel+0x114>
    6474:	4c 81       	ldd	r20, Y+4	; 0x04
    6476:	5d 81       	ldd	r21, Y+5	; 0x05
    6478:	42 30       	cpi	r20, 0x02	; 2
    647a:	51 05       	cpc	r21, r1
    647c:	b9 f1       	breq	.+110    	; 0x64ec <Dio_udtreadChannel+0xb4>
    647e:	8c 81       	ldd	r24, Y+4	; 0x04
    6480:	9d 81       	ldd	r25, Y+5	; 0x05
    6482:	83 30       	cpi	r24, 0x03	; 3
    6484:	91 05       	cpc	r25, r1
    6486:	09 f4       	brne	.+2      	; 0x648a <Dio_udtreadChannel+0x52>
    6488:	49 c0       	rjmp	.+146    	; 0x651c <Dio_udtreadChannel+0xe4>
    648a:	60 c0       	rjmp	.+192    	; 0x654c <Dio_udtreadChannel+0x114>
	{
	case DIO_PORTA:
	{
		if(CHECK_BIT(DIO_PINA_REG,pin) == 1)
    648c:	e9 e3       	ldi	r30, 0x39	; 57
    648e:	f0 e0       	ldi	r31, 0x00	; 0
    6490:	80 81       	ld	r24, Z
    6492:	28 2f       	mov	r18, r24
    6494:	30 e0       	ldi	r19, 0x00	; 0
    6496:	8a 81       	ldd	r24, Y+2	; 0x02
    6498:	88 2f       	mov	r24, r24
    649a:	90 e0       	ldi	r25, 0x00	; 0
    649c:	a9 01       	movw	r20, r18
    649e:	02 c0       	rjmp	.+4      	; 0x64a4 <Dio_udtreadChannel+0x6c>
    64a0:	55 95       	asr	r21
    64a2:	47 95       	ror	r20
    64a4:	8a 95       	dec	r24
    64a6:	e2 f7       	brpl	.-8      	; 0x64a0 <Dio_udtreadChannel+0x68>
    64a8:	ca 01       	movw	r24, r20
    64aa:	81 70       	andi	r24, 0x01	; 1
    64ac:	90 70       	andi	r25, 0x00	; 0
    64ae:	88 23       	and	r24, r24
    64b0:	19 f0       	breq	.+6      	; 0x64b8 <Dio_udtreadChannel+0x80>
		{
			return DIO_HIGH;
    64b2:	51 e0       	ldi	r21, 0x01	; 1
    64b4:	5b 83       	std	Y+3, r21	; 0x03
    64b6:	4b c0       	rjmp	.+150    	; 0x654e <Dio_udtreadChannel+0x116>
		}
		else
		{
			return DIO_LOW;
    64b8:	1b 82       	std	Y+3, r1	; 0x03
    64ba:	49 c0       	rjmp	.+146    	; 0x654e <Dio_udtreadChannel+0x116>
		}
	}
	case DIO_PORTB:
	{
		if(CHECK_BIT(DIO_PINB_REG,pin) == 1)
    64bc:	e6 e3       	ldi	r30, 0x36	; 54
    64be:	f0 e0       	ldi	r31, 0x00	; 0
    64c0:	80 81       	ld	r24, Z
    64c2:	28 2f       	mov	r18, r24
    64c4:	30 e0       	ldi	r19, 0x00	; 0
    64c6:	8a 81       	ldd	r24, Y+2	; 0x02
    64c8:	88 2f       	mov	r24, r24
    64ca:	90 e0       	ldi	r25, 0x00	; 0
    64cc:	a9 01       	movw	r20, r18
    64ce:	02 c0       	rjmp	.+4      	; 0x64d4 <Dio_udtreadChannel+0x9c>
    64d0:	55 95       	asr	r21
    64d2:	47 95       	ror	r20
    64d4:	8a 95       	dec	r24
    64d6:	e2 f7       	brpl	.-8      	; 0x64d0 <Dio_udtreadChannel+0x98>
    64d8:	ca 01       	movw	r24, r20
    64da:	81 70       	andi	r24, 0x01	; 1
    64dc:	90 70       	andi	r25, 0x00	; 0
    64de:	88 23       	and	r24, r24
    64e0:	19 f0       	breq	.+6      	; 0x64e8 <Dio_udtreadChannel+0xb0>
		{
			return DIO_HIGH;
    64e2:	51 e0       	ldi	r21, 0x01	; 1
    64e4:	5b 83       	std	Y+3, r21	; 0x03
    64e6:	33 c0       	rjmp	.+102    	; 0x654e <Dio_udtreadChannel+0x116>
		}
		else
		{
			return DIO_LOW;
    64e8:	1b 82       	std	Y+3, r1	; 0x03
    64ea:	31 c0       	rjmp	.+98     	; 0x654e <Dio_udtreadChannel+0x116>
		}
	}
	case DIO_PORTC:
	{
		if(CHECK_BIT(DIO_PINC_REG,pin) == 1)
    64ec:	e3 e3       	ldi	r30, 0x33	; 51
    64ee:	f0 e0       	ldi	r31, 0x00	; 0
    64f0:	80 81       	ld	r24, Z
    64f2:	28 2f       	mov	r18, r24
    64f4:	30 e0       	ldi	r19, 0x00	; 0
    64f6:	8a 81       	ldd	r24, Y+2	; 0x02
    64f8:	88 2f       	mov	r24, r24
    64fa:	90 e0       	ldi	r25, 0x00	; 0
    64fc:	a9 01       	movw	r20, r18
    64fe:	02 c0       	rjmp	.+4      	; 0x6504 <Dio_udtreadChannel+0xcc>
    6500:	55 95       	asr	r21
    6502:	47 95       	ror	r20
    6504:	8a 95       	dec	r24
    6506:	e2 f7       	brpl	.-8      	; 0x6500 <Dio_udtreadChannel+0xc8>
    6508:	ca 01       	movw	r24, r20
    650a:	81 70       	andi	r24, 0x01	; 1
    650c:	90 70       	andi	r25, 0x00	; 0
    650e:	88 23       	and	r24, r24
    6510:	19 f0       	breq	.+6      	; 0x6518 <Dio_udtreadChannel+0xe0>
		{
			return DIO_HIGH;
    6512:	51 e0       	ldi	r21, 0x01	; 1
    6514:	5b 83       	std	Y+3, r21	; 0x03
    6516:	1b c0       	rjmp	.+54     	; 0x654e <Dio_udtreadChannel+0x116>
		}
		else
		{
			return DIO_LOW;
    6518:	1b 82       	std	Y+3, r1	; 0x03
    651a:	19 c0       	rjmp	.+50     	; 0x654e <Dio_udtreadChannel+0x116>
		}
	}
	case DIO_PORTD:
	{
		if(CHECK_BIT(DIO_PIND_REG,pin) == 1)
    651c:	e0 e3       	ldi	r30, 0x30	; 48
    651e:	f0 e0       	ldi	r31, 0x00	; 0
    6520:	80 81       	ld	r24, Z
    6522:	28 2f       	mov	r18, r24
    6524:	30 e0       	ldi	r19, 0x00	; 0
    6526:	8a 81       	ldd	r24, Y+2	; 0x02
    6528:	88 2f       	mov	r24, r24
    652a:	90 e0       	ldi	r25, 0x00	; 0
    652c:	a9 01       	movw	r20, r18
    652e:	02 c0       	rjmp	.+4      	; 0x6534 <Dio_udtreadChannel+0xfc>
    6530:	55 95       	asr	r21
    6532:	47 95       	ror	r20
    6534:	8a 95       	dec	r24
    6536:	e2 f7       	brpl	.-8      	; 0x6530 <Dio_udtreadChannel+0xf8>
    6538:	ca 01       	movw	r24, r20
    653a:	81 70       	andi	r24, 0x01	; 1
    653c:	90 70       	andi	r25, 0x00	; 0
    653e:	88 23       	and	r24, r24
    6540:	19 f0       	breq	.+6      	; 0x6548 <Dio_udtreadChannel+0x110>
		{
			return DIO_HIGH;
    6542:	51 e0       	ldi	r21, 0x01	; 1
    6544:	5b 83       	std	Y+3, r21	; 0x03
    6546:	03 c0       	rjmp	.+6      	; 0x654e <Dio_udtreadChannel+0x116>
		}
		else
		{
			return DIO_LOW;
    6548:	1b 82       	std	Y+3, r1	; 0x03
    654a:	01 c0       	rjmp	.+2      	; 0x654e <Dio_udtreadChannel+0x116>
		}
	}

	}
	return DIO_LOW;
    654c:	1b 82       	std	Y+3, r1	; 0x03
    654e:	8b 81       	ldd	r24, Y+3	; 0x03
}
    6550:	0f 90       	pop	r0
    6552:	0f 90       	pop	r0
    6554:	0f 90       	pop	r0
    6556:	0f 90       	pop	r0
    6558:	0f 90       	pop	r0
    655a:	cf 91       	pop	r28
    655c:	df 91       	pop	r29
    655e:	08 95       	ret

00006560 <Dio_vidflipChannel>:

void Dio_vidflipChannel(dio_port_t port,dio_pin_t pin)
{
    6560:	df 93       	push	r29
    6562:	cf 93       	push	r28
    6564:	00 d0       	rcall	.+0      	; 0x6566 <Dio_vidflipChannel+0x6>
    6566:	00 d0       	rcall	.+0      	; 0x6568 <Dio_vidflipChannel+0x8>
    6568:	cd b7       	in	r28, 0x3d	; 61
    656a:	de b7       	in	r29, 0x3e	; 62
    656c:	89 83       	std	Y+1, r24	; 0x01
    656e:	6a 83       	std	Y+2, r22	; 0x02
	switch(port)
    6570:	89 81       	ldd	r24, Y+1	; 0x01
    6572:	28 2f       	mov	r18, r24
    6574:	30 e0       	ldi	r19, 0x00	; 0
    6576:	3c 83       	std	Y+4, r19	; 0x04
    6578:	2b 83       	std	Y+3, r18	; 0x03
    657a:	8b 81       	ldd	r24, Y+3	; 0x03
    657c:	9c 81       	ldd	r25, Y+4	; 0x04
    657e:	81 30       	cpi	r24, 0x01	; 1
    6580:	91 05       	cpc	r25, r1
    6582:	49 f1       	breq	.+82     	; 0x65d6 <Dio_vidflipChannel+0x76>
    6584:	2b 81       	ldd	r18, Y+3	; 0x03
    6586:	3c 81       	ldd	r19, Y+4	; 0x04
    6588:	22 30       	cpi	r18, 0x02	; 2
    658a:	31 05       	cpc	r19, r1
    658c:	2c f4       	brge	.+10     	; 0x6598 <Dio_vidflipChannel+0x38>
    658e:	8b 81       	ldd	r24, Y+3	; 0x03
    6590:	9c 81       	ldd	r25, Y+4	; 0x04
    6592:	00 97       	sbiw	r24, 0x00	; 0
    6594:	61 f0       	breq	.+24     	; 0x65ae <Dio_vidflipChannel+0x4e>
    6596:	5a c0       	rjmp	.+180    	; 0x664c <Dio_vidflipChannel+0xec>
    6598:	2b 81       	ldd	r18, Y+3	; 0x03
    659a:	3c 81       	ldd	r19, Y+4	; 0x04
    659c:	22 30       	cpi	r18, 0x02	; 2
    659e:	31 05       	cpc	r19, r1
    65a0:	71 f1       	breq	.+92     	; 0x65fe <Dio_vidflipChannel+0x9e>
    65a2:	8b 81       	ldd	r24, Y+3	; 0x03
    65a4:	9c 81       	ldd	r25, Y+4	; 0x04
    65a6:	83 30       	cpi	r24, 0x03	; 3
    65a8:	91 05       	cpc	r25, r1
    65aa:	e9 f1       	breq	.+122    	; 0x6626 <Dio_vidflipChannel+0xc6>
    65ac:	4f c0       	rjmp	.+158    	; 0x664c <Dio_vidflipChannel+0xec>
	{
	case DIO_PORTA:
	{
		FLIP_BIT(DIO_PORTA_REG,pin);
    65ae:	ab e3       	ldi	r26, 0x3B	; 59
    65b0:	b0 e0       	ldi	r27, 0x00	; 0
    65b2:	eb e3       	ldi	r30, 0x3B	; 59
    65b4:	f0 e0       	ldi	r31, 0x00	; 0
    65b6:	80 81       	ld	r24, Z
    65b8:	48 2f       	mov	r20, r24
    65ba:	8a 81       	ldd	r24, Y+2	; 0x02
    65bc:	28 2f       	mov	r18, r24
    65be:	30 e0       	ldi	r19, 0x00	; 0
    65c0:	81 e0       	ldi	r24, 0x01	; 1
    65c2:	90 e0       	ldi	r25, 0x00	; 0
    65c4:	02 2e       	mov	r0, r18
    65c6:	02 c0       	rjmp	.+4      	; 0x65cc <Dio_vidflipChannel+0x6c>
    65c8:	88 0f       	add	r24, r24
    65ca:	99 1f       	adc	r25, r25
    65cc:	0a 94       	dec	r0
    65ce:	e2 f7       	brpl	.-8      	; 0x65c8 <Dio_vidflipChannel+0x68>
    65d0:	84 27       	eor	r24, r20
    65d2:	8c 93       	st	X, r24
    65d4:	3b c0       	rjmp	.+118    	; 0x664c <Dio_vidflipChannel+0xec>
		break;
	}
	case DIO_PORTB:
	{
		FLIP_BIT(DIO_PORTB_REG,pin);
    65d6:	a8 e3       	ldi	r26, 0x38	; 56
    65d8:	b0 e0       	ldi	r27, 0x00	; 0
    65da:	e8 e3       	ldi	r30, 0x38	; 56
    65dc:	f0 e0       	ldi	r31, 0x00	; 0
    65de:	80 81       	ld	r24, Z
    65e0:	48 2f       	mov	r20, r24
    65e2:	8a 81       	ldd	r24, Y+2	; 0x02
    65e4:	28 2f       	mov	r18, r24
    65e6:	30 e0       	ldi	r19, 0x00	; 0
    65e8:	81 e0       	ldi	r24, 0x01	; 1
    65ea:	90 e0       	ldi	r25, 0x00	; 0
    65ec:	02 2e       	mov	r0, r18
    65ee:	02 c0       	rjmp	.+4      	; 0x65f4 <Dio_vidflipChannel+0x94>
    65f0:	88 0f       	add	r24, r24
    65f2:	99 1f       	adc	r25, r25
    65f4:	0a 94       	dec	r0
    65f6:	e2 f7       	brpl	.-8      	; 0x65f0 <Dio_vidflipChannel+0x90>
    65f8:	84 27       	eor	r24, r20
    65fa:	8c 93       	st	X, r24
    65fc:	27 c0       	rjmp	.+78     	; 0x664c <Dio_vidflipChannel+0xec>
		break;
	}
	case DIO_PORTC:
	{
		FLIP_BIT(DIO_PORTC_REG,pin);
    65fe:	a5 e3       	ldi	r26, 0x35	; 53
    6600:	b0 e0       	ldi	r27, 0x00	; 0
    6602:	e5 e3       	ldi	r30, 0x35	; 53
    6604:	f0 e0       	ldi	r31, 0x00	; 0
    6606:	80 81       	ld	r24, Z
    6608:	48 2f       	mov	r20, r24
    660a:	8a 81       	ldd	r24, Y+2	; 0x02
    660c:	28 2f       	mov	r18, r24
    660e:	30 e0       	ldi	r19, 0x00	; 0
    6610:	81 e0       	ldi	r24, 0x01	; 1
    6612:	90 e0       	ldi	r25, 0x00	; 0
    6614:	02 2e       	mov	r0, r18
    6616:	02 c0       	rjmp	.+4      	; 0x661c <Dio_vidflipChannel+0xbc>
    6618:	88 0f       	add	r24, r24
    661a:	99 1f       	adc	r25, r25
    661c:	0a 94       	dec	r0
    661e:	e2 f7       	brpl	.-8      	; 0x6618 <Dio_vidflipChannel+0xb8>
    6620:	84 27       	eor	r24, r20
    6622:	8c 93       	st	X, r24
    6624:	13 c0       	rjmp	.+38     	; 0x664c <Dio_vidflipChannel+0xec>
		break;
	}
	case DIO_PORTD:
	{
		FLIP_BIT(DIO_PORTD_REG,pin);
    6626:	a2 e3       	ldi	r26, 0x32	; 50
    6628:	b0 e0       	ldi	r27, 0x00	; 0
    662a:	e2 e3       	ldi	r30, 0x32	; 50
    662c:	f0 e0       	ldi	r31, 0x00	; 0
    662e:	80 81       	ld	r24, Z
    6630:	48 2f       	mov	r20, r24
    6632:	8a 81       	ldd	r24, Y+2	; 0x02
    6634:	28 2f       	mov	r18, r24
    6636:	30 e0       	ldi	r19, 0x00	; 0
    6638:	81 e0       	ldi	r24, 0x01	; 1
    663a:	90 e0       	ldi	r25, 0x00	; 0
    663c:	02 2e       	mov	r0, r18
    663e:	02 c0       	rjmp	.+4      	; 0x6644 <Dio_vidflipChannel+0xe4>
    6640:	88 0f       	add	r24, r24
    6642:	99 1f       	adc	r25, r25
    6644:	0a 94       	dec	r0
    6646:	e2 f7       	brpl	.-8      	; 0x6640 <Dio_vidflipChannel+0xe0>
    6648:	84 27       	eor	r24, r20
    664a:	8c 93       	st	X, r24
		break;
	}
	}
}
    664c:	0f 90       	pop	r0
    664e:	0f 90       	pop	r0
    6650:	0f 90       	pop	r0
    6652:	0f 90       	pop	r0
    6654:	cf 91       	pop	r28
    6656:	df 91       	pop	r29
    6658:	08 95       	ret

0000665a <Dio_vidwriteChannelGroup>:

void Dio_vidwriteChannelGroup(dio_port_t port,u8 data,u8 mask)
{
    665a:	df 93       	push	r29
    665c:	cf 93       	push	r28
    665e:	00 d0       	rcall	.+0      	; 0x6660 <Dio_vidwriteChannelGroup+0x6>
    6660:	00 d0       	rcall	.+0      	; 0x6662 <Dio_vidwriteChannelGroup+0x8>
    6662:	0f 92       	push	r0
    6664:	cd b7       	in	r28, 0x3d	; 61
    6666:	de b7       	in	r29, 0x3e	; 62
    6668:	89 83       	std	Y+1, r24	; 0x01
    666a:	6a 83       	std	Y+2, r22	; 0x02
    666c:	4b 83       	std	Y+3, r20	; 0x03
	switch(port)
    666e:	89 81       	ldd	r24, Y+1	; 0x01
    6670:	28 2f       	mov	r18, r24
    6672:	30 e0       	ldi	r19, 0x00	; 0
    6674:	3d 83       	std	Y+5, r19	; 0x05
    6676:	2c 83       	std	Y+4, r18	; 0x04
    6678:	8c 81       	ldd	r24, Y+4	; 0x04
    667a:	9d 81       	ldd	r25, Y+5	; 0x05
    667c:	81 30       	cpi	r24, 0x01	; 1
    667e:	91 05       	cpc	r25, r1
    6680:	01 f1       	breq	.+64     	; 0x66c2 <Dio_vidwriteChannelGroup+0x68>
    6682:	2c 81       	ldd	r18, Y+4	; 0x04
    6684:	3d 81       	ldd	r19, Y+5	; 0x05
    6686:	22 30       	cpi	r18, 0x02	; 2
    6688:	31 05       	cpc	r19, r1
    668a:	2c f4       	brge	.+10     	; 0x6696 <Dio_vidwriteChannelGroup+0x3c>
    668c:	8c 81       	ldd	r24, Y+4	; 0x04
    668e:	9d 81       	ldd	r25, Y+5	; 0x05
    6690:	00 97       	sbiw	r24, 0x00	; 0
    6692:	61 f0       	breq	.+24     	; 0x66ac <Dio_vidwriteChannelGroup+0x52>
    6694:	36 c0       	rjmp	.+108    	; 0x6702 <Dio_vidwriteChannelGroup+0xa8>
    6696:	2c 81       	ldd	r18, Y+4	; 0x04
    6698:	3d 81       	ldd	r19, Y+5	; 0x05
    669a:	22 30       	cpi	r18, 0x02	; 2
    669c:	31 05       	cpc	r19, r1
    669e:	e1 f0       	breq	.+56     	; 0x66d8 <Dio_vidwriteChannelGroup+0x7e>
    66a0:	8c 81       	ldd	r24, Y+4	; 0x04
    66a2:	9d 81       	ldd	r25, Y+5	; 0x05
    66a4:	83 30       	cpi	r24, 0x03	; 3
    66a6:	91 05       	cpc	r25, r1
    66a8:	11 f1       	breq	.+68     	; 0x66ee <Dio_vidwriteChannelGroup+0x94>
    66aa:	2b c0       	rjmp	.+86     	; 0x6702 <Dio_vidwriteChannelGroup+0xa8>
	{
	case DIO_PORTA:
	{
		DIO_PORTA_REG = (DIO_PORTA_REG & mask) | (data);
    66ac:	ab e3       	ldi	r26, 0x3B	; 59
    66ae:	b0 e0       	ldi	r27, 0x00	; 0
    66b0:	eb e3       	ldi	r30, 0x3B	; 59
    66b2:	f0 e0       	ldi	r31, 0x00	; 0
    66b4:	90 81       	ld	r25, Z
    66b6:	8b 81       	ldd	r24, Y+3	; 0x03
    66b8:	98 23       	and	r25, r24
    66ba:	8a 81       	ldd	r24, Y+2	; 0x02
    66bc:	89 2b       	or	r24, r25
    66be:	8c 93       	st	X, r24
    66c0:	20 c0       	rjmp	.+64     	; 0x6702 <Dio_vidwriteChannelGroup+0xa8>
		break;
	}
	case DIO_PORTB:
	{
		DIO_PORTB_REG = (DIO_PORTB_REG & mask) | (data);
    66c2:	a8 e3       	ldi	r26, 0x38	; 56
    66c4:	b0 e0       	ldi	r27, 0x00	; 0
    66c6:	e8 e3       	ldi	r30, 0x38	; 56
    66c8:	f0 e0       	ldi	r31, 0x00	; 0
    66ca:	90 81       	ld	r25, Z
    66cc:	8b 81       	ldd	r24, Y+3	; 0x03
    66ce:	98 23       	and	r25, r24
    66d0:	8a 81       	ldd	r24, Y+2	; 0x02
    66d2:	89 2b       	or	r24, r25
    66d4:	8c 93       	st	X, r24
    66d6:	15 c0       	rjmp	.+42     	; 0x6702 <Dio_vidwriteChannelGroup+0xa8>
		break;
	}
	case DIO_PORTC:
	{
		DIO_PORTC_REG = (DIO_PORTC_REG & mask) | (data);
    66d8:	a5 e3       	ldi	r26, 0x35	; 53
    66da:	b0 e0       	ldi	r27, 0x00	; 0
    66dc:	e5 e3       	ldi	r30, 0x35	; 53
    66de:	f0 e0       	ldi	r31, 0x00	; 0
    66e0:	90 81       	ld	r25, Z
    66e2:	8b 81       	ldd	r24, Y+3	; 0x03
    66e4:	98 23       	and	r25, r24
    66e6:	8a 81       	ldd	r24, Y+2	; 0x02
    66e8:	89 2b       	or	r24, r25
    66ea:	8c 93       	st	X, r24
    66ec:	0a c0       	rjmp	.+20     	; 0x6702 <Dio_vidwriteChannelGroup+0xa8>
		break;
	}
	case DIO_PORTD:
	{
		DIO_PORTD_REG = (DIO_PORTD_REG & mask) | (data);
    66ee:	a2 e3       	ldi	r26, 0x32	; 50
    66f0:	b0 e0       	ldi	r27, 0x00	; 0
    66f2:	e2 e3       	ldi	r30, 0x32	; 50
    66f4:	f0 e0       	ldi	r31, 0x00	; 0
    66f6:	90 81       	ld	r25, Z
    66f8:	8b 81       	ldd	r24, Y+3	; 0x03
    66fa:	98 23       	and	r25, r24
    66fc:	8a 81       	ldd	r24, Y+2	; 0x02
    66fe:	89 2b       	or	r24, r25
    6700:	8c 93       	st	X, r24
		break;
	}
	}
}
    6702:	0f 90       	pop	r0
    6704:	0f 90       	pop	r0
    6706:	0f 90       	pop	r0
    6708:	0f 90       	pop	r0
    670a:	0f 90       	pop	r0
    670c:	cf 91       	pop	r28
    670e:	df 91       	pop	r29
    6710:	08 95       	ret

00006712 <ADC_Init>:


#include "ADC.h"

void ADC_Init(void)
{
    6712:	df 93       	push	r29
    6714:	cf 93       	push	r28
    6716:	cd b7       	in	r28, 0x3d	; 61
    6718:	de b7       	in	r29, 0x3e	; 62
	/* 	Vref = AVCC	*/
	ADC_ADMUX_REG|=(AVCC5V_REF<<6);
    671a:	a7 e2       	ldi	r26, 0x27	; 39
    671c:	b0 e0       	ldi	r27, 0x00	; 0
    671e:	e7 e2       	ldi	r30, 0x27	; 39
    6720:	f0 e0       	ldi	r31, 0x00	; 0
    6722:	80 81       	ld	r24, Z
    6724:	80 64       	ori	r24, 0x40	; 64
    6726:	8c 93       	st	X, r24
	/*	Enable ADC, Prescaler = /128	*/
	ADC_ADCSRA_REG=(ADC_ENABLE)|(ADCPS_128);
    6728:	e6 e2       	ldi	r30, 0x26	; 38
    672a:	f0 e0       	ldi	r31, 0x00	; 0
    672c:	87 e8       	ldi	r24, 0x87	; 135
    672e:	80 83       	st	Z, r24
}
    6730:	cf 91       	pop	r28
    6732:	df 91       	pop	r29
    6734:	08 95       	ret

00006736 <ADC_Read>:

u16 ADC_Read(adc_Channel_t chnlNo)
{
    6736:	df 93       	push	r29
    6738:	cf 93       	push	r28
    673a:	00 d0       	rcall	.+0      	; 0x673c <ADC_Read+0x6>
    673c:	0f 92       	push	r0
    673e:	cd b7       	in	r28, 0x3d	; 61
    6740:	de b7       	in	r29, 0x3e	; 62
    6742:	8b 83       	std	Y+3, r24	; 0x03
	u16 result;
	/*	Select Channel	*/
	ADC_ADMUX_REG = (ADC_ADMUX_REG & 0xF8)|(chnlNo);
    6744:	a7 e2       	ldi	r26, 0x27	; 39
    6746:	b0 e0       	ldi	r27, 0x00	; 0
    6748:	e7 e2       	ldi	r30, 0x27	; 39
    674a:	f0 e0       	ldi	r31, 0x00	; 0
    674c:	80 81       	ld	r24, Z
    674e:	98 2f       	mov	r25, r24
    6750:	98 7f       	andi	r25, 0xF8	; 248
    6752:	8b 81       	ldd	r24, Y+3	; 0x03
    6754:	89 2b       	or	r24, r25
    6756:	8c 93       	st	X, r24
	/*	Start ADC Conversion	*/
	SET_BIT(ADC_ADCSRA_REG,ADC_START_CONVERSION_BIT_NO);
    6758:	a6 e2       	ldi	r26, 0x26	; 38
    675a:	b0 e0       	ldi	r27, 0x00	; 0
    675c:	e6 e2       	ldi	r30, 0x26	; 38
    675e:	f0 e0       	ldi	r31, 0x00	; 0
    6760:	80 81       	ld	r24, Z
    6762:	80 64       	ori	r24, 0x40	; 64
    6764:	8c 93       	st	X, r24
	/*	Wait Until ADC Conversion Finished	*/
	while(CHECK_BIT(ADC_ADCSRA_REG,ADIF_BIT_NO) != 1)
    6766:	e6 e2       	ldi	r30, 0x26	; 38
    6768:	f0 e0       	ldi	r31, 0x00	; 0
    676a:	80 81       	ld	r24, Z
    676c:	82 95       	swap	r24
    676e:	8f 70       	andi	r24, 0x0F	; 15
    6770:	88 2f       	mov	r24, r24
    6772:	90 e0       	ldi	r25, 0x00	; 0
    6774:	81 70       	andi	r24, 0x01	; 1
    6776:	90 70       	andi	r25, 0x00	; 0
    6778:	00 97       	sbiw	r24, 0x00	; 0
    677a:	a9 f3       	breq	.-22     	; 0x6766 <ADC_Read+0x30>
	{
		/*	Do Nothing	*/
	}
	/*	Clear Interrupt Flag To Be Ready For Another Conversion	*/
	SET_BIT(ADC_ADCSRA_REG,ADIF_BIT_NO);
    677c:	a6 e2       	ldi	r26, 0x26	; 38
    677e:	b0 e0       	ldi	r27, 0x00	; 0
    6780:	e6 e2       	ldi	r30, 0x26	; 38
    6782:	f0 e0       	ldi	r31, 0x00	; 0
    6784:	80 81       	ld	r24, Z
    6786:	80 61       	ori	r24, 0x10	; 16
    6788:	8c 93       	st	X, r24
	/*	Read ADC Result	*/
	result=(ADC_ADCL_REG|(ADC_ADCH_REG<<8));
    678a:	e4 e2       	ldi	r30, 0x24	; 36
    678c:	f0 e0       	ldi	r31, 0x00	; 0
    678e:	80 81       	ld	r24, Z
    6790:	28 2f       	mov	r18, r24
    6792:	30 e0       	ldi	r19, 0x00	; 0
    6794:	e5 e2       	ldi	r30, 0x25	; 37
    6796:	f0 e0       	ldi	r31, 0x00	; 0
    6798:	80 81       	ld	r24, Z
    679a:	88 2f       	mov	r24, r24
    679c:	90 e0       	ldi	r25, 0x00	; 0
    679e:	98 2f       	mov	r25, r24
    67a0:	88 27       	eor	r24, r24
    67a2:	82 2b       	or	r24, r18
    67a4:	93 2b       	or	r25, r19
    67a6:	9a 83       	std	Y+2, r25	; 0x02
    67a8:	89 83       	std	Y+1, r24	; 0x01
	return result;
    67aa:	89 81       	ldd	r24, Y+1	; 0x01
    67ac:	9a 81       	ldd	r25, Y+2	; 0x02
}
    67ae:	0f 90       	pop	r0
    67b0:	0f 90       	pop	r0
    67b2:	0f 90       	pop	r0
    67b4:	cf 91       	pop	r28
    67b6:	df 91       	pop	r29
    67b8:	08 95       	ret

000067ba <__mulsi3>:
    67ba:	62 9f       	mul	r22, r18
    67bc:	d0 01       	movw	r26, r0
    67be:	73 9f       	mul	r23, r19
    67c0:	f0 01       	movw	r30, r0
    67c2:	82 9f       	mul	r24, r18
    67c4:	e0 0d       	add	r30, r0
    67c6:	f1 1d       	adc	r31, r1
    67c8:	64 9f       	mul	r22, r20
    67ca:	e0 0d       	add	r30, r0
    67cc:	f1 1d       	adc	r31, r1
    67ce:	92 9f       	mul	r25, r18
    67d0:	f0 0d       	add	r31, r0
    67d2:	83 9f       	mul	r24, r19
    67d4:	f0 0d       	add	r31, r0
    67d6:	74 9f       	mul	r23, r20
    67d8:	f0 0d       	add	r31, r0
    67da:	65 9f       	mul	r22, r21
    67dc:	f0 0d       	add	r31, r0
    67de:	99 27       	eor	r25, r25
    67e0:	72 9f       	mul	r23, r18
    67e2:	b0 0d       	add	r27, r0
    67e4:	e1 1d       	adc	r30, r1
    67e6:	f9 1f       	adc	r31, r25
    67e8:	63 9f       	mul	r22, r19
    67ea:	b0 0d       	add	r27, r0
    67ec:	e1 1d       	adc	r30, r1
    67ee:	f9 1f       	adc	r31, r25
    67f0:	bd 01       	movw	r22, r26
    67f2:	cf 01       	movw	r24, r30
    67f4:	11 24       	eor	r1, r1
    67f6:	08 95       	ret

000067f8 <__udivmodqi4>:
    67f8:	99 1b       	sub	r25, r25
    67fa:	79 e0       	ldi	r23, 0x09	; 9
    67fc:	04 c0       	rjmp	.+8      	; 0x6806 <__udivmodqi4_ep>

000067fe <__udivmodqi4_loop>:
    67fe:	99 1f       	adc	r25, r25
    6800:	96 17       	cp	r25, r22
    6802:	08 f0       	brcs	.+2      	; 0x6806 <__udivmodqi4_ep>
    6804:	96 1b       	sub	r25, r22

00006806 <__udivmodqi4_ep>:
    6806:	88 1f       	adc	r24, r24
    6808:	7a 95       	dec	r23
    680a:	c9 f7       	brne	.-14     	; 0x67fe <__udivmodqi4_loop>
    680c:	80 95       	com	r24
    680e:	08 95       	ret

00006810 <__udivmodhi4>:
    6810:	aa 1b       	sub	r26, r26
    6812:	bb 1b       	sub	r27, r27
    6814:	51 e1       	ldi	r21, 0x11	; 17
    6816:	07 c0       	rjmp	.+14     	; 0x6826 <__udivmodhi4_ep>

00006818 <__udivmodhi4_loop>:
    6818:	aa 1f       	adc	r26, r26
    681a:	bb 1f       	adc	r27, r27
    681c:	a6 17       	cp	r26, r22
    681e:	b7 07       	cpc	r27, r23
    6820:	10 f0       	brcs	.+4      	; 0x6826 <__udivmodhi4_ep>
    6822:	a6 1b       	sub	r26, r22
    6824:	b7 0b       	sbc	r27, r23

00006826 <__udivmodhi4_ep>:
    6826:	88 1f       	adc	r24, r24
    6828:	99 1f       	adc	r25, r25
    682a:	5a 95       	dec	r21
    682c:	a9 f7       	brne	.-22     	; 0x6818 <__udivmodhi4_loop>
    682e:	80 95       	com	r24
    6830:	90 95       	com	r25
    6832:	bc 01       	movw	r22, r24
    6834:	cd 01       	movw	r24, r26
    6836:	08 95       	ret

00006838 <__udivmodsi4>:
    6838:	a1 e2       	ldi	r26, 0x21	; 33
    683a:	1a 2e       	mov	r1, r26
    683c:	aa 1b       	sub	r26, r26
    683e:	bb 1b       	sub	r27, r27
    6840:	fd 01       	movw	r30, r26
    6842:	0d c0       	rjmp	.+26     	; 0x685e <__udivmodsi4_ep>

00006844 <__udivmodsi4_loop>:
    6844:	aa 1f       	adc	r26, r26
    6846:	bb 1f       	adc	r27, r27
    6848:	ee 1f       	adc	r30, r30
    684a:	ff 1f       	adc	r31, r31
    684c:	a2 17       	cp	r26, r18
    684e:	b3 07       	cpc	r27, r19
    6850:	e4 07       	cpc	r30, r20
    6852:	f5 07       	cpc	r31, r21
    6854:	20 f0       	brcs	.+8      	; 0x685e <__udivmodsi4_ep>
    6856:	a2 1b       	sub	r26, r18
    6858:	b3 0b       	sbc	r27, r19
    685a:	e4 0b       	sbc	r30, r20
    685c:	f5 0b       	sbc	r31, r21

0000685e <__udivmodsi4_ep>:
    685e:	66 1f       	adc	r22, r22
    6860:	77 1f       	adc	r23, r23
    6862:	88 1f       	adc	r24, r24
    6864:	99 1f       	adc	r25, r25
    6866:	1a 94       	dec	r1
    6868:	69 f7       	brne	.-38     	; 0x6844 <__udivmodsi4_loop>
    686a:	60 95       	com	r22
    686c:	70 95       	com	r23
    686e:	80 95       	com	r24
    6870:	90 95       	com	r25
    6872:	9b 01       	movw	r18, r22
    6874:	ac 01       	movw	r20, r24
    6876:	bd 01       	movw	r22, r26
    6878:	cf 01       	movw	r24, r30
    687a:	08 95       	ret

0000687c <__prologue_saves__>:
    687c:	2f 92       	push	r2
    687e:	3f 92       	push	r3
    6880:	4f 92       	push	r4
    6882:	5f 92       	push	r5
    6884:	6f 92       	push	r6
    6886:	7f 92       	push	r7
    6888:	8f 92       	push	r8
    688a:	9f 92       	push	r9
    688c:	af 92       	push	r10
    688e:	bf 92       	push	r11
    6890:	cf 92       	push	r12
    6892:	df 92       	push	r13
    6894:	ef 92       	push	r14
    6896:	ff 92       	push	r15
    6898:	0f 93       	push	r16
    689a:	1f 93       	push	r17
    689c:	cf 93       	push	r28
    689e:	df 93       	push	r29
    68a0:	cd b7       	in	r28, 0x3d	; 61
    68a2:	de b7       	in	r29, 0x3e	; 62
    68a4:	ca 1b       	sub	r28, r26
    68a6:	db 0b       	sbc	r29, r27
    68a8:	0f b6       	in	r0, 0x3f	; 63
    68aa:	f8 94       	cli
    68ac:	de bf       	out	0x3e, r29	; 62
    68ae:	0f be       	out	0x3f, r0	; 63
    68b0:	cd bf       	out	0x3d, r28	; 61
    68b2:	09 94       	ijmp

000068b4 <__epilogue_restores__>:
    68b4:	2a 88       	ldd	r2, Y+18	; 0x12
    68b6:	39 88       	ldd	r3, Y+17	; 0x11
    68b8:	48 88       	ldd	r4, Y+16	; 0x10
    68ba:	5f 84       	ldd	r5, Y+15	; 0x0f
    68bc:	6e 84       	ldd	r6, Y+14	; 0x0e
    68be:	7d 84       	ldd	r7, Y+13	; 0x0d
    68c0:	8c 84       	ldd	r8, Y+12	; 0x0c
    68c2:	9b 84       	ldd	r9, Y+11	; 0x0b
    68c4:	aa 84       	ldd	r10, Y+10	; 0x0a
    68c6:	b9 84       	ldd	r11, Y+9	; 0x09
    68c8:	c8 84       	ldd	r12, Y+8	; 0x08
    68ca:	df 80       	ldd	r13, Y+7	; 0x07
    68cc:	ee 80       	ldd	r14, Y+6	; 0x06
    68ce:	fd 80       	ldd	r15, Y+5	; 0x05
    68d0:	0c 81       	ldd	r16, Y+4	; 0x04
    68d2:	1b 81       	ldd	r17, Y+3	; 0x03
    68d4:	aa 81       	ldd	r26, Y+2	; 0x02
    68d6:	b9 81       	ldd	r27, Y+1	; 0x01
    68d8:	ce 0f       	add	r28, r30
    68da:	d1 1d       	adc	r29, r1
    68dc:	0f b6       	in	r0, 0x3f	; 63
    68de:	f8 94       	cli
    68e0:	de bf       	out	0x3e, r29	; 62
    68e2:	0f be       	out	0x3f, r0	; 63
    68e4:	cd bf       	out	0x3d, r28	; 61
    68e6:	ed 01       	movw	r28, r26
    68e8:	08 95       	ret

000068ea <memcpy>:
    68ea:	fb 01       	movw	r30, r22
    68ec:	dc 01       	movw	r26, r24
    68ee:	02 c0       	rjmp	.+4      	; 0x68f4 <memcpy+0xa>
    68f0:	01 90       	ld	r0, Z+
    68f2:	0d 92       	st	X+, r0
    68f4:	41 50       	subi	r20, 0x01	; 1
    68f6:	50 40       	sbci	r21, 0x00	; 0
    68f8:	d8 f7       	brcc	.-10     	; 0x68f0 <memcpy+0x6>
    68fa:	08 95       	ret

000068fc <memset>:
    68fc:	dc 01       	movw	r26, r24
    68fe:	01 c0       	rjmp	.+2      	; 0x6902 <memset+0x6>
    6900:	6d 93       	st	X+, r22
    6902:	41 50       	subi	r20, 0x01	; 1
    6904:	50 40       	sbci	r21, 0x00	; 0
    6906:	e0 f7       	brcc	.-8      	; 0x6900 <memset+0x4>
    6908:	08 95       	ret

0000690a <strncpy>:
    690a:	fb 01       	movw	r30, r22
    690c:	dc 01       	movw	r26, r24
    690e:	41 50       	subi	r20, 0x01	; 1
    6910:	50 40       	sbci	r21, 0x00	; 0
    6912:	48 f0       	brcs	.+18     	; 0x6926 <strncpy+0x1c>
    6914:	01 90       	ld	r0, Z+
    6916:	0d 92       	st	X+, r0
    6918:	00 20       	and	r0, r0
    691a:	c9 f7       	brne	.-14     	; 0x690e <strncpy+0x4>
    691c:	01 c0       	rjmp	.+2      	; 0x6920 <strncpy+0x16>
    691e:	1d 92       	st	X+, r1
    6920:	41 50       	subi	r20, 0x01	; 1
    6922:	50 40       	sbci	r21, 0x00	; 0
    6924:	e0 f7       	brcc	.-8      	; 0x691e <strncpy+0x14>
    6926:	08 95       	ret

00006928 <sprintf>:
    6928:	ae e0       	ldi	r26, 0x0E	; 14
    692a:	b0 e0       	ldi	r27, 0x00	; 0
    692c:	ea e9       	ldi	r30, 0x9A	; 154
    692e:	f4 e3       	ldi	r31, 0x34	; 52
    6930:	0c 94 4c 34 	jmp	0x6898	; 0x6898 <__prologue_saves__+0x1c>
    6934:	0d 89       	ldd	r16, Y+21	; 0x15
    6936:	1e 89       	ldd	r17, Y+22	; 0x16
    6938:	86 e0       	ldi	r24, 0x06	; 6
    693a:	8c 83       	std	Y+4, r24	; 0x04
    693c:	1a 83       	std	Y+2, r17	; 0x02
    693e:	09 83       	std	Y+1, r16	; 0x01
    6940:	8f ef       	ldi	r24, 0xFF	; 255
    6942:	9f e7       	ldi	r25, 0x7F	; 127
    6944:	9e 83       	std	Y+6, r25	; 0x06
    6946:	8d 83       	std	Y+5, r24	; 0x05
    6948:	9e 01       	movw	r18, r28
    694a:	27 5e       	subi	r18, 0xE7	; 231
    694c:	3f 4f       	sbci	r19, 0xFF	; 255
    694e:	ce 01       	movw	r24, r28
    6950:	01 96       	adiw	r24, 0x01	; 1
    6952:	6f 89       	ldd	r22, Y+23	; 0x17
    6954:	78 8d       	ldd	r23, Y+24	; 0x18
    6956:	a9 01       	movw	r20, r18
    6958:	0e 94 b8 34 	call	0x6970	; 0x6970 <vfprintf>
    695c:	2f 81       	ldd	r18, Y+7	; 0x07
    695e:	38 85       	ldd	r19, Y+8	; 0x08
    6960:	02 0f       	add	r16, r18
    6962:	13 1f       	adc	r17, r19
    6964:	f8 01       	movw	r30, r16
    6966:	10 82       	st	Z, r1
    6968:	2e 96       	adiw	r28, 0x0e	; 14
    696a:	e4 e0       	ldi	r30, 0x04	; 4
    696c:	0c 94 68 34 	jmp	0x68d0	; 0x68d0 <__epilogue_restores__+0x1c>

00006970 <vfprintf>:
    6970:	ab e0       	ldi	r26, 0x0B	; 11
    6972:	b0 e0       	ldi	r27, 0x00	; 0
    6974:	ee eb       	ldi	r30, 0xBE	; 190
    6976:	f4 e3       	ldi	r31, 0x34	; 52
    6978:	0c 94 3e 34 	jmp	0x687c	; 0x687c <__prologue_saves__>
    697c:	3c 01       	movw	r6, r24
    697e:	2b 01       	movw	r4, r22
    6980:	5a 01       	movw	r10, r20
    6982:	fc 01       	movw	r30, r24
    6984:	17 82       	std	Z+7, r1	; 0x07
    6986:	16 82       	std	Z+6, r1	; 0x06
    6988:	83 81       	ldd	r24, Z+3	; 0x03
    698a:	81 fd       	sbrc	r24, 1
    698c:	03 c0       	rjmp	.+6      	; 0x6994 <vfprintf+0x24>
    698e:	6f ef       	ldi	r22, 0xFF	; 255
    6990:	7f ef       	ldi	r23, 0xFF	; 255
    6992:	c6 c1       	rjmp	.+908    	; 0x6d20 <vfprintf+0x3b0>
    6994:	9a e0       	ldi	r25, 0x0A	; 10
    6996:	89 2e       	mov	r8, r25
    6998:	1e 01       	movw	r2, r28
    699a:	08 94       	sec
    699c:	21 1c       	adc	r2, r1
    699e:	31 1c       	adc	r3, r1
    69a0:	f3 01       	movw	r30, r6
    69a2:	23 81       	ldd	r18, Z+3	; 0x03
    69a4:	f2 01       	movw	r30, r4
    69a6:	23 fd       	sbrc	r18, 3
    69a8:	85 91       	lpm	r24, Z+
    69aa:	23 ff       	sbrs	r18, 3
    69ac:	81 91       	ld	r24, Z+
    69ae:	2f 01       	movw	r4, r30
    69b0:	88 23       	and	r24, r24
    69b2:	09 f4       	brne	.+2      	; 0x69b6 <vfprintf+0x46>
    69b4:	b2 c1       	rjmp	.+868    	; 0x6d1a <vfprintf+0x3aa>
    69b6:	85 32       	cpi	r24, 0x25	; 37
    69b8:	39 f4       	brne	.+14     	; 0x69c8 <vfprintf+0x58>
    69ba:	23 fd       	sbrc	r18, 3
    69bc:	85 91       	lpm	r24, Z+
    69be:	23 ff       	sbrs	r18, 3
    69c0:	81 91       	ld	r24, Z+
    69c2:	2f 01       	movw	r4, r30
    69c4:	85 32       	cpi	r24, 0x25	; 37
    69c6:	29 f4       	brne	.+10     	; 0x69d2 <vfprintf+0x62>
    69c8:	90 e0       	ldi	r25, 0x00	; 0
    69ca:	b3 01       	movw	r22, r6
    69cc:	0e 94 ab 36 	call	0x6d56	; 0x6d56 <fputc>
    69d0:	e7 cf       	rjmp	.-50     	; 0x69a0 <vfprintf+0x30>
    69d2:	98 2f       	mov	r25, r24
    69d4:	ff 24       	eor	r15, r15
    69d6:	ee 24       	eor	r14, r14
    69d8:	99 24       	eor	r9, r9
    69da:	ff e1       	ldi	r31, 0x1F	; 31
    69dc:	ff 15       	cp	r31, r15
    69de:	d0 f0       	brcs	.+52     	; 0x6a14 <vfprintf+0xa4>
    69e0:	9b 32       	cpi	r25, 0x2B	; 43
    69e2:	69 f0       	breq	.+26     	; 0x69fe <vfprintf+0x8e>
    69e4:	9c 32       	cpi	r25, 0x2C	; 44
    69e6:	28 f4       	brcc	.+10     	; 0x69f2 <vfprintf+0x82>
    69e8:	90 32       	cpi	r25, 0x20	; 32
    69ea:	59 f0       	breq	.+22     	; 0x6a02 <vfprintf+0x92>
    69ec:	93 32       	cpi	r25, 0x23	; 35
    69ee:	91 f4       	brne	.+36     	; 0x6a14 <vfprintf+0xa4>
    69f0:	0e c0       	rjmp	.+28     	; 0x6a0e <vfprintf+0x9e>
    69f2:	9d 32       	cpi	r25, 0x2D	; 45
    69f4:	49 f0       	breq	.+18     	; 0x6a08 <vfprintf+0x98>
    69f6:	90 33       	cpi	r25, 0x30	; 48
    69f8:	69 f4       	brne	.+26     	; 0x6a14 <vfprintf+0xa4>
    69fa:	41 e0       	ldi	r20, 0x01	; 1
    69fc:	24 c0       	rjmp	.+72     	; 0x6a46 <vfprintf+0xd6>
    69fe:	52 e0       	ldi	r21, 0x02	; 2
    6a00:	f5 2a       	or	r15, r21
    6a02:	84 e0       	ldi	r24, 0x04	; 4
    6a04:	f8 2a       	or	r15, r24
    6a06:	28 c0       	rjmp	.+80     	; 0x6a58 <vfprintf+0xe8>
    6a08:	98 e0       	ldi	r25, 0x08	; 8
    6a0a:	f9 2a       	or	r15, r25
    6a0c:	25 c0       	rjmp	.+74     	; 0x6a58 <vfprintf+0xe8>
    6a0e:	e0 e1       	ldi	r30, 0x10	; 16
    6a10:	fe 2a       	or	r15, r30
    6a12:	22 c0       	rjmp	.+68     	; 0x6a58 <vfprintf+0xe8>
    6a14:	f7 fc       	sbrc	r15, 7
    6a16:	29 c0       	rjmp	.+82     	; 0x6a6a <vfprintf+0xfa>
    6a18:	89 2f       	mov	r24, r25
    6a1a:	80 53       	subi	r24, 0x30	; 48
    6a1c:	8a 30       	cpi	r24, 0x0A	; 10
    6a1e:	70 f4       	brcc	.+28     	; 0x6a3c <vfprintf+0xcc>
    6a20:	f6 fe       	sbrs	r15, 6
    6a22:	05 c0       	rjmp	.+10     	; 0x6a2e <vfprintf+0xbe>
    6a24:	98 9c       	mul	r9, r8
    6a26:	90 2c       	mov	r9, r0
    6a28:	11 24       	eor	r1, r1
    6a2a:	98 0e       	add	r9, r24
    6a2c:	15 c0       	rjmp	.+42     	; 0x6a58 <vfprintf+0xe8>
    6a2e:	e8 9c       	mul	r14, r8
    6a30:	e0 2c       	mov	r14, r0
    6a32:	11 24       	eor	r1, r1
    6a34:	e8 0e       	add	r14, r24
    6a36:	f0 e2       	ldi	r31, 0x20	; 32
    6a38:	ff 2a       	or	r15, r31
    6a3a:	0e c0       	rjmp	.+28     	; 0x6a58 <vfprintf+0xe8>
    6a3c:	9e 32       	cpi	r25, 0x2E	; 46
    6a3e:	29 f4       	brne	.+10     	; 0x6a4a <vfprintf+0xda>
    6a40:	f6 fc       	sbrc	r15, 6
    6a42:	6b c1       	rjmp	.+726    	; 0x6d1a <vfprintf+0x3aa>
    6a44:	40 e4       	ldi	r20, 0x40	; 64
    6a46:	f4 2a       	or	r15, r20
    6a48:	07 c0       	rjmp	.+14     	; 0x6a58 <vfprintf+0xe8>
    6a4a:	9c 36       	cpi	r25, 0x6C	; 108
    6a4c:	19 f4       	brne	.+6      	; 0x6a54 <vfprintf+0xe4>
    6a4e:	50 e8       	ldi	r21, 0x80	; 128
    6a50:	f5 2a       	or	r15, r21
    6a52:	02 c0       	rjmp	.+4      	; 0x6a58 <vfprintf+0xe8>
    6a54:	98 36       	cpi	r25, 0x68	; 104
    6a56:	49 f4       	brne	.+18     	; 0x6a6a <vfprintf+0xfa>
    6a58:	f2 01       	movw	r30, r4
    6a5a:	23 fd       	sbrc	r18, 3
    6a5c:	95 91       	lpm	r25, Z+
    6a5e:	23 ff       	sbrs	r18, 3
    6a60:	91 91       	ld	r25, Z+
    6a62:	2f 01       	movw	r4, r30
    6a64:	99 23       	and	r25, r25
    6a66:	09 f0       	breq	.+2      	; 0x6a6a <vfprintf+0xfa>
    6a68:	b8 cf       	rjmp	.-144    	; 0x69da <vfprintf+0x6a>
    6a6a:	89 2f       	mov	r24, r25
    6a6c:	85 54       	subi	r24, 0x45	; 69
    6a6e:	83 30       	cpi	r24, 0x03	; 3
    6a70:	18 f0       	brcs	.+6      	; 0x6a78 <vfprintf+0x108>
    6a72:	80 52       	subi	r24, 0x20	; 32
    6a74:	83 30       	cpi	r24, 0x03	; 3
    6a76:	38 f4       	brcc	.+14     	; 0x6a86 <vfprintf+0x116>
    6a78:	44 e0       	ldi	r20, 0x04	; 4
    6a7a:	50 e0       	ldi	r21, 0x00	; 0
    6a7c:	a4 0e       	add	r10, r20
    6a7e:	b5 1e       	adc	r11, r21
    6a80:	5f e3       	ldi	r21, 0x3F	; 63
    6a82:	59 83       	std	Y+1, r21	; 0x01
    6a84:	0f c0       	rjmp	.+30     	; 0x6aa4 <vfprintf+0x134>
    6a86:	93 36       	cpi	r25, 0x63	; 99
    6a88:	31 f0       	breq	.+12     	; 0x6a96 <vfprintf+0x126>
    6a8a:	93 37       	cpi	r25, 0x73	; 115
    6a8c:	79 f0       	breq	.+30     	; 0x6aac <vfprintf+0x13c>
    6a8e:	93 35       	cpi	r25, 0x53	; 83
    6a90:	09 f0       	breq	.+2      	; 0x6a94 <vfprintf+0x124>
    6a92:	56 c0       	rjmp	.+172    	; 0x6b40 <vfprintf+0x1d0>
    6a94:	20 c0       	rjmp	.+64     	; 0x6ad6 <vfprintf+0x166>
    6a96:	f5 01       	movw	r30, r10
    6a98:	80 81       	ld	r24, Z
    6a9a:	89 83       	std	Y+1, r24	; 0x01
    6a9c:	42 e0       	ldi	r20, 0x02	; 2
    6a9e:	50 e0       	ldi	r21, 0x00	; 0
    6aa0:	a4 0e       	add	r10, r20
    6aa2:	b5 1e       	adc	r11, r21
    6aa4:	61 01       	movw	r12, r2
    6aa6:	01 e0       	ldi	r16, 0x01	; 1
    6aa8:	10 e0       	ldi	r17, 0x00	; 0
    6aaa:	12 c0       	rjmp	.+36     	; 0x6ad0 <vfprintf+0x160>
    6aac:	f5 01       	movw	r30, r10
    6aae:	c0 80       	ld	r12, Z
    6ab0:	d1 80       	ldd	r13, Z+1	; 0x01
    6ab2:	f6 fc       	sbrc	r15, 6
    6ab4:	03 c0       	rjmp	.+6      	; 0x6abc <vfprintf+0x14c>
    6ab6:	6f ef       	ldi	r22, 0xFF	; 255
    6ab8:	7f ef       	ldi	r23, 0xFF	; 255
    6aba:	02 c0       	rjmp	.+4      	; 0x6ac0 <vfprintf+0x150>
    6abc:	69 2d       	mov	r22, r9
    6abe:	70 e0       	ldi	r23, 0x00	; 0
    6ac0:	42 e0       	ldi	r20, 0x02	; 2
    6ac2:	50 e0       	ldi	r21, 0x00	; 0
    6ac4:	a4 0e       	add	r10, r20
    6ac6:	b5 1e       	adc	r11, r21
    6ac8:	c6 01       	movw	r24, r12
    6aca:	0e 94 a0 36 	call	0x6d40	; 0x6d40 <strnlen>
    6ace:	8c 01       	movw	r16, r24
    6ad0:	5f e7       	ldi	r21, 0x7F	; 127
    6ad2:	f5 22       	and	r15, r21
    6ad4:	14 c0       	rjmp	.+40     	; 0x6afe <vfprintf+0x18e>
    6ad6:	f5 01       	movw	r30, r10
    6ad8:	c0 80       	ld	r12, Z
    6ada:	d1 80       	ldd	r13, Z+1	; 0x01
    6adc:	f6 fc       	sbrc	r15, 6
    6ade:	03 c0       	rjmp	.+6      	; 0x6ae6 <vfprintf+0x176>
    6ae0:	6f ef       	ldi	r22, 0xFF	; 255
    6ae2:	7f ef       	ldi	r23, 0xFF	; 255
    6ae4:	02 c0       	rjmp	.+4      	; 0x6aea <vfprintf+0x17a>
    6ae6:	69 2d       	mov	r22, r9
    6ae8:	70 e0       	ldi	r23, 0x00	; 0
    6aea:	42 e0       	ldi	r20, 0x02	; 2
    6aec:	50 e0       	ldi	r21, 0x00	; 0
    6aee:	a4 0e       	add	r10, r20
    6af0:	b5 1e       	adc	r11, r21
    6af2:	c6 01       	movw	r24, r12
    6af4:	0e 94 95 36 	call	0x6d2a	; 0x6d2a <strnlen_P>
    6af8:	8c 01       	movw	r16, r24
    6afa:	50 e8       	ldi	r21, 0x80	; 128
    6afc:	f5 2a       	or	r15, r21
    6afe:	f3 fe       	sbrs	r15, 3
    6b00:	07 c0       	rjmp	.+14     	; 0x6b10 <vfprintf+0x1a0>
    6b02:	1a c0       	rjmp	.+52     	; 0x6b38 <vfprintf+0x1c8>
    6b04:	80 e2       	ldi	r24, 0x20	; 32
    6b06:	90 e0       	ldi	r25, 0x00	; 0
    6b08:	b3 01       	movw	r22, r6
    6b0a:	0e 94 ab 36 	call	0x6d56	; 0x6d56 <fputc>
    6b0e:	ea 94       	dec	r14
    6b10:	8e 2d       	mov	r24, r14
    6b12:	90 e0       	ldi	r25, 0x00	; 0
    6b14:	08 17       	cp	r16, r24
    6b16:	19 07       	cpc	r17, r25
    6b18:	a8 f3       	brcs	.-22     	; 0x6b04 <vfprintf+0x194>
    6b1a:	0e c0       	rjmp	.+28     	; 0x6b38 <vfprintf+0x1c8>
    6b1c:	f6 01       	movw	r30, r12
    6b1e:	f7 fc       	sbrc	r15, 7
    6b20:	85 91       	lpm	r24, Z+
    6b22:	f7 fe       	sbrs	r15, 7
    6b24:	81 91       	ld	r24, Z+
    6b26:	6f 01       	movw	r12, r30
    6b28:	90 e0       	ldi	r25, 0x00	; 0
    6b2a:	b3 01       	movw	r22, r6
    6b2c:	0e 94 ab 36 	call	0x6d56	; 0x6d56 <fputc>
    6b30:	e1 10       	cpse	r14, r1
    6b32:	ea 94       	dec	r14
    6b34:	01 50       	subi	r16, 0x01	; 1
    6b36:	10 40       	sbci	r17, 0x00	; 0
    6b38:	01 15       	cp	r16, r1
    6b3a:	11 05       	cpc	r17, r1
    6b3c:	79 f7       	brne	.-34     	; 0x6b1c <vfprintf+0x1ac>
    6b3e:	ea c0       	rjmp	.+468    	; 0x6d14 <vfprintf+0x3a4>
    6b40:	94 36       	cpi	r25, 0x64	; 100
    6b42:	11 f0       	breq	.+4      	; 0x6b48 <vfprintf+0x1d8>
    6b44:	99 36       	cpi	r25, 0x69	; 105
    6b46:	69 f5       	brne	.+90     	; 0x6ba2 <vfprintf+0x232>
    6b48:	f7 fe       	sbrs	r15, 7
    6b4a:	08 c0       	rjmp	.+16     	; 0x6b5c <vfprintf+0x1ec>
    6b4c:	f5 01       	movw	r30, r10
    6b4e:	20 81       	ld	r18, Z
    6b50:	31 81       	ldd	r19, Z+1	; 0x01
    6b52:	42 81       	ldd	r20, Z+2	; 0x02
    6b54:	53 81       	ldd	r21, Z+3	; 0x03
    6b56:	84 e0       	ldi	r24, 0x04	; 4
    6b58:	90 e0       	ldi	r25, 0x00	; 0
    6b5a:	0a c0       	rjmp	.+20     	; 0x6b70 <vfprintf+0x200>
    6b5c:	f5 01       	movw	r30, r10
    6b5e:	80 81       	ld	r24, Z
    6b60:	91 81       	ldd	r25, Z+1	; 0x01
    6b62:	9c 01       	movw	r18, r24
    6b64:	44 27       	eor	r20, r20
    6b66:	37 fd       	sbrc	r19, 7
    6b68:	40 95       	com	r20
    6b6a:	54 2f       	mov	r21, r20
    6b6c:	82 e0       	ldi	r24, 0x02	; 2
    6b6e:	90 e0       	ldi	r25, 0x00	; 0
    6b70:	a8 0e       	add	r10, r24
    6b72:	b9 1e       	adc	r11, r25
    6b74:	9f e6       	ldi	r25, 0x6F	; 111
    6b76:	f9 22       	and	r15, r25
    6b78:	57 ff       	sbrs	r21, 7
    6b7a:	09 c0       	rjmp	.+18     	; 0x6b8e <vfprintf+0x21e>
    6b7c:	50 95       	com	r21
    6b7e:	40 95       	com	r20
    6b80:	30 95       	com	r19
    6b82:	21 95       	neg	r18
    6b84:	3f 4f       	sbci	r19, 0xFF	; 255
    6b86:	4f 4f       	sbci	r20, 0xFF	; 255
    6b88:	5f 4f       	sbci	r21, 0xFF	; 255
    6b8a:	e0 e8       	ldi	r30, 0x80	; 128
    6b8c:	fe 2a       	or	r15, r30
    6b8e:	ca 01       	movw	r24, r20
    6b90:	b9 01       	movw	r22, r18
    6b92:	a1 01       	movw	r20, r2
    6b94:	2a e0       	ldi	r18, 0x0A	; 10
    6b96:	30 e0       	ldi	r19, 0x00	; 0
    6b98:	0e 94 d7 36 	call	0x6dae	; 0x6dae <__ultoa_invert>
    6b9c:	d8 2e       	mov	r13, r24
    6b9e:	d2 18       	sub	r13, r2
    6ba0:	40 c0       	rjmp	.+128    	; 0x6c22 <vfprintf+0x2b2>
    6ba2:	95 37       	cpi	r25, 0x75	; 117
    6ba4:	29 f4       	brne	.+10     	; 0x6bb0 <vfprintf+0x240>
    6ba6:	1f 2d       	mov	r17, r15
    6ba8:	1f 7e       	andi	r17, 0xEF	; 239
    6baa:	2a e0       	ldi	r18, 0x0A	; 10
    6bac:	30 e0       	ldi	r19, 0x00	; 0
    6bae:	1d c0       	rjmp	.+58     	; 0x6bea <vfprintf+0x27a>
    6bb0:	1f 2d       	mov	r17, r15
    6bb2:	19 7f       	andi	r17, 0xF9	; 249
    6bb4:	9f 36       	cpi	r25, 0x6F	; 111
    6bb6:	61 f0       	breq	.+24     	; 0x6bd0 <vfprintf+0x260>
    6bb8:	90 37       	cpi	r25, 0x70	; 112
    6bba:	20 f4       	brcc	.+8      	; 0x6bc4 <vfprintf+0x254>
    6bbc:	98 35       	cpi	r25, 0x58	; 88
    6bbe:	09 f0       	breq	.+2      	; 0x6bc2 <vfprintf+0x252>
    6bc0:	ac c0       	rjmp	.+344    	; 0x6d1a <vfprintf+0x3aa>
    6bc2:	0f c0       	rjmp	.+30     	; 0x6be2 <vfprintf+0x272>
    6bc4:	90 37       	cpi	r25, 0x70	; 112
    6bc6:	39 f0       	breq	.+14     	; 0x6bd6 <vfprintf+0x266>
    6bc8:	98 37       	cpi	r25, 0x78	; 120
    6bca:	09 f0       	breq	.+2      	; 0x6bce <vfprintf+0x25e>
    6bcc:	a6 c0       	rjmp	.+332    	; 0x6d1a <vfprintf+0x3aa>
    6bce:	04 c0       	rjmp	.+8      	; 0x6bd8 <vfprintf+0x268>
    6bd0:	28 e0       	ldi	r18, 0x08	; 8
    6bd2:	30 e0       	ldi	r19, 0x00	; 0
    6bd4:	0a c0       	rjmp	.+20     	; 0x6bea <vfprintf+0x27a>
    6bd6:	10 61       	ori	r17, 0x10	; 16
    6bd8:	14 fd       	sbrc	r17, 4
    6bda:	14 60       	ori	r17, 0x04	; 4
    6bdc:	20 e1       	ldi	r18, 0x10	; 16
    6bde:	30 e0       	ldi	r19, 0x00	; 0
    6be0:	04 c0       	rjmp	.+8      	; 0x6bea <vfprintf+0x27a>
    6be2:	14 fd       	sbrc	r17, 4
    6be4:	16 60       	ori	r17, 0x06	; 6
    6be6:	20 e1       	ldi	r18, 0x10	; 16
    6be8:	32 e0       	ldi	r19, 0x02	; 2
    6bea:	17 ff       	sbrs	r17, 7
    6bec:	08 c0       	rjmp	.+16     	; 0x6bfe <vfprintf+0x28e>
    6bee:	f5 01       	movw	r30, r10
    6bf0:	60 81       	ld	r22, Z
    6bf2:	71 81       	ldd	r23, Z+1	; 0x01
    6bf4:	82 81       	ldd	r24, Z+2	; 0x02
    6bf6:	93 81       	ldd	r25, Z+3	; 0x03
    6bf8:	44 e0       	ldi	r20, 0x04	; 4
    6bfa:	50 e0       	ldi	r21, 0x00	; 0
    6bfc:	08 c0       	rjmp	.+16     	; 0x6c0e <vfprintf+0x29e>
    6bfe:	f5 01       	movw	r30, r10
    6c00:	80 81       	ld	r24, Z
    6c02:	91 81       	ldd	r25, Z+1	; 0x01
    6c04:	bc 01       	movw	r22, r24
    6c06:	80 e0       	ldi	r24, 0x00	; 0
    6c08:	90 e0       	ldi	r25, 0x00	; 0
    6c0a:	42 e0       	ldi	r20, 0x02	; 2
    6c0c:	50 e0       	ldi	r21, 0x00	; 0
    6c0e:	a4 0e       	add	r10, r20
    6c10:	b5 1e       	adc	r11, r21
    6c12:	a1 01       	movw	r20, r2
    6c14:	0e 94 d7 36 	call	0x6dae	; 0x6dae <__ultoa_invert>
    6c18:	d8 2e       	mov	r13, r24
    6c1a:	d2 18       	sub	r13, r2
    6c1c:	8f e7       	ldi	r24, 0x7F	; 127
    6c1e:	f8 2e       	mov	r15, r24
    6c20:	f1 22       	and	r15, r17
    6c22:	f6 fe       	sbrs	r15, 6
    6c24:	0b c0       	rjmp	.+22     	; 0x6c3c <vfprintf+0x2cc>
    6c26:	5e ef       	ldi	r21, 0xFE	; 254
    6c28:	f5 22       	and	r15, r21
    6c2a:	d9 14       	cp	r13, r9
    6c2c:	38 f4       	brcc	.+14     	; 0x6c3c <vfprintf+0x2cc>
    6c2e:	f4 fe       	sbrs	r15, 4
    6c30:	07 c0       	rjmp	.+14     	; 0x6c40 <vfprintf+0x2d0>
    6c32:	f2 fc       	sbrc	r15, 2
    6c34:	05 c0       	rjmp	.+10     	; 0x6c40 <vfprintf+0x2d0>
    6c36:	8f ee       	ldi	r24, 0xEF	; 239
    6c38:	f8 22       	and	r15, r24
    6c3a:	02 c0       	rjmp	.+4      	; 0x6c40 <vfprintf+0x2d0>
    6c3c:	1d 2d       	mov	r17, r13
    6c3e:	01 c0       	rjmp	.+2      	; 0x6c42 <vfprintf+0x2d2>
    6c40:	19 2d       	mov	r17, r9
    6c42:	f4 fe       	sbrs	r15, 4
    6c44:	0d c0       	rjmp	.+26     	; 0x6c60 <vfprintf+0x2f0>
    6c46:	fe 01       	movw	r30, r28
    6c48:	ed 0d       	add	r30, r13
    6c4a:	f1 1d       	adc	r31, r1
    6c4c:	80 81       	ld	r24, Z
    6c4e:	80 33       	cpi	r24, 0x30	; 48
    6c50:	19 f4       	brne	.+6      	; 0x6c58 <vfprintf+0x2e8>
    6c52:	99 ee       	ldi	r25, 0xE9	; 233
    6c54:	f9 22       	and	r15, r25
    6c56:	08 c0       	rjmp	.+16     	; 0x6c68 <vfprintf+0x2f8>
    6c58:	1f 5f       	subi	r17, 0xFF	; 255
    6c5a:	f2 fe       	sbrs	r15, 2
    6c5c:	05 c0       	rjmp	.+10     	; 0x6c68 <vfprintf+0x2f8>
    6c5e:	03 c0       	rjmp	.+6      	; 0x6c66 <vfprintf+0x2f6>
    6c60:	8f 2d       	mov	r24, r15
    6c62:	86 78       	andi	r24, 0x86	; 134
    6c64:	09 f0       	breq	.+2      	; 0x6c68 <vfprintf+0x2f8>
    6c66:	1f 5f       	subi	r17, 0xFF	; 255
    6c68:	0f 2d       	mov	r16, r15
    6c6a:	f3 fc       	sbrc	r15, 3
    6c6c:	14 c0       	rjmp	.+40     	; 0x6c96 <vfprintf+0x326>
    6c6e:	f0 fe       	sbrs	r15, 0
    6c70:	0f c0       	rjmp	.+30     	; 0x6c90 <vfprintf+0x320>
    6c72:	1e 15       	cp	r17, r14
    6c74:	10 f0       	brcs	.+4      	; 0x6c7a <vfprintf+0x30a>
    6c76:	9d 2c       	mov	r9, r13
    6c78:	0b c0       	rjmp	.+22     	; 0x6c90 <vfprintf+0x320>
    6c7a:	9d 2c       	mov	r9, r13
    6c7c:	9e 0c       	add	r9, r14
    6c7e:	91 1a       	sub	r9, r17
    6c80:	1e 2d       	mov	r17, r14
    6c82:	06 c0       	rjmp	.+12     	; 0x6c90 <vfprintf+0x320>
    6c84:	80 e2       	ldi	r24, 0x20	; 32
    6c86:	90 e0       	ldi	r25, 0x00	; 0
    6c88:	b3 01       	movw	r22, r6
    6c8a:	0e 94 ab 36 	call	0x6d56	; 0x6d56 <fputc>
    6c8e:	1f 5f       	subi	r17, 0xFF	; 255
    6c90:	1e 15       	cp	r17, r14
    6c92:	c0 f3       	brcs	.-16     	; 0x6c84 <vfprintf+0x314>
    6c94:	04 c0       	rjmp	.+8      	; 0x6c9e <vfprintf+0x32e>
    6c96:	1e 15       	cp	r17, r14
    6c98:	10 f4       	brcc	.+4      	; 0x6c9e <vfprintf+0x32e>
    6c9a:	e1 1a       	sub	r14, r17
    6c9c:	01 c0       	rjmp	.+2      	; 0x6ca0 <vfprintf+0x330>
    6c9e:	ee 24       	eor	r14, r14
    6ca0:	04 ff       	sbrs	r16, 4
    6ca2:	0f c0       	rjmp	.+30     	; 0x6cc2 <vfprintf+0x352>
    6ca4:	80 e3       	ldi	r24, 0x30	; 48
    6ca6:	90 e0       	ldi	r25, 0x00	; 0
    6ca8:	b3 01       	movw	r22, r6
    6caa:	0e 94 ab 36 	call	0x6d56	; 0x6d56 <fputc>
    6cae:	02 ff       	sbrs	r16, 2
    6cb0:	1d c0       	rjmp	.+58     	; 0x6cec <vfprintf+0x37c>
    6cb2:	01 fd       	sbrc	r16, 1
    6cb4:	03 c0       	rjmp	.+6      	; 0x6cbc <vfprintf+0x34c>
    6cb6:	88 e7       	ldi	r24, 0x78	; 120
    6cb8:	90 e0       	ldi	r25, 0x00	; 0
    6cba:	0e c0       	rjmp	.+28     	; 0x6cd8 <vfprintf+0x368>
    6cbc:	88 e5       	ldi	r24, 0x58	; 88
    6cbe:	90 e0       	ldi	r25, 0x00	; 0
    6cc0:	0b c0       	rjmp	.+22     	; 0x6cd8 <vfprintf+0x368>
    6cc2:	80 2f       	mov	r24, r16
    6cc4:	86 78       	andi	r24, 0x86	; 134
    6cc6:	91 f0       	breq	.+36     	; 0x6cec <vfprintf+0x37c>
    6cc8:	01 ff       	sbrs	r16, 1
    6cca:	02 c0       	rjmp	.+4      	; 0x6cd0 <vfprintf+0x360>
    6ccc:	8b e2       	ldi	r24, 0x2B	; 43
    6cce:	01 c0       	rjmp	.+2      	; 0x6cd2 <vfprintf+0x362>
    6cd0:	80 e2       	ldi	r24, 0x20	; 32
    6cd2:	f7 fc       	sbrc	r15, 7
    6cd4:	8d e2       	ldi	r24, 0x2D	; 45
    6cd6:	90 e0       	ldi	r25, 0x00	; 0
    6cd8:	b3 01       	movw	r22, r6
    6cda:	0e 94 ab 36 	call	0x6d56	; 0x6d56 <fputc>
    6cde:	06 c0       	rjmp	.+12     	; 0x6cec <vfprintf+0x37c>
    6ce0:	80 e3       	ldi	r24, 0x30	; 48
    6ce2:	90 e0       	ldi	r25, 0x00	; 0
    6ce4:	b3 01       	movw	r22, r6
    6ce6:	0e 94 ab 36 	call	0x6d56	; 0x6d56 <fputc>
    6cea:	9a 94       	dec	r9
    6cec:	d9 14       	cp	r13, r9
    6cee:	c0 f3       	brcs	.-16     	; 0x6ce0 <vfprintf+0x370>
    6cf0:	da 94       	dec	r13
    6cf2:	f1 01       	movw	r30, r2
    6cf4:	ed 0d       	add	r30, r13
    6cf6:	f1 1d       	adc	r31, r1
    6cf8:	80 81       	ld	r24, Z
    6cfa:	90 e0       	ldi	r25, 0x00	; 0
    6cfc:	b3 01       	movw	r22, r6
    6cfe:	0e 94 ab 36 	call	0x6d56	; 0x6d56 <fputc>
    6d02:	dd 20       	and	r13, r13
    6d04:	a9 f7       	brne	.-22     	; 0x6cf0 <vfprintf+0x380>
    6d06:	06 c0       	rjmp	.+12     	; 0x6d14 <vfprintf+0x3a4>
    6d08:	80 e2       	ldi	r24, 0x20	; 32
    6d0a:	90 e0       	ldi	r25, 0x00	; 0
    6d0c:	b3 01       	movw	r22, r6
    6d0e:	0e 94 ab 36 	call	0x6d56	; 0x6d56 <fputc>
    6d12:	ea 94       	dec	r14
    6d14:	ee 20       	and	r14, r14
    6d16:	c1 f7       	brne	.-16     	; 0x6d08 <vfprintf+0x398>
    6d18:	43 ce       	rjmp	.-890    	; 0x69a0 <vfprintf+0x30>
    6d1a:	f3 01       	movw	r30, r6
    6d1c:	66 81       	ldd	r22, Z+6	; 0x06
    6d1e:	77 81       	ldd	r23, Z+7	; 0x07
    6d20:	cb 01       	movw	r24, r22
    6d22:	2b 96       	adiw	r28, 0x0b	; 11
    6d24:	e2 e1       	ldi	r30, 0x12	; 18
    6d26:	0c 94 5a 34 	jmp	0x68b4	; 0x68b4 <__epilogue_restores__>

00006d2a <strnlen_P>:
    6d2a:	fc 01       	movw	r30, r24
    6d2c:	05 90       	lpm	r0, Z+
    6d2e:	61 50       	subi	r22, 0x01	; 1
    6d30:	70 40       	sbci	r23, 0x00	; 0
    6d32:	01 10       	cpse	r0, r1
    6d34:	d8 f7       	brcc	.-10     	; 0x6d2c <strnlen_P+0x2>
    6d36:	80 95       	com	r24
    6d38:	90 95       	com	r25
    6d3a:	8e 0f       	add	r24, r30
    6d3c:	9f 1f       	adc	r25, r31
    6d3e:	08 95       	ret

00006d40 <strnlen>:
    6d40:	fc 01       	movw	r30, r24
    6d42:	61 50       	subi	r22, 0x01	; 1
    6d44:	70 40       	sbci	r23, 0x00	; 0
    6d46:	01 90       	ld	r0, Z+
    6d48:	01 10       	cpse	r0, r1
    6d4a:	d8 f7       	brcc	.-10     	; 0x6d42 <strnlen+0x2>
    6d4c:	80 95       	com	r24
    6d4e:	90 95       	com	r25
    6d50:	8e 0f       	add	r24, r30
    6d52:	9f 1f       	adc	r25, r31
    6d54:	08 95       	ret

00006d56 <fputc>:
    6d56:	0f 93       	push	r16
    6d58:	1f 93       	push	r17
    6d5a:	cf 93       	push	r28
    6d5c:	df 93       	push	r29
    6d5e:	8c 01       	movw	r16, r24
    6d60:	eb 01       	movw	r28, r22
    6d62:	8b 81       	ldd	r24, Y+3	; 0x03
    6d64:	81 ff       	sbrs	r24, 1
    6d66:	1b c0       	rjmp	.+54     	; 0x6d9e <fputc+0x48>
    6d68:	82 ff       	sbrs	r24, 2
    6d6a:	0d c0       	rjmp	.+26     	; 0x6d86 <fputc+0x30>
    6d6c:	2e 81       	ldd	r18, Y+6	; 0x06
    6d6e:	3f 81       	ldd	r19, Y+7	; 0x07
    6d70:	8c 81       	ldd	r24, Y+4	; 0x04
    6d72:	9d 81       	ldd	r25, Y+5	; 0x05
    6d74:	28 17       	cp	r18, r24
    6d76:	39 07       	cpc	r19, r25
    6d78:	64 f4       	brge	.+24     	; 0x6d92 <fputc+0x3c>
    6d7a:	e8 81       	ld	r30, Y
    6d7c:	f9 81       	ldd	r31, Y+1	; 0x01
    6d7e:	01 93       	st	Z+, r16
    6d80:	f9 83       	std	Y+1, r31	; 0x01
    6d82:	e8 83       	st	Y, r30
    6d84:	06 c0       	rjmp	.+12     	; 0x6d92 <fputc+0x3c>
    6d86:	e8 85       	ldd	r30, Y+8	; 0x08
    6d88:	f9 85       	ldd	r31, Y+9	; 0x09
    6d8a:	80 2f       	mov	r24, r16
    6d8c:	09 95       	icall
    6d8e:	89 2b       	or	r24, r25
    6d90:	31 f4       	brne	.+12     	; 0x6d9e <fputc+0x48>
    6d92:	8e 81       	ldd	r24, Y+6	; 0x06
    6d94:	9f 81       	ldd	r25, Y+7	; 0x07
    6d96:	01 96       	adiw	r24, 0x01	; 1
    6d98:	9f 83       	std	Y+7, r25	; 0x07
    6d9a:	8e 83       	std	Y+6, r24	; 0x06
    6d9c:	02 c0       	rjmp	.+4      	; 0x6da2 <fputc+0x4c>
    6d9e:	0f ef       	ldi	r16, 0xFF	; 255
    6da0:	1f ef       	ldi	r17, 0xFF	; 255
    6da2:	c8 01       	movw	r24, r16
    6da4:	df 91       	pop	r29
    6da6:	cf 91       	pop	r28
    6da8:	1f 91       	pop	r17
    6daa:	0f 91       	pop	r16
    6dac:	08 95       	ret

00006dae <__ultoa_invert>:
    6dae:	fa 01       	movw	r30, r20
    6db0:	aa 27       	eor	r26, r26
    6db2:	28 30       	cpi	r18, 0x08	; 8
    6db4:	51 f1       	breq	.+84     	; 0x6e0a <__ultoa_invert+0x5c>
    6db6:	20 31       	cpi	r18, 0x10	; 16
    6db8:	81 f1       	breq	.+96     	; 0x6e1a <__ultoa_invert+0x6c>
    6dba:	e8 94       	clt
    6dbc:	6f 93       	push	r22
    6dbe:	6e 7f       	andi	r22, 0xFE	; 254
    6dc0:	6e 5f       	subi	r22, 0xFE	; 254
    6dc2:	7f 4f       	sbci	r23, 0xFF	; 255
    6dc4:	8f 4f       	sbci	r24, 0xFF	; 255
    6dc6:	9f 4f       	sbci	r25, 0xFF	; 255
    6dc8:	af 4f       	sbci	r26, 0xFF	; 255
    6dca:	b1 e0       	ldi	r27, 0x01	; 1
    6dcc:	3e d0       	rcall	.+124    	; 0x6e4a <__ultoa_invert+0x9c>
    6dce:	b4 e0       	ldi	r27, 0x04	; 4
    6dd0:	3c d0       	rcall	.+120    	; 0x6e4a <__ultoa_invert+0x9c>
    6dd2:	67 0f       	add	r22, r23
    6dd4:	78 1f       	adc	r23, r24
    6dd6:	89 1f       	adc	r24, r25
    6dd8:	9a 1f       	adc	r25, r26
    6dda:	a1 1d       	adc	r26, r1
    6ddc:	68 0f       	add	r22, r24
    6dde:	79 1f       	adc	r23, r25
    6de0:	8a 1f       	adc	r24, r26
    6de2:	91 1d       	adc	r25, r1
    6de4:	a1 1d       	adc	r26, r1
    6de6:	6a 0f       	add	r22, r26
    6de8:	71 1d       	adc	r23, r1
    6dea:	81 1d       	adc	r24, r1
    6dec:	91 1d       	adc	r25, r1
    6dee:	a1 1d       	adc	r26, r1
    6df0:	20 d0       	rcall	.+64     	; 0x6e32 <__ultoa_invert+0x84>
    6df2:	09 f4       	brne	.+2      	; 0x6df6 <__ultoa_invert+0x48>
    6df4:	68 94       	set
    6df6:	3f 91       	pop	r19
    6df8:	2a e0       	ldi	r18, 0x0A	; 10
    6dfa:	26 9f       	mul	r18, r22
    6dfc:	11 24       	eor	r1, r1
    6dfe:	30 19       	sub	r19, r0
    6e00:	30 5d       	subi	r19, 0xD0	; 208
    6e02:	31 93       	st	Z+, r19
    6e04:	de f6       	brtc	.-74     	; 0x6dbc <__ultoa_invert+0xe>
    6e06:	cf 01       	movw	r24, r30
    6e08:	08 95       	ret
    6e0a:	46 2f       	mov	r20, r22
    6e0c:	47 70       	andi	r20, 0x07	; 7
    6e0e:	40 5d       	subi	r20, 0xD0	; 208
    6e10:	41 93       	st	Z+, r20
    6e12:	b3 e0       	ldi	r27, 0x03	; 3
    6e14:	0f d0       	rcall	.+30     	; 0x6e34 <__ultoa_invert+0x86>
    6e16:	c9 f7       	brne	.-14     	; 0x6e0a <__ultoa_invert+0x5c>
    6e18:	f6 cf       	rjmp	.-20     	; 0x6e06 <__ultoa_invert+0x58>
    6e1a:	46 2f       	mov	r20, r22
    6e1c:	4f 70       	andi	r20, 0x0F	; 15
    6e1e:	40 5d       	subi	r20, 0xD0	; 208
    6e20:	4a 33       	cpi	r20, 0x3A	; 58
    6e22:	18 f0       	brcs	.+6      	; 0x6e2a <__ultoa_invert+0x7c>
    6e24:	49 5d       	subi	r20, 0xD9	; 217
    6e26:	31 fd       	sbrc	r19, 1
    6e28:	40 52       	subi	r20, 0x20	; 32
    6e2a:	41 93       	st	Z+, r20
    6e2c:	02 d0       	rcall	.+4      	; 0x6e32 <__ultoa_invert+0x84>
    6e2e:	a9 f7       	brne	.-22     	; 0x6e1a <__ultoa_invert+0x6c>
    6e30:	ea cf       	rjmp	.-44     	; 0x6e06 <__ultoa_invert+0x58>
    6e32:	b4 e0       	ldi	r27, 0x04	; 4
    6e34:	a6 95       	lsr	r26
    6e36:	97 95       	ror	r25
    6e38:	87 95       	ror	r24
    6e3a:	77 95       	ror	r23
    6e3c:	67 95       	ror	r22
    6e3e:	ba 95       	dec	r27
    6e40:	c9 f7       	brne	.-14     	; 0x6e34 <__ultoa_invert+0x86>
    6e42:	00 97       	sbiw	r24, 0x00	; 0
    6e44:	61 05       	cpc	r22, r1
    6e46:	71 05       	cpc	r23, r1
    6e48:	08 95       	ret
    6e4a:	9b 01       	movw	r18, r22
    6e4c:	ac 01       	movw	r20, r24
    6e4e:	0a 2e       	mov	r0, r26
    6e50:	06 94       	lsr	r0
    6e52:	57 95       	ror	r21
    6e54:	47 95       	ror	r20
    6e56:	37 95       	ror	r19
    6e58:	27 95       	ror	r18
    6e5a:	ba 95       	dec	r27
    6e5c:	c9 f7       	brne	.-14     	; 0x6e50 <__ultoa_invert+0xa2>
    6e5e:	62 0f       	add	r22, r18
    6e60:	73 1f       	adc	r23, r19
    6e62:	84 1f       	adc	r24, r20
    6e64:	95 1f       	adc	r25, r21
    6e66:	a0 1d       	adc	r26, r0
    6e68:	08 95       	ret

00006e6a <_exit>:
    6e6a:	f8 94       	cli

00006e6c <__stop_program>:
    6e6c:	ff cf       	rjmp	.-2      	; 0x6e6c <__stop_program>
