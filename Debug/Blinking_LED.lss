
Blinking_LED.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         00006990  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         0000015c  00800060  00006990  00006a24  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000578  008001bc  008001bc  00006b80  2**0
                  ALLOC
  3 .stab         000089b8  00000000  00000000  00006b80  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00004c69  00000000  00000000  0000f538  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 000001a0  00000000  00000000  000141a1  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000001f2  00000000  00000000  00014341  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0000240b  00000000  00000000  00014533  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00001386  00000000  00000000  0001693e  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   000011d6  00000000  00000000  00017cc4  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  000001c0  00000000  00000000  00018e9c  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    000002f6  00000000  00000000  0001905c  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000096e  00000000  00000000  00019352  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_ranges 00000050  00000000  00000000  00019cc0  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 2a 00 	jmp	0x54	; 0x54 <__ctors_end>
       4:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       8:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
       c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      10:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      14:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      18:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      1c:	0c 94 65 0e 	jmp	0x1cca	; 0x1cca <__vector_7>
      20:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      24:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      28:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      2c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      30:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      34:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      38:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      3c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      40:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      44:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      48:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      4c:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>
      50:	0c 94 47 00 	jmp	0x8e	; 0x8e <__bad_interrupt>

00000054 <__ctors_end>:
      54:	11 24       	eor	r1, r1
      56:	1f be       	out	0x3f, r1	; 63
      58:	cf e5       	ldi	r28, 0x5F	; 95
      5a:	d8 e0       	ldi	r29, 0x08	; 8
      5c:	de bf       	out	0x3e, r29	; 62
      5e:	cd bf       	out	0x3d, r28	; 61

00000060 <__do_copy_data>:
      60:	11 e0       	ldi	r17, 0x01	; 1
      62:	a0 e6       	ldi	r26, 0x60	; 96
      64:	b0 e0       	ldi	r27, 0x00	; 0
      66:	e0 e9       	ldi	r30, 0x90	; 144
      68:	f9 e6       	ldi	r31, 0x69	; 105
      6a:	02 c0       	rjmp	.+4      	; 0x70 <.do_copy_data_start>

0000006c <.do_copy_data_loop>:
      6c:	05 90       	lpm	r0, Z+
      6e:	0d 92       	st	X+, r0

00000070 <.do_copy_data_start>:
      70:	ac 3b       	cpi	r26, 0xBC	; 188
      72:	b1 07       	cpc	r27, r17
      74:	d9 f7       	brne	.-10     	; 0x6c <.do_copy_data_loop>

00000076 <__do_clear_bss>:
      76:	17 e0       	ldi	r17, 0x07	; 7
      78:	ac eb       	ldi	r26, 0xBC	; 188
      7a:	b1 e0       	ldi	r27, 0x01	; 1
      7c:	01 c0       	rjmp	.+2      	; 0x80 <.do_clear_bss_start>

0000007e <.do_clear_bss_loop>:
      7e:	1d 92       	st	X+, r1

00000080 <.do_clear_bss_start>:
      80:	a4 33       	cpi	r26, 0x34	; 52
      82:	b1 07       	cpc	r27, r17
      84:	e1 f7       	brne	.-8      	; 0x7e <.do_clear_bss_loop>
      86:	0e 94 b1 21 	call	0x4362	; 0x4362 <main>
      8a:	0c 94 c6 34 	jmp	0x698c	; 0x698c <_exit>

0000008e <__bad_interrupt>:
      8e:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

00000092 <__fixunssfsi>:
      92:	ef 92       	push	r14
      94:	ff 92       	push	r15
      96:	0f 93       	push	r16
      98:	1f 93       	push	r17
      9a:	7b 01       	movw	r14, r22
      9c:	8c 01       	movw	r16, r24
      9e:	20 e0       	ldi	r18, 0x00	; 0
      a0:	30 e0       	ldi	r19, 0x00	; 0
      a2:	40 e0       	ldi	r20, 0x00	; 0
      a4:	5f e4       	ldi	r21, 0x4F	; 79
      a6:	0e 94 f5 03 	call	0x7ea	; 0x7ea <__gesf2>
      aa:	88 23       	and	r24, r24
      ac:	8c f0       	brlt	.+34     	; 0xd0 <__fixunssfsi+0x3e>
      ae:	c8 01       	movw	r24, r16
      b0:	b7 01       	movw	r22, r14
      b2:	20 e0       	ldi	r18, 0x00	; 0
      b4:	30 e0       	ldi	r19, 0x00	; 0
      b6:	40 e0       	ldi	r20, 0x00	; 0
      b8:	5f e4       	ldi	r21, 0x4F	; 79
      ba:	0e 94 c1 01 	call	0x382	; 0x382 <__subsf3>
      be:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      c2:	9b 01       	movw	r18, r22
      c4:	ac 01       	movw	r20, r24
      c6:	20 50       	subi	r18, 0x00	; 0
      c8:	30 40       	sbci	r19, 0x00	; 0
      ca:	40 40       	sbci	r20, 0x00	; 0
      cc:	50 48       	sbci	r21, 0x80	; 128
      ce:	06 c0       	rjmp	.+12     	; 0xdc <__fixunssfsi+0x4a>
      d0:	c8 01       	movw	r24, r16
      d2:	b7 01       	movw	r22, r14
      d4:	0e 94 55 04 	call	0x8aa	; 0x8aa <__fixsfsi>
      d8:	9b 01       	movw	r18, r22
      da:	ac 01       	movw	r20, r24
      dc:	b9 01       	movw	r22, r18
      de:	ca 01       	movw	r24, r20
      e0:	1f 91       	pop	r17
      e2:	0f 91       	pop	r16
      e4:	ff 90       	pop	r15
      e6:	ef 90       	pop	r14
      e8:	08 95       	ret

000000ea <_fpadd_parts>:
      ea:	a0 e0       	ldi	r26, 0x00	; 0
      ec:	b0 e0       	ldi	r27, 0x00	; 0
      ee:	eb e7       	ldi	r30, 0x7B	; 123
      f0:	f0 e0       	ldi	r31, 0x00	; 0
      f2:	0c 94 cf 31 	jmp	0x639e	; 0x639e <__prologue_saves__>
      f6:	dc 01       	movw	r26, r24
      f8:	2b 01       	movw	r4, r22
      fa:	fa 01       	movw	r30, r20
      fc:	9c 91       	ld	r25, X
      fe:	92 30       	cpi	r25, 0x02	; 2
     100:	08 f4       	brcc	.+2      	; 0x104 <_fpadd_parts+0x1a>
     102:	39 c1       	rjmp	.+626    	; 0x376 <_fpadd_parts+0x28c>
     104:	eb 01       	movw	r28, r22
     106:	88 81       	ld	r24, Y
     108:	82 30       	cpi	r24, 0x02	; 2
     10a:	08 f4       	brcc	.+2      	; 0x10e <_fpadd_parts+0x24>
     10c:	33 c1       	rjmp	.+614    	; 0x374 <_fpadd_parts+0x28a>
     10e:	94 30       	cpi	r25, 0x04	; 4
     110:	69 f4       	brne	.+26     	; 0x12c <_fpadd_parts+0x42>
     112:	84 30       	cpi	r24, 0x04	; 4
     114:	09 f0       	breq	.+2      	; 0x118 <_fpadd_parts+0x2e>
     116:	2f c1       	rjmp	.+606    	; 0x376 <_fpadd_parts+0x28c>
     118:	11 96       	adiw	r26, 0x01	; 1
     11a:	9c 91       	ld	r25, X
     11c:	11 97       	sbiw	r26, 0x01	; 1
     11e:	89 81       	ldd	r24, Y+1	; 0x01
     120:	98 17       	cp	r25, r24
     122:	09 f4       	brne	.+2      	; 0x126 <_fpadd_parts+0x3c>
     124:	28 c1       	rjmp	.+592    	; 0x376 <_fpadd_parts+0x28c>
     126:	a7 e9       	ldi	r26, 0x97	; 151
     128:	b0 e0       	ldi	r27, 0x00	; 0
     12a:	25 c1       	rjmp	.+586    	; 0x376 <_fpadd_parts+0x28c>
     12c:	84 30       	cpi	r24, 0x04	; 4
     12e:	09 f4       	brne	.+2      	; 0x132 <_fpadd_parts+0x48>
     130:	21 c1       	rjmp	.+578    	; 0x374 <_fpadd_parts+0x28a>
     132:	82 30       	cpi	r24, 0x02	; 2
     134:	a9 f4       	brne	.+42     	; 0x160 <_fpadd_parts+0x76>
     136:	92 30       	cpi	r25, 0x02	; 2
     138:	09 f0       	breq	.+2      	; 0x13c <_fpadd_parts+0x52>
     13a:	1d c1       	rjmp	.+570    	; 0x376 <_fpadd_parts+0x28c>
     13c:	9a 01       	movw	r18, r20
     13e:	ad 01       	movw	r20, r26
     140:	88 e0       	ldi	r24, 0x08	; 8
     142:	ea 01       	movw	r28, r20
     144:	09 90       	ld	r0, Y+
     146:	ae 01       	movw	r20, r28
     148:	e9 01       	movw	r28, r18
     14a:	09 92       	st	Y+, r0
     14c:	9e 01       	movw	r18, r28
     14e:	81 50       	subi	r24, 0x01	; 1
     150:	c1 f7       	brne	.-16     	; 0x142 <_fpadd_parts+0x58>
     152:	e2 01       	movw	r28, r4
     154:	89 81       	ldd	r24, Y+1	; 0x01
     156:	11 96       	adiw	r26, 0x01	; 1
     158:	9c 91       	ld	r25, X
     15a:	89 23       	and	r24, r25
     15c:	81 83       	std	Z+1, r24	; 0x01
     15e:	08 c1       	rjmp	.+528    	; 0x370 <_fpadd_parts+0x286>
     160:	92 30       	cpi	r25, 0x02	; 2
     162:	09 f4       	brne	.+2      	; 0x166 <_fpadd_parts+0x7c>
     164:	07 c1       	rjmp	.+526    	; 0x374 <_fpadd_parts+0x28a>
     166:	12 96       	adiw	r26, 0x02	; 2
     168:	2d 90       	ld	r2, X+
     16a:	3c 90       	ld	r3, X
     16c:	13 97       	sbiw	r26, 0x03	; 3
     16e:	eb 01       	movw	r28, r22
     170:	8a 81       	ldd	r24, Y+2	; 0x02
     172:	9b 81       	ldd	r25, Y+3	; 0x03
     174:	14 96       	adiw	r26, 0x04	; 4
     176:	ad 90       	ld	r10, X+
     178:	bd 90       	ld	r11, X+
     17a:	cd 90       	ld	r12, X+
     17c:	dc 90       	ld	r13, X
     17e:	17 97       	sbiw	r26, 0x07	; 7
     180:	ec 80       	ldd	r14, Y+4	; 0x04
     182:	fd 80       	ldd	r15, Y+5	; 0x05
     184:	0e 81       	ldd	r16, Y+6	; 0x06
     186:	1f 81       	ldd	r17, Y+7	; 0x07
     188:	91 01       	movw	r18, r2
     18a:	28 1b       	sub	r18, r24
     18c:	39 0b       	sbc	r19, r25
     18e:	b9 01       	movw	r22, r18
     190:	37 ff       	sbrs	r19, 7
     192:	04 c0       	rjmp	.+8      	; 0x19c <_fpadd_parts+0xb2>
     194:	66 27       	eor	r22, r22
     196:	77 27       	eor	r23, r23
     198:	62 1b       	sub	r22, r18
     19a:	73 0b       	sbc	r23, r19
     19c:	60 32       	cpi	r22, 0x20	; 32
     19e:	71 05       	cpc	r23, r1
     1a0:	0c f0       	brlt	.+2      	; 0x1a4 <_fpadd_parts+0xba>
     1a2:	61 c0       	rjmp	.+194    	; 0x266 <_fpadd_parts+0x17c>
     1a4:	12 16       	cp	r1, r18
     1a6:	13 06       	cpc	r1, r19
     1a8:	6c f5       	brge	.+90     	; 0x204 <_fpadd_parts+0x11a>
     1aa:	37 01       	movw	r6, r14
     1ac:	48 01       	movw	r8, r16
     1ae:	06 2e       	mov	r0, r22
     1b0:	04 c0       	rjmp	.+8      	; 0x1ba <_fpadd_parts+0xd0>
     1b2:	96 94       	lsr	r9
     1b4:	87 94       	ror	r8
     1b6:	77 94       	ror	r7
     1b8:	67 94       	ror	r6
     1ba:	0a 94       	dec	r0
     1bc:	d2 f7       	brpl	.-12     	; 0x1b2 <_fpadd_parts+0xc8>
     1be:	21 e0       	ldi	r18, 0x01	; 1
     1c0:	30 e0       	ldi	r19, 0x00	; 0
     1c2:	40 e0       	ldi	r20, 0x00	; 0
     1c4:	50 e0       	ldi	r21, 0x00	; 0
     1c6:	04 c0       	rjmp	.+8      	; 0x1d0 <_fpadd_parts+0xe6>
     1c8:	22 0f       	add	r18, r18
     1ca:	33 1f       	adc	r19, r19
     1cc:	44 1f       	adc	r20, r20
     1ce:	55 1f       	adc	r21, r21
     1d0:	6a 95       	dec	r22
     1d2:	d2 f7       	brpl	.-12     	; 0x1c8 <_fpadd_parts+0xde>
     1d4:	21 50       	subi	r18, 0x01	; 1
     1d6:	30 40       	sbci	r19, 0x00	; 0
     1d8:	40 40       	sbci	r20, 0x00	; 0
     1da:	50 40       	sbci	r21, 0x00	; 0
     1dc:	2e 21       	and	r18, r14
     1de:	3f 21       	and	r19, r15
     1e0:	40 23       	and	r20, r16
     1e2:	51 23       	and	r21, r17
     1e4:	21 15       	cp	r18, r1
     1e6:	31 05       	cpc	r19, r1
     1e8:	41 05       	cpc	r20, r1
     1ea:	51 05       	cpc	r21, r1
     1ec:	21 f0       	breq	.+8      	; 0x1f6 <_fpadd_parts+0x10c>
     1ee:	21 e0       	ldi	r18, 0x01	; 1
     1f0:	30 e0       	ldi	r19, 0x00	; 0
     1f2:	40 e0       	ldi	r20, 0x00	; 0
     1f4:	50 e0       	ldi	r21, 0x00	; 0
     1f6:	79 01       	movw	r14, r18
     1f8:	8a 01       	movw	r16, r20
     1fa:	e6 28       	or	r14, r6
     1fc:	f7 28       	or	r15, r7
     1fe:	08 29       	or	r16, r8
     200:	19 29       	or	r17, r9
     202:	3c c0       	rjmp	.+120    	; 0x27c <_fpadd_parts+0x192>
     204:	23 2b       	or	r18, r19
     206:	d1 f1       	breq	.+116    	; 0x27c <_fpadd_parts+0x192>
     208:	26 0e       	add	r2, r22
     20a:	37 1e       	adc	r3, r23
     20c:	35 01       	movw	r6, r10
     20e:	46 01       	movw	r8, r12
     210:	06 2e       	mov	r0, r22
     212:	04 c0       	rjmp	.+8      	; 0x21c <_fpadd_parts+0x132>
     214:	96 94       	lsr	r9
     216:	87 94       	ror	r8
     218:	77 94       	ror	r7
     21a:	67 94       	ror	r6
     21c:	0a 94       	dec	r0
     21e:	d2 f7       	brpl	.-12     	; 0x214 <_fpadd_parts+0x12a>
     220:	21 e0       	ldi	r18, 0x01	; 1
     222:	30 e0       	ldi	r19, 0x00	; 0
     224:	40 e0       	ldi	r20, 0x00	; 0
     226:	50 e0       	ldi	r21, 0x00	; 0
     228:	04 c0       	rjmp	.+8      	; 0x232 <_fpadd_parts+0x148>
     22a:	22 0f       	add	r18, r18
     22c:	33 1f       	adc	r19, r19
     22e:	44 1f       	adc	r20, r20
     230:	55 1f       	adc	r21, r21
     232:	6a 95       	dec	r22
     234:	d2 f7       	brpl	.-12     	; 0x22a <_fpadd_parts+0x140>
     236:	21 50       	subi	r18, 0x01	; 1
     238:	30 40       	sbci	r19, 0x00	; 0
     23a:	40 40       	sbci	r20, 0x00	; 0
     23c:	50 40       	sbci	r21, 0x00	; 0
     23e:	2a 21       	and	r18, r10
     240:	3b 21       	and	r19, r11
     242:	4c 21       	and	r20, r12
     244:	5d 21       	and	r21, r13
     246:	21 15       	cp	r18, r1
     248:	31 05       	cpc	r19, r1
     24a:	41 05       	cpc	r20, r1
     24c:	51 05       	cpc	r21, r1
     24e:	21 f0       	breq	.+8      	; 0x258 <_fpadd_parts+0x16e>
     250:	21 e0       	ldi	r18, 0x01	; 1
     252:	30 e0       	ldi	r19, 0x00	; 0
     254:	40 e0       	ldi	r20, 0x00	; 0
     256:	50 e0       	ldi	r21, 0x00	; 0
     258:	59 01       	movw	r10, r18
     25a:	6a 01       	movw	r12, r20
     25c:	a6 28       	or	r10, r6
     25e:	b7 28       	or	r11, r7
     260:	c8 28       	or	r12, r8
     262:	d9 28       	or	r13, r9
     264:	0b c0       	rjmp	.+22     	; 0x27c <_fpadd_parts+0x192>
     266:	82 15       	cp	r24, r2
     268:	93 05       	cpc	r25, r3
     26a:	2c f0       	brlt	.+10     	; 0x276 <_fpadd_parts+0x18c>
     26c:	1c 01       	movw	r2, r24
     26e:	aa 24       	eor	r10, r10
     270:	bb 24       	eor	r11, r11
     272:	65 01       	movw	r12, r10
     274:	03 c0       	rjmp	.+6      	; 0x27c <_fpadd_parts+0x192>
     276:	ee 24       	eor	r14, r14
     278:	ff 24       	eor	r15, r15
     27a:	87 01       	movw	r16, r14
     27c:	11 96       	adiw	r26, 0x01	; 1
     27e:	9c 91       	ld	r25, X
     280:	d2 01       	movw	r26, r4
     282:	11 96       	adiw	r26, 0x01	; 1
     284:	8c 91       	ld	r24, X
     286:	98 17       	cp	r25, r24
     288:	09 f4       	brne	.+2      	; 0x28c <_fpadd_parts+0x1a2>
     28a:	45 c0       	rjmp	.+138    	; 0x316 <_fpadd_parts+0x22c>
     28c:	99 23       	and	r25, r25
     28e:	39 f0       	breq	.+14     	; 0x29e <_fpadd_parts+0x1b4>
     290:	a8 01       	movw	r20, r16
     292:	97 01       	movw	r18, r14
     294:	2a 19       	sub	r18, r10
     296:	3b 09       	sbc	r19, r11
     298:	4c 09       	sbc	r20, r12
     29a:	5d 09       	sbc	r21, r13
     29c:	06 c0       	rjmp	.+12     	; 0x2aa <_fpadd_parts+0x1c0>
     29e:	a6 01       	movw	r20, r12
     2a0:	95 01       	movw	r18, r10
     2a2:	2e 19       	sub	r18, r14
     2a4:	3f 09       	sbc	r19, r15
     2a6:	40 0b       	sbc	r20, r16
     2a8:	51 0b       	sbc	r21, r17
     2aa:	57 fd       	sbrc	r21, 7
     2ac:	08 c0       	rjmp	.+16     	; 0x2be <_fpadd_parts+0x1d4>
     2ae:	11 82       	std	Z+1, r1	; 0x01
     2b0:	33 82       	std	Z+3, r3	; 0x03
     2b2:	22 82       	std	Z+2, r2	; 0x02
     2b4:	24 83       	std	Z+4, r18	; 0x04
     2b6:	35 83       	std	Z+5, r19	; 0x05
     2b8:	46 83       	std	Z+6, r20	; 0x06
     2ba:	57 83       	std	Z+7, r21	; 0x07
     2bc:	1d c0       	rjmp	.+58     	; 0x2f8 <_fpadd_parts+0x20e>
     2be:	81 e0       	ldi	r24, 0x01	; 1
     2c0:	81 83       	std	Z+1, r24	; 0x01
     2c2:	33 82       	std	Z+3, r3	; 0x03
     2c4:	22 82       	std	Z+2, r2	; 0x02
     2c6:	88 27       	eor	r24, r24
     2c8:	99 27       	eor	r25, r25
     2ca:	dc 01       	movw	r26, r24
     2cc:	82 1b       	sub	r24, r18
     2ce:	93 0b       	sbc	r25, r19
     2d0:	a4 0b       	sbc	r26, r20
     2d2:	b5 0b       	sbc	r27, r21
     2d4:	84 83       	std	Z+4, r24	; 0x04
     2d6:	95 83       	std	Z+5, r25	; 0x05
     2d8:	a6 83       	std	Z+6, r26	; 0x06
     2da:	b7 83       	std	Z+7, r27	; 0x07
     2dc:	0d c0       	rjmp	.+26     	; 0x2f8 <_fpadd_parts+0x20e>
     2de:	22 0f       	add	r18, r18
     2e0:	33 1f       	adc	r19, r19
     2e2:	44 1f       	adc	r20, r20
     2e4:	55 1f       	adc	r21, r21
     2e6:	24 83       	std	Z+4, r18	; 0x04
     2e8:	35 83       	std	Z+5, r19	; 0x05
     2ea:	46 83       	std	Z+6, r20	; 0x06
     2ec:	57 83       	std	Z+7, r21	; 0x07
     2ee:	82 81       	ldd	r24, Z+2	; 0x02
     2f0:	93 81       	ldd	r25, Z+3	; 0x03
     2f2:	01 97       	sbiw	r24, 0x01	; 1
     2f4:	93 83       	std	Z+3, r25	; 0x03
     2f6:	82 83       	std	Z+2, r24	; 0x02
     2f8:	24 81       	ldd	r18, Z+4	; 0x04
     2fa:	35 81       	ldd	r19, Z+5	; 0x05
     2fc:	46 81       	ldd	r20, Z+6	; 0x06
     2fe:	57 81       	ldd	r21, Z+7	; 0x07
     300:	da 01       	movw	r26, r20
     302:	c9 01       	movw	r24, r18
     304:	01 97       	sbiw	r24, 0x01	; 1
     306:	a1 09       	sbc	r26, r1
     308:	b1 09       	sbc	r27, r1
     30a:	8f 5f       	subi	r24, 0xFF	; 255
     30c:	9f 4f       	sbci	r25, 0xFF	; 255
     30e:	af 4f       	sbci	r26, 0xFF	; 255
     310:	bf 43       	sbci	r27, 0x3F	; 63
     312:	28 f3       	brcs	.-54     	; 0x2de <_fpadd_parts+0x1f4>
     314:	0b c0       	rjmp	.+22     	; 0x32c <_fpadd_parts+0x242>
     316:	91 83       	std	Z+1, r25	; 0x01
     318:	33 82       	std	Z+3, r3	; 0x03
     31a:	22 82       	std	Z+2, r2	; 0x02
     31c:	ea 0c       	add	r14, r10
     31e:	fb 1c       	adc	r15, r11
     320:	0c 1d       	adc	r16, r12
     322:	1d 1d       	adc	r17, r13
     324:	e4 82       	std	Z+4, r14	; 0x04
     326:	f5 82       	std	Z+5, r15	; 0x05
     328:	06 83       	std	Z+6, r16	; 0x06
     32a:	17 83       	std	Z+7, r17	; 0x07
     32c:	83 e0       	ldi	r24, 0x03	; 3
     32e:	80 83       	st	Z, r24
     330:	24 81       	ldd	r18, Z+4	; 0x04
     332:	35 81       	ldd	r19, Z+5	; 0x05
     334:	46 81       	ldd	r20, Z+6	; 0x06
     336:	57 81       	ldd	r21, Z+7	; 0x07
     338:	57 ff       	sbrs	r21, 7
     33a:	1a c0       	rjmp	.+52     	; 0x370 <_fpadd_parts+0x286>
     33c:	c9 01       	movw	r24, r18
     33e:	aa 27       	eor	r26, r26
     340:	97 fd       	sbrc	r25, 7
     342:	a0 95       	com	r26
     344:	ba 2f       	mov	r27, r26
     346:	81 70       	andi	r24, 0x01	; 1
     348:	90 70       	andi	r25, 0x00	; 0
     34a:	a0 70       	andi	r26, 0x00	; 0
     34c:	b0 70       	andi	r27, 0x00	; 0
     34e:	56 95       	lsr	r21
     350:	47 95       	ror	r20
     352:	37 95       	ror	r19
     354:	27 95       	ror	r18
     356:	82 2b       	or	r24, r18
     358:	93 2b       	or	r25, r19
     35a:	a4 2b       	or	r26, r20
     35c:	b5 2b       	or	r27, r21
     35e:	84 83       	std	Z+4, r24	; 0x04
     360:	95 83       	std	Z+5, r25	; 0x05
     362:	a6 83       	std	Z+6, r26	; 0x06
     364:	b7 83       	std	Z+7, r27	; 0x07
     366:	82 81       	ldd	r24, Z+2	; 0x02
     368:	93 81       	ldd	r25, Z+3	; 0x03
     36a:	01 96       	adiw	r24, 0x01	; 1
     36c:	93 83       	std	Z+3, r25	; 0x03
     36e:	82 83       	std	Z+2, r24	; 0x02
     370:	df 01       	movw	r26, r30
     372:	01 c0       	rjmp	.+2      	; 0x376 <_fpadd_parts+0x28c>
     374:	d2 01       	movw	r26, r4
     376:	cd 01       	movw	r24, r26
     378:	cd b7       	in	r28, 0x3d	; 61
     37a:	de b7       	in	r29, 0x3e	; 62
     37c:	e2 e1       	ldi	r30, 0x12	; 18
     37e:	0c 94 eb 31 	jmp	0x63d6	; 0x63d6 <__epilogue_restores__>

00000382 <__subsf3>:
     382:	a0 e2       	ldi	r26, 0x20	; 32
     384:	b0 e0       	ldi	r27, 0x00	; 0
     386:	e7 ec       	ldi	r30, 0xC7	; 199
     388:	f1 e0       	ldi	r31, 0x01	; 1
     38a:	0c 94 db 31 	jmp	0x63b6	; 0x63b6 <__prologue_saves__+0x18>
     38e:	69 83       	std	Y+1, r22	; 0x01
     390:	7a 83       	std	Y+2, r23	; 0x02
     392:	8b 83       	std	Y+3, r24	; 0x03
     394:	9c 83       	std	Y+4, r25	; 0x04
     396:	2d 83       	std	Y+5, r18	; 0x05
     398:	3e 83       	std	Y+6, r19	; 0x06
     39a:	4f 83       	std	Y+7, r20	; 0x07
     39c:	58 87       	std	Y+8, r21	; 0x08
     39e:	e9 e0       	ldi	r30, 0x09	; 9
     3a0:	ee 2e       	mov	r14, r30
     3a2:	f1 2c       	mov	r15, r1
     3a4:	ec 0e       	add	r14, r28
     3a6:	fd 1e       	adc	r15, r29
     3a8:	ce 01       	movw	r24, r28
     3aa:	01 96       	adiw	r24, 0x01	; 1
     3ac:	b7 01       	movw	r22, r14
     3ae:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     3b2:	8e 01       	movw	r16, r28
     3b4:	0f 5e       	subi	r16, 0xEF	; 239
     3b6:	1f 4f       	sbci	r17, 0xFF	; 255
     3b8:	ce 01       	movw	r24, r28
     3ba:	05 96       	adiw	r24, 0x05	; 5
     3bc:	b8 01       	movw	r22, r16
     3be:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     3c2:	8a 89       	ldd	r24, Y+18	; 0x12
     3c4:	91 e0       	ldi	r25, 0x01	; 1
     3c6:	89 27       	eor	r24, r25
     3c8:	8a 8b       	std	Y+18, r24	; 0x12
     3ca:	c7 01       	movw	r24, r14
     3cc:	b8 01       	movw	r22, r16
     3ce:	ae 01       	movw	r20, r28
     3d0:	47 5e       	subi	r20, 0xE7	; 231
     3d2:	5f 4f       	sbci	r21, 0xFF	; 255
     3d4:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     3d8:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     3dc:	a0 96       	adiw	r28, 0x20	; 32
     3de:	e6 e0       	ldi	r30, 0x06	; 6
     3e0:	0c 94 f7 31 	jmp	0x63ee	; 0x63ee <__epilogue_restores__+0x18>

000003e4 <__addsf3>:
     3e4:	a0 e2       	ldi	r26, 0x20	; 32
     3e6:	b0 e0       	ldi	r27, 0x00	; 0
     3e8:	e8 ef       	ldi	r30, 0xF8	; 248
     3ea:	f1 e0       	ldi	r31, 0x01	; 1
     3ec:	0c 94 db 31 	jmp	0x63b6	; 0x63b6 <__prologue_saves__+0x18>
     3f0:	69 83       	std	Y+1, r22	; 0x01
     3f2:	7a 83       	std	Y+2, r23	; 0x02
     3f4:	8b 83       	std	Y+3, r24	; 0x03
     3f6:	9c 83       	std	Y+4, r25	; 0x04
     3f8:	2d 83       	std	Y+5, r18	; 0x05
     3fa:	3e 83       	std	Y+6, r19	; 0x06
     3fc:	4f 83       	std	Y+7, r20	; 0x07
     3fe:	58 87       	std	Y+8, r21	; 0x08
     400:	f9 e0       	ldi	r31, 0x09	; 9
     402:	ef 2e       	mov	r14, r31
     404:	f1 2c       	mov	r15, r1
     406:	ec 0e       	add	r14, r28
     408:	fd 1e       	adc	r15, r29
     40a:	ce 01       	movw	r24, r28
     40c:	01 96       	adiw	r24, 0x01	; 1
     40e:	b7 01       	movw	r22, r14
     410:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     414:	8e 01       	movw	r16, r28
     416:	0f 5e       	subi	r16, 0xEF	; 239
     418:	1f 4f       	sbci	r17, 0xFF	; 255
     41a:	ce 01       	movw	r24, r28
     41c:	05 96       	adiw	r24, 0x05	; 5
     41e:	b8 01       	movw	r22, r16
     420:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     424:	c7 01       	movw	r24, r14
     426:	b8 01       	movw	r22, r16
     428:	ae 01       	movw	r20, r28
     42a:	47 5e       	subi	r20, 0xE7	; 231
     42c:	5f 4f       	sbci	r21, 0xFF	; 255
     42e:	0e 94 75 00 	call	0xea	; 0xea <_fpadd_parts>
     432:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     436:	a0 96       	adiw	r28, 0x20	; 32
     438:	e6 e0       	ldi	r30, 0x06	; 6
     43a:	0c 94 f7 31 	jmp	0x63ee	; 0x63ee <__epilogue_restores__+0x18>

0000043e <__mulsf3>:
     43e:	a0 e2       	ldi	r26, 0x20	; 32
     440:	b0 e0       	ldi	r27, 0x00	; 0
     442:	e5 e2       	ldi	r30, 0x25	; 37
     444:	f2 e0       	ldi	r31, 0x02	; 2
     446:	0c 94 cf 31 	jmp	0x639e	; 0x639e <__prologue_saves__>
     44a:	69 83       	std	Y+1, r22	; 0x01
     44c:	7a 83       	std	Y+2, r23	; 0x02
     44e:	8b 83       	std	Y+3, r24	; 0x03
     450:	9c 83       	std	Y+4, r25	; 0x04
     452:	2d 83       	std	Y+5, r18	; 0x05
     454:	3e 83       	std	Y+6, r19	; 0x06
     456:	4f 83       	std	Y+7, r20	; 0x07
     458:	58 87       	std	Y+8, r21	; 0x08
     45a:	ce 01       	movw	r24, r28
     45c:	01 96       	adiw	r24, 0x01	; 1
     45e:	be 01       	movw	r22, r28
     460:	67 5f       	subi	r22, 0xF7	; 247
     462:	7f 4f       	sbci	r23, 0xFF	; 255
     464:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     468:	ce 01       	movw	r24, r28
     46a:	05 96       	adiw	r24, 0x05	; 5
     46c:	be 01       	movw	r22, r28
     46e:	6f 5e       	subi	r22, 0xEF	; 239
     470:	7f 4f       	sbci	r23, 0xFF	; 255
     472:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     476:	99 85       	ldd	r25, Y+9	; 0x09
     478:	92 30       	cpi	r25, 0x02	; 2
     47a:	88 f0       	brcs	.+34     	; 0x49e <__mulsf3+0x60>
     47c:	89 89       	ldd	r24, Y+17	; 0x11
     47e:	82 30       	cpi	r24, 0x02	; 2
     480:	c8 f0       	brcs	.+50     	; 0x4b4 <__mulsf3+0x76>
     482:	94 30       	cpi	r25, 0x04	; 4
     484:	19 f4       	brne	.+6      	; 0x48c <__mulsf3+0x4e>
     486:	82 30       	cpi	r24, 0x02	; 2
     488:	51 f4       	brne	.+20     	; 0x49e <__mulsf3+0x60>
     48a:	04 c0       	rjmp	.+8      	; 0x494 <__mulsf3+0x56>
     48c:	84 30       	cpi	r24, 0x04	; 4
     48e:	29 f4       	brne	.+10     	; 0x49a <__mulsf3+0x5c>
     490:	92 30       	cpi	r25, 0x02	; 2
     492:	81 f4       	brne	.+32     	; 0x4b4 <__mulsf3+0x76>
     494:	87 e9       	ldi	r24, 0x97	; 151
     496:	90 e0       	ldi	r25, 0x00	; 0
     498:	c6 c0       	rjmp	.+396    	; 0x626 <__mulsf3+0x1e8>
     49a:	92 30       	cpi	r25, 0x02	; 2
     49c:	49 f4       	brne	.+18     	; 0x4b0 <__mulsf3+0x72>
     49e:	20 e0       	ldi	r18, 0x00	; 0
     4a0:	9a 85       	ldd	r25, Y+10	; 0x0a
     4a2:	8a 89       	ldd	r24, Y+18	; 0x12
     4a4:	98 13       	cpse	r25, r24
     4a6:	21 e0       	ldi	r18, 0x01	; 1
     4a8:	2a 87       	std	Y+10, r18	; 0x0a
     4aa:	ce 01       	movw	r24, r28
     4ac:	09 96       	adiw	r24, 0x09	; 9
     4ae:	bb c0       	rjmp	.+374    	; 0x626 <__mulsf3+0x1e8>
     4b0:	82 30       	cpi	r24, 0x02	; 2
     4b2:	49 f4       	brne	.+18     	; 0x4c6 <__mulsf3+0x88>
     4b4:	20 e0       	ldi	r18, 0x00	; 0
     4b6:	9a 85       	ldd	r25, Y+10	; 0x0a
     4b8:	8a 89       	ldd	r24, Y+18	; 0x12
     4ba:	98 13       	cpse	r25, r24
     4bc:	21 e0       	ldi	r18, 0x01	; 1
     4be:	2a 8b       	std	Y+18, r18	; 0x12
     4c0:	ce 01       	movw	r24, r28
     4c2:	41 96       	adiw	r24, 0x11	; 17
     4c4:	b0 c0       	rjmp	.+352    	; 0x626 <__mulsf3+0x1e8>
     4c6:	2d 84       	ldd	r2, Y+13	; 0x0d
     4c8:	3e 84       	ldd	r3, Y+14	; 0x0e
     4ca:	4f 84       	ldd	r4, Y+15	; 0x0f
     4cc:	58 88       	ldd	r5, Y+16	; 0x10
     4ce:	6d 88       	ldd	r6, Y+21	; 0x15
     4d0:	7e 88       	ldd	r7, Y+22	; 0x16
     4d2:	8f 88       	ldd	r8, Y+23	; 0x17
     4d4:	98 8c       	ldd	r9, Y+24	; 0x18
     4d6:	ee 24       	eor	r14, r14
     4d8:	ff 24       	eor	r15, r15
     4da:	87 01       	movw	r16, r14
     4dc:	aa 24       	eor	r10, r10
     4de:	bb 24       	eor	r11, r11
     4e0:	65 01       	movw	r12, r10
     4e2:	40 e0       	ldi	r20, 0x00	; 0
     4e4:	50 e0       	ldi	r21, 0x00	; 0
     4e6:	60 e0       	ldi	r22, 0x00	; 0
     4e8:	70 e0       	ldi	r23, 0x00	; 0
     4ea:	e0 e0       	ldi	r30, 0x00	; 0
     4ec:	f0 e0       	ldi	r31, 0x00	; 0
     4ee:	c1 01       	movw	r24, r2
     4f0:	81 70       	andi	r24, 0x01	; 1
     4f2:	90 70       	andi	r25, 0x00	; 0
     4f4:	89 2b       	or	r24, r25
     4f6:	e9 f0       	breq	.+58     	; 0x532 <__mulsf3+0xf4>
     4f8:	e6 0c       	add	r14, r6
     4fa:	f7 1c       	adc	r15, r7
     4fc:	08 1d       	adc	r16, r8
     4fe:	19 1d       	adc	r17, r9
     500:	9a 01       	movw	r18, r20
     502:	ab 01       	movw	r20, r22
     504:	2a 0d       	add	r18, r10
     506:	3b 1d       	adc	r19, r11
     508:	4c 1d       	adc	r20, r12
     50a:	5d 1d       	adc	r21, r13
     50c:	80 e0       	ldi	r24, 0x00	; 0
     50e:	90 e0       	ldi	r25, 0x00	; 0
     510:	a0 e0       	ldi	r26, 0x00	; 0
     512:	b0 e0       	ldi	r27, 0x00	; 0
     514:	e6 14       	cp	r14, r6
     516:	f7 04       	cpc	r15, r7
     518:	08 05       	cpc	r16, r8
     51a:	19 05       	cpc	r17, r9
     51c:	20 f4       	brcc	.+8      	; 0x526 <__mulsf3+0xe8>
     51e:	81 e0       	ldi	r24, 0x01	; 1
     520:	90 e0       	ldi	r25, 0x00	; 0
     522:	a0 e0       	ldi	r26, 0x00	; 0
     524:	b0 e0       	ldi	r27, 0x00	; 0
     526:	ba 01       	movw	r22, r20
     528:	a9 01       	movw	r20, r18
     52a:	48 0f       	add	r20, r24
     52c:	59 1f       	adc	r21, r25
     52e:	6a 1f       	adc	r22, r26
     530:	7b 1f       	adc	r23, r27
     532:	aa 0c       	add	r10, r10
     534:	bb 1c       	adc	r11, r11
     536:	cc 1c       	adc	r12, r12
     538:	dd 1c       	adc	r13, r13
     53a:	97 fe       	sbrs	r9, 7
     53c:	08 c0       	rjmp	.+16     	; 0x54e <__mulsf3+0x110>
     53e:	81 e0       	ldi	r24, 0x01	; 1
     540:	90 e0       	ldi	r25, 0x00	; 0
     542:	a0 e0       	ldi	r26, 0x00	; 0
     544:	b0 e0       	ldi	r27, 0x00	; 0
     546:	a8 2a       	or	r10, r24
     548:	b9 2a       	or	r11, r25
     54a:	ca 2a       	or	r12, r26
     54c:	db 2a       	or	r13, r27
     54e:	31 96       	adiw	r30, 0x01	; 1
     550:	e0 32       	cpi	r30, 0x20	; 32
     552:	f1 05       	cpc	r31, r1
     554:	49 f0       	breq	.+18     	; 0x568 <__mulsf3+0x12a>
     556:	66 0c       	add	r6, r6
     558:	77 1c       	adc	r7, r7
     55a:	88 1c       	adc	r8, r8
     55c:	99 1c       	adc	r9, r9
     55e:	56 94       	lsr	r5
     560:	47 94       	ror	r4
     562:	37 94       	ror	r3
     564:	27 94       	ror	r2
     566:	c3 cf       	rjmp	.-122    	; 0x4ee <__mulsf3+0xb0>
     568:	fa 85       	ldd	r31, Y+10	; 0x0a
     56a:	ea 89       	ldd	r30, Y+18	; 0x12
     56c:	2b 89       	ldd	r18, Y+19	; 0x13
     56e:	3c 89       	ldd	r19, Y+20	; 0x14
     570:	8b 85       	ldd	r24, Y+11	; 0x0b
     572:	9c 85       	ldd	r25, Y+12	; 0x0c
     574:	28 0f       	add	r18, r24
     576:	39 1f       	adc	r19, r25
     578:	2e 5f       	subi	r18, 0xFE	; 254
     57a:	3f 4f       	sbci	r19, 0xFF	; 255
     57c:	17 c0       	rjmp	.+46     	; 0x5ac <__mulsf3+0x16e>
     57e:	ca 01       	movw	r24, r20
     580:	81 70       	andi	r24, 0x01	; 1
     582:	90 70       	andi	r25, 0x00	; 0
     584:	89 2b       	or	r24, r25
     586:	61 f0       	breq	.+24     	; 0x5a0 <__mulsf3+0x162>
     588:	16 95       	lsr	r17
     58a:	07 95       	ror	r16
     58c:	f7 94       	ror	r15
     58e:	e7 94       	ror	r14
     590:	80 e0       	ldi	r24, 0x00	; 0
     592:	90 e0       	ldi	r25, 0x00	; 0
     594:	a0 e0       	ldi	r26, 0x00	; 0
     596:	b0 e8       	ldi	r27, 0x80	; 128
     598:	e8 2a       	or	r14, r24
     59a:	f9 2a       	or	r15, r25
     59c:	0a 2b       	or	r16, r26
     59e:	1b 2b       	or	r17, r27
     5a0:	76 95       	lsr	r23
     5a2:	67 95       	ror	r22
     5a4:	57 95       	ror	r21
     5a6:	47 95       	ror	r20
     5a8:	2f 5f       	subi	r18, 0xFF	; 255
     5aa:	3f 4f       	sbci	r19, 0xFF	; 255
     5ac:	77 fd       	sbrc	r23, 7
     5ae:	e7 cf       	rjmp	.-50     	; 0x57e <__mulsf3+0x140>
     5b0:	0c c0       	rjmp	.+24     	; 0x5ca <__mulsf3+0x18c>
     5b2:	44 0f       	add	r20, r20
     5b4:	55 1f       	adc	r21, r21
     5b6:	66 1f       	adc	r22, r22
     5b8:	77 1f       	adc	r23, r23
     5ba:	17 fd       	sbrc	r17, 7
     5bc:	41 60       	ori	r20, 0x01	; 1
     5be:	ee 0c       	add	r14, r14
     5c0:	ff 1c       	adc	r15, r15
     5c2:	00 1f       	adc	r16, r16
     5c4:	11 1f       	adc	r17, r17
     5c6:	21 50       	subi	r18, 0x01	; 1
     5c8:	30 40       	sbci	r19, 0x00	; 0
     5ca:	40 30       	cpi	r20, 0x00	; 0
     5cc:	90 e0       	ldi	r25, 0x00	; 0
     5ce:	59 07       	cpc	r21, r25
     5d0:	90 e0       	ldi	r25, 0x00	; 0
     5d2:	69 07       	cpc	r22, r25
     5d4:	90 e4       	ldi	r25, 0x40	; 64
     5d6:	79 07       	cpc	r23, r25
     5d8:	60 f3       	brcs	.-40     	; 0x5b2 <__mulsf3+0x174>
     5da:	2b 8f       	std	Y+27, r18	; 0x1b
     5dc:	3c 8f       	std	Y+28, r19	; 0x1c
     5de:	db 01       	movw	r26, r22
     5e0:	ca 01       	movw	r24, r20
     5e2:	8f 77       	andi	r24, 0x7F	; 127
     5e4:	90 70       	andi	r25, 0x00	; 0
     5e6:	a0 70       	andi	r26, 0x00	; 0
     5e8:	b0 70       	andi	r27, 0x00	; 0
     5ea:	80 34       	cpi	r24, 0x40	; 64
     5ec:	91 05       	cpc	r25, r1
     5ee:	a1 05       	cpc	r26, r1
     5f0:	b1 05       	cpc	r27, r1
     5f2:	61 f4       	brne	.+24     	; 0x60c <__mulsf3+0x1ce>
     5f4:	47 fd       	sbrc	r20, 7
     5f6:	0a c0       	rjmp	.+20     	; 0x60c <__mulsf3+0x1ce>
     5f8:	e1 14       	cp	r14, r1
     5fa:	f1 04       	cpc	r15, r1
     5fc:	01 05       	cpc	r16, r1
     5fe:	11 05       	cpc	r17, r1
     600:	29 f0       	breq	.+10     	; 0x60c <__mulsf3+0x1ce>
     602:	40 5c       	subi	r20, 0xC0	; 192
     604:	5f 4f       	sbci	r21, 0xFF	; 255
     606:	6f 4f       	sbci	r22, 0xFF	; 255
     608:	7f 4f       	sbci	r23, 0xFF	; 255
     60a:	40 78       	andi	r20, 0x80	; 128
     60c:	1a 8e       	std	Y+26, r1	; 0x1a
     60e:	fe 17       	cp	r31, r30
     610:	11 f0       	breq	.+4      	; 0x616 <__mulsf3+0x1d8>
     612:	81 e0       	ldi	r24, 0x01	; 1
     614:	8a 8f       	std	Y+26, r24	; 0x1a
     616:	4d 8f       	std	Y+29, r20	; 0x1d
     618:	5e 8f       	std	Y+30, r21	; 0x1e
     61a:	6f 8f       	std	Y+31, r22	; 0x1f
     61c:	78 a3       	std	Y+32, r23	; 0x20
     61e:	83 e0       	ldi	r24, 0x03	; 3
     620:	89 8f       	std	Y+25, r24	; 0x19
     622:	ce 01       	movw	r24, r28
     624:	49 96       	adiw	r24, 0x19	; 25
     626:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     62a:	a0 96       	adiw	r28, 0x20	; 32
     62c:	e2 e1       	ldi	r30, 0x12	; 18
     62e:	0c 94 eb 31 	jmp	0x63d6	; 0x63d6 <__epilogue_restores__>

00000632 <__divsf3>:
     632:	a8 e1       	ldi	r26, 0x18	; 24
     634:	b0 e0       	ldi	r27, 0x00	; 0
     636:	ef e1       	ldi	r30, 0x1F	; 31
     638:	f3 e0       	ldi	r31, 0x03	; 3
     63a:	0c 94 d7 31 	jmp	0x63ae	; 0x63ae <__prologue_saves__+0x10>
     63e:	69 83       	std	Y+1, r22	; 0x01
     640:	7a 83       	std	Y+2, r23	; 0x02
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	2d 83       	std	Y+5, r18	; 0x05
     648:	3e 83       	std	Y+6, r19	; 0x06
     64a:	4f 83       	std	Y+7, r20	; 0x07
     64c:	58 87       	std	Y+8, r21	; 0x08
     64e:	b9 e0       	ldi	r27, 0x09	; 9
     650:	eb 2e       	mov	r14, r27
     652:	f1 2c       	mov	r15, r1
     654:	ec 0e       	add	r14, r28
     656:	fd 1e       	adc	r15, r29
     658:	ce 01       	movw	r24, r28
     65a:	01 96       	adiw	r24, 0x01	; 1
     65c:	b7 01       	movw	r22, r14
     65e:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     662:	8e 01       	movw	r16, r28
     664:	0f 5e       	subi	r16, 0xEF	; 239
     666:	1f 4f       	sbci	r17, 0xFF	; 255
     668:	ce 01       	movw	r24, r28
     66a:	05 96       	adiw	r24, 0x05	; 5
     66c:	b8 01       	movw	r22, r16
     66e:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     672:	29 85       	ldd	r18, Y+9	; 0x09
     674:	22 30       	cpi	r18, 0x02	; 2
     676:	08 f4       	brcc	.+2      	; 0x67a <__divsf3+0x48>
     678:	7e c0       	rjmp	.+252    	; 0x776 <__divsf3+0x144>
     67a:	39 89       	ldd	r19, Y+17	; 0x11
     67c:	32 30       	cpi	r19, 0x02	; 2
     67e:	10 f4       	brcc	.+4      	; 0x684 <__divsf3+0x52>
     680:	b8 01       	movw	r22, r16
     682:	7c c0       	rjmp	.+248    	; 0x77c <__divsf3+0x14a>
     684:	8a 85       	ldd	r24, Y+10	; 0x0a
     686:	9a 89       	ldd	r25, Y+18	; 0x12
     688:	89 27       	eor	r24, r25
     68a:	8a 87       	std	Y+10, r24	; 0x0a
     68c:	24 30       	cpi	r18, 0x04	; 4
     68e:	11 f0       	breq	.+4      	; 0x694 <__divsf3+0x62>
     690:	22 30       	cpi	r18, 0x02	; 2
     692:	31 f4       	brne	.+12     	; 0x6a0 <__divsf3+0x6e>
     694:	23 17       	cp	r18, r19
     696:	09 f0       	breq	.+2      	; 0x69a <__divsf3+0x68>
     698:	6e c0       	rjmp	.+220    	; 0x776 <__divsf3+0x144>
     69a:	67 e9       	ldi	r22, 0x97	; 151
     69c:	70 e0       	ldi	r23, 0x00	; 0
     69e:	6e c0       	rjmp	.+220    	; 0x77c <__divsf3+0x14a>
     6a0:	34 30       	cpi	r19, 0x04	; 4
     6a2:	39 f4       	brne	.+14     	; 0x6b2 <__divsf3+0x80>
     6a4:	1d 86       	std	Y+13, r1	; 0x0d
     6a6:	1e 86       	std	Y+14, r1	; 0x0e
     6a8:	1f 86       	std	Y+15, r1	; 0x0f
     6aa:	18 8a       	std	Y+16, r1	; 0x10
     6ac:	1c 86       	std	Y+12, r1	; 0x0c
     6ae:	1b 86       	std	Y+11, r1	; 0x0b
     6b0:	04 c0       	rjmp	.+8      	; 0x6ba <__divsf3+0x88>
     6b2:	32 30       	cpi	r19, 0x02	; 2
     6b4:	21 f4       	brne	.+8      	; 0x6be <__divsf3+0x8c>
     6b6:	84 e0       	ldi	r24, 0x04	; 4
     6b8:	89 87       	std	Y+9, r24	; 0x09
     6ba:	b7 01       	movw	r22, r14
     6bc:	5f c0       	rjmp	.+190    	; 0x77c <__divsf3+0x14a>
     6be:	2b 85       	ldd	r18, Y+11	; 0x0b
     6c0:	3c 85       	ldd	r19, Y+12	; 0x0c
     6c2:	8b 89       	ldd	r24, Y+19	; 0x13
     6c4:	9c 89       	ldd	r25, Y+20	; 0x14
     6c6:	28 1b       	sub	r18, r24
     6c8:	39 0b       	sbc	r19, r25
     6ca:	3c 87       	std	Y+12, r19	; 0x0c
     6cc:	2b 87       	std	Y+11, r18	; 0x0b
     6ce:	ed 84       	ldd	r14, Y+13	; 0x0d
     6d0:	fe 84       	ldd	r15, Y+14	; 0x0e
     6d2:	0f 85       	ldd	r16, Y+15	; 0x0f
     6d4:	18 89       	ldd	r17, Y+16	; 0x10
     6d6:	ad 88       	ldd	r10, Y+21	; 0x15
     6d8:	be 88       	ldd	r11, Y+22	; 0x16
     6da:	cf 88       	ldd	r12, Y+23	; 0x17
     6dc:	d8 8c       	ldd	r13, Y+24	; 0x18
     6de:	ea 14       	cp	r14, r10
     6e0:	fb 04       	cpc	r15, r11
     6e2:	0c 05       	cpc	r16, r12
     6e4:	1d 05       	cpc	r17, r13
     6e6:	40 f4       	brcc	.+16     	; 0x6f8 <__divsf3+0xc6>
     6e8:	ee 0c       	add	r14, r14
     6ea:	ff 1c       	adc	r15, r15
     6ec:	00 1f       	adc	r16, r16
     6ee:	11 1f       	adc	r17, r17
     6f0:	21 50       	subi	r18, 0x01	; 1
     6f2:	30 40       	sbci	r19, 0x00	; 0
     6f4:	3c 87       	std	Y+12, r19	; 0x0c
     6f6:	2b 87       	std	Y+11, r18	; 0x0b
     6f8:	20 e0       	ldi	r18, 0x00	; 0
     6fa:	30 e0       	ldi	r19, 0x00	; 0
     6fc:	40 e0       	ldi	r20, 0x00	; 0
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	90 e0       	ldi	r25, 0x00	; 0
     704:	a0 e0       	ldi	r26, 0x00	; 0
     706:	b0 e4       	ldi	r27, 0x40	; 64
     708:	60 e0       	ldi	r22, 0x00	; 0
     70a:	70 e0       	ldi	r23, 0x00	; 0
     70c:	ea 14       	cp	r14, r10
     70e:	fb 04       	cpc	r15, r11
     710:	0c 05       	cpc	r16, r12
     712:	1d 05       	cpc	r17, r13
     714:	40 f0       	brcs	.+16     	; 0x726 <__divsf3+0xf4>
     716:	28 2b       	or	r18, r24
     718:	39 2b       	or	r19, r25
     71a:	4a 2b       	or	r20, r26
     71c:	5b 2b       	or	r21, r27
     71e:	ea 18       	sub	r14, r10
     720:	fb 08       	sbc	r15, r11
     722:	0c 09       	sbc	r16, r12
     724:	1d 09       	sbc	r17, r13
     726:	b6 95       	lsr	r27
     728:	a7 95       	ror	r26
     72a:	97 95       	ror	r25
     72c:	87 95       	ror	r24
     72e:	ee 0c       	add	r14, r14
     730:	ff 1c       	adc	r15, r15
     732:	00 1f       	adc	r16, r16
     734:	11 1f       	adc	r17, r17
     736:	6f 5f       	subi	r22, 0xFF	; 255
     738:	7f 4f       	sbci	r23, 0xFF	; 255
     73a:	6f 31       	cpi	r22, 0x1F	; 31
     73c:	71 05       	cpc	r23, r1
     73e:	31 f7       	brne	.-52     	; 0x70c <__divsf3+0xda>
     740:	da 01       	movw	r26, r20
     742:	c9 01       	movw	r24, r18
     744:	8f 77       	andi	r24, 0x7F	; 127
     746:	90 70       	andi	r25, 0x00	; 0
     748:	a0 70       	andi	r26, 0x00	; 0
     74a:	b0 70       	andi	r27, 0x00	; 0
     74c:	80 34       	cpi	r24, 0x40	; 64
     74e:	91 05       	cpc	r25, r1
     750:	a1 05       	cpc	r26, r1
     752:	b1 05       	cpc	r27, r1
     754:	61 f4       	brne	.+24     	; 0x76e <__divsf3+0x13c>
     756:	27 fd       	sbrc	r18, 7
     758:	0a c0       	rjmp	.+20     	; 0x76e <__divsf3+0x13c>
     75a:	e1 14       	cp	r14, r1
     75c:	f1 04       	cpc	r15, r1
     75e:	01 05       	cpc	r16, r1
     760:	11 05       	cpc	r17, r1
     762:	29 f0       	breq	.+10     	; 0x76e <__divsf3+0x13c>
     764:	20 5c       	subi	r18, 0xC0	; 192
     766:	3f 4f       	sbci	r19, 0xFF	; 255
     768:	4f 4f       	sbci	r20, 0xFF	; 255
     76a:	5f 4f       	sbci	r21, 0xFF	; 255
     76c:	20 78       	andi	r18, 0x80	; 128
     76e:	2d 87       	std	Y+13, r18	; 0x0d
     770:	3e 87       	std	Y+14, r19	; 0x0e
     772:	4f 87       	std	Y+15, r20	; 0x0f
     774:	58 8b       	std	Y+16, r21	; 0x10
     776:	be 01       	movw	r22, r28
     778:	67 5f       	subi	r22, 0xF7	; 247
     77a:	7f 4f       	sbci	r23, 0xFF	; 255
     77c:	cb 01       	movw	r24, r22
     77e:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     782:	68 96       	adiw	r28, 0x18	; 24
     784:	ea e0       	ldi	r30, 0x0A	; 10
     786:	0c 94 f3 31 	jmp	0x63e6	; 0x63e6 <__epilogue_restores__+0x10>

0000078a <__gtsf2>:
     78a:	a8 e1       	ldi	r26, 0x18	; 24
     78c:	b0 e0       	ldi	r27, 0x00	; 0
     78e:	eb ec       	ldi	r30, 0xCB	; 203
     790:	f3 e0       	ldi	r31, 0x03	; 3
     792:	0c 94 db 31 	jmp	0x63b6	; 0x63b6 <__prologue_saves__+0x18>
     796:	69 83       	std	Y+1, r22	; 0x01
     798:	7a 83       	std	Y+2, r23	; 0x02
     79a:	8b 83       	std	Y+3, r24	; 0x03
     79c:	9c 83       	std	Y+4, r25	; 0x04
     79e:	2d 83       	std	Y+5, r18	; 0x05
     7a0:	3e 83       	std	Y+6, r19	; 0x06
     7a2:	4f 83       	std	Y+7, r20	; 0x07
     7a4:	58 87       	std	Y+8, r21	; 0x08
     7a6:	89 e0       	ldi	r24, 0x09	; 9
     7a8:	e8 2e       	mov	r14, r24
     7aa:	f1 2c       	mov	r15, r1
     7ac:	ec 0e       	add	r14, r28
     7ae:	fd 1e       	adc	r15, r29
     7b0:	ce 01       	movw	r24, r28
     7b2:	01 96       	adiw	r24, 0x01	; 1
     7b4:	b7 01       	movw	r22, r14
     7b6:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     7ba:	8e 01       	movw	r16, r28
     7bc:	0f 5e       	subi	r16, 0xEF	; 239
     7be:	1f 4f       	sbci	r17, 0xFF	; 255
     7c0:	ce 01       	movw	r24, r28
     7c2:	05 96       	adiw	r24, 0x05	; 5
     7c4:	b8 01       	movw	r22, r16
     7c6:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     7ca:	89 85       	ldd	r24, Y+9	; 0x09
     7cc:	82 30       	cpi	r24, 0x02	; 2
     7ce:	40 f0       	brcs	.+16     	; 0x7e0 <__gtsf2+0x56>
     7d0:	89 89       	ldd	r24, Y+17	; 0x11
     7d2:	82 30       	cpi	r24, 0x02	; 2
     7d4:	28 f0       	brcs	.+10     	; 0x7e0 <__gtsf2+0x56>
     7d6:	c7 01       	movw	r24, r14
     7d8:	b8 01       	movw	r22, r16
     7da:	0e 94 be 06 	call	0xd7c	; 0xd7c <__fpcmp_parts_f>
     7de:	01 c0       	rjmp	.+2      	; 0x7e2 <__gtsf2+0x58>
     7e0:	8f ef       	ldi	r24, 0xFF	; 255
     7e2:	68 96       	adiw	r28, 0x18	; 24
     7e4:	e6 e0       	ldi	r30, 0x06	; 6
     7e6:	0c 94 f7 31 	jmp	0x63ee	; 0x63ee <__epilogue_restores__+0x18>

000007ea <__gesf2>:
     7ea:	a8 e1       	ldi	r26, 0x18	; 24
     7ec:	b0 e0       	ldi	r27, 0x00	; 0
     7ee:	eb ef       	ldi	r30, 0xFB	; 251
     7f0:	f3 e0       	ldi	r31, 0x03	; 3
     7f2:	0c 94 db 31 	jmp	0x63b6	; 0x63b6 <__prologue_saves__+0x18>
     7f6:	69 83       	std	Y+1, r22	; 0x01
     7f8:	7a 83       	std	Y+2, r23	; 0x02
     7fa:	8b 83       	std	Y+3, r24	; 0x03
     7fc:	9c 83       	std	Y+4, r25	; 0x04
     7fe:	2d 83       	std	Y+5, r18	; 0x05
     800:	3e 83       	std	Y+6, r19	; 0x06
     802:	4f 83       	std	Y+7, r20	; 0x07
     804:	58 87       	std	Y+8, r21	; 0x08
     806:	89 e0       	ldi	r24, 0x09	; 9
     808:	e8 2e       	mov	r14, r24
     80a:	f1 2c       	mov	r15, r1
     80c:	ec 0e       	add	r14, r28
     80e:	fd 1e       	adc	r15, r29
     810:	ce 01       	movw	r24, r28
     812:	01 96       	adiw	r24, 0x01	; 1
     814:	b7 01       	movw	r22, r14
     816:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     81a:	8e 01       	movw	r16, r28
     81c:	0f 5e       	subi	r16, 0xEF	; 239
     81e:	1f 4f       	sbci	r17, 0xFF	; 255
     820:	ce 01       	movw	r24, r28
     822:	05 96       	adiw	r24, 0x05	; 5
     824:	b8 01       	movw	r22, r16
     826:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     82a:	89 85       	ldd	r24, Y+9	; 0x09
     82c:	82 30       	cpi	r24, 0x02	; 2
     82e:	40 f0       	brcs	.+16     	; 0x840 <__gesf2+0x56>
     830:	89 89       	ldd	r24, Y+17	; 0x11
     832:	82 30       	cpi	r24, 0x02	; 2
     834:	28 f0       	brcs	.+10     	; 0x840 <__gesf2+0x56>
     836:	c7 01       	movw	r24, r14
     838:	b8 01       	movw	r22, r16
     83a:	0e 94 be 06 	call	0xd7c	; 0xd7c <__fpcmp_parts_f>
     83e:	01 c0       	rjmp	.+2      	; 0x842 <__gesf2+0x58>
     840:	8f ef       	ldi	r24, 0xFF	; 255
     842:	68 96       	adiw	r28, 0x18	; 24
     844:	e6 e0       	ldi	r30, 0x06	; 6
     846:	0c 94 f7 31 	jmp	0x63ee	; 0x63ee <__epilogue_restores__+0x18>

0000084a <__ltsf2>:
     84a:	a8 e1       	ldi	r26, 0x18	; 24
     84c:	b0 e0       	ldi	r27, 0x00	; 0
     84e:	eb e2       	ldi	r30, 0x2B	; 43
     850:	f4 e0       	ldi	r31, 0x04	; 4
     852:	0c 94 db 31 	jmp	0x63b6	; 0x63b6 <__prologue_saves__+0x18>
     856:	69 83       	std	Y+1, r22	; 0x01
     858:	7a 83       	std	Y+2, r23	; 0x02
     85a:	8b 83       	std	Y+3, r24	; 0x03
     85c:	9c 83       	std	Y+4, r25	; 0x04
     85e:	2d 83       	std	Y+5, r18	; 0x05
     860:	3e 83       	std	Y+6, r19	; 0x06
     862:	4f 83       	std	Y+7, r20	; 0x07
     864:	58 87       	std	Y+8, r21	; 0x08
     866:	89 e0       	ldi	r24, 0x09	; 9
     868:	e8 2e       	mov	r14, r24
     86a:	f1 2c       	mov	r15, r1
     86c:	ec 0e       	add	r14, r28
     86e:	fd 1e       	adc	r15, r29
     870:	ce 01       	movw	r24, r28
     872:	01 96       	adiw	r24, 0x01	; 1
     874:	b7 01       	movw	r22, r14
     876:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     87a:	8e 01       	movw	r16, r28
     87c:	0f 5e       	subi	r16, 0xEF	; 239
     87e:	1f 4f       	sbci	r17, 0xFF	; 255
     880:	ce 01       	movw	r24, r28
     882:	05 96       	adiw	r24, 0x05	; 5
     884:	b8 01       	movw	r22, r16
     886:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     88a:	89 85       	ldd	r24, Y+9	; 0x09
     88c:	82 30       	cpi	r24, 0x02	; 2
     88e:	40 f0       	brcs	.+16     	; 0x8a0 <__stack+0x41>
     890:	89 89       	ldd	r24, Y+17	; 0x11
     892:	82 30       	cpi	r24, 0x02	; 2
     894:	28 f0       	brcs	.+10     	; 0x8a0 <__stack+0x41>
     896:	c7 01       	movw	r24, r14
     898:	b8 01       	movw	r22, r16
     89a:	0e 94 be 06 	call	0xd7c	; 0xd7c <__fpcmp_parts_f>
     89e:	01 c0       	rjmp	.+2      	; 0x8a2 <__stack+0x43>
     8a0:	81 e0       	ldi	r24, 0x01	; 1
     8a2:	68 96       	adiw	r28, 0x18	; 24
     8a4:	e6 e0       	ldi	r30, 0x06	; 6
     8a6:	0c 94 f7 31 	jmp	0x63ee	; 0x63ee <__epilogue_restores__+0x18>

000008aa <__fixsfsi>:
     8aa:	ac e0       	ldi	r26, 0x0C	; 12
     8ac:	b0 e0       	ldi	r27, 0x00	; 0
     8ae:	eb e5       	ldi	r30, 0x5B	; 91
     8b0:	f4 e0       	ldi	r31, 0x04	; 4
     8b2:	0c 94 df 31 	jmp	0x63be	; 0x63be <__prologue_saves__+0x20>
     8b6:	69 83       	std	Y+1, r22	; 0x01
     8b8:	7a 83       	std	Y+2, r23	; 0x02
     8ba:	8b 83       	std	Y+3, r24	; 0x03
     8bc:	9c 83       	std	Y+4, r25	; 0x04
     8be:	ce 01       	movw	r24, r28
     8c0:	01 96       	adiw	r24, 0x01	; 1
     8c2:	be 01       	movw	r22, r28
     8c4:	6b 5f       	subi	r22, 0xFB	; 251
     8c6:	7f 4f       	sbci	r23, 0xFF	; 255
     8c8:	0e 94 46 06 	call	0xc8c	; 0xc8c <__unpack_f>
     8cc:	8d 81       	ldd	r24, Y+5	; 0x05
     8ce:	82 30       	cpi	r24, 0x02	; 2
     8d0:	61 f1       	breq	.+88     	; 0x92a <__fixsfsi+0x80>
     8d2:	82 30       	cpi	r24, 0x02	; 2
     8d4:	50 f1       	brcs	.+84     	; 0x92a <__fixsfsi+0x80>
     8d6:	84 30       	cpi	r24, 0x04	; 4
     8d8:	21 f4       	brne	.+8      	; 0x8e2 <__fixsfsi+0x38>
     8da:	8e 81       	ldd	r24, Y+6	; 0x06
     8dc:	88 23       	and	r24, r24
     8de:	51 f1       	breq	.+84     	; 0x934 <__fixsfsi+0x8a>
     8e0:	2e c0       	rjmp	.+92     	; 0x93e <__fixsfsi+0x94>
     8e2:	2f 81       	ldd	r18, Y+7	; 0x07
     8e4:	38 85       	ldd	r19, Y+8	; 0x08
     8e6:	37 fd       	sbrc	r19, 7
     8e8:	20 c0       	rjmp	.+64     	; 0x92a <__fixsfsi+0x80>
     8ea:	6e 81       	ldd	r22, Y+6	; 0x06
     8ec:	2f 31       	cpi	r18, 0x1F	; 31
     8ee:	31 05       	cpc	r19, r1
     8f0:	1c f0       	brlt	.+6      	; 0x8f8 <__fixsfsi+0x4e>
     8f2:	66 23       	and	r22, r22
     8f4:	f9 f0       	breq	.+62     	; 0x934 <__fixsfsi+0x8a>
     8f6:	23 c0       	rjmp	.+70     	; 0x93e <__fixsfsi+0x94>
     8f8:	8e e1       	ldi	r24, 0x1E	; 30
     8fa:	90 e0       	ldi	r25, 0x00	; 0
     8fc:	82 1b       	sub	r24, r18
     8fe:	93 0b       	sbc	r25, r19
     900:	29 85       	ldd	r18, Y+9	; 0x09
     902:	3a 85       	ldd	r19, Y+10	; 0x0a
     904:	4b 85       	ldd	r20, Y+11	; 0x0b
     906:	5c 85       	ldd	r21, Y+12	; 0x0c
     908:	04 c0       	rjmp	.+8      	; 0x912 <__fixsfsi+0x68>
     90a:	56 95       	lsr	r21
     90c:	47 95       	ror	r20
     90e:	37 95       	ror	r19
     910:	27 95       	ror	r18
     912:	8a 95       	dec	r24
     914:	d2 f7       	brpl	.-12     	; 0x90a <__fixsfsi+0x60>
     916:	66 23       	and	r22, r22
     918:	b1 f0       	breq	.+44     	; 0x946 <__fixsfsi+0x9c>
     91a:	50 95       	com	r21
     91c:	40 95       	com	r20
     91e:	30 95       	com	r19
     920:	21 95       	neg	r18
     922:	3f 4f       	sbci	r19, 0xFF	; 255
     924:	4f 4f       	sbci	r20, 0xFF	; 255
     926:	5f 4f       	sbci	r21, 0xFF	; 255
     928:	0e c0       	rjmp	.+28     	; 0x946 <__fixsfsi+0x9c>
     92a:	20 e0       	ldi	r18, 0x00	; 0
     92c:	30 e0       	ldi	r19, 0x00	; 0
     92e:	40 e0       	ldi	r20, 0x00	; 0
     930:	50 e0       	ldi	r21, 0x00	; 0
     932:	09 c0       	rjmp	.+18     	; 0x946 <__fixsfsi+0x9c>
     934:	2f ef       	ldi	r18, 0xFF	; 255
     936:	3f ef       	ldi	r19, 0xFF	; 255
     938:	4f ef       	ldi	r20, 0xFF	; 255
     93a:	5f e7       	ldi	r21, 0x7F	; 127
     93c:	04 c0       	rjmp	.+8      	; 0x946 <__fixsfsi+0x9c>
     93e:	20 e0       	ldi	r18, 0x00	; 0
     940:	30 e0       	ldi	r19, 0x00	; 0
     942:	40 e0       	ldi	r20, 0x00	; 0
     944:	50 e8       	ldi	r21, 0x80	; 128
     946:	b9 01       	movw	r22, r18
     948:	ca 01       	movw	r24, r20
     94a:	2c 96       	adiw	r28, 0x0c	; 12
     94c:	e2 e0       	ldi	r30, 0x02	; 2
     94e:	0c 94 fb 31 	jmp	0x63f6	; 0x63f6 <__epilogue_restores__+0x20>

00000952 <__floatunsisf>:
     952:	a8 e0       	ldi	r26, 0x08	; 8
     954:	b0 e0       	ldi	r27, 0x00	; 0
     956:	ef ea       	ldi	r30, 0xAF	; 175
     958:	f4 e0       	ldi	r31, 0x04	; 4
     95a:	0c 94 d7 31 	jmp	0x63ae	; 0x63ae <__prologue_saves__+0x10>
     95e:	7b 01       	movw	r14, r22
     960:	8c 01       	movw	r16, r24
     962:	61 15       	cp	r22, r1
     964:	71 05       	cpc	r23, r1
     966:	81 05       	cpc	r24, r1
     968:	91 05       	cpc	r25, r1
     96a:	19 f4       	brne	.+6      	; 0x972 <__floatunsisf+0x20>
     96c:	82 e0       	ldi	r24, 0x02	; 2
     96e:	89 83       	std	Y+1, r24	; 0x01
     970:	60 c0       	rjmp	.+192    	; 0xa32 <__floatunsisf+0xe0>
     972:	83 e0       	ldi	r24, 0x03	; 3
     974:	89 83       	std	Y+1, r24	; 0x01
     976:	8e e1       	ldi	r24, 0x1E	; 30
     978:	c8 2e       	mov	r12, r24
     97a:	d1 2c       	mov	r13, r1
     97c:	dc 82       	std	Y+4, r13	; 0x04
     97e:	cb 82       	std	Y+3, r12	; 0x03
     980:	ed 82       	std	Y+5, r14	; 0x05
     982:	fe 82       	std	Y+6, r15	; 0x06
     984:	0f 83       	std	Y+7, r16	; 0x07
     986:	18 87       	std	Y+8, r17	; 0x08
     988:	c8 01       	movw	r24, r16
     98a:	b7 01       	movw	r22, r14
     98c:	0e 94 22 05 	call	0xa44	; 0xa44 <__clzsi2>
     990:	fc 01       	movw	r30, r24
     992:	31 97       	sbiw	r30, 0x01	; 1
     994:	f7 ff       	sbrs	r31, 7
     996:	3b c0       	rjmp	.+118    	; 0xa0e <__floatunsisf+0xbc>
     998:	22 27       	eor	r18, r18
     99a:	33 27       	eor	r19, r19
     99c:	2e 1b       	sub	r18, r30
     99e:	3f 0b       	sbc	r19, r31
     9a0:	57 01       	movw	r10, r14
     9a2:	68 01       	movw	r12, r16
     9a4:	02 2e       	mov	r0, r18
     9a6:	04 c0       	rjmp	.+8      	; 0x9b0 <__floatunsisf+0x5e>
     9a8:	d6 94       	lsr	r13
     9aa:	c7 94       	ror	r12
     9ac:	b7 94       	ror	r11
     9ae:	a7 94       	ror	r10
     9b0:	0a 94       	dec	r0
     9b2:	d2 f7       	brpl	.-12     	; 0x9a8 <__floatunsisf+0x56>
     9b4:	40 e0       	ldi	r20, 0x00	; 0
     9b6:	50 e0       	ldi	r21, 0x00	; 0
     9b8:	60 e0       	ldi	r22, 0x00	; 0
     9ba:	70 e0       	ldi	r23, 0x00	; 0
     9bc:	81 e0       	ldi	r24, 0x01	; 1
     9be:	90 e0       	ldi	r25, 0x00	; 0
     9c0:	a0 e0       	ldi	r26, 0x00	; 0
     9c2:	b0 e0       	ldi	r27, 0x00	; 0
     9c4:	04 c0       	rjmp	.+8      	; 0x9ce <__floatunsisf+0x7c>
     9c6:	88 0f       	add	r24, r24
     9c8:	99 1f       	adc	r25, r25
     9ca:	aa 1f       	adc	r26, r26
     9cc:	bb 1f       	adc	r27, r27
     9ce:	2a 95       	dec	r18
     9d0:	d2 f7       	brpl	.-12     	; 0x9c6 <__floatunsisf+0x74>
     9d2:	01 97       	sbiw	r24, 0x01	; 1
     9d4:	a1 09       	sbc	r26, r1
     9d6:	b1 09       	sbc	r27, r1
     9d8:	8e 21       	and	r24, r14
     9da:	9f 21       	and	r25, r15
     9dc:	a0 23       	and	r26, r16
     9de:	b1 23       	and	r27, r17
     9e0:	00 97       	sbiw	r24, 0x00	; 0
     9e2:	a1 05       	cpc	r26, r1
     9e4:	b1 05       	cpc	r27, r1
     9e6:	21 f0       	breq	.+8      	; 0x9f0 <__floatunsisf+0x9e>
     9e8:	41 e0       	ldi	r20, 0x01	; 1
     9ea:	50 e0       	ldi	r21, 0x00	; 0
     9ec:	60 e0       	ldi	r22, 0x00	; 0
     9ee:	70 e0       	ldi	r23, 0x00	; 0
     9f0:	4a 29       	or	r20, r10
     9f2:	5b 29       	or	r21, r11
     9f4:	6c 29       	or	r22, r12
     9f6:	7d 29       	or	r23, r13
     9f8:	4d 83       	std	Y+5, r20	; 0x05
     9fa:	5e 83       	std	Y+6, r21	; 0x06
     9fc:	6f 83       	std	Y+7, r22	; 0x07
     9fe:	78 87       	std	Y+8, r23	; 0x08
     a00:	8e e1       	ldi	r24, 0x1E	; 30
     a02:	90 e0       	ldi	r25, 0x00	; 0
     a04:	8e 1b       	sub	r24, r30
     a06:	9f 0b       	sbc	r25, r31
     a08:	9c 83       	std	Y+4, r25	; 0x04
     a0a:	8b 83       	std	Y+3, r24	; 0x03
     a0c:	12 c0       	rjmp	.+36     	; 0xa32 <__floatunsisf+0xe0>
     a0e:	30 97       	sbiw	r30, 0x00	; 0
     a10:	81 f0       	breq	.+32     	; 0xa32 <__floatunsisf+0xe0>
     a12:	0e 2e       	mov	r0, r30
     a14:	04 c0       	rjmp	.+8      	; 0xa1e <__floatunsisf+0xcc>
     a16:	ee 0c       	add	r14, r14
     a18:	ff 1c       	adc	r15, r15
     a1a:	00 1f       	adc	r16, r16
     a1c:	11 1f       	adc	r17, r17
     a1e:	0a 94       	dec	r0
     a20:	d2 f7       	brpl	.-12     	; 0xa16 <__floatunsisf+0xc4>
     a22:	ed 82       	std	Y+5, r14	; 0x05
     a24:	fe 82       	std	Y+6, r15	; 0x06
     a26:	0f 83       	std	Y+7, r16	; 0x07
     a28:	18 87       	std	Y+8, r17	; 0x08
     a2a:	ce 1a       	sub	r12, r30
     a2c:	df 0a       	sbc	r13, r31
     a2e:	dc 82       	std	Y+4, r13	; 0x04
     a30:	cb 82       	std	Y+3, r12	; 0x03
     a32:	1a 82       	std	Y+2, r1	; 0x02
     a34:	ce 01       	movw	r24, r28
     a36:	01 96       	adiw	r24, 0x01	; 1
     a38:	0e 94 71 05 	call	0xae2	; 0xae2 <__pack_f>
     a3c:	28 96       	adiw	r28, 0x08	; 8
     a3e:	ea e0       	ldi	r30, 0x0A	; 10
     a40:	0c 94 f3 31 	jmp	0x63e6	; 0x63e6 <__epilogue_restores__+0x10>

00000a44 <__clzsi2>:
     a44:	ef 92       	push	r14
     a46:	ff 92       	push	r15
     a48:	0f 93       	push	r16
     a4a:	1f 93       	push	r17
     a4c:	7b 01       	movw	r14, r22
     a4e:	8c 01       	movw	r16, r24
     a50:	80 e0       	ldi	r24, 0x00	; 0
     a52:	e8 16       	cp	r14, r24
     a54:	80 e0       	ldi	r24, 0x00	; 0
     a56:	f8 06       	cpc	r15, r24
     a58:	81 e0       	ldi	r24, 0x01	; 1
     a5a:	08 07       	cpc	r16, r24
     a5c:	80 e0       	ldi	r24, 0x00	; 0
     a5e:	18 07       	cpc	r17, r24
     a60:	88 f4       	brcc	.+34     	; 0xa84 <__clzsi2+0x40>
     a62:	8f ef       	ldi	r24, 0xFF	; 255
     a64:	e8 16       	cp	r14, r24
     a66:	f1 04       	cpc	r15, r1
     a68:	01 05       	cpc	r16, r1
     a6a:	11 05       	cpc	r17, r1
     a6c:	31 f0       	breq	.+12     	; 0xa7a <__clzsi2+0x36>
     a6e:	28 f0       	brcs	.+10     	; 0xa7a <__clzsi2+0x36>
     a70:	88 e0       	ldi	r24, 0x08	; 8
     a72:	90 e0       	ldi	r25, 0x00	; 0
     a74:	a0 e0       	ldi	r26, 0x00	; 0
     a76:	b0 e0       	ldi	r27, 0x00	; 0
     a78:	17 c0       	rjmp	.+46     	; 0xaa8 <__clzsi2+0x64>
     a7a:	80 e0       	ldi	r24, 0x00	; 0
     a7c:	90 e0       	ldi	r25, 0x00	; 0
     a7e:	a0 e0       	ldi	r26, 0x00	; 0
     a80:	b0 e0       	ldi	r27, 0x00	; 0
     a82:	12 c0       	rjmp	.+36     	; 0xaa8 <__clzsi2+0x64>
     a84:	80 e0       	ldi	r24, 0x00	; 0
     a86:	e8 16       	cp	r14, r24
     a88:	80 e0       	ldi	r24, 0x00	; 0
     a8a:	f8 06       	cpc	r15, r24
     a8c:	80 e0       	ldi	r24, 0x00	; 0
     a8e:	08 07       	cpc	r16, r24
     a90:	81 e0       	ldi	r24, 0x01	; 1
     a92:	18 07       	cpc	r17, r24
     a94:	28 f0       	brcs	.+10     	; 0xaa0 <__clzsi2+0x5c>
     a96:	88 e1       	ldi	r24, 0x18	; 24
     a98:	90 e0       	ldi	r25, 0x00	; 0
     a9a:	a0 e0       	ldi	r26, 0x00	; 0
     a9c:	b0 e0       	ldi	r27, 0x00	; 0
     a9e:	04 c0       	rjmp	.+8      	; 0xaa8 <__clzsi2+0x64>
     aa0:	80 e1       	ldi	r24, 0x10	; 16
     aa2:	90 e0       	ldi	r25, 0x00	; 0
     aa4:	a0 e0       	ldi	r26, 0x00	; 0
     aa6:	b0 e0       	ldi	r27, 0x00	; 0
     aa8:	20 e2       	ldi	r18, 0x20	; 32
     aaa:	30 e0       	ldi	r19, 0x00	; 0
     aac:	40 e0       	ldi	r20, 0x00	; 0
     aae:	50 e0       	ldi	r21, 0x00	; 0
     ab0:	28 1b       	sub	r18, r24
     ab2:	39 0b       	sbc	r19, r25
     ab4:	4a 0b       	sbc	r20, r26
     ab6:	5b 0b       	sbc	r21, r27
     ab8:	04 c0       	rjmp	.+8      	; 0xac2 <__clzsi2+0x7e>
     aba:	16 95       	lsr	r17
     abc:	07 95       	ror	r16
     abe:	f7 94       	ror	r15
     ac0:	e7 94       	ror	r14
     ac2:	8a 95       	dec	r24
     ac4:	d2 f7       	brpl	.-12     	; 0xaba <__clzsi2+0x76>
     ac6:	f7 01       	movw	r30, r14
     ac8:	e1 56       	subi	r30, 0x61	; 97
     aca:	ff 4f       	sbci	r31, 0xFF	; 255
     acc:	80 81       	ld	r24, Z
     ace:	28 1b       	sub	r18, r24
     ad0:	31 09       	sbc	r19, r1
     ad2:	41 09       	sbc	r20, r1
     ad4:	51 09       	sbc	r21, r1
     ad6:	c9 01       	movw	r24, r18
     ad8:	1f 91       	pop	r17
     ada:	0f 91       	pop	r16
     adc:	ff 90       	pop	r15
     ade:	ef 90       	pop	r14
     ae0:	08 95       	ret

00000ae2 <__pack_f>:
     ae2:	df 92       	push	r13
     ae4:	ef 92       	push	r14
     ae6:	ff 92       	push	r15
     ae8:	0f 93       	push	r16
     aea:	1f 93       	push	r17
     aec:	fc 01       	movw	r30, r24
     aee:	e4 80       	ldd	r14, Z+4	; 0x04
     af0:	f5 80       	ldd	r15, Z+5	; 0x05
     af2:	06 81       	ldd	r16, Z+6	; 0x06
     af4:	17 81       	ldd	r17, Z+7	; 0x07
     af6:	d1 80       	ldd	r13, Z+1	; 0x01
     af8:	80 81       	ld	r24, Z
     afa:	82 30       	cpi	r24, 0x02	; 2
     afc:	48 f4       	brcc	.+18     	; 0xb10 <__pack_f+0x2e>
     afe:	80 e0       	ldi	r24, 0x00	; 0
     b00:	90 e0       	ldi	r25, 0x00	; 0
     b02:	a0 e1       	ldi	r26, 0x10	; 16
     b04:	b0 e0       	ldi	r27, 0x00	; 0
     b06:	e8 2a       	or	r14, r24
     b08:	f9 2a       	or	r15, r25
     b0a:	0a 2b       	or	r16, r26
     b0c:	1b 2b       	or	r17, r27
     b0e:	a5 c0       	rjmp	.+330    	; 0xc5a <__pack_f+0x178>
     b10:	84 30       	cpi	r24, 0x04	; 4
     b12:	09 f4       	brne	.+2      	; 0xb16 <__pack_f+0x34>
     b14:	9f c0       	rjmp	.+318    	; 0xc54 <__pack_f+0x172>
     b16:	82 30       	cpi	r24, 0x02	; 2
     b18:	21 f4       	brne	.+8      	; 0xb22 <__pack_f+0x40>
     b1a:	ee 24       	eor	r14, r14
     b1c:	ff 24       	eor	r15, r15
     b1e:	87 01       	movw	r16, r14
     b20:	05 c0       	rjmp	.+10     	; 0xb2c <__pack_f+0x4a>
     b22:	e1 14       	cp	r14, r1
     b24:	f1 04       	cpc	r15, r1
     b26:	01 05       	cpc	r16, r1
     b28:	11 05       	cpc	r17, r1
     b2a:	19 f4       	brne	.+6      	; 0xb32 <__pack_f+0x50>
     b2c:	e0 e0       	ldi	r30, 0x00	; 0
     b2e:	f0 e0       	ldi	r31, 0x00	; 0
     b30:	96 c0       	rjmp	.+300    	; 0xc5e <__pack_f+0x17c>
     b32:	62 81       	ldd	r22, Z+2	; 0x02
     b34:	73 81       	ldd	r23, Z+3	; 0x03
     b36:	9f ef       	ldi	r25, 0xFF	; 255
     b38:	62 38       	cpi	r22, 0x82	; 130
     b3a:	79 07       	cpc	r23, r25
     b3c:	0c f0       	brlt	.+2      	; 0xb40 <__pack_f+0x5e>
     b3e:	5b c0       	rjmp	.+182    	; 0xbf6 <__pack_f+0x114>
     b40:	22 e8       	ldi	r18, 0x82	; 130
     b42:	3f ef       	ldi	r19, 0xFF	; 255
     b44:	26 1b       	sub	r18, r22
     b46:	37 0b       	sbc	r19, r23
     b48:	2a 31       	cpi	r18, 0x1A	; 26
     b4a:	31 05       	cpc	r19, r1
     b4c:	2c f0       	brlt	.+10     	; 0xb58 <__pack_f+0x76>
     b4e:	20 e0       	ldi	r18, 0x00	; 0
     b50:	30 e0       	ldi	r19, 0x00	; 0
     b52:	40 e0       	ldi	r20, 0x00	; 0
     b54:	50 e0       	ldi	r21, 0x00	; 0
     b56:	2a c0       	rjmp	.+84     	; 0xbac <__pack_f+0xca>
     b58:	b8 01       	movw	r22, r16
     b5a:	a7 01       	movw	r20, r14
     b5c:	02 2e       	mov	r0, r18
     b5e:	04 c0       	rjmp	.+8      	; 0xb68 <__pack_f+0x86>
     b60:	76 95       	lsr	r23
     b62:	67 95       	ror	r22
     b64:	57 95       	ror	r21
     b66:	47 95       	ror	r20
     b68:	0a 94       	dec	r0
     b6a:	d2 f7       	brpl	.-12     	; 0xb60 <__pack_f+0x7e>
     b6c:	81 e0       	ldi	r24, 0x01	; 1
     b6e:	90 e0       	ldi	r25, 0x00	; 0
     b70:	a0 e0       	ldi	r26, 0x00	; 0
     b72:	b0 e0       	ldi	r27, 0x00	; 0
     b74:	04 c0       	rjmp	.+8      	; 0xb7e <__pack_f+0x9c>
     b76:	88 0f       	add	r24, r24
     b78:	99 1f       	adc	r25, r25
     b7a:	aa 1f       	adc	r26, r26
     b7c:	bb 1f       	adc	r27, r27
     b7e:	2a 95       	dec	r18
     b80:	d2 f7       	brpl	.-12     	; 0xb76 <__pack_f+0x94>
     b82:	01 97       	sbiw	r24, 0x01	; 1
     b84:	a1 09       	sbc	r26, r1
     b86:	b1 09       	sbc	r27, r1
     b88:	8e 21       	and	r24, r14
     b8a:	9f 21       	and	r25, r15
     b8c:	a0 23       	and	r26, r16
     b8e:	b1 23       	and	r27, r17
     b90:	00 97       	sbiw	r24, 0x00	; 0
     b92:	a1 05       	cpc	r26, r1
     b94:	b1 05       	cpc	r27, r1
     b96:	21 f0       	breq	.+8      	; 0xba0 <__pack_f+0xbe>
     b98:	81 e0       	ldi	r24, 0x01	; 1
     b9a:	90 e0       	ldi	r25, 0x00	; 0
     b9c:	a0 e0       	ldi	r26, 0x00	; 0
     b9e:	b0 e0       	ldi	r27, 0x00	; 0
     ba0:	9a 01       	movw	r18, r20
     ba2:	ab 01       	movw	r20, r22
     ba4:	28 2b       	or	r18, r24
     ba6:	39 2b       	or	r19, r25
     ba8:	4a 2b       	or	r20, r26
     baa:	5b 2b       	or	r21, r27
     bac:	da 01       	movw	r26, r20
     bae:	c9 01       	movw	r24, r18
     bb0:	8f 77       	andi	r24, 0x7F	; 127
     bb2:	90 70       	andi	r25, 0x00	; 0
     bb4:	a0 70       	andi	r26, 0x00	; 0
     bb6:	b0 70       	andi	r27, 0x00	; 0
     bb8:	80 34       	cpi	r24, 0x40	; 64
     bba:	91 05       	cpc	r25, r1
     bbc:	a1 05       	cpc	r26, r1
     bbe:	b1 05       	cpc	r27, r1
     bc0:	39 f4       	brne	.+14     	; 0xbd0 <__pack_f+0xee>
     bc2:	27 ff       	sbrs	r18, 7
     bc4:	09 c0       	rjmp	.+18     	; 0xbd8 <__pack_f+0xf6>
     bc6:	20 5c       	subi	r18, 0xC0	; 192
     bc8:	3f 4f       	sbci	r19, 0xFF	; 255
     bca:	4f 4f       	sbci	r20, 0xFF	; 255
     bcc:	5f 4f       	sbci	r21, 0xFF	; 255
     bce:	04 c0       	rjmp	.+8      	; 0xbd8 <__pack_f+0xf6>
     bd0:	21 5c       	subi	r18, 0xC1	; 193
     bd2:	3f 4f       	sbci	r19, 0xFF	; 255
     bd4:	4f 4f       	sbci	r20, 0xFF	; 255
     bd6:	5f 4f       	sbci	r21, 0xFF	; 255
     bd8:	e0 e0       	ldi	r30, 0x00	; 0
     bda:	f0 e0       	ldi	r31, 0x00	; 0
     bdc:	20 30       	cpi	r18, 0x00	; 0
     bde:	a0 e0       	ldi	r26, 0x00	; 0
     be0:	3a 07       	cpc	r19, r26
     be2:	a0 e0       	ldi	r26, 0x00	; 0
     be4:	4a 07       	cpc	r20, r26
     be6:	a0 e4       	ldi	r26, 0x40	; 64
     be8:	5a 07       	cpc	r21, r26
     bea:	10 f0       	brcs	.+4      	; 0xbf0 <__pack_f+0x10e>
     bec:	e1 e0       	ldi	r30, 0x01	; 1
     bee:	f0 e0       	ldi	r31, 0x00	; 0
     bf0:	79 01       	movw	r14, r18
     bf2:	8a 01       	movw	r16, r20
     bf4:	27 c0       	rjmp	.+78     	; 0xc44 <__pack_f+0x162>
     bf6:	60 38       	cpi	r22, 0x80	; 128
     bf8:	71 05       	cpc	r23, r1
     bfa:	64 f5       	brge	.+88     	; 0xc54 <__pack_f+0x172>
     bfc:	fb 01       	movw	r30, r22
     bfe:	e1 58       	subi	r30, 0x81	; 129
     c00:	ff 4f       	sbci	r31, 0xFF	; 255
     c02:	d8 01       	movw	r26, r16
     c04:	c7 01       	movw	r24, r14
     c06:	8f 77       	andi	r24, 0x7F	; 127
     c08:	90 70       	andi	r25, 0x00	; 0
     c0a:	a0 70       	andi	r26, 0x00	; 0
     c0c:	b0 70       	andi	r27, 0x00	; 0
     c0e:	80 34       	cpi	r24, 0x40	; 64
     c10:	91 05       	cpc	r25, r1
     c12:	a1 05       	cpc	r26, r1
     c14:	b1 05       	cpc	r27, r1
     c16:	39 f4       	brne	.+14     	; 0xc26 <__pack_f+0x144>
     c18:	e7 fe       	sbrs	r14, 7
     c1a:	0d c0       	rjmp	.+26     	; 0xc36 <__pack_f+0x154>
     c1c:	80 e4       	ldi	r24, 0x40	; 64
     c1e:	90 e0       	ldi	r25, 0x00	; 0
     c20:	a0 e0       	ldi	r26, 0x00	; 0
     c22:	b0 e0       	ldi	r27, 0x00	; 0
     c24:	04 c0       	rjmp	.+8      	; 0xc2e <__pack_f+0x14c>
     c26:	8f e3       	ldi	r24, 0x3F	; 63
     c28:	90 e0       	ldi	r25, 0x00	; 0
     c2a:	a0 e0       	ldi	r26, 0x00	; 0
     c2c:	b0 e0       	ldi	r27, 0x00	; 0
     c2e:	e8 0e       	add	r14, r24
     c30:	f9 1e       	adc	r15, r25
     c32:	0a 1f       	adc	r16, r26
     c34:	1b 1f       	adc	r17, r27
     c36:	17 ff       	sbrs	r17, 7
     c38:	05 c0       	rjmp	.+10     	; 0xc44 <__pack_f+0x162>
     c3a:	16 95       	lsr	r17
     c3c:	07 95       	ror	r16
     c3e:	f7 94       	ror	r15
     c40:	e7 94       	ror	r14
     c42:	31 96       	adiw	r30, 0x01	; 1
     c44:	87 e0       	ldi	r24, 0x07	; 7
     c46:	16 95       	lsr	r17
     c48:	07 95       	ror	r16
     c4a:	f7 94       	ror	r15
     c4c:	e7 94       	ror	r14
     c4e:	8a 95       	dec	r24
     c50:	d1 f7       	brne	.-12     	; 0xc46 <__pack_f+0x164>
     c52:	05 c0       	rjmp	.+10     	; 0xc5e <__pack_f+0x17c>
     c54:	ee 24       	eor	r14, r14
     c56:	ff 24       	eor	r15, r15
     c58:	87 01       	movw	r16, r14
     c5a:	ef ef       	ldi	r30, 0xFF	; 255
     c5c:	f0 e0       	ldi	r31, 0x00	; 0
     c5e:	6e 2f       	mov	r22, r30
     c60:	67 95       	ror	r22
     c62:	66 27       	eor	r22, r22
     c64:	67 95       	ror	r22
     c66:	90 2f       	mov	r25, r16
     c68:	9f 77       	andi	r25, 0x7F	; 127
     c6a:	d7 94       	ror	r13
     c6c:	dd 24       	eor	r13, r13
     c6e:	d7 94       	ror	r13
     c70:	8e 2f       	mov	r24, r30
     c72:	86 95       	lsr	r24
     c74:	49 2f       	mov	r20, r25
     c76:	46 2b       	or	r20, r22
     c78:	58 2f       	mov	r21, r24
     c7a:	5d 29       	or	r21, r13
     c7c:	b7 01       	movw	r22, r14
     c7e:	ca 01       	movw	r24, r20
     c80:	1f 91       	pop	r17
     c82:	0f 91       	pop	r16
     c84:	ff 90       	pop	r15
     c86:	ef 90       	pop	r14
     c88:	df 90       	pop	r13
     c8a:	08 95       	ret

00000c8c <__unpack_f>:
     c8c:	fc 01       	movw	r30, r24
     c8e:	db 01       	movw	r26, r22
     c90:	40 81       	ld	r20, Z
     c92:	51 81       	ldd	r21, Z+1	; 0x01
     c94:	22 81       	ldd	r18, Z+2	; 0x02
     c96:	62 2f       	mov	r22, r18
     c98:	6f 77       	andi	r22, 0x7F	; 127
     c9a:	70 e0       	ldi	r23, 0x00	; 0
     c9c:	22 1f       	adc	r18, r18
     c9e:	22 27       	eor	r18, r18
     ca0:	22 1f       	adc	r18, r18
     ca2:	93 81       	ldd	r25, Z+3	; 0x03
     ca4:	89 2f       	mov	r24, r25
     ca6:	88 0f       	add	r24, r24
     ca8:	82 2b       	or	r24, r18
     caa:	28 2f       	mov	r18, r24
     cac:	30 e0       	ldi	r19, 0x00	; 0
     cae:	99 1f       	adc	r25, r25
     cb0:	99 27       	eor	r25, r25
     cb2:	99 1f       	adc	r25, r25
     cb4:	11 96       	adiw	r26, 0x01	; 1
     cb6:	9c 93       	st	X, r25
     cb8:	11 97       	sbiw	r26, 0x01	; 1
     cba:	21 15       	cp	r18, r1
     cbc:	31 05       	cpc	r19, r1
     cbe:	a9 f5       	brne	.+106    	; 0xd2a <__unpack_f+0x9e>
     cc0:	41 15       	cp	r20, r1
     cc2:	51 05       	cpc	r21, r1
     cc4:	61 05       	cpc	r22, r1
     cc6:	71 05       	cpc	r23, r1
     cc8:	11 f4       	brne	.+4      	; 0xcce <__unpack_f+0x42>
     cca:	82 e0       	ldi	r24, 0x02	; 2
     ccc:	37 c0       	rjmp	.+110    	; 0xd3c <__unpack_f+0xb0>
     cce:	82 e8       	ldi	r24, 0x82	; 130
     cd0:	9f ef       	ldi	r25, 0xFF	; 255
     cd2:	13 96       	adiw	r26, 0x03	; 3
     cd4:	9c 93       	st	X, r25
     cd6:	8e 93       	st	-X, r24
     cd8:	12 97       	sbiw	r26, 0x02	; 2
     cda:	9a 01       	movw	r18, r20
     cdc:	ab 01       	movw	r20, r22
     cde:	67 e0       	ldi	r22, 0x07	; 7
     ce0:	22 0f       	add	r18, r18
     ce2:	33 1f       	adc	r19, r19
     ce4:	44 1f       	adc	r20, r20
     ce6:	55 1f       	adc	r21, r21
     ce8:	6a 95       	dec	r22
     cea:	d1 f7       	brne	.-12     	; 0xce0 <__unpack_f+0x54>
     cec:	83 e0       	ldi	r24, 0x03	; 3
     cee:	8c 93       	st	X, r24
     cf0:	0d c0       	rjmp	.+26     	; 0xd0c <__unpack_f+0x80>
     cf2:	22 0f       	add	r18, r18
     cf4:	33 1f       	adc	r19, r19
     cf6:	44 1f       	adc	r20, r20
     cf8:	55 1f       	adc	r21, r21
     cfa:	12 96       	adiw	r26, 0x02	; 2
     cfc:	8d 91       	ld	r24, X+
     cfe:	9c 91       	ld	r25, X
     d00:	13 97       	sbiw	r26, 0x03	; 3
     d02:	01 97       	sbiw	r24, 0x01	; 1
     d04:	13 96       	adiw	r26, 0x03	; 3
     d06:	9c 93       	st	X, r25
     d08:	8e 93       	st	-X, r24
     d0a:	12 97       	sbiw	r26, 0x02	; 2
     d0c:	20 30       	cpi	r18, 0x00	; 0
     d0e:	80 e0       	ldi	r24, 0x00	; 0
     d10:	38 07       	cpc	r19, r24
     d12:	80 e0       	ldi	r24, 0x00	; 0
     d14:	48 07       	cpc	r20, r24
     d16:	80 e4       	ldi	r24, 0x40	; 64
     d18:	58 07       	cpc	r21, r24
     d1a:	58 f3       	brcs	.-42     	; 0xcf2 <__unpack_f+0x66>
     d1c:	14 96       	adiw	r26, 0x04	; 4
     d1e:	2d 93       	st	X+, r18
     d20:	3d 93       	st	X+, r19
     d22:	4d 93       	st	X+, r20
     d24:	5c 93       	st	X, r21
     d26:	17 97       	sbiw	r26, 0x07	; 7
     d28:	08 95       	ret
     d2a:	2f 3f       	cpi	r18, 0xFF	; 255
     d2c:	31 05       	cpc	r19, r1
     d2e:	79 f4       	brne	.+30     	; 0xd4e <__unpack_f+0xc2>
     d30:	41 15       	cp	r20, r1
     d32:	51 05       	cpc	r21, r1
     d34:	61 05       	cpc	r22, r1
     d36:	71 05       	cpc	r23, r1
     d38:	19 f4       	brne	.+6      	; 0xd40 <__unpack_f+0xb4>
     d3a:	84 e0       	ldi	r24, 0x04	; 4
     d3c:	8c 93       	st	X, r24
     d3e:	08 95       	ret
     d40:	64 ff       	sbrs	r22, 4
     d42:	03 c0       	rjmp	.+6      	; 0xd4a <__unpack_f+0xbe>
     d44:	81 e0       	ldi	r24, 0x01	; 1
     d46:	8c 93       	st	X, r24
     d48:	12 c0       	rjmp	.+36     	; 0xd6e <__unpack_f+0xe2>
     d4a:	1c 92       	st	X, r1
     d4c:	10 c0       	rjmp	.+32     	; 0xd6e <__unpack_f+0xe2>
     d4e:	2f 57       	subi	r18, 0x7F	; 127
     d50:	30 40       	sbci	r19, 0x00	; 0
     d52:	13 96       	adiw	r26, 0x03	; 3
     d54:	3c 93       	st	X, r19
     d56:	2e 93       	st	-X, r18
     d58:	12 97       	sbiw	r26, 0x02	; 2
     d5a:	83 e0       	ldi	r24, 0x03	; 3
     d5c:	8c 93       	st	X, r24
     d5e:	87 e0       	ldi	r24, 0x07	; 7
     d60:	44 0f       	add	r20, r20
     d62:	55 1f       	adc	r21, r21
     d64:	66 1f       	adc	r22, r22
     d66:	77 1f       	adc	r23, r23
     d68:	8a 95       	dec	r24
     d6a:	d1 f7       	brne	.-12     	; 0xd60 <__unpack_f+0xd4>
     d6c:	70 64       	ori	r23, 0x40	; 64
     d6e:	14 96       	adiw	r26, 0x04	; 4
     d70:	4d 93       	st	X+, r20
     d72:	5d 93       	st	X+, r21
     d74:	6d 93       	st	X+, r22
     d76:	7c 93       	st	X, r23
     d78:	17 97       	sbiw	r26, 0x07	; 7
     d7a:	08 95       	ret

00000d7c <__fpcmp_parts_f>:
     d7c:	1f 93       	push	r17
     d7e:	dc 01       	movw	r26, r24
     d80:	fb 01       	movw	r30, r22
     d82:	9c 91       	ld	r25, X
     d84:	92 30       	cpi	r25, 0x02	; 2
     d86:	08 f4       	brcc	.+2      	; 0xd8a <__fpcmp_parts_f+0xe>
     d88:	47 c0       	rjmp	.+142    	; 0xe18 <__fpcmp_parts_f+0x9c>
     d8a:	80 81       	ld	r24, Z
     d8c:	82 30       	cpi	r24, 0x02	; 2
     d8e:	08 f4       	brcc	.+2      	; 0xd92 <__fpcmp_parts_f+0x16>
     d90:	43 c0       	rjmp	.+134    	; 0xe18 <__fpcmp_parts_f+0x9c>
     d92:	94 30       	cpi	r25, 0x04	; 4
     d94:	51 f4       	brne	.+20     	; 0xdaa <__fpcmp_parts_f+0x2e>
     d96:	11 96       	adiw	r26, 0x01	; 1
     d98:	1c 91       	ld	r17, X
     d9a:	84 30       	cpi	r24, 0x04	; 4
     d9c:	99 f5       	brne	.+102    	; 0xe04 <__fpcmp_parts_f+0x88>
     d9e:	81 81       	ldd	r24, Z+1	; 0x01
     da0:	68 2f       	mov	r22, r24
     da2:	70 e0       	ldi	r23, 0x00	; 0
     da4:	61 1b       	sub	r22, r17
     da6:	71 09       	sbc	r23, r1
     da8:	3f c0       	rjmp	.+126    	; 0xe28 <__fpcmp_parts_f+0xac>
     daa:	84 30       	cpi	r24, 0x04	; 4
     dac:	21 f0       	breq	.+8      	; 0xdb6 <__fpcmp_parts_f+0x3a>
     dae:	92 30       	cpi	r25, 0x02	; 2
     db0:	31 f4       	brne	.+12     	; 0xdbe <__fpcmp_parts_f+0x42>
     db2:	82 30       	cpi	r24, 0x02	; 2
     db4:	b9 f1       	breq	.+110    	; 0xe24 <__fpcmp_parts_f+0xa8>
     db6:	81 81       	ldd	r24, Z+1	; 0x01
     db8:	88 23       	and	r24, r24
     dba:	89 f1       	breq	.+98     	; 0xe1e <__fpcmp_parts_f+0xa2>
     dbc:	2d c0       	rjmp	.+90     	; 0xe18 <__fpcmp_parts_f+0x9c>
     dbe:	11 96       	adiw	r26, 0x01	; 1
     dc0:	1c 91       	ld	r17, X
     dc2:	11 97       	sbiw	r26, 0x01	; 1
     dc4:	82 30       	cpi	r24, 0x02	; 2
     dc6:	f1 f0       	breq	.+60     	; 0xe04 <__fpcmp_parts_f+0x88>
     dc8:	81 81       	ldd	r24, Z+1	; 0x01
     dca:	18 17       	cp	r17, r24
     dcc:	d9 f4       	brne	.+54     	; 0xe04 <__fpcmp_parts_f+0x88>
     dce:	12 96       	adiw	r26, 0x02	; 2
     dd0:	2d 91       	ld	r18, X+
     dd2:	3c 91       	ld	r19, X
     dd4:	13 97       	sbiw	r26, 0x03	; 3
     dd6:	82 81       	ldd	r24, Z+2	; 0x02
     dd8:	93 81       	ldd	r25, Z+3	; 0x03
     dda:	82 17       	cp	r24, r18
     ddc:	93 07       	cpc	r25, r19
     dde:	94 f0       	brlt	.+36     	; 0xe04 <__fpcmp_parts_f+0x88>
     de0:	28 17       	cp	r18, r24
     de2:	39 07       	cpc	r19, r25
     de4:	bc f0       	brlt	.+46     	; 0xe14 <__fpcmp_parts_f+0x98>
     de6:	14 96       	adiw	r26, 0x04	; 4
     de8:	8d 91       	ld	r24, X+
     dea:	9d 91       	ld	r25, X+
     dec:	0d 90       	ld	r0, X+
     dee:	bc 91       	ld	r27, X
     df0:	a0 2d       	mov	r26, r0
     df2:	24 81       	ldd	r18, Z+4	; 0x04
     df4:	35 81       	ldd	r19, Z+5	; 0x05
     df6:	46 81       	ldd	r20, Z+6	; 0x06
     df8:	57 81       	ldd	r21, Z+7	; 0x07
     dfa:	28 17       	cp	r18, r24
     dfc:	39 07       	cpc	r19, r25
     dfe:	4a 07       	cpc	r20, r26
     e00:	5b 07       	cpc	r21, r27
     e02:	18 f4       	brcc	.+6      	; 0xe0a <__fpcmp_parts_f+0x8e>
     e04:	11 23       	and	r17, r17
     e06:	41 f0       	breq	.+16     	; 0xe18 <__fpcmp_parts_f+0x9c>
     e08:	0a c0       	rjmp	.+20     	; 0xe1e <__fpcmp_parts_f+0xa2>
     e0a:	82 17       	cp	r24, r18
     e0c:	93 07       	cpc	r25, r19
     e0e:	a4 07       	cpc	r26, r20
     e10:	b5 07       	cpc	r27, r21
     e12:	40 f4       	brcc	.+16     	; 0xe24 <__fpcmp_parts_f+0xa8>
     e14:	11 23       	and	r17, r17
     e16:	19 f0       	breq	.+6      	; 0xe1e <__fpcmp_parts_f+0xa2>
     e18:	61 e0       	ldi	r22, 0x01	; 1
     e1a:	70 e0       	ldi	r23, 0x00	; 0
     e1c:	05 c0       	rjmp	.+10     	; 0xe28 <__fpcmp_parts_f+0xac>
     e1e:	6f ef       	ldi	r22, 0xFF	; 255
     e20:	7f ef       	ldi	r23, 0xFF	; 255
     e22:	02 c0       	rjmp	.+4      	; 0xe28 <__fpcmp_parts_f+0xac>
     e24:	60 e0       	ldi	r22, 0x00	; 0
     e26:	70 e0       	ldi	r23, 0x00	; 0
     e28:	cb 01       	movw	r24, r22
     e2a:	1f 91       	pop	r17
     e2c:	08 95       	ret

00000e2e <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
     e2e:	df 93       	push	r29
     e30:	cf 93       	push	r28
     e32:	cd b7       	in	r28, 0x3d	; 61
     e34:	de b7       	in	r29, 0x3e	; 62
     e36:	27 97       	sbiw	r28, 0x07	; 7
     e38:	0f b6       	in	r0, 0x3f	; 63
     e3a:	f8 94       	cli
     e3c:	de bf       	out	0x3e, r29	; 62
     e3e:	0f be       	out	0x3f, r0	; 63
     e40:	cd bf       	out	0x3d, r28	; 61
     e42:	9d 83       	std	Y+5, r25	; 0x05
     e44:	8c 83       	std	Y+4, r24	; 0x04
     e46:	6e 83       	std	Y+6, r22	; 0x06
     e48:	4f 83       	std	Y+7, r20	; 0x07
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
     e4a:	8a e1       	ldi	r24, 0x1A	; 26
     e4c:	90 e0       	ldi	r25, 0x00	; 0
     e4e:	0e 94 ef 09 	call	0x13de	; 0x13de <pvPortMalloc>
     e52:	9a 83       	std	Y+2, r25	; 0x02
     e54:	89 83       	std	Y+1, r24	; 0x01
	if( pxCoRoutine )
     e56:	89 81       	ldd	r24, Y+1	; 0x01
     e58:	9a 81       	ldd	r25, Y+2	; 0x02
     e5a:	00 97       	sbiw	r24, 0x00	; 0
     e5c:	09 f4       	brne	.+2      	; 0xe60 <xCoRoutineCreate+0x32>
     e5e:	6f c0       	rjmp	.+222    	; 0xf3e <xCoRoutineCreate+0x110>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
     e60:	80 91 bc 01 	lds	r24, 0x01BC
     e64:	90 91 bd 01 	lds	r25, 0x01BD
     e68:	00 97       	sbiw	r24, 0x00	; 0
     e6a:	41 f4       	brne	.+16     	; 0xe7c <xCoRoutineCreate+0x4e>
		{
			pxCurrentCoRoutine = pxCoRoutine;
     e6c:	89 81       	ldd	r24, Y+1	; 0x01
     e6e:	9a 81       	ldd	r25, Y+2	; 0x02
     e70:	90 93 bd 01 	sts	0x01BD, r25
     e74:	80 93 bc 01 	sts	0x01BC, r24
			prvInitialiseCoRoutineLists();
     e78:	0e 94 7e 09 	call	0x12fc	; 0x12fc <prvInitialiseCoRoutineLists>
		}

		/* Check the priority is within limits. */
		if( uxPriority >= configMAX_CO_ROUTINE_PRIORITIES )
     e7c:	8e 81       	ldd	r24, Y+6	; 0x06
     e7e:	82 30       	cpi	r24, 0x02	; 2
     e80:	10 f0       	brcs	.+4      	; 0xe86 <xCoRoutineCreate+0x58>
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
     e82:	81 e0       	ldi	r24, 0x01	; 1
     e84:	8e 83       	std	Y+6, r24	; 0x06
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
     e86:	e9 81       	ldd	r30, Y+1	; 0x01
     e88:	fa 81       	ldd	r31, Y+2	; 0x02
     e8a:	11 8e       	std	Z+25, r1	; 0x19
     e8c:	10 8e       	std	Z+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
     e8e:	e9 81       	ldd	r30, Y+1	; 0x01
     e90:	fa 81       	ldd	r31, Y+2	; 0x02
     e92:	8e 81       	ldd	r24, Y+6	; 0x06
     e94:	86 8b       	std	Z+22, r24	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
     e96:	e9 81       	ldd	r30, Y+1	; 0x01
     e98:	fa 81       	ldd	r31, Y+2	; 0x02
     e9a:	8f 81       	ldd	r24, Y+7	; 0x07
     e9c:	87 8b       	std	Z+23, r24	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
     e9e:	e9 81       	ldd	r30, Y+1	; 0x01
     ea0:	fa 81       	ldd	r31, Y+2	; 0x02
     ea2:	8c 81       	ldd	r24, Y+4	; 0x04
     ea4:	9d 81       	ldd	r25, Y+5	; 0x05
     ea6:	91 83       	std	Z+1, r25	; 0x01
     ea8:	80 83       	st	Z, r24

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
     eaa:	89 81       	ldd	r24, Y+1	; 0x01
     eac:	9a 81       	ldd	r25, Y+2	; 0x02
     eae:	02 96       	adiw	r24, 0x02	; 2
     eb0:	0e 94 85 0a 	call	0x150a	; 0x150a <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
     eb4:	89 81       	ldd	r24, Y+1	; 0x01
     eb6:	9a 81       	ldd	r25, Y+2	; 0x02
     eb8:	0c 96       	adiw	r24, 0x0c	; 12
     eba:	0e 94 85 0a 	call	0x150a	; 0x150a <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
     ebe:	e9 81       	ldd	r30, Y+1	; 0x01
     ec0:	fa 81       	ldd	r31, Y+2	; 0x02
     ec2:	89 81       	ldd	r24, Y+1	; 0x01
     ec4:	9a 81       	ldd	r25, Y+2	; 0x02
     ec6:	91 87       	std	Z+9, r25	; 0x09
     ec8:	80 87       	std	Z+8, r24	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
     eca:	e9 81       	ldd	r30, Y+1	; 0x01
     ecc:	fa 81       	ldd	r31, Y+2	; 0x02
     ece:	89 81       	ldd	r24, Y+1	; 0x01
     ed0:	9a 81       	ldd	r25, Y+2	; 0x02
     ed2:	93 8b       	std	Z+19, r25	; 0x13
     ed4:	82 8b       	std	Z+18, r24	; 0x12
	
		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     ed6:	8e 81       	ldd	r24, Y+6	; 0x06
     ed8:	28 2f       	mov	r18, r24
     eda:	30 e0       	ldi	r19, 0x00	; 0
     edc:	85 e0       	ldi	r24, 0x05	; 5
     ede:	90 e0       	ldi	r25, 0x00	; 0
     ee0:	82 1b       	sub	r24, r18
     ee2:	93 0b       	sbc	r25, r19
     ee4:	e9 81       	ldd	r30, Y+1	; 0x01
     ee6:	fa 81       	ldd	r31, Y+2	; 0x02
     ee8:	95 87       	std	Z+13, r25	; 0x0d
     eea:	84 87       	std	Z+12, r24	; 0x0c
		
		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
     eec:	e9 81       	ldd	r30, Y+1	; 0x01
     eee:	fa 81       	ldd	r31, Y+2	; 0x02
     ef0:	96 89       	ldd	r25, Z+22	; 0x16
     ef2:	80 91 be 01 	lds	r24, 0x01BE
     ef6:	89 17       	cp	r24, r25
     ef8:	28 f4       	brcc	.+10     	; 0xf04 <xCoRoutineCreate+0xd6>
     efa:	e9 81       	ldd	r30, Y+1	; 0x01
     efc:	fa 81       	ldd	r31, Y+2	; 0x02
     efe:	86 89       	ldd	r24, Z+22	; 0x16
     f00:	80 93 be 01 	sts	0x01BE, r24
     f04:	e9 81       	ldd	r30, Y+1	; 0x01
     f06:	fa 81       	ldd	r31, Y+2	; 0x02
     f08:	86 89       	ldd	r24, Z+22	; 0x16
     f0a:	28 2f       	mov	r18, r24
     f0c:	30 e0       	ldi	r19, 0x00	; 0
     f0e:	c9 01       	movw	r24, r18
     f10:	88 0f       	add	r24, r24
     f12:	99 1f       	adc	r25, r25
     f14:	88 0f       	add	r24, r24
     f16:	99 1f       	adc	r25, r25
     f18:	88 0f       	add	r24, r24
     f1a:	99 1f       	adc	r25, r25
     f1c:	82 0f       	add	r24, r18
     f1e:	93 1f       	adc	r25, r19
     f20:	ac 01       	movw	r20, r24
     f22:	4b 53       	subi	r20, 0x3B	; 59
     f24:	5e 4f       	sbci	r21, 0xFE	; 254
     f26:	89 81       	ldd	r24, Y+1	; 0x01
     f28:	9a 81       	ldd	r25, Y+2	; 0x02
     f2a:	9c 01       	movw	r18, r24
     f2c:	2e 5f       	subi	r18, 0xFE	; 254
     f2e:	3f 4f       	sbci	r19, 0xFF	; 255
     f30:	ca 01       	movw	r24, r20
     f32:	b9 01       	movw	r22, r18
     f34:	0e 94 95 0a 	call	0x152a	; 0x152a <vListInsertEnd>

		xReturn = pdPASS;
     f38:	81 e0       	ldi	r24, 0x01	; 1
     f3a:	8b 83       	std	Y+3, r24	; 0x03
     f3c:	02 c0       	rjmp	.+4      	; 0xf42 <xCoRoutineCreate+0x114>
	}
	else
	{		
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
     f3e:	8f ef       	ldi	r24, 0xFF	; 255
     f40:	8b 83       	std	Y+3, r24	; 0x03
	}
	
	return xReturn;	
     f42:	8b 81       	ldd	r24, Y+3	; 0x03
}
     f44:	27 96       	adiw	r28, 0x07	; 7
     f46:	0f b6       	in	r0, 0x3f	; 63
     f48:	f8 94       	cli
     f4a:	de bf       	out	0x3e, r29	; 62
     f4c:	0f be       	out	0x3f, r0	; 63
     f4e:	cd bf       	out	0x3d, r28	; 61
     f50:	cf 91       	pop	r28
     f52:	df 91       	pop	r29
     f54:	08 95       	ret

00000f56 <vCoRoutineAddToDelayedList>:
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
     f56:	df 93       	push	r29
     f58:	cf 93       	push	r28
     f5a:	00 d0       	rcall	.+0      	; 0xf5c <vCoRoutineAddToDelayedList+0x6>
     f5c:	00 d0       	rcall	.+0      	; 0xf5e <vCoRoutineAddToDelayedList+0x8>
     f5e:	00 d0       	rcall	.+0      	; 0xf60 <vCoRoutineAddToDelayedList+0xa>
     f60:	cd b7       	in	r28, 0x3d	; 61
     f62:	de b7       	in	r29, 0x3e	; 62
     f64:	9c 83       	std	Y+4, r25	; 0x04
     f66:	8b 83       	std	Y+3, r24	; 0x03
     f68:	7e 83       	std	Y+6, r23	; 0x06
     f6a:	6d 83       	std	Y+5, r22	; 0x05
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
     f6c:	20 91 bf 01 	lds	r18, 0x01BF
     f70:	30 91 c0 01 	lds	r19, 0x01C0
     f74:	8b 81       	ldd	r24, Y+3	; 0x03
     f76:	9c 81       	ldd	r25, Y+4	; 0x04
     f78:	82 0f       	add	r24, r18
     f7a:	93 1f       	adc	r25, r19
     f7c:	9a 83       	std	Y+2, r25	; 0x02
     f7e:	89 83       	std	Y+1, r24	; 0x01

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	vListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     f80:	80 91 bc 01 	lds	r24, 0x01BC
     f84:	90 91 bd 01 	lds	r25, 0x01BD
     f88:	02 96       	adiw	r24, 0x02	; 2
     f8a:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
     f8e:	e0 91 bc 01 	lds	r30, 0x01BC
     f92:	f0 91 bd 01 	lds	r31, 0x01BD
     f96:	89 81       	ldd	r24, Y+1	; 0x01
     f98:	9a 81       	ldd	r25, Y+2	; 0x02
     f9a:	93 83       	std	Z+3, r25	; 0x03
     f9c:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
     f9e:	20 91 bf 01 	lds	r18, 0x01BF
     fa2:	30 91 c0 01 	lds	r19, 0x01C0
     fa6:	89 81       	ldd	r24, Y+1	; 0x01
     fa8:	9a 81       	ldd	r25, Y+2	; 0x02
     faa:	82 17       	cp	r24, r18
     fac:	93 07       	cpc	r25, r19
     fae:	70 f4       	brcc	.+28     	; 0xfcc <vCoRoutineAddToDelayedList+0x76>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     fb0:	80 91 eb 01 	lds	r24, 0x01EB
     fb4:	90 91 ec 01 	lds	r25, 0x01EC
     fb8:	20 91 bc 01 	lds	r18, 0x01BC
     fbc:	30 91 bd 01 	lds	r19, 0x01BD
     fc0:	2e 5f       	subi	r18, 0xFE	; 254
     fc2:	3f 4f       	sbci	r19, 0xFF	; 255
     fc4:	b9 01       	movw	r22, r18
     fc6:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <vListInsert>
     fca:	0d c0       	rjmp	.+26     	; 0xfe6 <vCoRoutineAddToDelayedList+0x90>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
     fcc:	80 91 e9 01 	lds	r24, 0x01E9
     fd0:	90 91 ea 01 	lds	r25, 0x01EA
     fd4:	20 91 bc 01 	lds	r18, 0x01BC
     fd8:	30 91 bd 01 	lds	r19, 0x01BD
     fdc:	2e 5f       	subi	r18, 0xFE	; 254
     fde:	3f 4f       	sbci	r19, 0xFF	; 255
     fe0:	b9 01       	movw	r22, r18
     fe2:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <vListInsert>
	}

	if( pxEventList )
     fe6:	8d 81       	ldd	r24, Y+5	; 0x05
     fe8:	9e 81       	ldd	r25, Y+6	; 0x06
     fea:	00 97       	sbiw	r24, 0x00	; 0
     fec:	61 f0       	breq	.+24     	; 0x1006 <vCoRoutineAddToDelayedList+0xb0>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
     fee:	80 91 bc 01 	lds	r24, 0x01BC
     ff2:	90 91 bd 01 	lds	r25, 0x01BD
     ff6:	9c 01       	movw	r18, r24
     ff8:	24 5f       	subi	r18, 0xF4	; 244
     ffa:	3f 4f       	sbci	r19, 0xFF	; 255
     ffc:	8d 81       	ldd	r24, Y+5	; 0x05
     ffe:	9e 81       	ldd	r25, Y+6	; 0x06
    1000:	b9 01       	movw	r22, r18
    1002:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <vListInsert>
	}
}
    1006:	26 96       	adiw	r28, 0x06	; 6
    1008:	0f b6       	in	r0, 0x3f	; 63
    100a:	f8 94       	cli
    100c:	de bf       	out	0x3e, r29	; 62
    100e:	0f be       	out	0x3f, r0	; 63
    1010:	cd bf       	out	0x3d, r28	; 61
    1012:	cf 91       	pop	r28
    1014:	df 91       	pop	r29
    1016:	08 95       	ret

00001018 <prvCheckPendingReadyList>:
/*-----------------------------------------------------------*/

static void prvCheckPendingReadyList( void )
{
    1018:	df 93       	push	r29
    101a:	cf 93       	push	r28
    101c:	00 d0       	rcall	.+0      	; 0x101e <prvCheckPendingReadyList+0x6>
    101e:	cd b7       	in	r28, 0x3d	; 61
    1020:	de b7       	in	r29, 0x3e	; 62
    1022:	3a c0       	rjmp	.+116    	; 0x1098 <prvCheckPendingReadyList+0x80>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    1024:	f8 94       	cli
		{	
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );			
    1026:	e0 91 f2 01 	lds	r30, 0x01F2
    102a:	f0 91 f3 01 	lds	r31, 0x01F3
    102e:	86 81       	ldd	r24, Z+6	; 0x06
    1030:	97 81       	ldd	r25, Z+7	; 0x07
    1032:	9a 83       	std	Y+2, r25	; 0x02
    1034:	89 83       	std	Y+1, r24	; 0x01
			vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1036:	89 81       	ldd	r24, Y+1	; 0x01
    1038:	9a 81       	ldd	r25, Y+2	; 0x02
    103a:	0c 96       	adiw	r24, 0x0c	; 12
    103c:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>
		}
		portENABLE_INTERRUPTS();
    1040:	78 94       	sei

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    1042:	89 81       	ldd	r24, Y+1	; 0x01
    1044:	9a 81       	ldd	r25, Y+2	; 0x02
    1046:	02 96       	adiw	r24, 0x02	; 2
    1048:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
    104c:	e9 81       	ldd	r30, Y+1	; 0x01
    104e:	fa 81       	ldd	r31, Y+2	; 0x02
    1050:	96 89       	ldd	r25, Z+22	; 0x16
    1052:	80 91 be 01 	lds	r24, 0x01BE
    1056:	89 17       	cp	r24, r25
    1058:	28 f4       	brcc	.+10     	; 0x1064 <prvCheckPendingReadyList+0x4c>
    105a:	e9 81       	ldd	r30, Y+1	; 0x01
    105c:	fa 81       	ldd	r31, Y+2	; 0x02
    105e:	86 89       	ldd	r24, Z+22	; 0x16
    1060:	80 93 be 01 	sts	0x01BE, r24
    1064:	e9 81       	ldd	r30, Y+1	; 0x01
    1066:	fa 81       	ldd	r31, Y+2	; 0x02
    1068:	86 89       	ldd	r24, Z+22	; 0x16
    106a:	28 2f       	mov	r18, r24
    106c:	30 e0       	ldi	r19, 0x00	; 0
    106e:	c9 01       	movw	r24, r18
    1070:	88 0f       	add	r24, r24
    1072:	99 1f       	adc	r25, r25
    1074:	88 0f       	add	r24, r24
    1076:	99 1f       	adc	r25, r25
    1078:	88 0f       	add	r24, r24
    107a:	99 1f       	adc	r25, r25
    107c:	82 0f       	add	r24, r18
    107e:	93 1f       	adc	r25, r19
    1080:	ac 01       	movw	r20, r24
    1082:	4b 53       	subi	r20, 0x3B	; 59
    1084:	5e 4f       	sbci	r21, 0xFE	; 254
    1086:	89 81       	ldd	r24, Y+1	; 0x01
    1088:	9a 81       	ldd	r25, Y+2	; 0x02
    108a:	9c 01       	movw	r18, r24
    108c:	2e 5f       	subi	r18, 0xFE	; 254
    108e:	3f 4f       	sbci	r19, 0xFF	; 255
    1090:	ca 01       	movw	r24, r20
    1092:	b9 01       	movw	r22, r18
    1094:	0e 94 95 0a 	call	0x152a	; 0x152a <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    1098:	80 91 ed 01 	lds	r24, 0x01ED
    109c:	88 23       	and	r24, r24
    109e:	09 f0       	breq	.+2      	; 0x10a2 <prvCheckPendingReadyList+0x8a>
    10a0:	c1 cf       	rjmp	.-126    	; 0x1024 <prvCheckPendingReadyList+0xc>
		portENABLE_INTERRUPTS();

		vListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );	
	}
}
    10a2:	0f 90       	pop	r0
    10a4:	0f 90       	pop	r0
    10a6:	cf 91       	pop	r28
    10a8:	df 91       	pop	r29
    10aa:	08 95       	ret

000010ac <prvCheckDelayedList>:
/*-----------------------------------------------------------*/

static void prvCheckDelayedList( void )
{
    10ac:	df 93       	push	r29
    10ae:	cf 93       	push	r28
    10b0:	00 d0       	rcall	.+0      	; 0x10b2 <prvCheckDelayedList+0x6>
    10b2:	00 d0       	rcall	.+0      	; 0x10b4 <prvCheckDelayedList+0x8>
    10b4:	cd b7       	in	r28, 0x3d	; 61
    10b6:	de b7       	in	r29, 0x3e	; 62
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    10b8:	0e 94 c6 17 	call	0x2f8c	; 0x2f8c <xTaskGetTickCount>
    10bc:	20 91 c1 01 	lds	r18, 0x01C1
    10c0:	30 91 c2 01 	lds	r19, 0x01C2
    10c4:	82 1b       	sub	r24, r18
    10c6:	93 0b       	sbc	r25, r19
    10c8:	90 93 c4 01 	sts	0x01C4, r25
    10cc:	80 93 c3 01 	sts	0x01C3, r24
    10d0:	85 c0       	rjmp	.+266    	; 0x11dc <prvCheckDelayedList+0x130>
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    10d2:	80 91 bf 01 	lds	r24, 0x01BF
    10d6:	90 91 c0 01 	lds	r25, 0x01C0
    10da:	01 96       	adiw	r24, 0x01	; 1
    10dc:	90 93 c0 01 	sts	0x01C0, r25
    10e0:	80 93 bf 01 	sts	0x01BF, r24
		xPassedTicks--;
    10e4:	80 91 c3 01 	lds	r24, 0x01C3
    10e8:	90 91 c4 01 	lds	r25, 0x01C4
    10ec:	01 97       	sbiw	r24, 0x01	; 1
    10ee:	90 93 c4 01 	sts	0x01C4, r25
    10f2:	80 93 c3 01 	sts	0x01C3, r24

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    10f6:	80 91 bf 01 	lds	r24, 0x01BF
    10fa:	90 91 c0 01 	lds	r25, 0x01C0
    10fe:	00 97       	sbiw	r24, 0x00	; 0
    1100:	09 f0       	breq	.+2      	; 0x1104 <prvCheckDelayedList+0x58>
    1102:	64 c0       	rjmp	.+200    	; 0x11cc <prvCheckDelayedList+0x120>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    1104:	80 91 e9 01 	lds	r24, 0x01E9
    1108:	90 91 ea 01 	lds	r25, 0x01EA
    110c:	9a 83       	std	Y+2, r25	; 0x02
    110e:	89 83       	std	Y+1, r24	; 0x01
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    1110:	80 91 eb 01 	lds	r24, 0x01EB
    1114:	90 91 ec 01 	lds	r25, 0x01EC
    1118:	90 93 ea 01 	sts	0x01EA, r25
    111c:	80 93 e9 01 	sts	0x01E9, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    1120:	89 81       	ldd	r24, Y+1	; 0x01
    1122:	9a 81       	ldd	r25, Y+2	; 0x02
    1124:	90 93 ec 01 	sts	0x01EC, r25
    1128:	80 93 eb 01 	sts	0x01EB, r24
    112c:	4f c0       	rjmp	.+158    	; 0x11cc <prvCheckDelayedList+0x120>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    112e:	e0 91 e9 01 	lds	r30, 0x01E9
    1132:	f0 91 ea 01 	lds	r31, 0x01EA
    1136:	05 80       	ldd	r0, Z+5	; 0x05
    1138:	f6 81       	ldd	r31, Z+6	; 0x06
    113a:	e0 2d       	mov	r30, r0
    113c:	86 81       	ldd	r24, Z+6	; 0x06
    113e:	97 81       	ldd	r25, Z+7	; 0x07
    1140:	9c 83       	std	Y+4, r25	; 0x04
    1142:	8b 83       	std	Y+3, r24	; 0x03

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )				
    1144:	eb 81       	ldd	r30, Y+3	; 0x03
    1146:	fc 81       	ldd	r31, Y+4	; 0x04
    1148:	22 81       	ldd	r18, Z+2	; 0x02
    114a:	33 81       	ldd	r19, Z+3	; 0x03
    114c:	80 91 bf 01 	lds	r24, 0x01BF
    1150:	90 91 c0 01 	lds	r25, 0x01C0
    1154:	82 17       	cp	r24, r18
    1156:	93 07       	cpc	r25, r19
    1158:	08 f4       	brcc	.+2      	; 0x115c <prvCheckDelayedList+0xb0>
    115a:	40 c0       	rjmp	.+128    	; 0x11dc <prvCheckDelayedList+0x130>
			{			
				/* Timeout not yet expired. */																			
				break;																				
			}																						

			portDISABLE_INTERRUPTS();
    115c:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				vListRemove( &( pxCRCB->xGenericListItem ) );											
    115e:	8b 81       	ldd	r24, Y+3	; 0x03
    1160:	9c 81       	ldd	r25, Y+4	; 0x04
    1162:	02 96       	adiw	r24, 0x02	; 2
    1164:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>

				/* Is the co-routine waiting on an event also? */												
				if( pxCRCB->xEventListItem.pvContainer )													
    1168:	eb 81       	ldd	r30, Y+3	; 0x03
    116a:	fc 81       	ldd	r31, Y+4	; 0x04
    116c:	84 89       	ldd	r24, Z+20	; 0x14
    116e:	95 89       	ldd	r25, Z+21	; 0x15
    1170:	00 97       	sbiw	r24, 0x00	; 0
    1172:	29 f0       	breq	.+10     	; 0x117e <prvCheckDelayedList+0xd2>
				{															
					vListRemove( &( pxCRCB->xEventListItem ) );											
    1174:	8b 81       	ldd	r24, Y+3	; 0x03
    1176:	9c 81       	ldd	r25, Y+4	; 0x04
    1178:	0c 96       	adiw	r24, 0x0c	; 12
    117a:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    117e:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );													
    1180:	eb 81       	ldd	r30, Y+3	; 0x03
    1182:	fc 81       	ldd	r31, Y+4	; 0x04
    1184:	96 89       	ldd	r25, Z+22	; 0x16
    1186:	80 91 be 01 	lds	r24, 0x01BE
    118a:	89 17       	cp	r24, r25
    118c:	28 f4       	brcc	.+10     	; 0x1198 <prvCheckDelayedList+0xec>
    118e:	eb 81       	ldd	r30, Y+3	; 0x03
    1190:	fc 81       	ldd	r31, Y+4	; 0x04
    1192:	86 89       	ldd	r24, Z+22	; 0x16
    1194:	80 93 be 01 	sts	0x01BE, r24
    1198:	eb 81       	ldd	r30, Y+3	; 0x03
    119a:	fc 81       	ldd	r31, Y+4	; 0x04
    119c:	86 89       	ldd	r24, Z+22	; 0x16
    119e:	28 2f       	mov	r18, r24
    11a0:	30 e0       	ldi	r19, 0x00	; 0
    11a2:	c9 01       	movw	r24, r18
    11a4:	88 0f       	add	r24, r24
    11a6:	99 1f       	adc	r25, r25
    11a8:	88 0f       	add	r24, r24
    11aa:	99 1f       	adc	r25, r25
    11ac:	88 0f       	add	r24, r24
    11ae:	99 1f       	adc	r25, r25
    11b0:	82 0f       	add	r24, r18
    11b2:	93 1f       	adc	r25, r19
    11b4:	ac 01       	movw	r20, r24
    11b6:	4b 53       	subi	r20, 0x3B	; 59
    11b8:	5e 4f       	sbci	r21, 0xFE	; 254
    11ba:	8b 81       	ldd	r24, Y+3	; 0x03
    11bc:	9c 81       	ldd	r25, Y+4	; 0x04
    11be:	9c 01       	movw	r18, r24
    11c0:	2e 5f       	subi	r18, 0xFE	; 254
    11c2:	3f 4f       	sbci	r19, 0xFF	; 255
    11c4:	ca 01       	movw	r24, r20
    11c6:	b9 01       	movw	r22, r18
    11c8:	0e 94 95 0a 	call	0x152a	; 0x152a <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    11cc:	e0 91 e9 01 	lds	r30, 0x01E9
    11d0:	f0 91 ea 01 	lds	r31, 0x01EA
    11d4:	80 81       	ld	r24, Z
    11d6:	88 23       	and	r24, r24
    11d8:	09 f0       	breq	.+2      	; 0x11dc <prvCheckDelayedList+0x130>
    11da:	a9 cf       	rjmp	.-174    	; 0x112e <prvCheckDelayedList+0x82>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    11dc:	80 91 c3 01 	lds	r24, 0x01C3
    11e0:	90 91 c4 01 	lds	r25, 0x01C4
    11e4:	00 97       	sbiw	r24, 0x00	; 0
    11e6:	09 f0       	breq	.+2      	; 0x11ea <prvCheckDelayedList+0x13e>
    11e8:	74 cf       	rjmp	.-280    	; 0x10d2 <prvCheckDelayedList+0x26>

			prvAddCoRoutineToReadyQueue( pxCRCB );													
		}																									
	}

	xLastTickCount = xCoRoutineTickCount;
    11ea:	80 91 bf 01 	lds	r24, 0x01BF
    11ee:	90 91 c0 01 	lds	r25, 0x01C0
    11f2:	90 93 c2 01 	sts	0x01C2, r25
    11f6:	80 93 c1 01 	sts	0x01C1, r24
}
    11fa:	0f 90       	pop	r0
    11fc:	0f 90       	pop	r0
    11fe:	0f 90       	pop	r0
    1200:	0f 90       	pop	r0
    1202:	cf 91       	pop	r28
    1204:	df 91       	pop	r29
    1206:	08 95       	ret

00001208 <vCoRoutineSchedule>:
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    1208:	df 93       	push	r29
    120a:	cf 93       	push	r28
    120c:	00 d0       	rcall	.+0      	; 0x120e <vCoRoutineSchedule+0x6>
    120e:	cd b7       	in	r28, 0x3d	; 61
    1210:	de b7       	in	r29, 0x3e	; 62
	/* See if any co-routines readied by events need moving to the ready lists. */
	prvCheckPendingReadyList();
    1212:	0e 94 0c 08 	call	0x1018	; 0x1018 <prvCheckPendingReadyList>

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();
    1216:	0e 94 56 08 	call	0x10ac	; 0x10ac <prvCheckDelayedList>
    121a:	0a c0       	rjmp	.+20     	; 0x1230 <vCoRoutineSchedule+0x28>

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    121c:	80 91 be 01 	lds	r24, 0x01BE
    1220:	88 23       	and	r24, r24
    1222:	09 f4       	brne	.+2      	; 0x1226 <vCoRoutineSchedule+0x1e>
    1224:	66 c0       	rjmp	.+204    	; 0x12f2 <vCoRoutineSchedule+0xea>
		{
			/* No more co-routines to check. */
			return;
		}
		--uxTopCoRoutineReadyPriority;
    1226:	80 91 be 01 	lds	r24, 0x01BE
    122a:	81 50       	subi	r24, 0x01	; 1
    122c:	80 93 be 01 	sts	0x01BE, r24

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1230:	80 91 be 01 	lds	r24, 0x01BE
    1234:	28 2f       	mov	r18, r24
    1236:	30 e0       	ldi	r19, 0x00	; 0
    1238:	c9 01       	movw	r24, r18
    123a:	88 0f       	add	r24, r24
    123c:	99 1f       	adc	r25, r25
    123e:	88 0f       	add	r24, r24
    1240:	99 1f       	adc	r25, r25
    1242:	88 0f       	add	r24, r24
    1244:	99 1f       	adc	r25, r25
    1246:	82 0f       	add	r24, r18
    1248:	93 1f       	adc	r25, r19
    124a:	fc 01       	movw	r30, r24
    124c:	eb 53       	subi	r30, 0x3B	; 59
    124e:	fe 4f       	sbci	r31, 0xFE	; 254
    1250:	80 81       	ld	r24, Z
    1252:	88 23       	and	r24, r24
    1254:	19 f3       	breq	.-58     	; 0x121c <vCoRoutineSchedule+0x14>
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    1256:	80 91 be 01 	lds	r24, 0x01BE
    125a:	28 2f       	mov	r18, r24
    125c:	30 e0       	ldi	r19, 0x00	; 0
    125e:	c9 01       	movw	r24, r18
    1260:	88 0f       	add	r24, r24
    1262:	99 1f       	adc	r25, r25
    1264:	88 0f       	add	r24, r24
    1266:	99 1f       	adc	r25, r25
    1268:	88 0f       	add	r24, r24
    126a:	99 1f       	adc	r25, r25
    126c:	82 0f       	add	r24, r18
    126e:	93 1f       	adc	r25, r19
    1270:	8b 53       	subi	r24, 0x3B	; 59
    1272:	9e 4f       	sbci	r25, 0xFE	; 254
    1274:	9a 83       	std	Y+2, r25	; 0x02
    1276:	89 83       	std	Y+1, r24	; 0x01
    1278:	e9 81       	ldd	r30, Y+1	; 0x01
    127a:	fa 81       	ldd	r31, Y+2	; 0x02
    127c:	01 80       	ldd	r0, Z+1	; 0x01
    127e:	f2 81       	ldd	r31, Z+2	; 0x02
    1280:	e0 2d       	mov	r30, r0
    1282:	82 81       	ldd	r24, Z+2	; 0x02
    1284:	93 81       	ldd	r25, Z+3	; 0x03
    1286:	e9 81       	ldd	r30, Y+1	; 0x01
    1288:	fa 81       	ldd	r31, Y+2	; 0x02
    128a:	92 83       	std	Z+2, r25	; 0x02
    128c:	81 83       	std	Z+1, r24	; 0x01
    128e:	e9 81       	ldd	r30, Y+1	; 0x01
    1290:	fa 81       	ldd	r31, Y+2	; 0x02
    1292:	21 81       	ldd	r18, Z+1	; 0x01
    1294:	32 81       	ldd	r19, Z+2	; 0x02
    1296:	89 81       	ldd	r24, Y+1	; 0x01
    1298:	9a 81       	ldd	r25, Y+2	; 0x02
    129a:	03 96       	adiw	r24, 0x03	; 3
    129c:	28 17       	cp	r18, r24
    129e:	39 07       	cpc	r19, r25
    12a0:	59 f4       	brne	.+22     	; 0x12b8 <vCoRoutineSchedule+0xb0>
    12a2:	e9 81       	ldd	r30, Y+1	; 0x01
    12a4:	fa 81       	ldd	r31, Y+2	; 0x02
    12a6:	01 80       	ldd	r0, Z+1	; 0x01
    12a8:	f2 81       	ldd	r31, Z+2	; 0x02
    12aa:	e0 2d       	mov	r30, r0
    12ac:	82 81       	ldd	r24, Z+2	; 0x02
    12ae:	93 81       	ldd	r25, Z+3	; 0x03
    12b0:	e9 81       	ldd	r30, Y+1	; 0x01
    12b2:	fa 81       	ldd	r31, Y+2	; 0x02
    12b4:	92 83       	std	Z+2, r25	; 0x02
    12b6:	81 83       	std	Z+1, r24	; 0x01
    12b8:	e9 81       	ldd	r30, Y+1	; 0x01
    12ba:	fa 81       	ldd	r31, Y+2	; 0x02
    12bc:	01 80       	ldd	r0, Z+1	; 0x01
    12be:	f2 81       	ldd	r31, Z+2	; 0x02
    12c0:	e0 2d       	mov	r30, r0
    12c2:	86 81       	ldd	r24, Z+6	; 0x06
    12c4:	97 81       	ldd	r25, Z+7	; 0x07
    12c6:	90 93 bd 01 	sts	0x01BD, r25
    12ca:	80 93 bc 01 	sts	0x01BC, r24

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    12ce:	e0 91 bc 01 	lds	r30, 0x01BC
    12d2:	f0 91 bd 01 	lds	r31, 0x01BD
    12d6:	40 81       	ld	r20, Z
    12d8:	51 81       	ldd	r21, Z+1	; 0x01
    12da:	80 91 bc 01 	lds	r24, 0x01BC
    12de:	90 91 bd 01 	lds	r25, 0x01BD
    12e2:	e0 91 bc 01 	lds	r30, 0x01BC
    12e6:	f0 91 bd 01 	lds	r31, 0x01BD
    12ea:	27 89       	ldd	r18, Z+23	; 0x17
    12ec:	62 2f       	mov	r22, r18
    12ee:	fa 01       	movw	r30, r20
    12f0:	09 95       	icall

	return;
}
    12f2:	0f 90       	pop	r0
    12f4:	0f 90       	pop	r0
    12f6:	cf 91       	pop	r28
    12f8:	df 91       	pop	r29
    12fa:	08 95       	ret

000012fc <prvInitialiseCoRoutineLists>:
/*-----------------------------------------------------------*/

static void prvInitialiseCoRoutineLists( void )
{
    12fc:	df 93       	push	r29
    12fe:	cf 93       	push	r28
    1300:	0f 92       	push	r0
    1302:	cd b7       	in	r28, 0x3d	; 61
    1304:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    1306:	19 82       	std	Y+1, r1	; 0x01
    1308:	13 c0       	rjmp	.+38     	; 0x1330 <prvInitialiseCoRoutineLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    130a:	89 81       	ldd	r24, Y+1	; 0x01
    130c:	28 2f       	mov	r18, r24
    130e:	30 e0       	ldi	r19, 0x00	; 0
    1310:	c9 01       	movw	r24, r18
    1312:	88 0f       	add	r24, r24
    1314:	99 1f       	adc	r25, r25
    1316:	88 0f       	add	r24, r24
    1318:	99 1f       	adc	r25, r25
    131a:	88 0f       	add	r24, r24
    131c:	99 1f       	adc	r25, r25
    131e:	82 0f       	add	r24, r18
    1320:	93 1f       	adc	r25, r19
    1322:	8b 53       	subi	r24, 0x3B	; 59
    1324:	9e 4f       	sbci	r25, 0xFE	; 254
    1326:	0e 94 5b 0a 	call	0x14b6	; 0x14b6 <vListInitialise>

static void prvInitialiseCoRoutineLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
    132a:	89 81       	ldd	r24, Y+1	; 0x01
    132c:	8f 5f       	subi	r24, 0xFF	; 255
    132e:	89 83       	std	Y+1, r24	; 0x01
    1330:	89 81       	ldd	r24, Y+1	; 0x01
    1332:	82 30       	cpi	r24, 0x02	; 2
    1334:	50 f3       	brcs	.-44     	; 0x130a <prvInitialiseCoRoutineLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    1336:	87 ed       	ldi	r24, 0xD7	; 215
    1338:	91 e0       	ldi	r25, 0x01	; 1
    133a:	0e 94 5b 0a 	call	0x14b6	; 0x14b6 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    133e:	80 ee       	ldi	r24, 0xE0	; 224
    1340:	91 e0       	ldi	r25, 0x01	; 1
    1342:	0e 94 5b 0a 	call	0x14b6	; 0x14b6 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    1346:	8d ee       	ldi	r24, 0xED	; 237
    1348:	91 e0       	ldi	r25, 0x01	; 1
    134a:	0e 94 5b 0a 	call	0x14b6	; 0x14b6 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    134e:	87 ed       	ldi	r24, 0xD7	; 215
    1350:	91 e0       	ldi	r25, 0x01	; 1
    1352:	90 93 ea 01 	sts	0x01EA, r25
    1356:	80 93 e9 01 	sts	0x01E9, r24
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    135a:	80 ee       	ldi	r24, 0xE0	; 224
    135c:	91 e0       	ldi	r25, 0x01	; 1
    135e:	90 93 ec 01 	sts	0x01EC, r25
    1362:	80 93 eb 01 	sts	0x01EB, r24
}
    1366:	0f 90       	pop	r0
    1368:	cf 91       	pop	r28
    136a:	df 91       	pop	r29
    136c:	08 95       	ret

0000136e <xCoRoutineRemoveFromEventList>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    136e:	df 93       	push	r29
    1370:	cf 93       	push	r28
    1372:	00 d0       	rcall	.+0      	; 0x1374 <xCoRoutineRemoveFromEventList+0x6>
    1374:	00 d0       	rcall	.+0      	; 0x1376 <xCoRoutineRemoveFromEventList+0x8>
    1376:	0f 92       	push	r0
    1378:	cd b7       	in	r28, 0x3d	; 61
    137a:	de b7       	in	r29, 0x3e	; 62
    137c:	9d 83       	std	Y+5, r25	; 0x05
    137e:	8c 83       	std	Y+4, r24	; 0x04
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1380:	ec 81       	ldd	r30, Y+4	; 0x04
    1382:	fd 81       	ldd	r31, Y+5	; 0x05
    1384:	05 80       	ldd	r0, Z+5	; 0x05
    1386:	f6 81       	ldd	r31, Z+6	; 0x06
    1388:	e0 2d       	mov	r30, r0
    138a:	86 81       	ldd	r24, Z+6	; 0x06
    138c:	97 81       	ldd	r25, Z+7	; 0x07
    138e:	9b 83       	std	Y+3, r25	; 0x03
    1390:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1392:	8a 81       	ldd	r24, Y+2	; 0x02
    1394:	9b 81       	ldd	r25, Y+3	; 0x03
    1396:	0c 96       	adiw	r24, 0x0c	; 12
    1398:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    139c:	8a 81       	ldd	r24, Y+2	; 0x02
    139e:	9b 81       	ldd	r25, Y+3	; 0x03
    13a0:	9c 01       	movw	r18, r24
    13a2:	24 5f       	subi	r18, 0xF4	; 244
    13a4:	3f 4f       	sbci	r19, 0xFF	; 255
    13a6:	8d ee       	ldi	r24, 0xED	; 237
    13a8:	91 e0       	ldi	r25, 0x01	; 1
    13aa:	b9 01       	movw	r22, r18
    13ac:	0e 94 95 0a 	call	0x152a	; 0x152a <vListInsertEnd>

	if( pxUnblockedCRCB->uxPriority >= pxCurrentCoRoutine->uxPriority )
    13b0:	ea 81       	ldd	r30, Y+2	; 0x02
    13b2:	fb 81       	ldd	r31, Y+3	; 0x03
    13b4:	96 89       	ldd	r25, Z+22	; 0x16
    13b6:	e0 91 bc 01 	lds	r30, 0x01BC
    13ba:	f0 91 bd 01 	lds	r31, 0x01BD
    13be:	86 89       	ldd	r24, Z+22	; 0x16
    13c0:	98 17       	cp	r25, r24
    13c2:	18 f0       	brcs	.+6      	; 0x13ca <xCoRoutineRemoveFromEventList+0x5c>
	{
		xReturn = pdTRUE;
    13c4:	81 e0       	ldi	r24, 0x01	; 1
    13c6:	89 83       	std	Y+1, r24	; 0x01
    13c8:	01 c0       	rjmp	.+2      	; 0x13cc <xCoRoutineRemoveFromEventList+0x5e>
	}
	else
	{
		xReturn = pdFALSE;
    13ca:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    13cc:	89 81       	ldd	r24, Y+1	; 0x01
}
    13ce:	0f 90       	pop	r0
    13d0:	0f 90       	pop	r0
    13d2:	0f 90       	pop	r0
    13d4:	0f 90       	pop	r0
    13d6:	0f 90       	pop	r0
    13d8:	cf 91       	pop	r28
    13da:	df 91       	pop	r29
    13dc:	08 95       	ret

000013de <pvPortMalloc>:

static size_t xNextFreeByte = ( size_t ) 0;
/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    13de:	df 93       	push	r29
    13e0:	cf 93       	push	r28
    13e2:	00 d0       	rcall	.+0      	; 0x13e4 <pvPortMalloc+0x6>
    13e4:	00 d0       	rcall	.+0      	; 0x13e6 <pvPortMalloc+0x8>
    13e6:	cd b7       	in	r28, 0x3d	; 61
    13e8:	de b7       	in	r29, 0x3e	; 62
    13ea:	9c 83       	std	Y+4, r25	; 0x04
    13ec:	8b 83       	std	Y+3, r24	; 0x03
void *pvReturn = NULL; 
    13ee:	1a 82       	std	Y+2, r1	; 0x02
    13f0:	19 82       	std	Y+1, r1	; 0x01
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    13f2:	0e 94 32 17 	call	0x2e64	; 0x2e64 <vTaskSuspendAll>
	{
		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configTOTAL_HEAP_SIZE ) &&
    13f6:	80 91 f6 01 	lds	r24, 0x01F6
    13fa:	90 91 f7 01 	lds	r25, 0x01F7
    13fe:	2b 81       	ldd	r18, Y+3	; 0x03
    1400:	3c 81       	ldd	r19, Y+4	; 0x04
    1402:	82 0f       	add	r24, r18
    1404:	93 1f       	adc	r25, r19
    1406:	24 e0       	ldi	r18, 0x04	; 4
    1408:	80 3b       	cpi	r24, 0xB0	; 176
    140a:	92 07       	cpc	r25, r18
    140c:	18 f5       	brcc	.+70     	; 0x1454 <pvPortMalloc+0x76>
    140e:	20 91 f6 01 	lds	r18, 0x01F6
    1412:	30 91 f7 01 	lds	r19, 0x01F7
    1416:	8b 81       	ldd	r24, Y+3	; 0x03
    1418:	9c 81       	ldd	r25, Y+4	; 0x04
    141a:	28 0f       	add	r18, r24
    141c:	39 1f       	adc	r19, r25
    141e:	80 91 f6 01 	lds	r24, 0x01F6
    1422:	90 91 f7 01 	lds	r25, 0x01F7
    1426:	82 17       	cp	r24, r18
    1428:	93 07       	cpc	r25, r19
    142a:	a0 f4       	brcc	.+40     	; 0x1454 <pvPortMalloc+0x76>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = &( xHeap.ucHeap[ xNextFreeByte ] );
    142c:	80 91 f6 01 	lds	r24, 0x01F6
    1430:	90 91 f7 01 	lds	r25, 0x01F7
    1434:	88 50       	subi	r24, 0x08	; 8
    1436:	9e 4f       	sbci	r25, 0xFE	; 254
    1438:	9a 83       	std	Y+2, r25	; 0x02
    143a:	89 83       	std	Y+1, r24	; 0x01
			xNextFreeByte += xWantedSize;			
    143c:	20 91 f6 01 	lds	r18, 0x01F6
    1440:	30 91 f7 01 	lds	r19, 0x01F7
    1444:	8b 81       	ldd	r24, Y+3	; 0x03
    1446:	9c 81       	ldd	r25, Y+4	; 0x04
    1448:	82 0f       	add	r24, r18
    144a:	93 1f       	adc	r25, r19
    144c:	90 93 f7 01 	sts	0x01F7, r25
    1450:	80 93 f6 01 	sts	0x01F6, r24
		}	
	}
	xTaskResumeAll();
    1454:	0e 94 3e 17 	call	0x2e7c	; 0x2e7c <xTaskResumeAll>
			vApplicationMallocFailedHook();
		}
	}
	#endif	

	return pvReturn;
    1458:	89 81       	ldd	r24, Y+1	; 0x01
    145a:	9a 81       	ldd	r25, Y+2	; 0x02
}
    145c:	0f 90       	pop	r0
    145e:	0f 90       	pop	r0
    1460:	0f 90       	pop	r0
    1462:	0f 90       	pop	r0
    1464:	cf 91       	pop	r28
    1466:	df 91       	pop	r29
    1468:	08 95       	ret

0000146a <vPortFree>:
/*-----------------------------------------------------------*/

void vPortFree( void *pv )
{
    146a:	df 93       	push	r29
    146c:	cf 93       	push	r28
    146e:	00 d0       	rcall	.+0      	; 0x1470 <vPortFree+0x6>
    1470:	cd b7       	in	r28, 0x3d	; 61
    1472:	de b7       	in	r29, 0x3e	; 62
    1474:	9a 83       	std	Y+2, r25	; 0x02
    1476:	89 83       	std	Y+1, r24	; 0x01
	/* Memory cannot be freed using this scheme.  See heap_2.c and heap_3.c 
	for alternative implementations, and the memory management pages of 
	http://www.FreeRTOS.org for more information. */
	( void ) pv;
}
    1478:	0f 90       	pop	r0
    147a:	0f 90       	pop	r0
    147c:	cf 91       	pop	r28
    147e:	df 91       	pop	r29
    1480:	08 95       	ret

00001482 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
    1482:	df 93       	push	r29
    1484:	cf 93       	push	r28
    1486:	cd b7       	in	r28, 0x3d	; 61
    1488:	de b7       	in	r29, 0x3e	; 62
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    148a:	10 92 f7 01 	sts	0x01F7, r1
    148e:	10 92 f6 01 	sts	0x01F6, r1
}
    1492:	cf 91       	pop	r28
    1494:	df 91       	pop	r29
    1496:	08 95       	ret

00001498 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    1498:	df 93       	push	r29
    149a:	cf 93       	push	r28
    149c:	cd b7       	in	r28, 0x3d	; 61
    149e:	de b7       	in	r29, 0x3e	; 62
	return ( configTOTAL_HEAP_SIZE - xNextFreeByte );
    14a0:	20 91 f6 01 	lds	r18, 0x01F6
    14a4:	30 91 f7 01 	lds	r19, 0x01F7
    14a8:	80 eb       	ldi	r24, 0xB0	; 176
    14aa:	94 e0       	ldi	r25, 0x04	; 4
    14ac:	82 1b       	sub	r24, r18
    14ae:	93 0b       	sbc	r25, r19
}
    14b0:	cf 91       	pop	r28
    14b2:	df 91       	pop	r29
    14b4:	08 95       	ret

000014b6 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    14b6:	df 93       	push	r29
    14b8:	cf 93       	push	r28
    14ba:	00 d0       	rcall	.+0      	; 0x14bc <vListInitialise+0x6>
    14bc:	cd b7       	in	r28, 0x3d	; 61
    14be:	de b7       	in	r29, 0x3e	; 62
    14c0:	9a 83       	std	Y+2, r25	; 0x02
    14c2:	89 83       	std	Y+1, r24	; 0x01
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    14c4:	89 81       	ldd	r24, Y+1	; 0x01
    14c6:	9a 81       	ldd	r25, Y+2	; 0x02
    14c8:	03 96       	adiw	r24, 0x03	; 3
    14ca:	e9 81       	ldd	r30, Y+1	; 0x01
    14cc:	fa 81       	ldd	r31, Y+2	; 0x02
    14ce:	92 83       	std	Z+2, r25	; 0x02
    14d0:	81 83       	std	Z+1, r24	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    14d2:	e9 81       	ldd	r30, Y+1	; 0x01
    14d4:	fa 81       	ldd	r31, Y+2	; 0x02
    14d6:	8f ef       	ldi	r24, 0xFF	; 255
    14d8:	9f ef       	ldi	r25, 0xFF	; 255
    14da:	94 83       	std	Z+4, r25	; 0x04
    14dc:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    14de:	89 81       	ldd	r24, Y+1	; 0x01
    14e0:	9a 81       	ldd	r25, Y+2	; 0x02
    14e2:	03 96       	adiw	r24, 0x03	; 3
    14e4:	e9 81       	ldd	r30, Y+1	; 0x01
    14e6:	fa 81       	ldd	r31, Y+2	; 0x02
    14e8:	96 83       	std	Z+6, r25	; 0x06
    14ea:	85 83       	std	Z+5, r24	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    14ec:	89 81       	ldd	r24, Y+1	; 0x01
    14ee:	9a 81       	ldd	r25, Y+2	; 0x02
    14f0:	03 96       	adiw	r24, 0x03	; 3
    14f2:	e9 81       	ldd	r30, Y+1	; 0x01
    14f4:	fa 81       	ldd	r31, Y+2	; 0x02
    14f6:	90 87       	std	Z+8, r25	; 0x08
    14f8:	87 83       	std	Z+7, r24	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    14fa:	e9 81       	ldd	r30, Y+1	; 0x01
    14fc:	fa 81       	ldd	r31, Y+2	; 0x02
    14fe:	10 82       	st	Z, r1
}
    1500:	0f 90       	pop	r0
    1502:	0f 90       	pop	r0
    1504:	cf 91       	pop	r28
    1506:	df 91       	pop	r29
    1508:	08 95       	ret

0000150a <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
    150a:	df 93       	push	r29
    150c:	cf 93       	push	r28
    150e:	00 d0       	rcall	.+0      	; 0x1510 <vListInitialiseItem+0x6>
    1510:	cd b7       	in	r28, 0x3d	; 61
    1512:	de b7       	in	r29, 0x3e	; 62
    1514:	9a 83       	std	Y+2, r25	; 0x02
    1516:	89 83       	std	Y+1, r24	; 0x01
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1518:	e9 81       	ldd	r30, Y+1	; 0x01
    151a:	fa 81       	ldd	r31, Y+2	; 0x02
    151c:	11 86       	std	Z+9, r1	; 0x09
    151e:	10 86       	std	Z+8, r1	; 0x08
}
    1520:	0f 90       	pop	r0
    1522:	0f 90       	pop	r0
    1524:	cf 91       	pop	r28
    1526:	df 91       	pop	r29
    1528:	08 95       	ret

0000152a <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    152a:	df 93       	push	r29
    152c:	cf 93       	push	r28
    152e:	00 d0       	rcall	.+0      	; 0x1530 <vListInsertEnd+0x6>
    1530:	00 d0       	rcall	.+0      	; 0x1532 <vListInsertEnd+0x8>
    1532:	00 d0       	rcall	.+0      	; 0x1534 <vListInsertEnd+0xa>
    1534:	cd b7       	in	r28, 0x3d	; 61
    1536:	de b7       	in	r29, 0x3e	; 62
    1538:	9c 83       	std	Y+4, r25	; 0x04
    153a:	8b 83       	std	Y+3, r24	; 0x03
    153c:	7e 83       	std	Y+6, r23	; 0x06
    153e:	6d 83       	std	Y+5, r22	; 0x05

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1540:	eb 81       	ldd	r30, Y+3	; 0x03
    1542:	fc 81       	ldd	r31, Y+4	; 0x04
    1544:	81 81       	ldd	r24, Z+1	; 0x01
    1546:	92 81       	ldd	r25, Z+2	; 0x02
    1548:	9a 83       	std	Y+2, r25	; 0x02
    154a:	89 83       	std	Y+1, r24	; 0x01

	pxNewListItem->pxNext = pxIndex->pxNext;
    154c:	e9 81       	ldd	r30, Y+1	; 0x01
    154e:	fa 81       	ldd	r31, Y+2	; 0x02
    1550:	82 81       	ldd	r24, Z+2	; 0x02
    1552:	93 81       	ldd	r25, Z+3	; 0x03
    1554:	ed 81       	ldd	r30, Y+5	; 0x05
    1556:	fe 81       	ldd	r31, Y+6	; 0x06
    1558:	93 83       	std	Z+3, r25	; 0x03
    155a:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxPrevious = pxList->pxIndex;
    155c:	eb 81       	ldd	r30, Y+3	; 0x03
    155e:	fc 81       	ldd	r31, Y+4	; 0x04
    1560:	81 81       	ldd	r24, Z+1	; 0x01
    1562:	92 81       	ldd	r25, Z+2	; 0x02
    1564:	ed 81       	ldd	r30, Y+5	; 0x05
    1566:	fe 81       	ldd	r31, Y+6	; 0x06
    1568:	95 83       	std	Z+5, r25	; 0x05
    156a:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    156c:	e9 81       	ldd	r30, Y+1	; 0x01
    156e:	fa 81       	ldd	r31, Y+2	; 0x02
    1570:	02 80       	ldd	r0, Z+2	; 0x02
    1572:	f3 81       	ldd	r31, Z+3	; 0x03
    1574:	e0 2d       	mov	r30, r0
    1576:	8d 81       	ldd	r24, Y+5	; 0x05
    1578:	9e 81       	ldd	r25, Y+6	; 0x06
    157a:	95 83       	std	Z+5, r25	; 0x05
    157c:	84 83       	std	Z+4, r24	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    157e:	8d 81       	ldd	r24, Y+5	; 0x05
    1580:	9e 81       	ldd	r25, Y+6	; 0x06
    1582:	e9 81       	ldd	r30, Y+1	; 0x01
    1584:	fa 81       	ldd	r31, Y+2	; 0x02
    1586:	93 83       	std	Z+3, r25	; 0x03
    1588:	82 83       	std	Z+2, r24	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    158a:	8d 81       	ldd	r24, Y+5	; 0x05
    158c:	9e 81       	ldd	r25, Y+6	; 0x06
    158e:	eb 81       	ldd	r30, Y+3	; 0x03
    1590:	fc 81       	ldd	r31, Y+4	; 0x04
    1592:	92 83       	std	Z+2, r25	; 0x02
    1594:	81 83       	std	Z+1, r24	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1596:	ed 81       	ldd	r30, Y+5	; 0x05
    1598:	fe 81       	ldd	r31, Y+6	; 0x06
    159a:	8b 81       	ldd	r24, Y+3	; 0x03
    159c:	9c 81       	ldd	r25, Y+4	; 0x04
    159e:	91 87       	std	Z+9, r25	; 0x09
    15a0:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    15a2:	eb 81       	ldd	r30, Y+3	; 0x03
    15a4:	fc 81       	ldd	r31, Y+4	; 0x04
    15a6:	80 81       	ld	r24, Z
    15a8:	8f 5f       	subi	r24, 0xFF	; 255
    15aa:	eb 81       	ldd	r30, Y+3	; 0x03
    15ac:	fc 81       	ldd	r31, Y+4	; 0x04
    15ae:	80 83       	st	Z, r24
}
    15b0:	26 96       	adiw	r28, 0x06	; 6
    15b2:	0f b6       	in	r0, 0x3f	; 63
    15b4:	f8 94       	cli
    15b6:	de bf       	out	0x3e, r29	; 62
    15b8:	0f be       	out	0x3f, r0	; 63
    15ba:	cd bf       	out	0x3d, r28	; 61
    15bc:	cf 91       	pop	r28
    15be:	df 91       	pop	r29
    15c0:	08 95       	ret

000015c2 <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    15c2:	df 93       	push	r29
    15c4:	cf 93       	push	r28
    15c6:	cd b7       	in	r28, 0x3d	; 61
    15c8:	de b7       	in	r29, 0x3e	; 62
    15ca:	28 97       	sbiw	r28, 0x08	; 8
    15cc:	0f b6       	in	r0, 0x3f	; 63
    15ce:	f8 94       	cli
    15d0:	de bf       	out	0x3e, r29	; 62
    15d2:	0f be       	out	0x3f, r0	; 63
    15d4:	cd bf       	out	0x3d, r28	; 61
    15d6:	9e 83       	std	Y+6, r25	; 0x06
    15d8:	8d 83       	std	Y+5, r24	; 0x05
    15da:	78 87       	std	Y+8, r23	; 0x08
    15dc:	6f 83       	std	Y+7, r22	; 0x07
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    15de:	ef 81       	ldd	r30, Y+7	; 0x07
    15e0:	f8 85       	ldd	r31, Y+8	; 0x08
    15e2:	80 81       	ld	r24, Z
    15e4:	91 81       	ldd	r25, Z+1	; 0x01
    15e6:	9a 83       	std	Y+2, r25	; 0x02
    15e8:	89 83       	std	Y+1, r24	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    15ea:	89 81       	ldd	r24, Y+1	; 0x01
    15ec:	9a 81       	ldd	r25, Y+2	; 0x02
    15ee:	2f ef       	ldi	r18, 0xFF	; 255
    15f0:	8f 3f       	cpi	r24, 0xFF	; 255
    15f2:	92 07       	cpc	r25, r18
    15f4:	39 f4       	brne	.+14     	; 0x1604 <vListInsert+0x42>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    15f6:	ed 81       	ldd	r30, Y+5	; 0x05
    15f8:	fe 81       	ldd	r31, Y+6	; 0x06
    15fa:	87 81       	ldd	r24, Z+7	; 0x07
    15fc:	90 85       	ldd	r25, Z+8	; 0x08
    15fe:	9c 83       	std	Y+4, r25	; 0x04
    1600:	8b 83       	std	Y+3, r24	; 0x03
    1602:	18 c0       	rjmp	.+48     	; 0x1634 <vListInsert+0x72>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/
		
		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1604:	8d 81       	ldd	r24, Y+5	; 0x05
    1606:	9e 81       	ldd	r25, Y+6	; 0x06
    1608:	03 96       	adiw	r24, 0x03	; 3
    160a:	9c 83       	std	Y+4, r25	; 0x04
    160c:	8b 83       	std	Y+3, r24	; 0x03
    160e:	06 c0       	rjmp	.+12     	; 0x161c <vListInsert+0x5a>
    1610:	eb 81       	ldd	r30, Y+3	; 0x03
    1612:	fc 81       	ldd	r31, Y+4	; 0x04
    1614:	82 81       	ldd	r24, Z+2	; 0x02
    1616:	93 81       	ldd	r25, Z+3	; 0x03
    1618:	9c 83       	std	Y+4, r25	; 0x04
    161a:	8b 83       	std	Y+3, r24	; 0x03
    161c:	eb 81       	ldd	r30, Y+3	; 0x03
    161e:	fc 81       	ldd	r31, Y+4	; 0x04
    1620:	02 80       	ldd	r0, Z+2	; 0x02
    1622:	f3 81       	ldd	r31, Z+3	; 0x03
    1624:	e0 2d       	mov	r30, r0
    1626:	20 81       	ld	r18, Z
    1628:	31 81       	ldd	r19, Z+1	; 0x01
    162a:	89 81       	ldd	r24, Y+1	; 0x01
    162c:	9a 81       	ldd	r25, Y+2	; 0x02
    162e:	82 17       	cp	r24, r18
    1630:	93 07       	cpc	r25, r19
    1632:	70 f7       	brcc	.-36     	; 0x1610 <vListInsert+0x4e>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1634:	eb 81       	ldd	r30, Y+3	; 0x03
    1636:	fc 81       	ldd	r31, Y+4	; 0x04
    1638:	82 81       	ldd	r24, Z+2	; 0x02
    163a:	93 81       	ldd	r25, Z+3	; 0x03
    163c:	ef 81       	ldd	r30, Y+7	; 0x07
    163e:	f8 85       	ldd	r31, Y+8	; 0x08
    1640:	93 83       	std	Z+3, r25	; 0x03
    1642:	82 83       	std	Z+2, r24	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1644:	ef 81       	ldd	r30, Y+7	; 0x07
    1646:	f8 85       	ldd	r31, Y+8	; 0x08
    1648:	02 80       	ldd	r0, Z+2	; 0x02
    164a:	f3 81       	ldd	r31, Z+3	; 0x03
    164c:	e0 2d       	mov	r30, r0
    164e:	8f 81       	ldd	r24, Y+7	; 0x07
    1650:	98 85       	ldd	r25, Y+8	; 0x08
    1652:	95 83       	std	Z+5, r25	; 0x05
    1654:	84 83       	std	Z+4, r24	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    1656:	ef 81       	ldd	r30, Y+7	; 0x07
    1658:	f8 85       	ldd	r31, Y+8	; 0x08
    165a:	8b 81       	ldd	r24, Y+3	; 0x03
    165c:	9c 81       	ldd	r25, Y+4	; 0x04
    165e:	95 83       	std	Z+5, r25	; 0x05
    1660:	84 83       	std	Z+4, r24	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    1662:	8f 81       	ldd	r24, Y+7	; 0x07
    1664:	98 85       	ldd	r25, Y+8	; 0x08
    1666:	eb 81       	ldd	r30, Y+3	; 0x03
    1668:	fc 81       	ldd	r31, Y+4	; 0x04
    166a:	93 83       	std	Z+3, r25	; 0x03
    166c:	82 83       	std	Z+2, r24	; 0x02

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    166e:	ef 81       	ldd	r30, Y+7	; 0x07
    1670:	f8 85       	ldd	r31, Y+8	; 0x08
    1672:	8d 81       	ldd	r24, Y+5	; 0x05
    1674:	9e 81       	ldd	r25, Y+6	; 0x06
    1676:	91 87       	std	Z+9, r25	; 0x09
    1678:	80 87       	std	Z+8, r24	; 0x08

	( pxList->uxNumberOfItems )++;
    167a:	ed 81       	ldd	r30, Y+5	; 0x05
    167c:	fe 81       	ldd	r31, Y+6	; 0x06
    167e:	80 81       	ld	r24, Z
    1680:	8f 5f       	subi	r24, 0xFF	; 255
    1682:	ed 81       	ldd	r30, Y+5	; 0x05
    1684:	fe 81       	ldd	r31, Y+6	; 0x06
    1686:	80 83       	st	Z, r24
}
    1688:	28 96       	adiw	r28, 0x08	; 8
    168a:	0f b6       	in	r0, 0x3f	; 63
    168c:	f8 94       	cli
    168e:	de bf       	out	0x3e, r29	; 62
    1690:	0f be       	out	0x3f, r0	; 63
    1692:	cd bf       	out	0x3d, r28	; 61
    1694:	cf 91       	pop	r28
    1696:	df 91       	pop	r29
    1698:	08 95       	ret

0000169a <vListRemove>:
/*-----------------------------------------------------------*/

void vListRemove( xListItem *pxItemToRemove )
{
    169a:	df 93       	push	r29
    169c:	cf 93       	push	r28
    169e:	00 d0       	rcall	.+0      	; 0x16a0 <vListRemove+0x6>
    16a0:	00 d0       	rcall	.+0      	; 0x16a2 <vListRemove+0x8>
    16a2:	cd b7       	in	r28, 0x3d	; 61
    16a4:	de b7       	in	r29, 0x3e	; 62
    16a6:	9c 83       	std	Y+4, r25	; 0x04
    16a8:	8b 83       	std	Y+3, r24	; 0x03
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    16aa:	eb 81       	ldd	r30, Y+3	; 0x03
    16ac:	fc 81       	ldd	r31, Y+4	; 0x04
    16ae:	a2 81       	ldd	r26, Z+2	; 0x02
    16b0:	b3 81       	ldd	r27, Z+3	; 0x03
    16b2:	eb 81       	ldd	r30, Y+3	; 0x03
    16b4:	fc 81       	ldd	r31, Y+4	; 0x04
    16b6:	84 81       	ldd	r24, Z+4	; 0x04
    16b8:	95 81       	ldd	r25, Z+5	; 0x05
    16ba:	15 96       	adiw	r26, 0x05	; 5
    16bc:	9c 93       	st	X, r25
    16be:	8e 93       	st	-X, r24
    16c0:	14 97       	sbiw	r26, 0x04	; 4
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    16c2:	eb 81       	ldd	r30, Y+3	; 0x03
    16c4:	fc 81       	ldd	r31, Y+4	; 0x04
    16c6:	a4 81       	ldd	r26, Z+4	; 0x04
    16c8:	b5 81       	ldd	r27, Z+5	; 0x05
    16ca:	eb 81       	ldd	r30, Y+3	; 0x03
    16cc:	fc 81       	ldd	r31, Y+4	; 0x04
    16ce:	82 81       	ldd	r24, Z+2	; 0x02
    16d0:	93 81       	ldd	r25, Z+3	; 0x03
    16d2:	13 96       	adiw	r26, 0x03	; 3
    16d4:	9c 93       	st	X, r25
    16d6:	8e 93       	st	-X, r24
    16d8:	12 97       	sbiw	r26, 0x02	; 2
	
	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    16da:	eb 81       	ldd	r30, Y+3	; 0x03
    16dc:	fc 81       	ldd	r31, Y+4	; 0x04
    16de:	80 85       	ldd	r24, Z+8	; 0x08
    16e0:	91 85       	ldd	r25, Z+9	; 0x09
    16e2:	9a 83       	std	Y+2, r25	; 0x02
    16e4:	89 83       	std	Y+1, r24	; 0x01

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    16e6:	e9 81       	ldd	r30, Y+1	; 0x01
    16e8:	fa 81       	ldd	r31, Y+2	; 0x02
    16ea:	21 81       	ldd	r18, Z+1	; 0x01
    16ec:	32 81       	ldd	r19, Z+2	; 0x02
    16ee:	8b 81       	ldd	r24, Y+3	; 0x03
    16f0:	9c 81       	ldd	r25, Y+4	; 0x04
    16f2:	28 17       	cp	r18, r24
    16f4:	39 07       	cpc	r19, r25
    16f6:	41 f4       	brne	.+16     	; 0x1708 <vListRemove+0x6e>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    16f8:	eb 81       	ldd	r30, Y+3	; 0x03
    16fa:	fc 81       	ldd	r31, Y+4	; 0x04
    16fc:	84 81       	ldd	r24, Z+4	; 0x04
    16fe:	95 81       	ldd	r25, Z+5	; 0x05
    1700:	e9 81       	ldd	r30, Y+1	; 0x01
    1702:	fa 81       	ldd	r31, Y+2	; 0x02
    1704:	92 83       	std	Z+2, r25	; 0x02
    1706:	81 83       	std	Z+1, r24	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    1708:	eb 81       	ldd	r30, Y+3	; 0x03
    170a:	fc 81       	ldd	r31, Y+4	; 0x04
    170c:	11 86       	std	Z+9, r1	; 0x09
    170e:	10 86       	std	Z+8, r1	; 0x08
	( pxList->uxNumberOfItems )--;
    1710:	e9 81       	ldd	r30, Y+1	; 0x01
    1712:	fa 81       	ldd	r31, Y+2	; 0x02
    1714:	80 81       	ld	r24, Z
    1716:	81 50       	subi	r24, 0x01	; 1
    1718:	e9 81       	ldd	r30, Y+1	; 0x01
    171a:	fa 81       	ldd	r31, Y+2	; 0x02
    171c:	80 83       	st	Z, r24
}
    171e:	0f 90       	pop	r0
    1720:	0f 90       	pop	r0
    1722:	0f 90       	pop	r0
    1724:	0f 90       	pop	r0
    1726:	cf 91       	pop	r28
    1728:	df 91       	pop	r29
    172a:	08 95       	ret

0000172c <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    172c:	df 93       	push	r29
    172e:	cf 93       	push	r28
    1730:	cd b7       	in	r28, 0x3d	; 61
    1732:	de b7       	in	r29, 0x3e	; 62
    1734:	28 97       	sbiw	r28, 0x08	; 8
    1736:	0f b6       	in	r0, 0x3f	; 63
    1738:	f8 94       	cli
    173a:	de bf       	out	0x3e, r29	; 62
    173c:	0f be       	out	0x3f, r0	; 63
    173e:	cd bf       	out	0x3d, r28	; 61
    1740:	9c 83       	std	Y+4, r25	; 0x04
    1742:	8b 83       	std	Y+3, r24	; 0x03
    1744:	7e 83       	std	Y+6, r23	; 0x06
    1746:	6d 83       	std	Y+5, r22	; 0x05
    1748:	58 87       	std	Y+8, r21	; 0x08
    174a:	4f 83       	std	Y+7, r20	; 0x07
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    174c:	eb 81       	ldd	r30, Y+3	; 0x03
    174e:	fc 81       	ldd	r31, Y+4	; 0x04
    1750:	81 e1       	ldi	r24, 0x11	; 17
    1752:	80 83       	st	Z, r24
	pxTopOfStack--;
    1754:	8b 81       	ldd	r24, Y+3	; 0x03
    1756:	9c 81       	ldd	r25, Y+4	; 0x04
    1758:	01 97       	sbiw	r24, 0x01	; 1
    175a:	9c 83       	std	Y+4, r25	; 0x04
    175c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x22;
    175e:	eb 81       	ldd	r30, Y+3	; 0x03
    1760:	fc 81       	ldd	r31, Y+4	; 0x04
    1762:	82 e2       	ldi	r24, 0x22	; 34
    1764:	80 83       	st	Z, r24
	pxTopOfStack--;
    1766:	8b 81       	ldd	r24, Y+3	; 0x03
    1768:	9c 81       	ldd	r25, Y+4	; 0x04
    176a:	01 97       	sbiw	r24, 0x01	; 1
    176c:	9c 83       	std	Y+4, r25	; 0x04
    176e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = 0x33;
    1770:	eb 81       	ldd	r30, Y+3	; 0x03
    1772:	fc 81       	ldd	r31, Y+4	; 0x04
    1774:	83 e3       	ldi	r24, 0x33	; 51
    1776:	80 83       	st	Z, r24
	pxTopOfStack--;
    1778:	8b 81       	ldd	r24, Y+3	; 0x03
    177a:	9c 81       	ldd	r25, Y+4	; 0x04
    177c:	01 97       	sbiw	r24, 0x01	; 1
    177e:	9c 83       	std	Y+4, r25	; 0x04
    1780:	8b 83       	std	Y+3, r24	; 0x03

	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
    1782:	8d 81       	ldd	r24, Y+5	; 0x05
    1784:	9e 81       	ldd	r25, Y+6	; 0x06
    1786:	9a 83       	std	Y+2, r25	; 0x02
    1788:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    178a:	89 81       	ldd	r24, Y+1	; 0x01
    178c:	eb 81       	ldd	r30, Y+3	; 0x03
    178e:	fc 81       	ldd	r31, Y+4	; 0x04
    1790:	80 83       	st	Z, r24
	pxTopOfStack--;
    1792:	8b 81       	ldd	r24, Y+3	; 0x03
    1794:	9c 81       	ldd	r25, Y+4	; 0x04
    1796:	01 97       	sbiw	r24, 0x01	; 1
    1798:	9c 83       	std	Y+4, r25	; 0x04
    179a:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    179c:	89 81       	ldd	r24, Y+1	; 0x01
    179e:	9a 81       	ldd	r25, Y+2	; 0x02
    17a0:	89 2f       	mov	r24, r25
    17a2:	99 27       	eor	r25, r25
    17a4:	9a 83       	std	Y+2, r25	; 0x02
    17a6:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    17a8:	89 81       	ldd	r24, Y+1	; 0x01
    17aa:	eb 81       	ldd	r30, Y+3	; 0x03
    17ac:	fc 81       	ldd	r31, Y+4	; 0x04
    17ae:	80 83       	st	Z, r24
	pxTopOfStack--;
    17b0:	8b 81       	ldd	r24, Y+3	; 0x03
    17b2:	9c 81       	ldd	r25, Y+4	; 0x04
    17b4:	01 97       	sbiw	r24, 0x01	; 1
    17b6:	9c 83       	std	Y+4, r25	; 0x04
    17b8:	8b 83       	std	Y+3, r24	; 0x03

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    17ba:	eb 81       	ldd	r30, Y+3	; 0x03
    17bc:	fc 81       	ldd	r31, Y+4	; 0x04
    17be:	10 82       	st	Z, r1
	pxTopOfStack--;
    17c0:	8b 81       	ldd	r24, Y+3	; 0x03
    17c2:	9c 81       	ldd	r25, Y+4	; 0x04
    17c4:	01 97       	sbiw	r24, 0x01	; 1
    17c6:	9c 83       	std	Y+4, r25	; 0x04
    17c8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    17ca:	eb 81       	ldd	r30, Y+3	; 0x03
    17cc:	fc 81       	ldd	r31, Y+4	; 0x04
    17ce:	80 e8       	ldi	r24, 0x80	; 128
    17d0:	80 83       	st	Z, r24
	pxTopOfStack--;
    17d2:	8b 81       	ldd	r24, Y+3	; 0x03
    17d4:	9c 81       	ldd	r25, Y+4	; 0x04
    17d6:	01 97       	sbiw	r24, 0x01	; 1
    17d8:	9c 83       	std	Y+4, r25	; 0x04
    17da:	8b 83       	std	Y+3, r24	; 0x03


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    17dc:	eb 81       	ldd	r30, Y+3	; 0x03
    17de:	fc 81       	ldd	r31, Y+4	; 0x04
    17e0:	10 82       	st	Z, r1
	pxTopOfStack--;
    17e2:	8b 81       	ldd	r24, Y+3	; 0x03
    17e4:	9c 81       	ldd	r25, Y+4	; 0x04
    17e6:	01 97       	sbiw	r24, 0x01	; 1
    17e8:	9c 83       	std	Y+4, r25	; 0x04
    17ea:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    17ec:	eb 81       	ldd	r30, Y+3	; 0x03
    17ee:	fc 81       	ldd	r31, Y+4	; 0x04
    17f0:	82 e0       	ldi	r24, 0x02	; 2
    17f2:	80 83       	st	Z, r24
	pxTopOfStack--;
    17f4:	8b 81       	ldd	r24, Y+3	; 0x03
    17f6:	9c 81       	ldd	r25, Y+4	; 0x04
    17f8:	01 97       	sbiw	r24, 0x01	; 1
    17fa:	9c 83       	std	Y+4, r25	; 0x04
    17fc:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    17fe:	eb 81       	ldd	r30, Y+3	; 0x03
    1800:	fc 81       	ldd	r31, Y+4	; 0x04
    1802:	83 e0       	ldi	r24, 0x03	; 3
    1804:	80 83       	st	Z, r24
	pxTopOfStack--;
    1806:	8b 81       	ldd	r24, Y+3	; 0x03
    1808:	9c 81       	ldd	r25, Y+4	; 0x04
    180a:	01 97       	sbiw	r24, 0x01	; 1
    180c:	9c 83       	std	Y+4, r25	; 0x04
    180e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    1810:	eb 81       	ldd	r30, Y+3	; 0x03
    1812:	fc 81       	ldd	r31, Y+4	; 0x04
    1814:	84 e0       	ldi	r24, 0x04	; 4
    1816:	80 83       	st	Z, r24
	pxTopOfStack--;
    1818:	8b 81       	ldd	r24, Y+3	; 0x03
    181a:	9c 81       	ldd	r25, Y+4	; 0x04
    181c:	01 97       	sbiw	r24, 0x01	; 1
    181e:	9c 83       	std	Y+4, r25	; 0x04
    1820:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    1822:	eb 81       	ldd	r30, Y+3	; 0x03
    1824:	fc 81       	ldd	r31, Y+4	; 0x04
    1826:	85 e0       	ldi	r24, 0x05	; 5
    1828:	80 83       	st	Z, r24
	pxTopOfStack--;
    182a:	8b 81       	ldd	r24, Y+3	; 0x03
    182c:	9c 81       	ldd	r25, Y+4	; 0x04
    182e:	01 97       	sbiw	r24, 0x01	; 1
    1830:	9c 83       	std	Y+4, r25	; 0x04
    1832:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    1834:	eb 81       	ldd	r30, Y+3	; 0x03
    1836:	fc 81       	ldd	r31, Y+4	; 0x04
    1838:	86 e0       	ldi	r24, 0x06	; 6
    183a:	80 83       	st	Z, r24
	pxTopOfStack--;
    183c:	8b 81       	ldd	r24, Y+3	; 0x03
    183e:	9c 81       	ldd	r25, Y+4	; 0x04
    1840:	01 97       	sbiw	r24, 0x01	; 1
    1842:	9c 83       	std	Y+4, r25	; 0x04
    1844:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    1846:	eb 81       	ldd	r30, Y+3	; 0x03
    1848:	fc 81       	ldd	r31, Y+4	; 0x04
    184a:	87 e0       	ldi	r24, 0x07	; 7
    184c:	80 83       	st	Z, r24
	pxTopOfStack--;
    184e:	8b 81       	ldd	r24, Y+3	; 0x03
    1850:	9c 81       	ldd	r25, Y+4	; 0x04
    1852:	01 97       	sbiw	r24, 0x01	; 1
    1854:	9c 83       	std	Y+4, r25	; 0x04
    1856:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    1858:	eb 81       	ldd	r30, Y+3	; 0x03
    185a:	fc 81       	ldd	r31, Y+4	; 0x04
    185c:	88 e0       	ldi	r24, 0x08	; 8
    185e:	80 83       	st	Z, r24
	pxTopOfStack--;
    1860:	8b 81       	ldd	r24, Y+3	; 0x03
    1862:	9c 81       	ldd	r25, Y+4	; 0x04
    1864:	01 97       	sbiw	r24, 0x01	; 1
    1866:	9c 83       	std	Y+4, r25	; 0x04
    1868:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    186a:	eb 81       	ldd	r30, Y+3	; 0x03
    186c:	fc 81       	ldd	r31, Y+4	; 0x04
    186e:	89 e0       	ldi	r24, 0x09	; 9
    1870:	80 83       	st	Z, r24
	pxTopOfStack--;
    1872:	8b 81       	ldd	r24, Y+3	; 0x03
    1874:	9c 81       	ldd	r25, Y+4	; 0x04
    1876:	01 97       	sbiw	r24, 0x01	; 1
    1878:	9c 83       	std	Y+4, r25	; 0x04
    187a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    187c:	eb 81       	ldd	r30, Y+3	; 0x03
    187e:	fc 81       	ldd	r31, Y+4	; 0x04
    1880:	80 e1       	ldi	r24, 0x10	; 16
    1882:	80 83       	st	Z, r24
	pxTopOfStack--;
    1884:	8b 81       	ldd	r24, Y+3	; 0x03
    1886:	9c 81       	ldd	r25, Y+4	; 0x04
    1888:	01 97       	sbiw	r24, 0x01	; 1
    188a:	9c 83       	std	Y+4, r25	; 0x04
    188c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    188e:	eb 81       	ldd	r30, Y+3	; 0x03
    1890:	fc 81       	ldd	r31, Y+4	; 0x04
    1892:	81 e1       	ldi	r24, 0x11	; 17
    1894:	80 83       	st	Z, r24
	pxTopOfStack--;
    1896:	8b 81       	ldd	r24, Y+3	; 0x03
    1898:	9c 81       	ldd	r25, Y+4	; 0x04
    189a:	01 97       	sbiw	r24, 0x01	; 1
    189c:	9c 83       	std	Y+4, r25	; 0x04
    189e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    18a0:	eb 81       	ldd	r30, Y+3	; 0x03
    18a2:	fc 81       	ldd	r31, Y+4	; 0x04
    18a4:	82 e1       	ldi	r24, 0x12	; 18
    18a6:	80 83       	st	Z, r24
	pxTopOfStack--;
    18a8:	8b 81       	ldd	r24, Y+3	; 0x03
    18aa:	9c 81       	ldd	r25, Y+4	; 0x04
    18ac:	01 97       	sbiw	r24, 0x01	; 1
    18ae:	9c 83       	std	Y+4, r25	; 0x04
    18b0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    18b2:	eb 81       	ldd	r30, Y+3	; 0x03
    18b4:	fc 81       	ldd	r31, Y+4	; 0x04
    18b6:	83 e1       	ldi	r24, 0x13	; 19
    18b8:	80 83       	st	Z, r24
	pxTopOfStack--;
    18ba:	8b 81       	ldd	r24, Y+3	; 0x03
    18bc:	9c 81       	ldd	r25, Y+4	; 0x04
    18be:	01 97       	sbiw	r24, 0x01	; 1
    18c0:	9c 83       	std	Y+4, r25	; 0x04
    18c2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    18c4:	eb 81       	ldd	r30, Y+3	; 0x03
    18c6:	fc 81       	ldd	r31, Y+4	; 0x04
    18c8:	84 e1       	ldi	r24, 0x14	; 20
    18ca:	80 83       	st	Z, r24
	pxTopOfStack--;
    18cc:	8b 81       	ldd	r24, Y+3	; 0x03
    18ce:	9c 81       	ldd	r25, Y+4	; 0x04
    18d0:	01 97       	sbiw	r24, 0x01	; 1
    18d2:	9c 83       	std	Y+4, r25	; 0x04
    18d4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    18d6:	eb 81       	ldd	r30, Y+3	; 0x03
    18d8:	fc 81       	ldd	r31, Y+4	; 0x04
    18da:	85 e1       	ldi	r24, 0x15	; 21
    18dc:	80 83       	st	Z, r24
	pxTopOfStack--;
    18de:	8b 81       	ldd	r24, Y+3	; 0x03
    18e0:	9c 81       	ldd	r25, Y+4	; 0x04
    18e2:	01 97       	sbiw	r24, 0x01	; 1
    18e4:	9c 83       	std	Y+4, r25	; 0x04
    18e6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    18e8:	eb 81       	ldd	r30, Y+3	; 0x03
    18ea:	fc 81       	ldd	r31, Y+4	; 0x04
    18ec:	86 e1       	ldi	r24, 0x16	; 22
    18ee:	80 83       	st	Z, r24
	pxTopOfStack--;
    18f0:	8b 81       	ldd	r24, Y+3	; 0x03
    18f2:	9c 81       	ldd	r25, Y+4	; 0x04
    18f4:	01 97       	sbiw	r24, 0x01	; 1
    18f6:	9c 83       	std	Y+4, r25	; 0x04
    18f8:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    18fa:	eb 81       	ldd	r30, Y+3	; 0x03
    18fc:	fc 81       	ldd	r31, Y+4	; 0x04
    18fe:	87 e1       	ldi	r24, 0x17	; 23
    1900:	80 83       	st	Z, r24
	pxTopOfStack--;
    1902:	8b 81       	ldd	r24, Y+3	; 0x03
    1904:	9c 81       	ldd	r25, Y+4	; 0x04
    1906:	01 97       	sbiw	r24, 0x01	; 1
    1908:	9c 83       	std	Y+4, r25	; 0x04
    190a:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    190c:	eb 81       	ldd	r30, Y+3	; 0x03
    190e:	fc 81       	ldd	r31, Y+4	; 0x04
    1910:	88 e1       	ldi	r24, 0x18	; 24
    1912:	80 83       	st	Z, r24
	pxTopOfStack--;
    1914:	8b 81       	ldd	r24, Y+3	; 0x03
    1916:	9c 81       	ldd	r25, Y+4	; 0x04
    1918:	01 97       	sbiw	r24, 0x01	; 1
    191a:	9c 83       	std	Y+4, r25	; 0x04
    191c:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    191e:	eb 81       	ldd	r30, Y+3	; 0x03
    1920:	fc 81       	ldd	r31, Y+4	; 0x04
    1922:	89 e1       	ldi	r24, 0x19	; 25
    1924:	80 83       	st	Z, r24
	pxTopOfStack--;
    1926:	8b 81       	ldd	r24, Y+3	; 0x03
    1928:	9c 81       	ldd	r25, Y+4	; 0x04
    192a:	01 97       	sbiw	r24, 0x01	; 1
    192c:	9c 83       	std	Y+4, r25	; 0x04
    192e:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    1930:	eb 81       	ldd	r30, Y+3	; 0x03
    1932:	fc 81       	ldd	r31, Y+4	; 0x04
    1934:	80 e2       	ldi	r24, 0x20	; 32
    1936:	80 83       	st	Z, r24
	pxTopOfStack--;
    1938:	8b 81       	ldd	r24, Y+3	; 0x03
    193a:	9c 81       	ldd	r25, Y+4	; 0x04
    193c:	01 97       	sbiw	r24, 0x01	; 1
    193e:	9c 83       	std	Y+4, r25	; 0x04
    1940:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    1942:	eb 81       	ldd	r30, Y+3	; 0x03
    1944:	fc 81       	ldd	r31, Y+4	; 0x04
    1946:	81 e2       	ldi	r24, 0x21	; 33
    1948:	80 83       	st	Z, r24
	pxTopOfStack--;
    194a:	8b 81       	ldd	r24, Y+3	; 0x03
    194c:	9c 81       	ldd	r25, Y+4	; 0x04
    194e:	01 97       	sbiw	r24, 0x01	; 1
    1950:	9c 83       	std	Y+4, r25	; 0x04
    1952:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    1954:	eb 81       	ldd	r30, Y+3	; 0x03
    1956:	fc 81       	ldd	r31, Y+4	; 0x04
    1958:	82 e2       	ldi	r24, 0x22	; 34
    195a:	80 83       	st	Z, r24
	pxTopOfStack--;
    195c:	8b 81       	ldd	r24, Y+3	; 0x03
    195e:	9c 81       	ldd	r25, Y+4	; 0x04
    1960:	01 97       	sbiw	r24, 0x01	; 1
    1962:	9c 83       	std	Y+4, r25	; 0x04
    1964:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    1966:	eb 81       	ldd	r30, Y+3	; 0x03
    1968:	fc 81       	ldd	r31, Y+4	; 0x04
    196a:	83 e2       	ldi	r24, 0x23	; 35
    196c:	80 83       	st	Z, r24
	pxTopOfStack--;
    196e:	8b 81       	ldd	r24, Y+3	; 0x03
    1970:	9c 81       	ldd	r25, Y+4	; 0x04
    1972:	01 97       	sbiw	r24, 0x01	; 1
    1974:	9c 83       	std	Y+4, r25	; 0x04
    1976:	8b 83       	std	Y+3, r24	; 0x03

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
    1978:	8f 81       	ldd	r24, Y+7	; 0x07
    197a:	98 85       	ldd	r25, Y+8	; 0x08
    197c:	9a 83       	std	Y+2, r25	; 0x02
    197e:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1980:	89 81       	ldd	r24, Y+1	; 0x01
    1982:	eb 81       	ldd	r30, Y+3	; 0x03
    1984:	fc 81       	ldd	r31, Y+4	; 0x04
    1986:	80 83       	st	Z, r24
	pxTopOfStack--;
    1988:	8b 81       	ldd	r24, Y+3	; 0x03
    198a:	9c 81       	ldd	r25, Y+4	; 0x04
    198c:	01 97       	sbiw	r24, 0x01	; 1
    198e:	9c 83       	std	Y+4, r25	; 0x04
    1990:	8b 83       	std	Y+3, r24	; 0x03

	usAddress >>= 8;
    1992:	89 81       	ldd	r24, Y+1	; 0x01
    1994:	9a 81       	ldd	r25, Y+2	; 0x02
    1996:	89 2f       	mov	r24, r25
    1998:	99 27       	eor	r25, r25
    199a:	9a 83       	std	Y+2, r25	; 0x02
    199c:	89 83       	std	Y+1, r24	; 0x01
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    199e:	89 81       	ldd	r24, Y+1	; 0x01
    19a0:	eb 81       	ldd	r30, Y+3	; 0x03
    19a2:	fc 81       	ldd	r31, Y+4	; 0x04
    19a4:	80 83       	st	Z, r24
	pxTopOfStack--;
    19a6:	8b 81       	ldd	r24, Y+3	; 0x03
    19a8:	9c 81       	ldd	r25, Y+4	; 0x04
    19aa:	01 97       	sbiw	r24, 0x01	; 1
    19ac:	9c 83       	std	Y+4, r25	; 0x04
    19ae:	8b 83       	std	Y+3, r24	; 0x03

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    19b0:	eb 81       	ldd	r30, Y+3	; 0x03
    19b2:	fc 81       	ldd	r31, Y+4	; 0x04
    19b4:	86 e2       	ldi	r24, 0x26	; 38
    19b6:	80 83       	st	Z, r24
	pxTopOfStack--;
    19b8:	8b 81       	ldd	r24, Y+3	; 0x03
    19ba:	9c 81       	ldd	r25, Y+4	; 0x04
    19bc:	01 97       	sbiw	r24, 0x01	; 1
    19be:	9c 83       	std	Y+4, r25	; 0x04
    19c0:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    19c2:	eb 81       	ldd	r30, Y+3	; 0x03
    19c4:	fc 81       	ldd	r31, Y+4	; 0x04
    19c6:	87 e2       	ldi	r24, 0x27	; 39
    19c8:	80 83       	st	Z, r24
	pxTopOfStack--;
    19ca:	8b 81       	ldd	r24, Y+3	; 0x03
    19cc:	9c 81       	ldd	r25, Y+4	; 0x04
    19ce:	01 97       	sbiw	r24, 0x01	; 1
    19d0:	9c 83       	std	Y+4, r25	; 0x04
    19d2:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    19d4:	eb 81       	ldd	r30, Y+3	; 0x03
    19d6:	fc 81       	ldd	r31, Y+4	; 0x04
    19d8:	88 e2       	ldi	r24, 0x28	; 40
    19da:	80 83       	st	Z, r24
	pxTopOfStack--;
    19dc:	8b 81       	ldd	r24, Y+3	; 0x03
    19de:	9c 81       	ldd	r25, Y+4	; 0x04
    19e0:	01 97       	sbiw	r24, 0x01	; 1
    19e2:	9c 83       	std	Y+4, r25	; 0x04
    19e4:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    19e6:	eb 81       	ldd	r30, Y+3	; 0x03
    19e8:	fc 81       	ldd	r31, Y+4	; 0x04
    19ea:	89 e2       	ldi	r24, 0x29	; 41
    19ec:	80 83       	st	Z, r24
	pxTopOfStack--;
    19ee:	8b 81       	ldd	r24, Y+3	; 0x03
    19f0:	9c 81       	ldd	r25, Y+4	; 0x04
    19f2:	01 97       	sbiw	r24, 0x01	; 1
    19f4:	9c 83       	std	Y+4, r25	; 0x04
    19f6:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    19f8:	eb 81       	ldd	r30, Y+3	; 0x03
    19fa:	fc 81       	ldd	r31, Y+4	; 0x04
    19fc:	80 e3       	ldi	r24, 0x30	; 48
    19fe:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a00:	8b 81       	ldd	r24, Y+3	; 0x03
    1a02:	9c 81       	ldd	r25, Y+4	; 0x04
    1a04:	01 97       	sbiw	r24, 0x01	; 1
    1a06:	9c 83       	std	Y+4, r25	; 0x04
    1a08:	8b 83       	std	Y+3, r24	; 0x03
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    1a0a:	eb 81       	ldd	r30, Y+3	; 0x03
    1a0c:	fc 81       	ldd	r31, Y+4	; 0x04
    1a0e:	81 e3       	ldi	r24, 0x31	; 49
    1a10:	80 83       	st	Z, r24
	pxTopOfStack--;
    1a12:	8b 81       	ldd	r24, Y+3	; 0x03
    1a14:	9c 81       	ldd	r25, Y+4	; 0x04
    1a16:	01 97       	sbiw	r24, 0x01	; 1
    1a18:	9c 83       	std	Y+4, r25	; 0x04
    1a1a:	8b 83       	std	Y+3, r24	; 0x03

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
    1a1c:	8b 81       	ldd	r24, Y+3	; 0x03
    1a1e:	9c 81       	ldd	r25, Y+4	; 0x04
}
    1a20:	28 96       	adiw	r28, 0x08	; 8
    1a22:	0f b6       	in	r0, 0x3f	; 63
    1a24:	f8 94       	cli
    1a26:	de bf       	out	0x3e, r29	; 62
    1a28:	0f be       	out	0x3f, r0	; 63
    1a2a:	cd bf       	out	0x3d, r28	; 61
    1a2c:	cf 91       	pop	r28
    1a2e:	df 91       	pop	r29
    1a30:	08 95       	ret

00001a32 <xPortStartScheduler>:
/*-----------------------------------------------------------*/

portBASE_TYPE xPortStartScheduler( void )
{
    1a32:	df 93       	push	r29
    1a34:	cf 93       	push	r28
    1a36:	cd b7       	in	r28, 0x3d	; 61
    1a38:	de b7       	in	r29, 0x3e	; 62
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();
    1a3a:	0e 94 09 0e 	call	0x1c12	; 0x1c12 <prvSetupTimerInterrupt>

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1a3e:	a0 91 a8 06 	lds	r26, 0x06A8
    1a42:	b0 91 a9 06 	lds	r27, 0x06A9
    1a46:	cd 91       	ld	r28, X+
    1a48:	cd bf       	out	0x3d, r28	; 61
    1a4a:	dd 91       	ld	r29, X+
    1a4c:	de bf       	out	0x3e, r29	; 62
    1a4e:	ff 91       	pop	r31
    1a50:	ef 91       	pop	r30
    1a52:	df 91       	pop	r29
    1a54:	cf 91       	pop	r28
    1a56:	bf 91       	pop	r27
    1a58:	af 91       	pop	r26
    1a5a:	9f 91       	pop	r25
    1a5c:	8f 91       	pop	r24
    1a5e:	7f 91       	pop	r23
    1a60:	6f 91       	pop	r22
    1a62:	5f 91       	pop	r21
    1a64:	4f 91       	pop	r20
    1a66:	3f 91       	pop	r19
    1a68:	2f 91       	pop	r18
    1a6a:	1f 91       	pop	r17
    1a6c:	0f 91       	pop	r16
    1a6e:	ff 90       	pop	r15
    1a70:	ef 90       	pop	r14
    1a72:	df 90       	pop	r13
    1a74:	cf 90       	pop	r12
    1a76:	bf 90       	pop	r11
    1a78:	af 90       	pop	r10
    1a7a:	9f 90       	pop	r9
    1a7c:	8f 90       	pop	r8
    1a7e:	7f 90       	pop	r7
    1a80:	6f 90       	pop	r6
    1a82:	5f 90       	pop	r5
    1a84:	4f 90       	pop	r4
    1a86:	3f 90       	pop	r3
    1a88:	2f 90       	pop	r2
    1a8a:	1f 90       	pop	r1
    1a8c:	0f 90       	pop	r0
    1a8e:	0f be       	out	0x3f, r0	; 63
    1a90:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1a92:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
    1a94:	81 e0       	ldi	r24, 0x01	; 1
}
    1a96:	cf 91       	pop	r28
    1a98:	df 91       	pop	r29
    1a9a:	08 95       	ret

00001a9c <vPortEndScheduler>:
/*-----------------------------------------------------------*/

void vPortEndScheduler( void )
{
    1a9c:	df 93       	push	r29
    1a9e:	cf 93       	push	r28
    1aa0:	cd b7       	in	r28, 0x3d	; 61
    1aa2:	de b7       	in	r29, 0x3e	; 62
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1aa4:	cf 91       	pop	r28
    1aa6:	df 91       	pop	r29
    1aa8:	08 95       	ret

00001aaa <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1aaa:	0f 92       	push	r0
    1aac:	0f b6       	in	r0, 0x3f	; 63
    1aae:	f8 94       	cli
    1ab0:	0f 92       	push	r0
    1ab2:	1f 92       	push	r1
    1ab4:	11 24       	eor	r1, r1
    1ab6:	2f 92       	push	r2
    1ab8:	3f 92       	push	r3
    1aba:	4f 92       	push	r4
    1abc:	5f 92       	push	r5
    1abe:	6f 92       	push	r6
    1ac0:	7f 92       	push	r7
    1ac2:	8f 92       	push	r8
    1ac4:	9f 92       	push	r9
    1ac6:	af 92       	push	r10
    1ac8:	bf 92       	push	r11
    1aca:	cf 92       	push	r12
    1acc:	df 92       	push	r13
    1ace:	ef 92       	push	r14
    1ad0:	ff 92       	push	r15
    1ad2:	0f 93       	push	r16
    1ad4:	1f 93       	push	r17
    1ad6:	2f 93       	push	r18
    1ad8:	3f 93       	push	r19
    1ada:	4f 93       	push	r20
    1adc:	5f 93       	push	r21
    1ade:	6f 93       	push	r22
    1ae0:	7f 93       	push	r23
    1ae2:	8f 93       	push	r24
    1ae4:	9f 93       	push	r25
    1ae6:	af 93       	push	r26
    1ae8:	bf 93       	push	r27
    1aea:	cf 93       	push	r28
    1aec:	df 93       	push	r29
    1aee:	ef 93       	push	r30
    1af0:	ff 93       	push	r31
    1af2:	a0 91 a8 06 	lds	r26, 0x06A8
    1af6:	b0 91 a9 06 	lds	r27, 0x06A9
    1afa:	0d b6       	in	r0, 0x3d	; 61
    1afc:	0d 92       	st	X+, r0
    1afe:	0e b6       	in	r0, 0x3e	; 62
    1b00:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1b02:	0e 94 d0 18 	call	0x31a0	; 0x31a0 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1b06:	a0 91 a8 06 	lds	r26, 0x06A8
    1b0a:	b0 91 a9 06 	lds	r27, 0x06A9
    1b0e:	cd 91       	ld	r28, X+
    1b10:	cd bf       	out	0x3d, r28	; 61
    1b12:	dd 91       	ld	r29, X+
    1b14:	de bf       	out	0x3e, r29	; 62
    1b16:	ff 91       	pop	r31
    1b18:	ef 91       	pop	r30
    1b1a:	df 91       	pop	r29
    1b1c:	cf 91       	pop	r28
    1b1e:	bf 91       	pop	r27
    1b20:	af 91       	pop	r26
    1b22:	9f 91       	pop	r25
    1b24:	8f 91       	pop	r24
    1b26:	7f 91       	pop	r23
    1b28:	6f 91       	pop	r22
    1b2a:	5f 91       	pop	r21
    1b2c:	4f 91       	pop	r20
    1b2e:	3f 91       	pop	r19
    1b30:	2f 91       	pop	r18
    1b32:	1f 91       	pop	r17
    1b34:	0f 91       	pop	r16
    1b36:	ff 90       	pop	r15
    1b38:	ef 90       	pop	r14
    1b3a:	df 90       	pop	r13
    1b3c:	cf 90       	pop	r12
    1b3e:	bf 90       	pop	r11
    1b40:	af 90       	pop	r10
    1b42:	9f 90       	pop	r9
    1b44:	8f 90       	pop	r8
    1b46:	7f 90       	pop	r7
    1b48:	6f 90       	pop	r6
    1b4a:	5f 90       	pop	r5
    1b4c:	4f 90       	pop	r4
    1b4e:	3f 90       	pop	r3
    1b50:	2f 90       	pop	r2
    1b52:	1f 90       	pop	r1
    1b54:	0f 90       	pop	r0
    1b56:	0f be       	out	0x3f, r0	; 63
    1b58:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1b5a:	08 95       	ret

00001b5c <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1b5c:	0f 92       	push	r0
    1b5e:	0f b6       	in	r0, 0x3f	; 63
    1b60:	f8 94       	cli
    1b62:	0f 92       	push	r0
    1b64:	1f 92       	push	r1
    1b66:	11 24       	eor	r1, r1
    1b68:	2f 92       	push	r2
    1b6a:	3f 92       	push	r3
    1b6c:	4f 92       	push	r4
    1b6e:	5f 92       	push	r5
    1b70:	6f 92       	push	r6
    1b72:	7f 92       	push	r7
    1b74:	8f 92       	push	r8
    1b76:	9f 92       	push	r9
    1b78:	af 92       	push	r10
    1b7a:	bf 92       	push	r11
    1b7c:	cf 92       	push	r12
    1b7e:	df 92       	push	r13
    1b80:	ef 92       	push	r14
    1b82:	ff 92       	push	r15
    1b84:	0f 93       	push	r16
    1b86:	1f 93       	push	r17
    1b88:	2f 93       	push	r18
    1b8a:	3f 93       	push	r19
    1b8c:	4f 93       	push	r20
    1b8e:	5f 93       	push	r21
    1b90:	6f 93       	push	r22
    1b92:	7f 93       	push	r23
    1b94:	8f 93       	push	r24
    1b96:	9f 93       	push	r25
    1b98:	af 93       	push	r26
    1b9a:	bf 93       	push	r27
    1b9c:	cf 93       	push	r28
    1b9e:	df 93       	push	r29
    1ba0:	ef 93       	push	r30
    1ba2:	ff 93       	push	r31
    1ba4:	a0 91 a8 06 	lds	r26, 0x06A8
    1ba8:	b0 91 a9 06 	lds	r27, 0x06A9
    1bac:	0d b6       	in	r0, 0x3d	; 61
    1bae:	0d 92       	st	X+, r0
    1bb0:	0e b6       	in	r0, 0x3e	; 62
    1bb2:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1bb4:	0e 94 fb 17 	call	0x2ff6	; 0x2ff6 <vTaskIncrementTick>
	vTaskSwitchContext();
    1bb8:	0e 94 d0 18 	call	0x31a0	; 0x31a0 <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1bbc:	a0 91 a8 06 	lds	r26, 0x06A8
    1bc0:	b0 91 a9 06 	lds	r27, 0x06A9
    1bc4:	cd 91       	ld	r28, X+
    1bc6:	cd bf       	out	0x3d, r28	; 61
    1bc8:	dd 91       	ld	r29, X+
    1bca:	de bf       	out	0x3e, r29	; 62
    1bcc:	ff 91       	pop	r31
    1bce:	ef 91       	pop	r30
    1bd0:	df 91       	pop	r29
    1bd2:	cf 91       	pop	r28
    1bd4:	bf 91       	pop	r27
    1bd6:	af 91       	pop	r26
    1bd8:	9f 91       	pop	r25
    1bda:	8f 91       	pop	r24
    1bdc:	7f 91       	pop	r23
    1bde:	6f 91       	pop	r22
    1be0:	5f 91       	pop	r21
    1be2:	4f 91       	pop	r20
    1be4:	3f 91       	pop	r19
    1be6:	2f 91       	pop	r18
    1be8:	1f 91       	pop	r17
    1bea:	0f 91       	pop	r16
    1bec:	ff 90       	pop	r15
    1bee:	ef 90       	pop	r14
    1bf0:	df 90       	pop	r13
    1bf2:	cf 90       	pop	r12
    1bf4:	bf 90       	pop	r11
    1bf6:	af 90       	pop	r10
    1bf8:	9f 90       	pop	r9
    1bfa:	8f 90       	pop	r8
    1bfc:	7f 90       	pop	r7
    1bfe:	6f 90       	pop	r6
    1c00:	5f 90       	pop	r5
    1c02:	4f 90       	pop	r4
    1c04:	3f 90       	pop	r3
    1c06:	2f 90       	pop	r2
    1c08:	1f 90       	pop	r1
    1c0a:	0f 90       	pop	r0
    1c0c:	0f be       	out	0x3f, r0	; 63
    1c0e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1c10:	08 95       	ret

00001c12 <prvSetupTimerInterrupt>:

/*
 * Setup timer 1 compare match A to generate a tick interrupt.
 */
static void prvSetupTimerInterrupt( void )
{
    1c12:	df 93       	push	r29
    1c14:	cf 93       	push	r28
    1c16:	00 d0       	rcall	.+0      	; 0x1c18 <prvSetupTimerInterrupt+0x6>
    1c18:	00 d0       	rcall	.+0      	; 0x1c1a <prvSetupTimerInterrupt+0x8>
    1c1a:	00 d0       	rcall	.+0      	; 0x1c1c <prvSetupTimerInterrupt+0xa>
    1c1c:	cd b7       	in	r28, 0x3d	; 61
    1c1e:	de b7       	in	r29, 0x3e	; 62
unsigned char ucHighByte, ucLowByte;

	/* Using 16bit timer 1 to generate the tick.  Correct fuses must be
	selected for the configCPU_CLOCK_HZ clock. */

	ulCompareMatch = configCPU_CLOCK_HZ / configTICK_RATE_HZ;
    1c20:	80 e8       	ldi	r24, 0x80	; 128
    1c22:	9e e3       	ldi	r25, 0x3E	; 62
    1c24:	a0 e0       	ldi	r26, 0x00	; 0
    1c26:	b0 e0       	ldi	r27, 0x00	; 0
    1c28:	8b 83       	std	Y+3, r24	; 0x03
    1c2a:	9c 83       	std	Y+4, r25	; 0x04
    1c2c:	ad 83       	std	Y+5, r26	; 0x05
    1c2e:	be 83       	std	Y+6, r27	; 0x06

	/* We only have 16 bits so have to scale to get our required tick rate. */
	ulCompareMatch /= portCLOCK_PRESCALER;
    1c30:	8b 81       	ldd	r24, Y+3	; 0x03
    1c32:	9c 81       	ldd	r25, Y+4	; 0x04
    1c34:	ad 81       	ldd	r26, Y+5	; 0x05
    1c36:	be 81       	ldd	r27, Y+6	; 0x06
    1c38:	68 94       	set
    1c3a:	15 f8       	bld	r1, 5
    1c3c:	b6 95       	lsr	r27
    1c3e:	a7 95       	ror	r26
    1c40:	97 95       	ror	r25
    1c42:	87 95       	ror	r24
    1c44:	16 94       	lsr	r1
    1c46:	d1 f7       	brne	.-12     	; 0x1c3c <prvSetupTimerInterrupt+0x2a>
    1c48:	8b 83       	std	Y+3, r24	; 0x03
    1c4a:	9c 83       	std	Y+4, r25	; 0x04
    1c4c:	ad 83       	std	Y+5, r26	; 0x05
    1c4e:	be 83       	std	Y+6, r27	; 0x06

	/* Adjust for correct value. */
	ulCompareMatch -= ( unsigned long ) 1;
    1c50:	8b 81       	ldd	r24, Y+3	; 0x03
    1c52:	9c 81       	ldd	r25, Y+4	; 0x04
    1c54:	ad 81       	ldd	r26, Y+5	; 0x05
    1c56:	be 81       	ldd	r27, Y+6	; 0x06
    1c58:	01 97       	sbiw	r24, 0x01	; 1
    1c5a:	a1 09       	sbc	r26, r1
    1c5c:	b1 09       	sbc	r27, r1
    1c5e:	8b 83       	std	Y+3, r24	; 0x03
    1c60:	9c 83       	std	Y+4, r25	; 0x04
    1c62:	ad 83       	std	Y+5, r26	; 0x05
    1c64:	be 83       	std	Y+6, r27	; 0x06

	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    1c66:	8b 81       	ldd	r24, Y+3	; 0x03
    1c68:	89 83       	std	Y+1, r24	; 0x01
	ulCompareMatch >>= 8;
    1c6a:	8b 81       	ldd	r24, Y+3	; 0x03
    1c6c:	9c 81       	ldd	r25, Y+4	; 0x04
    1c6e:	ad 81       	ldd	r26, Y+5	; 0x05
    1c70:	be 81       	ldd	r27, Y+6	; 0x06
    1c72:	89 2f       	mov	r24, r25
    1c74:	9a 2f       	mov	r25, r26
    1c76:	ab 2f       	mov	r26, r27
    1c78:	bb 27       	eor	r27, r27
    1c7a:	8b 83       	std	Y+3, r24	; 0x03
    1c7c:	9c 83       	std	Y+4, r25	; 0x04
    1c7e:	ad 83       	std	Y+5, r26	; 0x05
    1c80:	be 83       	std	Y+6, r27	; 0x06
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
    1c82:	8b 81       	ldd	r24, Y+3	; 0x03
    1c84:	8a 83       	std	Y+2, r24	; 0x02
	OCR1AH = ucHighByte;
    1c86:	eb e4       	ldi	r30, 0x4B	; 75
    1c88:	f0 e0       	ldi	r31, 0x00	; 0
    1c8a:	8a 81       	ldd	r24, Y+2	; 0x02
    1c8c:	80 83       	st	Z, r24
	OCR1AL = ucLowByte;
    1c8e:	ea e4       	ldi	r30, 0x4A	; 74
    1c90:	f0 e0       	ldi	r31, 0x00	; 0
    1c92:	89 81       	ldd	r24, Y+1	; 0x01
    1c94:	80 83       	st	Z, r24

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
    1c96:	8b e0       	ldi	r24, 0x0B	; 11
    1c98:	89 83       	std	Y+1, r24	; 0x01
	TCCR1B = ucLowByte;
    1c9a:	ee e4       	ldi	r30, 0x4E	; 78
    1c9c:	f0 e0       	ldi	r31, 0x00	; 0
    1c9e:	89 81       	ldd	r24, Y+1	; 0x01
    1ca0:	80 83       	st	Z, r24

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1ca2:	e9 e5       	ldi	r30, 0x59	; 89
    1ca4:	f0 e0       	ldi	r31, 0x00	; 0
    1ca6:	80 81       	ld	r24, Z
    1ca8:	89 83       	std	Y+1, r24	; 0x01
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1caa:	89 81       	ldd	r24, Y+1	; 0x01
    1cac:	80 61       	ori	r24, 0x10	; 16
    1cae:	89 83       	std	Y+1, r24	; 0x01
	TIMSK = ucLowByte;
    1cb0:	e9 e5       	ldi	r30, 0x59	; 89
    1cb2:	f0 e0       	ldi	r31, 0x00	; 0
    1cb4:	89 81       	ldd	r24, Y+1	; 0x01
    1cb6:	80 83       	st	Z, r24
}
    1cb8:	26 96       	adiw	r28, 0x06	; 6
    1cba:	0f b6       	in	r0, 0x3f	; 63
    1cbc:	f8 94       	cli
    1cbe:	de bf       	out	0x3e, r29	; 62
    1cc0:	0f be       	out	0x3f, r0	; 63
    1cc2:	cd bf       	out	0x3d, r28	; 61
    1cc4:	cf 91       	pop	r28
    1cc6:	df 91       	pop	r29
    1cc8:	08 95       	ret

00001cca <__vector_7>:
	 * tick count.  We don't need to switch context, this can only be done by
	 * manual calls to taskYIELD();
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
    1cca:	1f 92       	push	r1
    1ccc:	0f 92       	push	r0
    1cce:	0f b6       	in	r0, 0x3f	; 63
    1cd0:	0f 92       	push	r0
    1cd2:	11 24       	eor	r1, r1
    1cd4:	2f 93       	push	r18
    1cd6:	3f 93       	push	r19
    1cd8:	4f 93       	push	r20
    1cda:	5f 93       	push	r21
    1cdc:	6f 93       	push	r22
    1cde:	7f 93       	push	r23
    1ce0:	8f 93       	push	r24
    1ce2:	9f 93       	push	r25
    1ce4:	af 93       	push	r26
    1ce6:	bf 93       	push	r27
    1ce8:	ef 93       	push	r30
    1cea:	ff 93       	push	r31
    1cec:	df 93       	push	r29
    1cee:	cf 93       	push	r28
    1cf0:	cd b7       	in	r28, 0x3d	; 61
    1cf2:	de b7       	in	r29, 0x3e	; 62
		vTaskIncrementTick();
    1cf4:	0e 94 fb 17 	call	0x2ff6	; 0x2ff6 <vTaskIncrementTick>
	}
    1cf8:	cf 91       	pop	r28
    1cfa:	df 91       	pop	r29
    1cfc:	ff 91       	pop	r31
    1cfe:	ef 91       	pop	r30
    1d00:	bf 91       	pop	r27
    1d02:	af 91       	pop	r26
    1d04:	9f 91       	pop	r25
    1d06:	8f 91       	pop	r24
    1d08:	7f 91       	pop	r23
    1d0a:	6f 91       	pop	r22
    1d0c:	5f 91       	pop	r21
    1d0e:	4f 91       	pop	r20
    1d10:	3f 91       	pop	r19
    1d12:	2f 91       	pop	r18
    1d14:	0f 90       	pop	r0
    1d16:	0f be       	out	0x3f, r0	; 63
    1d18:	0f 90       	pop	r0
    1d1a:	1f 90       	pop	r1
    1d1c:	18 95       	reti

00001d1e <xQueueCreate>:
/*-----------------------------------------------------------
 * PUBLIC QUEUE MANAGEMENT API documented in queue.h
 *----------------------------------------------------------*/

xQueueHandle xQueueCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize )
{
    1d1e:	df 93       	push	r29
    1d20:	cf 93       	push	r28
    1d22:	cd b7       	in	r28, 0x3d	; 61
    1d24:	de b7       	in	r29, 0x3e	; 62
    1d26:	28 97       	sbiw	r28, 0x08	; 8
    1d28:	0f b6       	in	r0, 0x3f	; 63
    1d2a:	f8 94       	cli
    1d2c:	de bf       	out	0x3e, r29	; 62
    1d2e:	0f be       	out	0x3f, r0	; 63
    1d30:	cd bf       	out	0x3d, r28	; 61
    1d32:	8f 83       	std	Y+7, r24	; 0x07
    1d34:	68 87       	std	Y+8, r22	; 0x08
xQUEUE *pxNewQueue;
size_t xQueueSizeInBytes;
xQueueHandle xReturn = NULL;
    1d36:	1a 82       	std	Y+2, r1	; 0x02
    1d38:	19 82       	std	Y+1, r1	; 0x01

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    1d3a:	8f 81       	ldd	r24, Y+7	; 0x07
    1d3c:	88 23       	and	r24, r24
    1d3e:	09 f4       	brne	.+2      	; 0x1d42 <xQueueCreate+0x24>
    1d40:	8c c0       	rjmp	.+280    	; 0x1e5a <xQueueCreate+0x13c>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    1d42:	8f e1       	ldi	r24, 0x1F	; 31
    1d44:	90 e0       	ldi	r25, 0x00	; 0
    1d46:	0e 94 ef 09 	call	0x13de	; 0x13de <pvPortMalloc>
    1d4a:	9e 83       	std	Y+6, r25	; 0x06
    1d4c:	8d 83       	std	Y+5, r24	; 0x05
		if( pxNewQueue != NULL )
    1d4e:	8d 81       	ldd	r24, Y+5	; 0x05
    1d50:	9e 81       	ldd	r25, Y+6	; 0x06
    1d52:	00 97       	sbiw	r24, 0x00	; 0
    1d54:	09 f4       	brne	.+2      	; 0x1d58 <xQueueCreate+0x3a>
    1d56:	81 c0       	rjmp	.+258    	; 0x1e5a <xQueueCreate+0x13c>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;
    1d58:	8f 81       	ldd	r24, Y+7	; 0x07
    1d5a:	28 2f       	mov	r18, r24
    1d5c:	30 e0       	ldi	r19, 0x00	; 0
    1d5e:	88 85       	ldd	r24, Y+8	; 0x08
    1d60:	88 2f       	mov	r24, r24
    1d62:	90 e0       	ldi	r25, 0x00	; 0
    1d64:	ac 01       	movw	r20, r24
    1d66:	24 9f       	mul	r18, r20
    1d68:	c0 01       	movw	r24, r0
    1d6a:	25 9f       	mul	r18, r21
    1d6c:	90 0d       	add	r25, r0
    1d6e:	34 9f       	mul	r19, r20
    1d70:	90 0d       	add	r25, r0
    1d72:	11 24       	eor	r1, r1
    1d74:	01 96       	adiw	r24, 0x01	; 1
    1d76:	9c 83       	std	Y+4, r25	; 0x04
    1d78:	8b 83       	std	Y+3, r24	; 0x03

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    1d7a:	8b 81       	ldd	r24, Y+3	; 0x03
    1d7c:	9c 81       	ldd	r25, Y+4	; 0x04
    1d7e:	0e 94 ef 09 	call	0x13de	; 0x13de <pvPortMalloc>
    1d82:	ed 81       	ldd	r30, Y+5	; 0x05
    1d84:	fe 81       	ldd	r31, Y+6	; 0x06
    1d86:	91 83       	std	Z+1, r25	; 0x01
    1d88:	80 83       	st	Z, r24
			if( pxNewQueue->pcHead != NULL )
    1d8a:	ed 81       	ldd	r30, Y+5	; 0x05
    1d8c:	fe 81       	ldd	r31, Y+6	; 0x06
    1d8e:	80 81       	ld	r24, Z
    1d90:	91 81       	ldd	r25, Z+1	; 0x01
    1d92:	00 97       	sbiw	r24, 0x00	; 0
    1d94:	09 f4       	brne	.+2      	; 0x1d98 <xQueueCreate+0x7a>
    1d96:	5d c0       	rjmp	.+186    	; 0x1e52 <xQueueCreate+0x134>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->pcTail = pxNewQueue->pcHead + ( uxQueueLength * uxItemSize );
    1d98:	ed 81       	ldd	r30, Y+5	; 0x05
    1d9a:	fe 81       	ldd	r31, Y+6	; 0x06
    1d9c:	40 81       	ld	r20, Z
    1d9e:	51 81       	ldd	r21, Z+1	; 0x01
    1da0:	8f 81       	ldd	r24, Y+7	; 0x07
    1da2:	28 2f       	mov	r18, r24
    1da4:	30 e0       	ldi	r19, 0x00	; 0
    1da6:	88 85       	ldd	r24, Y+8	; 0x08
    1da8:	88 2f       	mov	r24, r24
    1daa:	90 e0       	ldi	r25, 0x00	; 0
    1dac:	bc 01       	movw	r22, r24
    1dae:	26 9f       	mul	r18, r22
    1db0:	c0 01       	movw	r24, r0
    1db2:	27 9f       	mul	r18, r23
    1db4:	90 0d       	add	r25, r0
    1db6:	36 9f       	mul	r19, r22
    1db8:	90 0d       	add	r25, r0
    1dba:	11 24       	eor	r1, r1
    1dbc:	84 0f       	add	r24, r20
    1dbe:	95 1f       	adc	r25, r21
    1dc0:	ed 81       	ldd	r30, Y+5	; 0x05
    1dc2:	fe 81       	ldd	r31, Y+6	; 0x06
    1dc4:	93 83       	std	Z+3, r25	; 0x03
    1dc6:	82 83       	std	Z+2, r24	; 0x02
				pxNewQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1dc8:	ed 81       	ldd	r30, Y+5	; 0x05
    1dca:	fe 81       	ldd	r31, Y+6	; 0x06
    1dcc:	12 8e       	std	Z+26, r1	; 0x1a
				pxNewQueue->pcWriteTo = pxNewQueue->pcHead;
    1dce:	ed 81       	ldd	r30, Y+5	; 0x05
    1dd0:	fe 81       	ldd	r31, Y+6	; 0x06
    1dd2:	80 81       	ld	r24, Z
    1dd4:	91 81       	ldd	r25, Z+1	; 0x01
    1dd6:	ed 81       	ldd	r30, Y+5	; 0x05
    1dd8:	fe 81       	ldd	r31, Y+6	; 0x06
    1dda:	95 83       	std	Z+5, r25	; 0x05
    1ddc:	84 83       	std	Z+4, r24	; 0x04
				pxNewQueue->pcReadFrom = pxNewQueue->pcHead + ( ( uxQueueLength - ( unsigned portBASE_TYPE ) 1U ) * uxItemSize );
    1dde:	ed 81       	ldd	r30, Y+5	; 0x05
    1de0:	fe 81       	ldd	r31, Y+6	; 0x06
    1de2:	40 81       	ld	r20, Z
    1de4:	51 81       	ldd	r21, Z+1	; 0x01
    1de6:	8f 81       	ldd	r24, Y+7	; 0x07
    1de8:	88 2f       	mov	r24, r24
    1dea:	90 e0       	ldi	r25, 0x00	; 0
    1dec:	9c 01       	movw	r18, r24
    1dee:	21 50       	subi	r18, 0x01	; 1
    1df0:	30 40       	sbci	r19, 0x00	; 0
    1df2:	88 85       	ldd	r24, Y+8	; 0x08
    1df4:	88 2f       	mov	r24, r24
    1df6:	90 e0       	ldi	r25, 0x00	; 0
    1df8:	bc 01       	movw	r22, r24
    1dfa:	26 9f       	mul	r18, r22
    1dfc:	c0 01       	movw	r24, r0
    1dfe:	27 9f       	mul	r18, r23
    1e00:	90 0d       	add	r25, r0
    1e02:	36 9f       	mul	r19, r22
    1e04:	90 0d       	add	r25, r0
    1e06:	11 24       	eor	r1, r1
    1e08:	84 0f       	add	r24, r20
    1e0a:	95 1f       	adc	r25, r21
    1e0c:	ed 81       	ldd	r30, Y+5	; 0x05
    1e0e:	fe 81       	ldd	r31, Y+6	; 0x06
    1e10:	97 83       	std	Z+7, r25	; 0x07
    1e12:	86 83       	std	Z+6, r24	; 0x06
				pxNewQueue->uxLength = uxQueueLength;
    1e14:	ed 81       	ldd	r30, Y+5	; 0x05
    1e16:	fe 81       	ldd	r31, Y+6	; 0x06
    1e18:	8f 81       	ldd	r24, Y+7	; 0x07
    1e1a:	83 8f       	std	Z+27, r24	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    1e1c:	ed 81       	ldd	r30, Y+5	; 0x05
    1e1e:	fe 81       	ldd	r31, Y+6	; 0x06
    1e20:	88 85       	ldd	r24, Y+8	; 0x08
    1e22:	84 8f       	std	Z+28, r24	; 0x1c
				pxNewQueue->xRxLock = queueUNLOCKED;
    1e24:	ed 81       	ldd	r30, Y+5	; 0x05
    1e26:	fe 81       	ldd	r31, Y+6	; 0x06
    1e28:	8f ef       	ldi	r24, 0xFF	; 255
    1e2a:	85 8f       	std	Z+29, r24	; 0x1d
				pxNewQueue->xTxLock = queueUNLOCKED;
    1e2c:	ed 81       	ldd	r30, Y+5	; 0x05
    1e2e:	fe 81       	ldd	r31, Y+6	; 0x06
    1e30:	8f ef       	ldi	r24, 0xFF	; 255
    1e32:	86 8f       	std	Z+30, r24	; 0x1e

				/* Likewise ensure the event queues start with the correct state. */
				vListInitialise( &( pxNewQueue->xTasksWaitingToSend ) );
    1e34:	8d 81       	ldd	r24, Y+5	; 0x05
    1e36:	9e 81       	ldd	r25, Y+6	; 0x06
    1e38:	08 96       	adiw	r24, 0x08	; 8
    1e3a:	0e 94 5b 0a 	call	0x14b6	; 0x14b6 <vListInitialise>
				vListInitialise( &( pxNewQueue->xTasksWaitingToReceive ) );
    1e3e:	8d 81       	ldd	r24, Y+5	; 0x05
    1e40:	9e 81       	ldd	r25, Y+6	; 0x06
    1e42:	41 96       	adiw	r24, 0x11	; 17
    1e44:	0e 94 5b 0a 	call	0x14b6	; 0x14b6 <vListInitialise>

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    1e48:	8d 81       	ldd	r24, Y+5	; 0x05
    1e4a:	9e 81       	ldd	r25, Y+6	; 0x06
    1e4c:	9a 83       	std	Y+2, r25	; 0x02
    1e4e:	89 83       	std	Y+1, r24	; 0x01
    1e50:	04 c0       	rjmp	.+8      	; 0x1e5a <xQueueCreate+0x13c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED();
				vPortFree( pxNewQueue );
    1e52:	8d 81       	ldd	r24, Y+5	; 0x05
    1e54:	9e 81       	ldd	r25, Y+6	; 0x06
    1e56:	0e 94 35 0a 	call	0x146a	; 0x146a <vPortFree>
		}
	}

	configASSERT( xReturn );

	return xReturn;
    1e5a:	89 81       	ldd	r24, Y+1	; 0x01
    1e5c:	9a 81       	ldd	r25, Y+2	; 0x02
}
    1e5e:	28 96       	adiw	r28, 0x08	; 8
    1e60:	0f b6       	in	r0, 0x3f	; 63
    1e62:	f8 94       	cli
    1e64:	de bf       	out	0x3e, r29	; 62
    1e66:	0f be       	out	0x3f, r0	; 63
    1e68:	cd bf       	out	0x3d, r28	; 61
    1e6a:	cf 91       	pop	r28
    1e6c:	df 91       	pop	r29
    1e6e:	08 95       	ret

00001e70 <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle pxQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    1e70:	df 93       	push	r29
    1e72:	cf 93       	push	r28
    1e74:	cd b7       	in	r28, 0x3d	; 61
    1e76:	de b7       	in	r29, 0x3e	; 62
    1e78:	2c 97       	sbiw	r28, 0x0c	; 12
    1e7a:	0f b6       	in	r0, 0x3f	; 63
    1e7c:	f8 94       	cli
    1e7e:	de bf       	out	0x3e, r29	; 62
    1e80:	0f be       	out	0x3f, r0	; 63
    1e82:	cd bf       	out	0x3d, r28	; 61
    1e84:	9e 83       	std	Y+6, r25	; 0x06
    1e86:	8d 83       	std	Y+5, r24	; 0x05
    1e88:	78 87       	std	Y+8, r23	; 0x08
    1e8a:	6f 83       	std	Y+7, r22	; 0x07
    1e8c:	5a 87       	std	Y+10, r21	; 0x0a
    1e8e:	49 87       	std	Y+9, r20	; 0x09
    1e90:	2b 87       	std	Y+11, r18	; 0x0b
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    1e92:	19 82       	std	Y+1, r1	; 0x01
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    1e94:	0f b6       	in	r0, 0x3f	; 63
    1e96:	f8 94       	cli
    1e98:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1e9a:	ed 81       	ldd	r30, Y+5	; 0x05
    1e9c:	fe 81       	ldd	r31, Y+6	; 0x06
    1e9e:	92 8d       	ldd	r25, Z+26	; 0x1a
    1ea0:	ed 81       	ldd	r30, Y+5	; 0x05
    1ea2:	fe 81       	ldd	r31, Y+6	; 0x06
    1ea4:	83 8d       	ldd	r24, Z+27	; 0x1b
    1ea6:	98 17       	cp	r25, r24
    1ea8:	d8 f4       	brcc	.+54     	; 0x1ee0 <xQueueGenericSend+0x70>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1eaa:	8d 81       	ldd	r24, Y+5	; 0x05
    1eac:	9e 81       	ldd	r25, Y+6	; 0x06
    1eae:	2f 81       	ldd	r18, Y+7	; 0x07
    1eb0:	38 85       	ldd	r19, Y+8	; 0x08
    1eb2:	b9 01       	movw	r22, r18
    1eb4:	4b 85       	ldd	r20, Y+11	; 0x0b
    1eb6:	0e 94 73 11 	call	0x22e6	; 0x22e6 <prvCopyDataToQueue>

				/* If there was a task waiting for data to arrive on the
				queue then unblock it now. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1eba:	ed 81       	ldd	r30, Y+5	; 0x05
    1ebc:	fe 81       	ldd	r31, Y+6	; 0x06
    1ebe:	81 89       	ldd	r24, Z+17	; 0x11
    1ec0:	88 23       	and	r24, r24
    1ec2:	49 f0       	breq	.+18     	; 0x1ed6 <xQueueGenericSend+0x66>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1ec4:	8d 81       	ldd	r24, Y+5	; 0x05
    1ec6:	9e 81       	ldd	r25, Y+6	; 0x06
    1ec8:	41 96       	adiw	r24, 0x11	; 17
    1eca:	0e 94 b5 19 	call	0x336a	; 0x336a <xTaskRemoveFromEventList>
    1ece:	81 30       	cpi	r24, 0x01	; 1
    1ed0:	11 f4       	brne	.+4      	; 0x1ed6 <xQueueGenericSend+0x66>
					{
						/* The unblocked task has a priority higher than
						our own so yield immediately.  Yes it is ok to do
						this from within the critical section - the kernel
						takes care of that. */
						portYIELD_WITHIN_API();
    1ed2:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <vPortYield>
					}
				}

				taskEXIT_CRITICAL();
    1ed6:	0f 90       	pop	r0
    1ed8:	0f be       	out	0x3f, r0	; 63

				/* Return to the original privilege level before exiting the
				function. */
				return pdPASS;
    1eda:	81 e0       	ldi	r24, 0x01	; 1
    1edc:	8c 87       	std	Y+12, r24	; 0x0c
    1ede:	5c c0       	rjmp	.+184    	; 0x1f98 <xQueueGenericSend+0x128>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1ee0:	89 85       	ldd	r24, Y+9	; 0x09
    1ee2:	9a 85       	ldd	r25, Y+10	; 0x0a
    1ee4:	00 97       	sbiw	r24, 0x00	; 0
    1ee6:	21 f4       	brne	.+8      	; 0x1ef0 <xQueueGenericSend+0x80>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1ee8:	0f 90       	pop	r0
    1eea:	0f be       	out	0x3f, r0	; 63

					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
    1eec:	1c 86       	std	Y+12, r1	; 0x0c
    1eee:	54 c0       	rjmp	.+168    	; 0x1f98 <xQueueGenericSend+0x128>
				}
				else if( xEntryTimeSet == pdFALSE )
    1ef0:	89 81       	ldd	r24, Y+1	; 0x01
    1ef2:	88 23       	and	r24, r24
    1ef4:	31 f4       	brne	.+12     	; 0x1f02 <xQueueGenericSend+0x92>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1ef6:	ce 01       	movw	r24, r28
    1ef8:	02 96       	adiw	r24, 0x02	; 2
    1efa:	0e 94 1d 1a 	call	0x343a	; 0x343a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    1efe:	81 e0       	ldi	r24, 0x01	; 1
    1f00:	89 83       	std	Y+1, r24	; 0x01
				}
			}
		}
		taskEXIT_CRITICAL();
    1f02:	0f 90       	pop	r0
    1f04:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1f06:	0e 94 32 17 	call	0x2e64	; 0x2e64 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1f0a:	0f b6       	in	r0, 0x3f	; 63
    1f0c:	f8 94       	cli
    1f0e:	0f 92       	push	r0
    1f10:	ed 81       	ldd	r30, Y+5	; 0x05
    1f12:	fe 81       	ldd	r31, Y+6	; 0x06
    1f14:	85 8d       	ldd	r24, Z+29	; 0x1d
    1f16:	8f 3f       	cpi	r24, 0xFF	; 255
    1f18:	19 f4       	brne	.+6      	; 0x1f20 <xQueueGenericSend+0xb0>
    1f1a:	ed 81       	ldd	r30, Y+5	; 0x05
    1f1c:	fe 81       	ldd	r31, Y+6	; 0x06
    1f1e:	15 8e       	std	Z+29, r1	; 0x1d
    1f20:	ed 81       	ldd	r30, Y+5	; 0x05
    1f22:	fe 81       	ldd	r31, Y+6	; 0x06
    1f24:	86 8d       	ldd	r24, Z+30	; 0x1e
    1f26:	8f 3f       	cpi	r24, 0xFF	; 255
    1f28:	19 f4       	brne	.+6      	; 0x1f30 <xQueueGenericSend+0xc0>
    1f2a:	ed 81       	ldd	r30, Y+5	; 0x05
    1f2c:	fe 81       	ldd	r31, Y+6	; 0x06
    1f2e:	16 8e       	std	Z+30, r1	; 0x1e
    1f30:	0f 90       	pop	r0
    1f32:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1f34:	ce 01       	movw	r24, r28
    1f36:	02 96       	adiw	r24, 0x02	; 2
    1f38:	9e 01       	movw	r18, r28
    1f3a:	27 5f       	subi	r18, 0xF7	; 247
    1f3c:	3f 4f       	sbci	r19, 0xFF	; 255
    1f3e:	b9 01       	movw	r22, r18
    1f40:	0e 94 36 1a 	call	0x346c	; 0x346c <xTaskCheckForTimeOut>
    1f44:	88 23       	and	r24, r24
    1f46:	09 f5       	brne	.+66     	; 0x1f8a <xQueueGenericSend+0x11a>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1f48:	8d 81       	ldd	r24, Y+5	; 0x05
    1f4a:	9e 81       	ldd	r25, Y+6	; 0x06
    1f4c:	0e 94 d7 12 	call	0x25ae	; 0x25ae <prvIsQueueFull>
    1f50:	88 23       	and	r24, r24
    1f52:	a1 f0       	breq	.+40     	; 0x1f7c <xQueueGenericSend+0x10c>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    1f54:	8d 81       	ldd	r24, Y+5	; 0x05
    1f56:	9e 81       	ldd	r25, Y+6	; 0x06
    1f58:	08 96       	adiw	r24, 0x08	; 8
    1f5a:	29 85       	ldd	r18, Y+9	; 0x09
    1f5c:	3a 85       	ldd	r19, Y+10	; 0x0a
    1f5e:	b9 01       	movw	r22, r18
    1f60:	0e 94 36 19 	call	0x326c	; 0x326c <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    1f64:	8d 81       	ldd	r24, Y+5	; 0x05
    1f66:	9e 81       	ldd	r25, Y+6	; 0x06
    1f68:	0e 94 50 12 	call	0x24a0	; 0x24a0 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    1f6c:	0e 94 3e 17 	call	0x2e7c	; 0x2e7c <xTaskResumeAll>
    1f70:	88 23       	and	r24, r24
    1f72:	09 f0       	breq	.+2      	; 0x1f76 <xQueueGenericSend+0x106>
    1f74:	8f cf       	rjmp	.-226    	; 0x1e94 <xQueueGenericSend+0x24>
				{
					portYIELD_WITHIN_API();
    1f76:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <vPortYield>
    1f7a:	8c cf       	rjmp	.-232    	; 0x1e94 <xQueueGenericSend+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1f7c:	8d 81       	ldd	r24, Y+5	; 0x05
    1f7e:	9e 81       	ldd	r25, Y+6	; 0x06
    1f80:	0e 94 50 12 	call	0x24a0	; 0x24a0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1f84:	0e 94 3e 17 	call	0x2e7c	; 0x2e7c <xTaskResumeAll>
    1f88:	85 cf       	rjmp	.-246    	; 0x1e94 <xQueueGenericSend+0x24>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    1f8a:	8d 81       	ldd	r24, Y+5	; 0x05
    1f8c:	9e 81       	ldd	r25, Y+6	; 0x06
    1f8e:	0e 94 50 12 	call	0x24a0	; 0x24a0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1f92:	0e 94 3e 17 	call	0x2e7c	; 0x2e7c <xTaskResumeAll>

			/* Return to the original privilege level before exiting the
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
    1f96:	1c 86       	std	Y+12, r1	; 0x0c
    1f98:	8c 85       	ldd	r24, Y+12	; 0x0c
		}
	}
}
    1f9a:	2c 96       	adiw	r28, 0x0c	; 12
    1f9c:	0f b6       	in	r0, 0x3f	; 63
    1f9e:	f8 94       	cli
    1fa0:	de bf       	out	0x3e, r29	; 62
    1fa2:	0f be       	out	0x3f, r0	; 63
    1fa4:	cd bf       	out	0x3d, r28	; 61
    1fa6:	cf 91       	pop	r28
    1fa8:	df 91       	pop	r29
    1faa:	08 95       	ret

00001fac <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle pxQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    1fac:	df 93       	push	r29
    1fae:	cf 93       	push	r28
    1fb0:	cd b7       	in	r28, 0x3d	; 61
    1fb2:	de b7       	in	r29, 0x3e	; 62
    1fb4:	29 97       	sbiw	r28, 0x09	; 9
    1fb6:	0f b6       	in	r0, 0x3f	; 63
    1fb8:	f8 94       	cli
    1fba:	de bf       	out	0x3e, r29	; 62
    1fbc:	0f be       	out	0x3f, r0	; 63
    1fbe:	cd bf       	out	0x3d, r28	; 61
    1fc0:	9c 83       	std	Y+4, r25	; 0x04
    1fc2:	8b 83       	std	Y+3, r24	; 0x03
    1fc4:	7e 83       	std	Y+6, r23	; 0x06
    1fc6:	6d 83       	std	Y+5, r22	; 0x05
    1fc8:	58 87       	std	Y+8, r21	; 0x08
    1fca:	4f 83       	std	Y+7, r20	; 0x07
    1fcc:	29 87       	std	Y+9, r18	; 0x09
	/* Similar to xQueueGenericSend, except we don't block if there is no room
	in the queue.  Also we don't directly wake a task that was blocked on a
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    1fce:	19 82       	std	Y+1, r1	; 0x01
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1fd0:	eb 81       	ldd	r30, Y+3	; 0x03
    1fd2:	fc 81       	ldd	r31, Y+4	; 0x04
    1fd4:	92 8d       	ldd	r25, Z+26	; 0x1a
    1fd6:	eb 81       	ldd	r30, Y+3	; 0x03
    1fd8:	fc 81       	ldd	r31, Y+4	; 0x04
    1fda:	83 8d       	ldd	r24, Z+27	; 0x1b
    1fdc:	98 17       	cp	r25, r24
    1fde:	40 f5       	brcc	.+80     	; 0x2030 <xQueueGenericSendFromISR+0x84>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1fe0:	8b 81       	ldd	r24, Y+3	; 0x03
    1fe2:	9c 81       	ldd	r25, Y+4	; 0x04
    1fe4:	2d 81       	ldd	r18, Y+5	; 0x05
    1fe6:	3e 81       	ldd	r19, Y+6	; 0x06
    1fe8:	b9 01       	movw	r22, r18
    1fea:	49 85       	ldd	r20, Y+9	; 0x09
    1fec:	0e 94 73 11 	call	0x22e6	; 0x22e6 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    1ff0:	eb 81       	ldd	r30, Y+3	; 0x03
    1ff2:	fc 81       	ldd	r31, Y+4	; 0x04
    1ff4:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ff6:	8f 3f       	cpi	r24, 0xFF	; 255
    1ff8:	89 f4       	brne	.+34     	; 0x201c <xQueueGenericSendFromISR+0x70>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1ffa:	eb 81       	ldd	r30, Y+3	; 0x03
    1ffc:	fc 81       	ldd	r31, Y+4	; 0x04
    1ffe:	81 89       	ldd	r24, Z+17	; 0x11
    2000:	88 23       	and	r24, r24
    2002:	99 f0       	breq	.+38     	; 0x202a <xQueueGenericSendFromISR+0x7e>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    2004:	8b 81       	ldd	r24, Y+3	; 0x03
    2006:	9c 81       	ldd	r25, Y+4	; 0x04
    2008:	41 96       	adiw	r24, 0x11	; 17
    200a:	0e 94 b5 19 	call	0x336a	; 0x336a <xTaskRemoveFromEventList>
    200e:	88 23       	and	r24, r24
    2010:	61 f0       	breq	.+24     	; 0x202a <xQueueGenericSendFromISR+0x7e>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						*pxHigherPriorityTaskWoken = pdTRUE;
    2012:	ef 81       	ldd	r30, Y+7	; 0x07
    2014:	f8 85       	ldd	r31, Y+8	; 0x08
    2016:	81 e0       	ldi	r24, 0x01	; 1
    2018:	80 83       	st	Z, r24
    201a:	07 c0       	rjmp	.+14     	; 0x202a <xQueueGenericSendFromISR+0x7e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    201c:	eb 81       	ldd	r30, Y+3	; 0x03
    201e:	fc 81       	ldd	r31, Y+4	; 0x04
    2020:	86 8d       	ldd	r24, Z+30	; 0x1e
    2022:	8f 5f       	subi	r24, 0xFF	; 255
    2024:	eb 81       	ldd	r30, Y+3	; 0x03
    2026:	fc 81       	ldd	r31, Y+4	; 0x04
    2028:	86 8f       	std	Z+30, r24	; 0x1e
			}

			xReturn = pdPASS;
    202a:	81 e0       	ldi	r24, 0x01	; 1
    202c:	8a 83       	std	Y+2, r24	; 0x02
    202e:	01 c0       	rjmp	.+2      	; 0x2032 <xQueueGenericSendFromISR+0x86>
		}
		else
		{
			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
			xReturn = errQUEUE_FULL;
    2030:	1a 82       	std	Y+2, r1	; 0x02
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2032:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2034:	29 96       	adiw	r28, 0x09	; 9
    2036:	0f b6       	in	r0, 0x3f	; 63
    2038:	f8 94       	cli
    203a:	de bf       	out	0x3e, r29	; 62
    203c:	0f be       	out	0x3f, r0	; 63
    203e:	cd bf       	out	0x3d, r28	; 61
    2040:	cf 91       	pop	r28
    2042:	df 91       	pop	r29
    2044:	08 95       	ret

00002046 <xQueueGenericReceive>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle pxQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    2046:	df 93       	push	r29
    2048:	cf 93       	push	r28
    204a:	cd b7       	in	r28, 0x3d	; 61
    204c:	de b7       	in	r29, 0x3e	; 62
    204e:	2e 97       	sbiw	r28, 0x0e	; 14
    2050:	0f b6       	in	r0, 0x3f	; 63
    2052:	f8 94       	cli
    2054:	de bf       	out	0x3e, r29	; 62
    2056:	0f be       	out	0x3f, r0	; 63
    2058:	cd bf       	out	0x3d, r28	; 61
    205a:	98 87       	std	Y+8, r25	; 0x08
    205c:	8f 83       	std	Y+7, r24	; 0x07
    205e:	7a 87       	std	Y+10, r23	; 0x0a
    2060:	69 87       	std	Y+9, r22	; 0x09
    2062:	5c 87       	std	Y+12, r21	; 0x0c
    2064:	4b 87       	std	Y+11, r20	; 0x0b
    2066:	2d 87       	std	Y+13, r18	; 0x0d
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
    2068:	1b 82       	std	Y+3, r1	; 0x03
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    206a:	0f b6       	in	r0, 0x3f	; 63
    206c:	f8 94       	cli
    206e:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    2070:	ef 81       	ldd	r30, Y+7	; 0x07
    2072:	f8 85       	ldd	r31, Y+8	; 0x08
    2074:	82 8d       	ldd	r24, Z+26	; 0x1a
    2076:	88 23       	and	r24, r24
    2078:	09 f4       	brne	.+2      	; 0x207c <xQueueGenericReceive+0x36>
    207a:	3f c0       	rjmp	.+126    	; 0x20fa <xQueueGenericReceive+0xb4>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    207c:	ef 81       	ldd	r30, Y+7	; 0x07
    207e:	f8 85       	ldd	r31, Y+8	; 0x08
    2080:	86 81       	ldd	r24, Z+6	; 0x06
    2082:	97 81       	ldd	r25, Z+7	; 0x07
    2084:	9a 83       	std	Y+2, r25	; 0x02
    2086:	89 83       	std	Y+1, r24	; 0x01

				prvCopyDataFromQueue( pxQueue, pvBuffer );
    2088:	8f 81       	ldd	r24, Y+7	; 0x07
    208a:	98 85       	ldd	r25, Y+8	; 0x08
    208c:	29 85       	ldd	r18, Y+9	; 0x09
    208e:	3a 85       	ldd	r19, Y+10	; 0x0a
    2090:	b9 01       	movw	r22, r18
    2092:	0e 94 08 12 	call	0x2410	; 0x2410 <prvCopyDataFromQueue>

				if( xJustPeeking == pdFALSE )
    2096:	8d 85       	ldd	r24, Y+13	; 0x0d
    2098:	88 23       	and	r24, r24
    209a:	b1 f4       	brne	.+44     	; 0x20c8 <xQueueGenericReceive+0x82>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    209c:	ef 81       	ldd	r30, Y+7	; 0x07
    209e:	f8 85       	ldd	r31, Y+8	; 0x08
    20a0:	82 8d       	ldd	r24, Z+26	; 0x1a
    20a2:	81 50       	subi	r24, 0x01	; 1
    20a4:	ef 81       	ldd	r30, Y+7	; 0x07
    20a6:	f8 85       	ldd	r31, Y+8	; 0x08
    20a8:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    20aa:	ef 81       	ldd	r30, Y+7	; 0x07
    20ac:	f8 85       	ldd	r31, Y+8	; 0x08
    20ae:	80 85       	ldd	r24, Z+8	; 0x08
    20b0:	88 23       	and	r24, r24
    20b2:	f1 f0       	breq	.+60     	; 0x20f0 <xQueueGenericReceive+0xaa>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    20b4:	8f 81       	ldd	r24, Y+7	; 0x07
    20b6:	98 85       	ldd	r25, Y+8	; 0x08
    20b8:	08 96       	adiw	r24, 0x08	; 8
    20ba:	0e 94 b5 19 	call	0x336a	; 0x336a <xTaskRemoveFromEventList>
    20be:	81 30       	cpi	r24, 0x01	; 1
    20c0:	b9 f4       	brne	.+46     	; 0x20f0 <xQueueGenericReceive+0xaa>
						{
							portYIELD_WITHIN_API();
    20c2:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <vPortYield>
    20c6:	14 c0       	rjmp	.+40     	; 0x20f0 <xQueueGenericReceive+0xaa>
				{
					traceQUEUE_PEEK( pxQueue );

					/* We are not removing the data, so reset our read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    20c8:	ef 81       	ldd	r30, Y+7	; 0x07
    20ca:	f8 85       	ldd	r31, Y+8	; 0x08
    20cc:	89 81       	ldd	r24, Y+1	; 0x01
    20ce:	9a 81       	ldd	r25, Y+2	; 0x02
    20d0:	97 83       	std	Z+7, r25	; 0x07
    20d2:	86 83       	std	Z+6, r24	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    20d4:	ef 81       	ldd	r30, Y+7	; 0x07
    20d6:	f8 85       	ldd	r31, Y+8	; 0x08
    20d8:	81 89       	ldd	r24, Z+17	; 0x11
    20da:	88 23       	and	r24, r24
    20dc:	49 f0       	breq	.+18     	; 0x20f0 <xQueueGenericReceive+0xaa>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    20de:	8f 81       	ldd	r24, Y+7	; 0x07
    20e0:	98 85       	ldd	r25, Y+8	; 0x08
    20e2:	41 96       	adiw	r24, 0x11	; 17
    20e4:	0e 94 b5 19 	call	0x336a	; 0x336a <xTaskRemoveFromEventList>
    20e8:	88 23       	and	r24, r24
    20ea:	11 f0       	breq	.+4      	; 0x20f0 <xQueueGenericReceive+0xaa>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    20ec:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <vPortYield>
						}
					}

				}

				taskEXIT_CRITICAL();
    20f0:	0f 90       	pop	r0
    20f2:	0f be       	out	0x3f, r0	; 63
				return pdPASS;
    20f4:	81 e0       	ldi	r24, 0x01	; 1
    20f6:	8e 87       	std	Y+14, r24	; 0x0e
    20f8:	5c c0       	rjmp	.+184    	; 0x21b2 <xQueueGenericReceive+0x16c>
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    20fa:	8b 85       	ldd	r24, Y+11	; 0x0b
    20fc:	9c 85       	ldd	r25, Y+12	; 0x0c
    20fe:	00 97       	sbiw	r24, 0x00	; 0
    2100:	21 f4       	brne	.+8      	; 0x210a <xQueueGenericReceive+0xc4>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    2102:	0f 90       	pop	r0
    2104:	0f be       	out	0x3f, r0	; 63
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
    2106:	1e 86       	std	Y+14, r1	; 0x0e
    2108:	54 c0       	rjmp	.+168    	; 0x21b2 <xQueueGenericReceive+0x16c>
				}
				else if( xEntryTimeSet == pdFALSE )
    210a:	8b 81       	ldd	r24, Y+3	; 0x03
    210c:	88 23       	and	r24, r24
    210e:	31 f4       	brne	.+12     	; 0x211c <xQueueGenericReceive+0xd6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    2110:	ce 01       	movw	r24, r28
    2112:	04 96       	adiw	r24, 0x04	; 4
    2114:	0e 94 1d 1a 	call	0x343a	; 0x343a <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
    2118:	81 e0       	ldi	r24, 0x01	; 1
    211a:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}
		taskEXIT_CRITICAL();
    211c:	0f 90       	pop	r0
    211e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    2120:	0e 94 32 17 	call	0x2e64	; 0x2e64 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    2124:	0f b6       	in	r0, 0x3f	; 63
    2126:	f8 94       	cli
    2128:	0f 92       	push	r0
    212a:	ef 81       	ldd	r30, Y+7	; 0x07
    212c:	f8 85       	ldd	r31, Y+8	; 0x08
    212e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2130:	8f 3f       	cpi	r24, 0xFF	; 255
    2132:	19 f4       	brne	.+6      	; 0x213a <xQueueGenericReceive+0xf4>
    2134:	ef 81       	ldd	r30, Y+7	; 0x07
    2136:	f8 85       	ldd	r31, Y+8	; 0x08
    2138:	15 8e       	std	Z+29, r1	; 0x1d
    213a:	ef 81       	ldd	r30, Y+7	; 0x07
    213c:	f8 85       	ldd	r31, Y+8	; 0x08
    213e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2140:	8f 3f       	cpi	r24, 0xFF	; 255
    2142:	19 f4       	brne	.+6      	; 0x214a <xQueueGenericReceive+0x104>
    2144:	ef 81       	ldd	r30, Y+7	; 0x07
    2146:	f8 85       	ldd	r31, Y+8	; 0x08
    2148:	16 8e       	std	Z+30, r1	; 0x1e
    214a:	0f 90       	pop	r0
    214c:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    214e:	ce 01       	movw	r24, r28
    2150:	04 96       	adiw	r24, 0x04	; 4
    2152:	9e 01       	movw	r18, r28
    2154:	25 5f       	subi	r18, 0xF5	; 245
    2156:	3f 4f       	sbci	r19, 0xFF	; 255
    2158:	b9 01       	movw	r22, r18
    215a:	0e 94 36 1a 	call	0x346c	; 0x346c <xTaskCheckForTimeOut>
    215e:	88 23       	and	r24, r24
    2160:	09 f5       	brne	.+66     	; 0x21a4 <xQueueGenericReceive+0x15e>
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    2162:	8f 81       	ldd	r24, Y+7	; 0x07
    2164:	98 85       	ldd	r25, Y+8	; 0x08
    2166:	0e 94 a4 12 	call	0x2548	; 0x2548 <prvIsQueueEmpty>
    216a:	88 23       	and	r24, r24
    216c:	a1 f0       	breq	.+40     	; 0x2196 <xQueueGenericReceive+0x150>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    216e:	8f 81       	ldd	r24, Y+7	; 0x07
    2170:	98 85       	ldd	r25, Y+8	; 0x08
    2172:	41 96       	adiw	r24, 0x11	; 17
    2174:	2b 85       	ldd	r18, Y+11	; 0x0b
    2176:	3c 85       	ldd	r19, Y+12	; 0x0c
    2178:	b9 01       	movw	r22, r18
    217a:	0e 94 36 19 	call	0x326c	; 0x326c <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    217e:	8f 81       	ldd	r24, Y+7	; 0x07
    2180:	98 85       	ldd	r25, Y+8	; 0x08
    2182:	0e 94 50 12 	call	0x24a0	; 0x24a0 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    2186:	0e 94 3e 17 	call	0x2e7c	; 0x2e7c <xTaskResumeAll>
    218a:	88 23       	and	r24, r24
    218c:	09 f0       	breq	.+2      	; 0x2190 <xQueueGenericReceive+0x14a>
    218e:	6d cf       	rjmp	.-294    	; 0x206a <xQueueGenericReceive+0x24>
				{
					portYIELD_WITHIN_API();
    2190:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <vPortYield>
    2194:	6a cf       	rjmp	.-300    	; 0x206a <xQueueGenericReceive+0x24>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    2196:	8f 81       	ldd	r24, Y+7	; 0x07
    2198:	98 85       	ldd	r25, Y+8	; 0x08
    219a:	0e 94 50 12 	call	0x24a0	; 0x24a0 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    219e:	0e 94 3e 17 	call	0x2e7c	; 0x2e7c <xTaskResumeAll>
    21a2:	63 cf       	rjmp	.-314    	; 0x206a <xQueueGenericReceive+0x24>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    21a4:	8f 81       	ldd	r24, Y+7	; 0x07
    21a6:	98 85       	ldd	r25, Y+8	; 0x08
    21a8:	0e 94 50 12 	call	0x24a0	; 0x24a0 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    21ac:	0e 94 3e 17 	call	0x2e7c	; 0x2e7c <xTaskResumeAll>
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
    21b0:	1e 86       	std	Y+14, r1	; 0x0e
    21b2:	8e 85       	ldd	r24, Y+14	; 0x0e
		}
	}
}
    21b4:	2e 96       	adiw	r28, 0x0e	; 14
    21b6:	0f b6       	in	r0, 0x3f	; 63
    21b8:	f8 94       	cli
    21ba:	de bf       	out	0x3e, r29	; 62
    21bc:	0f be       	out	0x3f, r0	; 63
    21be:	cd bf       	out	0x3d, r28	; 61
    21c0:	cf 91       	pop	r28
    21c2:	df 91       	pop	r29
    21c4:	08 95       	ret

000021c6 <xQueueReceiveFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle pxQueue, void * const pvBuffer, signed portBASE_TYPE *pxTaskWoken )
{
    21c6:	df 93       	push	r29
    21c8:	cf 93       	push	r28
    21ca:	cd b7       	in	r28, 0x3d	; 61
    21cc:	de b7       	in	r29, 0x3e	; 62
    21ce:	28 97       	sbiw	r28, 0x08	; 8
    21d0:	0f b6       	in	r0, 0x3f	; 63
    21d2:	f8 94       	cli
    21d4:	de bf       	out	0x3e, r29	; 62
    21d6:	0f be       	out	0x3f, r0	; 63
    21d8:	cd bf       	out	0x3d, r28	; 61
    21da:	9c 83       	std	Y+4, r25	; 0x04
    21dc:	8b 83       	std	Y+3, r24	; 0x03
    21de:	7e 83       	std	Y+6, r23	; 0x06
    21e0:	6d 83       	std	Y+5, r22	; 0x05
    21e2:	58 87       	std	Y+8, r21	; 0x08
    21e4:	4f 83       	std	Y+7, r20	; 0x07

	configASSERT( pxQueue );
	configASSERT( pxTaskWoken );
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    21e6:	19 82       	std	Y+1, r1	; 0x01
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    21e8:	eb 81       	ldd	r30, Y+3	; 0x03
    21ea:	fc 81       	ldd	r31, Y+4	; 0x04
    21ec:	82 8d       	ldd	r24, Z+26	; 0x1a
    21ee:	88 23       	and	r24, r24
    21f0:	71 f1       	breq	.+92     	; 0x224e <xQueueReceiveFromISR+0x88>
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
    21f2:	8b 81       	ldd	r24, Y+3	; 0x03
    21f4:	9c 81       	ldd	r25, Y+4	; 0x04
    21f6:	2d 81       	ldd	r18, Y+5	; 0x05
    21f8:	3e 81       	ldd	r19, Y+6	; 0x06
    21fa:	b9 01       	movw	r22, r18
    21fc:	0e 94 08 12 	call	0x2410	; 0x2410 <prvCopyDataFromQueue>
			--( pxQueue->uxMessagesWaiting );
    2200:	eb 81       	ldd	r30, Y+3	; 0x03
    2202:	fc 81       	ldd	r31, Y+4	; 0x04
    2204:	82 8d       	ldd	r24, Z+26	; 0x1a
    2206:	81 50       	subi	r24, 0x01	; 1
    2208:	eb 81       	ldd	r30, Y+3	; 0x03
    220a:	fc 81       	ldd	r31, Y+4	; 0x04
    220c:	82 8f       	std	Z+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    220e:	eb 81       	ldd	r30, Y+3	; 0x03
    2210:	fc 81       	ldd	r31, Y+4	; 0x04
    2212:	85 8d       	ldd	r24, Z+29	; 0x1d
    2214:	8f 3f       	cpi	r24, 0xFF	; 255
    2216:	89 f4       	brne	.+34     	; 0x223a <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    2218:	eb 81       	ldd	r30, Y+3	; 0x03
    221a:	fc 81       	ldd	r31, Y+4	; 0x04
    221c:	80 85       	ldd	r24, Z+8	; 0x08
    221e:	88 23       	and	r24, r24
    2220:	99 f0       	breq	.+38     	; 0x2248 <xQueueReceiveFromISR+0x82>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2222:	8b 81       	ldd	r24, Y+3	; 0x03
    2224:	9c 81       	ldd	r25, Y+4	; 0x04
    2226:	08 96       	adiw	r24, 0x08	; 8
    2228:	0e 94 b5 19 	call	0x336a	; 0x336a <xTaskRemoveFromEventList>
    222c:	88 23       	and	r24, r24
    222e:	61 f0       	breq	.+24     	; 0x2248 <xQueueReceiveFromISR+0x82>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						*pxTaskWoken = pdTRUE;
    2230:	ef 81       	ldd	r30, Y+7	; 0x07
    2232:	f8 85       	ldd	r31, Y+8	; 0x08
    2234:	81 e0       	ldi	r24, 0x01	; 1
    2236:	80 83       	st	Z, r24
    2238:	07 c0       	rjmp	.+14     	; 0x2248 <xQueueReceiveFromISR+0x82>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    223a:	eb 81       	ldd	r30, Y+3	; 0x03
    223c:	fc 81       	ldd	r31, Y+4	; 0x04
    223e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2240:	8f 5f       	subi	r24, 0xFF	; 255
    2242:	eb 81       	ldd	r30, Y+3	; 0x03
    2244:	fc 81       	ldd	r31, Y+4	; 0x04
    2246:	85 8f       	std	Z+29, r24	; 0x1d
			}

			xReturn = pdPASS;
    2248:	81 e0       	ldi	r24, 0x01	; 1
    224a:	8a 83       	std	Y+2, r24	; 0x02
    224c:	01 c0       	rjmp	.+2      	; 0x2250 <xQueueReceiveFromISR+0x8a>
		}
		else
		{
			xReturn = pdFAIL;
    224e:	1a 82       	std	Y+2, r1	; 0x02
			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2250:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2252:	28 96       	adiw	r28, 0x08	; 8
    2254:	0f b6       	in	r0, 0x3f	; 63
    2256:	f8 94       	cli
    2258:	de bf       	out	0x3e, r29	; 62
    225a:	0f be       	out	0x3f, r0	; 63
    225c:	cd bf       	out	0x3d, r28	; 61
    225e:	cf 91       	pop	r28
    2260:	df 91       	pop	r29
    2262:	08 95       	ret

00002264 <uxQueueMessagesWaiting>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaiting( const xQueueHandle pxQueue )
{
    2264:	df 93       	push	r29
    2266:	cf 93       	push	r28
    2268:	00 d0       	rcall	.+0      	; 0x226a <uxQueueMessagesWaiting+0x6>
    226a:	0f 92       	push	r0
    226c:	cd b7       	in	r28, 0x3d	; 61
    226e:	de b7       	in	r29, 0x3e	; 62
    2270:	9b 83       	std	Y+3, r25	; 0x03
    2272:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    2274:	0f b6       	in	r0, 0x3f	; 63
    2276:	f8 94       	cli
    2278:	0f 92       	push	r0
		uxReturn = pxQueue->uxMessagesWaiting;
    227a:	ea 81       	ldd	r30, Y+2	; 0x02
    227c:	fb 81       	ldd	r31, Y+3	; 0x03
    227e:	82 8d       	ldd	r24, Z+26	; 0x1a
    2280:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    2282:	0f 90       	pop	r0
    2284:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
    2286:	89 81       	ldd	r24, Y+1	; 0x01
}
    2288:	0f 90       	pop	r0
    228a:	0f 90       	pop	r0
    228c:	0f 90       	pop	r0
    228e:	cf 91       	pop	r28
    2290:	df 91       	pop	r29
    2292:	08 95       	ret

00002294 <uxQueueMessagesWaitingFromISR>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxQueueMessagesWaitingFromISR( const xQueueHandle pxQueue )
{
    2294:	df 93       	push	r29
    2296:	cf 93       	push	r28
    2298:	00 d0       	rcall	.+0      	; 0x229a <uxQueueMessagesWaitingFromISR+0x6>
    229a:	0f 92       	push	r0
    229c:	cd b7       	in	r28, 0x3d	; 61
    229e:	de b7       	in	r29, 0x3e	; 62
    22a0:	9b 83       	std	Y+3, r25	; 0x03
    22a2:	8a 83       	std	Y+2, r24	; 0x02
unsigned portBASE_TYPE uxReturn;

	configASSERT( pxQueue );

	uxReturn = pxQueue->uxMessagesWaiting;
    22a4:	ea 81       	ldd	r30, Y+2	; 0x02
    22a6:	fb 81       	ldd	r31, Y+3	; 0x03
    22a8:	82 8d       	ldd	r24, Z+26	; 0x1a
    22aa:	89 83       	std	Y+1, r24	; 0x01

	return uxReturn;
    22ac:	89 81       	ldd	r24, Y+1	; 0x01
}
    22ae:	0f 90       	pop	r0
    22b0:	0f 90       	pop	r0
    22b2:	0f 90       	pop	r0
    22b4:	cf 91       	pop	r28
    22b6:	df 91       	pop	r29
    22b8:	08 95       	ret

000022ba <vQueueDelete>:
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle pxQueue )
{
    22ba:	df 93       	push	r29
    22bc:	cf 93       	push	r28
    22be:	00 d0       	rcall	.+0      	; 0x22c0 <vQueueDelete+0x6>
    22c0:	cd b7       	in	r28, 0x3d	; 61
    22c2:	de b7       	in	r29, 0x3e	; 62
    22c4:	9a 83       	std	Y+2, r25	; 0x02
    22c6:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxQueue );

	traceQUEUE_DELETE( pxQueue );
	vQueueUnregisterQueue( pxQueue );
	vPortFree( pxQueue->pcHead );
    22c8:	e9 81       	ldd	r30, Y+1	; 0x01
    22ca:	fa 81       	ldd	r31, Y+2	; 0x02
    22cc:	80 81       	ld	r24, Z
    22ce:	91 81       	ldd	r25, Z+1	; 0x01
    22d0:	0e 94 35 0a 	call	0x146a	; 0x146a <vPortFree>
	vPortFree( pxQueue );
    22d4:	89 81       	ldd	r24, Y+1	; 0x01
    22d6:	9a 81       	ldd	r25, Y+2	; 0x02
    22d8:	0e 94 35 0a 	call	0x146a	; 0x146a <vPortFree>
}
    22dc:	0f 90       	pop	r0
    22de:	0f 90       	pop	r0
    22e0:	cf 91       	pop	r28
    22e2:	df 91       	pop	r29
    22e4:	08 95       	ret

000022e6 <prvCopyDataToQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    22e6:	df 93       	push	r29
    22e8:	cf 93       	push	r28
    22ea:	00 d0       	rcall	.+0      	; 0x22ec <prvCopyDataToQueue+0x6>
    22ec:	00 d0       	rcall	.+0      	; 0x22ee <prvCopyDataToQueue+0x8>
    22ee:	0f 92       	push	r0
    22f0:	cd b7       	in	r28, 0x3d	; 61
    22f2:	de b7       	in	r29, 0x3e	; 62
    22f4:	9a 83       	std	Y+2, r25	; 0x02
    22f6:	89 83       	std	Y+1, r24	; 0x01
    22f8:	7c 83       	std	Y+4, r23	; 0x04
    22fa:	6b 83       	std	Y+3, r22	; 0x03
    22fc:	4d 83       	std	Y+5, r20	; 0x05
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    22fe:	e9 81       	ldd	r30, Y+1	; 0x01
    2300:	fa 81       	ldd	r31, Y+2	; 0x02
    2302:	84 8d       	ldd	r24, Z+28	; 0x1c
    2304:	88 23       	and	r24, r24
    2306:	09 f4       	brne	.+2      	; 0x230a <prvCopyDataToQueue+0x24>
    2308:	74 c0       	rjmp	.+232    	; 0x23f2 <prvCopyDataToQueue+0x10c>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    230a:	8d 81       	ldd	r24, Y+5	; 0x05
    230c:	88 23       	and	r24, r24
    230e:	99 f5       	brne	.+102    	; 0x2376 <prvCopyDataToQueue+0x90>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    2310:	e9 81       	ldd	r30, Y+1	; 0x01
    2312:	fa 81       	ldd	r31, Y+2	; 0x02
    2314:	64 81       	ldd	r22, Z+4	; 0x04
    2316:	75 81       	ldd	r23, Z+5	; 0x05
    2318:	e9 81       	ldd	r30, Y+1	; 0x01
    231a:	fa 81       	ldd	r31, Y+2	; 0x02
    231c:	84 8d       	ldd	r24, Z+28	; 0x1c
    231e:	48 2f       	mov	r20, r24
    2320:	50 e0       	ldi	r21, 0x00	; 0
    2322:	2b 81       	ldd	r18, Y+3	; 0x03
    2324:	3c 81       	ldd	r19, Y+4	; 0x04
    2326:	cb 01       	movw	r24, r22
    2328:	b9 01       	movw	r22, r18
    232a:	0e 94 06 32 	call	0x640c	; 0x640c <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    232e:	e9 81       	ldd	r30, Y+1	; 0x01
    2330:	fa 81       	ldd	r31, Y+2	; 0x02
    2332:	24 81       	ldd	r18, Z+4	; 0x04
    2334:	35 81       	ldd	r19, Z+5	; 0x05
    2336:	e9 81       	ldd	r30, Y+1	; 0x01
    2338:	fa 81       	ldd	r31, Y+2	; 0x02
    233a:	84 8d       	ldd	r24, Z+28	; 0x1c
    233c:	88 2f       	mov	r24, r24
    233e:	90 e0       	ldi	r25, 0x00	; 0
    2340:	82 0f       	add	r24, r18
    2342:	93 1f       	adc	r25, r19
    2344:	e9 81       	ldd	r30, Y+1	; 0x01
    2346:	fa 81       	ldd	r31, Y+2	; 0x02
    2348:	95 83       	std	Z+5, r25	; 0x05
    234a:	84 83       	std	Z+4, r24	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    234c:	e9 81       	ldd	r30, Y+1	; 0x01
    234e:	fa 81       	ldd	r31, Y+2	; 0x02
    2350:	24 81       	ldd	r18, Z+4	; 0x04
    2352:	35 81       	ldd	r19, Z+5	; 0x05
    2354:	e9 81       	ldd	r30, Y+1	; 0x01
    2356:	fa 81       	ldd	r31, Y+2	; 0x02
    2358:	82 81       	ldd	r24, Z+2	; 0x02
    235a:	93 81       	ldd	r25, Z+3	; 0x03
    235c:	28 17       	cp	r18, r24
    235e:	39 07       	cpc	r19, r25
    2360:	08 f4       	brcc	.+2      	; 0x2364 <prvCopyDataToQueue+0x7e>
    2362:	47 c0       	rjmp	.+142    	; 0x23f2 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    2364:	e9 81       	ldd	r30, Y+1	; 0x01
    2366:	fa 81       	ldd	r31, Y+2	; 0x02
    2368:	80 81       	ld	r24, Z
    236a:	91 81       	ldd	r25, Z+1	; 0x01
    236c:	e9 81       	ldd	r30, Y+1	; 0x01
    236e:	fa 81       	ldd	r31, Y+2	; 0x02
    2370:	95 83       	std	Z+5, r25	; 0x05
    2372:	84 83       	std	Z+4, r24	; 0x04
    2374:	3e c0       	rjmp	.+124    	; 0x23f2 <prvCopyDataToQueue+0x10c>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    2376:	e9 81       	ldd	r30, Y+1	; 0x01
    2378:	fa 81       	ldd	r31, Y+2	; 0x02
    237a:	66 81       	ldd	r22, Z+6	; 0x06
    237c:	77 81       	ldd	r23, Z+7	; 0x07
    237e:	e9 81       	ldd	r30, Y+1	; 0x01
    2380:	fa 81       	ldd	r31, Y+2	; 0x02
    2382:	84 8d       	ldd	r24, Z+28	; 0x1c
    2384:	48 2f       	mov	r20, r24
    2386:	50 e0       	ldi	r21, 0x00	; 0
    2388:	2b 81       	ldd	r18, Y+3	; 0x03
    238a:	3c 81       	ldd	r19, Y+4	; 0x04
    238c:	cb 01       	movw	r24, r22
    238e:	b9 01       	movw	r22, r18
    2390:	0e 94 06 32 	call	0x640c	; 0x640c <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    2394:	e9 81       	ldd	r30, Y+1	; 0x01
    2396:	fa 81       	ldd	r31, Y+2	; 0x02
    2398:	26 81       	ldd	r18, Z+6	; 0x06
    239a:	37 81       	ldd	r19, Z+7	; 0x07
    239c:	e9 81       	ldd	r30, Y+1	; 0x01
    239e:	fa 81       	ldd	r31, Y+2	; 0x02
    23a0:	84 8d       	ldd	r24, Z+28	; 0x1c
    23a2:	88 2f       	mov	r24, r24
    23a4:	90 e0       	ldi	r25, 0x00	; 0
    23a6:	90 95       	com	r25
    23a8:	81 95       	neg	r24
    23aa:	9f 4f       	sbci	r25, 0xFF	; 255
    23ac:	82 0f       	add	r24, r18
    23ae:	93 1f       	adc	r25, r19
    23b0:	e9 81       	ldd	r30, Y+1	; 0x01
    23b2:	fa 81       	ldd	r31, Y+2	; 0x02
    23b4:	97 83       	std	Z+7, r25	; 0x07
    23b6:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    23b8:	e9 81       	ldd	r30, Y+1	; 0x01
    23ba:	fa 81       	ldd	r31, Y+2	; 0x02
    23bc:	26 81       	ldd	r18, Z+6	; 0x06
    23be:	37 81       	ldd	r19, Z+7	; 0x07
    23c0:	e9 81       	ldd	r30, Y+1	; 0x01
    23c2:	fa 81       	ldd	r31, Y+2	; 0x02
    23c4:	80 81       	ld	r24, Z
    23c6:	91 81       	ldd	r25, Z+1	; 0x01
    23c8:	28 17       	cp	r18, r24
    23ca:	39 07       	cpc	r19, r25
    23cc:	90 f4       	brcc	.+36     	; 0x23f2 <prvCopyDataToQueue+0x10c>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    23ce:	e9 81       	ldd	r30, Y+1	; 0x01
    23d0:	fa 81       	ldd	r31, Y+2	; 0x02
    23d2:	22 81       	ldd	r18, Z+2	; 0x02
    23d4:	33 81       	ldd	r19, Z+3	; 0x03
    23d6:	e9 81       	ldd	r30, Y+1	; 0x01
    23d8:	fa 81       	ldd	r31, Y+2	; 0x02
    23da:	84 8d       	ldd	r24, Z+28	; 0x1c
    23dc:	88 2f       	mov	r24, r24
    23de:	90 e0       	ldi	r25, 0x00	; 0
    23e0:	90 95       	com	r25
    23e2:	81 95       	neg	r24
    23e4:	9f 4f       	sbci	r25, 0xFF	; 255
    23e6:	82 0f       	add	r24, r18
    23e8:	93 1f       	adc	r25, r19
    23ea:	e9 81       	ldd	r30, Y+1	; 0x01
    23ec:	fa 81       	ldd	r31, Y+2	; 0x02
    23ee:	97 83       	std	Z+7, r25	; 0x07
    23f0:	86 83       	std	Z+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    23f2:	e9 81       	ldd	r30, Y+1	; 0x01
    23f4:	fa 81       	ldd	r31, Y+2	; 0x02
    23f6:	82 8d       	ldd	r24, Z+26	; 0x1a
    23f8:	8f 5f       	subi	r24, 0xFF	; 255
    23fa:	e9 81       	ldd	r30, Y+1	; 0x01
    23fc:	fa 81       	ldd	r31, Y+2	; 0x02
    23fe:	82 8f       	std	Z+26, r24	; 0x1a
}
    2400:	0f 90       	pop	r0
    2402:	0f 90       	pop	r0
    2404:	0f 90       	pop	r0
    2406:	0f 90       	pop	r0
    2408:	0f 90       	pop	r0
    240a:	cf 91       	pop	r28
    240c:	df 91       	pop	r29
    240e:	08 95       	ret

00002410 <prvCopyDataFromQueue>:
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
    2410:	df 93       	push	r29
    2412:	cf 93       	push	r28
    2414:	00 d0       	rcall	.+0      	; 0x2416 <prvCopyDataFromQueue+0x6>
    2416:	00 d0       	rcall	.+0      	; 0x2418 <prvCopyDataFromQueue+0x8>
    2418:	cd b7       	in	r28, 0x3d	; 61
    241a:	de b7       	in	r29, 0x3e	; 62
    241c:	9a 83       	std	Y+2, r25	; 0x02
    241e:	89 83       	std	Y+1, r24	; 0x01
    2420:	7c 83       	std	Y+4, r23	; 0x04
    2422:	6b 83       	std	Y+3, r22	; 0x03
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    2424:	e9 81       	ldd	r30, Y+1	; 0x01
    2426:	fa 81       	ldd	r31, Y+2	; 0x02
    2428:	80 81       	ld	r24, Z
    242a:	91 81       	ldd	r25, Z+1	; 0x01
    242c:	00 97       	sbiw	r24, 0x00	; 0
    242e:	89 f1       	breq	.+98     	; 0x2492 <prvCopyDataFromQueue+0x82>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    2430:	e9 81       	ldd	r30, Y+1	; 0x01
    2432:	fa 81       	ldd	r31, Y+2	; 0x02
    2434:	26 81       	ldd	r18, Z+6	; 0x06
    2436:	37 81       	ldd	r19, Z+7	; 0x07
    2438:	e9 81       	ldd	r30, Y+1	; 0x01
    243a:	fa 81       	ldd	r31, Y+2	; 0x02
    243c:	84 8d       	ldd	r24, Z+28	; 0x1c
    243e:	88 2f       	mov	r24, r24
    2440:	90 e0       	ldi	r25, 0x00	; 0
    2442:	82 0f       	add	r24, r18
    2444:	93 1f       	adc	r25, r19
    2446:	e9 81       	ldd	r30, Y+1	; 0x01
    2448:	fa 81       	ldd	r31, Y+2	; 0x02
    244a:	97 83       	std	Z+7, r25	; 0x07
    244c:	86 83       	std	Z+6, r24	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    244e:	e9 81       	ldd	r30, Y+1	; 0x01
    2450:	fa 81       	ldd	r31, Y+2	; 0x02
    2452:	26 81       	ldd	r18, Z+6	; 0x06
    2454:	37 81       	ldd	r19, Z+7	; 0x07
    2456:	e9 81       	ldd	r30, Y+1	; 0x01
    2458:	fa 81       	ldd	r31, Y+2	; 0x02
    245a:	82 81       	ldd	r24, Z+2	; 0x02
    245c:	93 81       	ldd	r25, Z+3	; 0x03
    245e:	28 17       	cp	r18, r24
    2460:	39 07       	cpc	r19, r25
    2462:	40 f0       	brcs	.+16     	; 0x2474 <prvCopyDataFromQueue+0x64>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    2464:	e9 81       	ldd	r30, Y+1	; 0x01
    2466:	fa 81       	ldd	r31, Y+2	; 0x02
    2468:	80 81       	ld	r24, Z
    246a:	91 81       	ldd	r25, Z+1	; 0x01
    246c:	e9 81       	ldd	r30, Y+1	; 0x01
    246e:	fa 81       	ldd	r31, Y+2	; 0x02
    2470:	97 83       	std	Z+7, r25	; 0x07
    2472:	86 83       	std	Z+6, r24	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    2474:	e9 81       	ldd	r30, Y+1	; 0x01
    2476:	fa 81       	ldd	r31, Y+2	; 0x02
    2478:	46 81       	ldd	r20, Z+6	; 0x06
    247a:	57 81       	ldd	r21, Z+7	; 0x07
    247c:	e9 81       	ldd	r30, Y+1	; 0x01
    247e:	fa 81       	ldd	r31, Y+2	; 0x02
    2480:	84 8d       	ldd	r24, Z+28	; 0x1c
    2482:	28 2f       	mov	r18, r24
    2484:	30 e0       	ldi	r19, 0x00	; 0
    2486:	8b 81       	ldd	r24, Y+3	; 0x03
    2488:	9c 81       	ldd	r25, Y+4	; 0x04
    248a:	ba 01       	movw	r22, r20
    248c:	a9 01       	movw	r20, r18
    248e:	0e 94 06 32 	call	0x640c	; 0x640c <memcpy>
	}
}
    2492:	0f 90       	pop	r0
    2494:	0f 90       	pop	r0
    2496:	0f 90       	pop	r0
    2498:	0f 90       	pop	r0
    249a:	cf 91       	pop	r28
    249c:	df 91       	pop	r29
    249e:	08 95       	ret

000024a0 <prvUnlockQueue>:
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQueueHandle pxQueue )
{
    24a0:	df 93       	push	r29
    24a2:	cf 93       	push	r28
    24a4:	00 d0       	rcall	.+0      	; 0x24a6 <prvUnlockQueue+0x6>
    24a6:	cd b7       	in	r28, 0x3d	; 61
    24a8:	de b7       	in	r29, 0x3e	; 62
    24aa:	9a 83       	std	Y+2, r25	; 0x02
    24ac:	89 83       	std	Y+1, r24	; 0x01

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    24ae:	0f b6       	in	r0, 0x3f	; 63
    24b0:	f8 94       	cli
    24b2:	0f 92       	push	r0
    24b4:	15 c0       	rjmp	.+42     	; 0x24e0 <prvUnlockQueue+0x40>
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
		{
			/* Data was posted while the queue was locked.  Are any tasks
			blocked waiting for data to become available? */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    24b6:	e9 81       	ldd	r30, Y+1	; 0x01
    24b8:	fa 81       	ldd	r31, Y+2	; 0x02
    24ba:	81 89       	ldd	r24, Z+17	; 0x11
    24bc:	88 23       	and	r24, r24
    24be:	a9 f0       	breq	.+42     	; 0x24ea <prvUnlockQueue+0x4a>
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    24c0:	89 81       	ldd	r24, Y+1	; 0x01
    24c2:	9a 81       	ldd	r25, Y+2	; 0x02
    24c4:	41 96       	adiw	r24, 0x11	; 17
    24c6:	0e 94 b5 19 	call	0x336a	; 0x336a <xTaskRemoveFromEventList>
    24ca:	88 23       	and	r24, r24
    24cc:	11 f0       	breq	.+4      	; 0x24d2 <prvUnlockQueue+0x32>
				{
					/* The task waiting has a higher priority so record that a
					context	switch is required. */
					vTaskMissedYield();
    24ce:	0e 94 9d 1a 	call	0x353a	; 0x353a <vTaskMissedYield>
				}

				--( pxQueue->xTxLock );
    24d2:	e9 81       	ldd	r30, Y+1	; 0x01
    24d4:	fa 81       	ldd	r31, Y+2	; 0x02
    24d6:	86 8d       	ldd	r24, Z+30	; 0x1e
    24d8:	81 50       	subi	r24, 0x01	; 1
    24da:	e9 81       	ldd	r30, Y+1	; 0x01
    24dc:	fa 81       	ldd	r31, Y+2	; 0x02
    24de:	86 8f       	std	Z+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    24e0:	e9 81       	ldd	r30, Y+1	; 0x01
    24e2:	fa 81       	ldd	r31, Y+2	; 0x02
    24e4:	86 8d       	ldd	r24, Z+30	; 0x1e
    24e6:	18 16       	cp	r1, r24
    24e8:	34 f3       	brlt	.-52     	; 0x24b6 <prvUnlockQueue+0x16>
			{
				break;
			}
		}

		pxQueue->xTxLock = queueUNLOCKED;
    24ea:	e9 81       	ldd	r30, Y+1	; 0x01
    24ec:	fa 81       	ldd	r31, Y+2	; 0x02
    24ee:	8f ef       	ldi	r24, 0xFF	; 255
    24f0:	86 8f       	std	Z+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    24f2:	0f 90       	pop	r0
    24f4:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    24f6:	0f b6       	in	r0, 0x3f	; 63
    24f8:	f8 94       	cli
    24fa:	0f 92       	push	r0
    24fc:	15 c0       	rjmp	.+42     	; 0x2528 <prvUnlockQueue+0x88>
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    24fe:	e9 81       	ldd	r30, Y+1	; 0x01
    2500:	fa 81       	ldd	r31, Y+2	; 0x02
    2502:	80 85       	ldd	r24, Z+8	; 0x08
    2504:	88 23       	and	r24, r24
    2506:	a9 f0       	breq	.+42     	; 0x2532 <prvUnlockQueue+0x92>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    2508:	89 81       	ldd	r24, Y+1	; 0x01
    250a:	9a 81       	ldd	r25, Y+2	; 0x02
    250c:	08 96       	adiw	r24, 0x08	; 8
    250e:	0e 94 b5 19 	call	0x336a	; 0x336a <xTaskRemoveFromEventList>
    2512:	88 23       	and	r24, r24
    2514:	11 f0       	breq	.+4      	; 0x251a <prvUnlockQueue+0x7a>
				{
					vTaskMissedYield();
    2516:	0e 94 9d 1a 	call	0x353a	; 0x353a <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    251a:	e9 81       	ldd	r30, Y+1	; 0x01
    251c:	fa 81       	ldd	r31, Y+2	; 0x02
    251e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2520:	81 50       	subi	r24, 0x01	; 1
    2522:	e9 81       	ldd	r30, Y+1	; 0x01
    2524:	fa 81       	ldd	r31, Y+2	; 0x02
    2526:	85 8f       	std	Z+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    2528:	e9 81       	ldd	r30, Y+1	; 0x01
    252a:	fa 81       	ldd	r31, Y+2	; 0x02
    252c:	85 8d       	ldd	r24, Z+29	; 0x1d
    252e:	18 16       	cp	r1, r24
    2530:	34 f3       	brlt	.-52     	; 0x24fe <prvUnlockQueue+0x5e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    2532:	e9 81       	ldd	r30, Y+1	; 0x01
    2534:	fa 81       	ldd	r31, Y+2	; 0x02
    2536:	8f ef       	ldi	r24, 0xFF	; 255
    2538:	85 8f       	std	Z+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    253a:	0f 90       	pop	r0
    253c:	0f be       	out	0x3f, r0	; 63
}
    253e:	0f 90       	pop	r0
    2540:	0f 90       	pop	r0
    2542:	cf 91       	pop	r28
    2544:	df 91       	pop	r29
    2546:	08 95       	ret

00002548 <prvIsQueueEmpty>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueEmpty( const xQueueHandle pxQueue )
{
    2548:	df 93       	push	r29
    254a:	cf 93       	push	r28
    254c:	00 d0       	rcall	.+0      	; 0x254e <prvIsQueueEmpty+0x6>
    254e:	0f 92       	push	r0
    2550:	cd b7       	in	r28, 0x3d	; 61
    2552:	de b7       	in	r29, 0x3e	; 62
    2554:	9b 83       	std	Y+3, r25	; 0x03
    2556:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    2558:	0f b6       	in	r0, 0x3f	; 63
    255a:	f8 94       	cli
    255c:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    255e:	ea 81       	ldd	r30, Y+2	; 0x02
    2560:	fb 81       	ldd	r31, Y+3	; 0x03
    2562:	82 8d       	ldd	r24, Z+26	; 0x1a
    2564:	19 82       	std	Y+1, r1	; 0x01
    2566:	88 23       	and	r24, r24
    2568:	11 f4       	brne	.+4      	; 0x256e <prvIsQueueEmpty+0x26>
    256a:	81 e0       	ldi	r24, 0x01	; 1
    256c:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    256e:	0f 90       	pop	r0
    2570:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    2572:	89 81       	ldd	r24, Y+1	; 0x01
}
    2574:	0f 90       	pop	r0
    2576:	0f 90       	pop	r0
    2578:	0f 90       	pop	r0
    257a:	cf 91       	pop	r28
    257c:	df 91       	pop	r29
    257e:	08 95       	ret

00002580 <xQueueIsQueueEmptyFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle pxQueue )
{
    2580:	df 93       	push	r29
    2582:	cf 93       	push	r28
    2584:	00 d0       	rcall	.+0      	; 0x2586 <xQueueIsQueueEmptyFromISR+0x6>
    2586:	0f 92       	push	r0
    2588:	cd b7       	in	r28, 0x3d	; 61
    258a:	de b7       	in	r29, 0x3e	; 62
    258c:	9b 83       	std	Y+3, r25	; 0x03
    258e:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 );
    2590:	ea 81       	ldd	r30, Y+2	; 0x02
    2592:	fb 81       	ldd	r31, Y+3	; 0x03
    2594:	82 8d       	ldd	r24, Z+26	; 0x1a
    2596:	19 82       	std	Y+1, r1	; 0x01
    2598:	88 23       	and	r24, r24
    259a:	11 f4       	brne	.+4      	; 0x25a0 <xQueueIsQueueEmptyFromISR+0x20>
    259c:	81 e0       	ldi	r24, 0x01	; 1
    259e:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    25a0:	89 81       	ldd	r24, Y+1	; 0x01
}
    25a2:	0f 90       	pop	r0
    25a4:	0f 90       	pop	r0
    25a6:	0f 90       	pop	r0
    25a8:	cf 91       	pop	r28
    25aa:	df 91       	pop	r29
    25ac:	08 95       	ret

000025ae <prvIsQueueFull>:
/*-----------------------------------------------------------*/

static signed portBASE_TYPE prvIsQueueFull( const xQueueHandle pxQueue )
{
    25ae:	df 93       	push	r29
    25b0:	cf 93       	push	r28
    25b2:	00 d0       	rcall	.+0      	; 0x25b4 <prvIsQueueFull+0x6>
    25b4:	0f 92       	push	r0
    25b6:	cd b7       	in	r28, 0x3d	; 61
    25b8:	de b7       	in	r29, 0x3e	; 62
    25ba:	9b 83       	std	Y+3, r25	; 0x03
    25bc:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    25be:	0f b6       	in	r0, 0x3f	; 63
    25c0:	f8 94       	cli
    25c2:	0f 92       	push	r0
		xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    25c4:	ea 81       	ldd	r30, Y+2	; 0x02
    25c6:	fb 81       	ldd	r31, Y+3	; 0x03
    25c8:	92 8d       	ldd	r25, Z+26	; 0x1a
    25ca:	ea 81       	ldd	r30, Y+2	; 0x02
    25cc:	fb 81       	ldd	r31, Y+3	; 0x03
    25ce:	83 8d       	ldd	r24, Z+27	; 0x1b
    25d0:	19 82       	std	Y+1, r1	; 0x01
    25d2:	98 17       	cp	r25, r24
    25d4:	11 f4       	brne	.+4      	; 0x25da <prvIsQueueFull+0x2c>
    25d6:	81 e0       	ldi	r24, 0x01	; 1
    25d8:	89 83       	std	Y+1, r24	; 0x01
	taskEXIT_CRITICAL();
    25da:	0f 90       	pop	r0
    25dc:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    25de:	89 81       	ldd	r24, Y+1	; 0x01
}
    25e0:	0f 90       	pop	r0
    25e2:	0f 90       	pop	r0
    25e4:	0f 90       	pop	r0
    25e6:	cf 91       	pop	r28
    25e8:	df 91       	pop	r29
    25ea:	08 95       	ret

000025ec <xQueueIsQueueFullFromISR>:
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle pxQueue )
{
    25ec:	df 93       	push	r29
    25ee:	cf 93       	push	r28
    25f0:	00 d0       	rcall	.+0      	; 0x25f2 <xQueueIsQueueFullFromISR+0x6>
    25f2:	0f 92       	push	r0
    25f4:	cd b7       	in	r28, 0x3d	; 61
    25f6:	de b7       	in	r29, 0x3e	; 62
    25f8:	9b 83       	std	Y+3, r25	; 0x03
    25fa:	8a 83       	std	Y+2, r24	; 0x02
signed portBASE_TYPE xReturn;

	configASSERT( pxQueue );
	xReturn = ( pxQueue->uxMessagesWaiting == pxQueue->uxLength );
    25fc:	ea 81       	ldd	r30, Y+2	; 0x02
    25fe:	fb 81       	ldd	r31, Y+3	; 0x03
    2600:	92 8d       	ldd	r25, Z+26	; 0x1a
    2602:	ea 81       	ldd	r30, Y+2	; 0x02
    2604:	fb 81       	ldd	r31, Y+3	; 0x03
    2606:	83 8d       	ldd	r24, Z+27	; 0x1b
    2608:	19 82       	std	Y+1, r1	; 0x01
    260a:	98 17       	cp	r25, r24
    260c:	11 f4       	brne	.+4      	; 0x2612 <xQueueIsQueueFullFromISR+0x26>
    260e:	81 e0       	ldi	r24, 0x01	; 1
    2610:	89 83       	std	Y+1, r24	; 0x01

	return xReturn;
    2612:	89 81       	ldd	r24, Y+1	; 0x01
}
    2614:	0f 90       	pop	r0
    2616:	0f 90       	pop	r0
    2618:	0f 90       	pop	r0
    261a:	cf 91       	pop	r28
    261c:	df 91       	pop	r29
    261e:	08 95       	ret

00002620 <vQueueWaitForMessageRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vQueueWaitForMessageRestricted( xQueueHandle pxQueue, portTickType xTicksToWait )
	{
    2620:	df 93       	push	r29
    2622:	cf 93       	push	r28
    2624:	00 d0       	rcall	.+0      	; 0x2626 <vQueueWaitForMessageRestricted+0x6>
    2626:	00 d0       	rcall	.+0      	; 0x2628 <vQueueWaitForMessageRestricted+0x8>
    2628:	cd b7       	in	r28, 0x3d	; 61
    262a:	de b7       	in	r29, 0x3e	; 62
    262c:	9a 83       	std	Y+2, r25	; 0x02
    262e:	89 83       	std	Y+1, r24	; 0x01
    2630:	7c 83       	std	Y+4, r23	; 0x04
    2632:	6b 83       	std	Y+3, r22	; 0x03
		will not actually cause the task to block, just place it on a blocked
		list.  It will not block until the scheduler is unlocked - at which
		time a yield will be performed.  If an item is added to the queue while
		the queue is locked, and the calling task blocks on the queue, then the
		calling task will be immediately unblocked when the queue is unlocked. */
		prvLockQueue( pxQueue );
    2634:	0f b6       	in	r0, 0x3f	; 63
    2636:	f8 94       	cli
    2638:	0f 92       	push	r0
    263a:	e9 81       	ldd	r30, Y+1	; 0x01
    263c:	fa 81       	ldd	r31, Y+2	; 0x02
    263e:	85 8d       	ldd	r24, Z+29	; 0x1d
    2640:	8f 3f       	cpi	r24, 0xFF	; 255
    2642:	19 f4       	brne	.+6      	; 0x264a <vQueueWaitForMessageRestricted+0x2a>
    2644:	e9 81       	ldd	r30, Y+1	; 0x01
    2646:	fa 81       	ldd	r31, Y+2	; 0x02
    2648:	15 8e       	std	Z+29, r1	; 0x1d
    264a:	e9 81       	ldd	r30, Y+1	; 0x01
    264c:	fa 81       	ldd	r31, Y+2	; 0x02
    264e:	86 8d       	ldd	r24, Z+30	; 0x1e
    2650:	8f 3f       	cpi	r24, 0xFF	; 255
    2652:	19 f4       	brne	.+6      	; 0x265a <vQueueWaitForMessageRestricted+0x3a>
    2654:	e9 81       	ldd	r30, Y+1	; 0x01
    2656:	fa 81       	ldd	r31, Y+2	; 0x02
    2658:	16 8e       	std	Z+30, r1	; 0x1e
    265a:	0f 90       	pop	r0
    265c:	0f be       	out	0x3f, r0	; 63
		if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0U )
    265e:	e9 81       	ldd	r30, Y+1	; 0x01
    2660:	fa 81       	ldd	r31, Y+2	; 0x02
    2662:	82 8d       	ldd	r24, Z+26	; 0x1a
    2664:	88 23       	and	r24, r24
    2666:	41 f4       	brne	.+16     	; 0x2678 <vQueueWaitForMessageRestricted+0x58>
		{
			/* There is nothing in the queue, block for the specified period. */
			vTaskPlaceOnEventListRestricted( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    2668:	89 81       	ldd	r24, Y+1	; 0x01
    266a:	9a 81       	ldd	r25, Y+2	; 0x02
    266c:	41 96       	adiw	r24, 0x11	; 17
    266e:	2b 81       	ldd	r18, Y+3	; 0x03
    2670:	3c 81       	ldd	r19, Y+4	; 0x04
    2672:	b9 01       	movw	r22, r18
    2674:	0e 94 7f 19 	call	0x32fe	; 0x32fe <vTaskPlaceOnEventListRestricted>
		}
		prvUnlockQueue( pxQueue );
    2678:	89 81       	ldd	r24, Y+1	; 0x01
    267a:	9a 81       	ldd	r25, Y+2	; 0x02
    267c:	0e 94 50 12 	call	0x24a0	; 0x24a0 <prvUnlockQueue>
	}
    2680:	0f 90       	pop	r0
    2682:	0f 90       	pop	r0
    2684:	0f 90       	pop	r0
    2686:	0f 90       	pop	r0
    2688:	cf 91       	pop	r28
    268a:	df 91       	pop	r29
    268c:	08 95       	ret

0000268e <xTaskGenericCreate>:
/*-----------------------------------------------------------
 * TASK CREATION API documented in task.h
 *----------------------------------------------------------*/

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
    268e:	af 92       	push	r10
    2690:	bf 92       	push	r11
    2692:	cf 92       	push	r12
    2694:	df 92       	push	r13
    2696:	ef 92       	push	r14
    2698:	ff 92       	push	r15
    269a:	0f 93       	push	r16
    269c:	1f 93       	push	r17
    269e:	df 93       	push	r29
    26a0:	cf 93       	push	r28
    26a2:	cd b7       	in	r28, 0x3d	; 61
    26a4:	de b7       	in	r29, 0x3e	; 62
    26a6:	64 97       	sbiw	r28, 0x14	; 20
    26a8:	0f b6       	in	r0, 0x3f	; 63
    26aa:	f8 94       	cli
    26ac:	de bf       	out	0x3e, r29	; 62
    26ae:	0f be       	out	0x3f, r0	; 63
    26b0:	cd bf       	out	0x3d, r28	; 61
    26b2:	9f 83       	std	Y+7, r25	; 0x07
    26b4:	8e 83       	std	Y+6, r24	; 0x06
    26b6:	79 87       	std	Y+9, r23	; 0x09
    26b8:	68 87       	std	Y+8, r22	; 0x08
    26ba:	5b 87       	std	Y+11, r21	; 0x0b
    26bc:	4a 87       	std	Y+10, r20	; 0x0a
    26be:	3d 87       	std	Y+13, r19	; 0x0d
    26c0:	2c 87       	std	Y+12, r18	; 0x0c
    26c2:	0e 87       	std	Y+14, r16	; 0x0e
    26c4:	f8 8a       	std	Y+16, r15	; 0x10
    26c6:	ef 86       	std	Y+15, r14	; 0x0f
    26c8:	da 8a       	std	Y+18, r13	; 0x12
    26ca:	c9 8a       	std	Y+17, r12	; 0x11
    26cc:	bc 8a       	std	Y+20, r11	; 0x14
    26ce:	ab 8a       	std	Y+19, r10	; 0x13
	configASSERT( pxTaskCode );
	configASSERT( ( uxPriority < configMAX_PRIORITIES ) );

	/* Allocate the memory required by the TCB and stack for the new task,
	checking that the allocation was successful. */
	pxNewTCB = prvAllocateTCBAndStack( usStackDepth, puxStackBuffer );
    26d0:	8a 85       	ldd	r24, Y+10	; 0x0a
    26d2:	9b 85       	ldd	r25, Y+11	; 0x0b
    26d4:	29 89       	ldd	r18, Y+17	; 0x11
    26d6:	3a 89       	ldd	r19, Y+18	; 0x12
    26d8:	b9 01       	movw	r22, r18
    26da:	0e 94 97 1b 	call	0x372e	; 0x372e <prvAllocateTCBAndStack>
    26de:	9c 83       	std	Y+4, r25	; 0x04
    26e0:	8b 83       	std	Y+3, r24	; 0x03

	if( pxNewTCB != NULL )
    26e2:	8b 81       	ldd	r24, Y+3	; 0x03
    26e4:	9c 81       	ldd	r25, Y+4	; 0x04
    26e6:	00 97       	sbiw	r24, 0x00	; 0
    26e8:	09 f4       	brne	.+2      	; 0x26ec <xTaskGenericCreate+0x5e>
    26ea:	99 c0       	rjmp	.+306    	; 0x281e <xTaskGenericCreate+0x190>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
    26ec:	eb 81       	ldd	r30, Y+3	; 0x03
    26ee:	fc 81       	ldd	r31, Y+4	; 0x04
    26f0:	27 89       	ldd	r18, Z+23	; 0x17
    26f2:	30 8d       	ldd	r19, Z+24	; 0x18
    26f4:	8a 85       	ldd	r24, Y+10	; 0x0a
    26f6:	9b 85       	ldd	r25, Y+11	; 0x0b
    26f8:	01 97       	sbiw	r24, 0x01	; 1
    26fa:	82 0f       	add	r24, r18
    26fc:	93 1f       	adc	r25, r19
    26fe:	9a 83       	std	Y+2, r25	; 0x02
    2700:	89 83       	std	Y+1, r24	; 0x01
			pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( usStackDepth - 1 );
		}
		#endif

		/* Setup the newly allocated TCB with the initial state of the task. */
		prvInitialiseTCBVariables( pxNewTCB, pcName, uxPriority, xRegions, usStackDepth );
    2702:	8b 81       	ldd	r24, Y+3	; 0x03
    2704:	9c 81       	ldd	r25, Y+4	; 0x04
    2706:	28 85       	ldd	r18, Y+8	; 0x08
    2708:	39 85       	ldd	r19, Y+9	; 0x09
    270a:	eb 89       	ldd	r30, Y+19	; 0x13
    270c:	fc 89       	ldd	r31, Y+20	; 0x14
    270e:	aa 85       	ldd	r26, Y+10	; 0x0a
    2710:	bb 85       	ldd	r27, Y+11	; 0x0b
    2712:	b9 01       	movw	r22, r18
    2714:	4e 85       	ldd	r20, Y+14	; 0x0e
    2716:	9f 01       	movw	r18, r30
    2718:	8d 01       	movw	r16, r26
    271a:	0e 94 b3 1a 	call	0x3566	; 0x3566 <prvInitialiseTCBVariables>
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
    271e:	89 81       	ldd	r24, Y+1	; 0x01
    2720:	9a 81       	ldd	r25, Y+2	; 0x02
    2722:	2e 81       	ldd	r18, Y+6	; 0x06
    2724:	3f 81       	ldd	r19, Y+7	; 0x07
    2726:	4c 85       	ldd	r20, Y+12	; 0x0c
    2728:	5d 85       	ldd	r21, Y+13	; 0x0d
    272a:	b9 01       	movw	r22, r18
    272c:	0e 94 96 0b 	call	0x172c	; 0x172c <pxPortInitialiseStack>
    2730:	eb 81       	ldd	r30, Y+3	; 0x03
    2732:	fc 81       	ldd	r31, Y+4	; 0x04
    2734:	91 83       	std	Z+1, r25	; 0x01
    2736:	80 83       	st	Z, r24
		#endif

		/* Check the alignment of the initialised stack. */
		configASSERT( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
    2738:	8f 85       	ldd	r24, Y+15	; 0x0f
    273a:	98 89       	ldd	r25, Y+16	; 0x10
    273c:	00 97       	sbiw	r24, 0x00	; 0
    273e:	31 f0       	breq	.+12     	; 0x274c <xTaskGenericCreate+0xbe>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
    2740:	ef 85       	ldd	r30, Y+15	; 0x0f
    2742:	f8 89       	ldd	r31, Y+16	; 0x10
    2744:	8b 81       	ldd	r24, Y+3	; 0x03
    2746:	9c 81       	ldd	r25, Y+4	; 0x04
    2748:	91 83       	std	Z+1, r25	; 0x01
    274a:	80 83       	st	Z, r24
		}
		
		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
    274c:	0f b6       	in	r0, 0x3f	; 63
    274e:	f8 94       	cli
    2750:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
    2752:	80 91 aa 06 	lds	r24, 0x06AA
    2756:	8f 5f       	subi	r24, 0xFF	; 255
    2758:	80 93 aa 06 	sts	0x06AA, r24
			if( pxCurrentTCB == NULL )
    275c:	80 91 a8 06 	lds	r24, 0x06A8
    2760:	90 91 a9 06 	lds	r25, 0x06A9
    2764:	00 97       	sbiw	r24, 0x00	; 0
    2766:	69 f4       	brne	.+26     	; 0x2782 <xTaskGenericCreate+0xf4>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
    2768:	8b 81       	ldd	r24, Y+3	; 0x03
    276a:	9c 81       	ldd	r25, Y+4	; 0x04
    276c:	90 93 a9 06 	sts	0x06A9, r25
    2770:	80 93 a8 06 	sts	0x06A8, r24

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
    2774:	80 91 aa 06 	lds	r24, 0x06AA
    2778:	81 30       	cpi	r24, 0x01	; 1
    277a:	a9 f4       	brne	.+42     	; 0x27a6 <xTaskGenericCreate+0x118>
				{
					/* This is the first task to be created so do the preliminary
					initialisation required.  We will not recover if this call
					fails, but we will report the failure. */
					prvInitialiseTaskLists();
    277c:	0e 94 0a 1b 	call	0x3614	; 0x3614 <prvInitialiseTaskLists>
    2780:	12 c0       	rjmp	.+36     	; 0x27a6 <xTaskGenericCreate+0x118>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
    2782:	80 91 af 06 	lds	r24, 0x06AF
    2786:	88 23       	and	r24, r24
    2788:	71 f4       	brne	.+28     	; 0x27a6 <xTaskGenericCreate+0x118>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
    278a:	e0 91 a8 06 	lds	r30, 0x06A8
    278e:	f0 91 a9 06 	lds	r31, 0x06A9
    2792:	96 89       	ldd	r25, Z+22	; 0x16
    2794:	8e 85       	ldd	r24, Y+14	; 0x0e
    2796:	89 17       	cp	r24, r25
    2798:	30 f0       	brcs	.+12     	; 0x27a6 <xTaskGenericCreate+0x118>
					{
						pxCurrentTCB = pxNewTCB;
    279a:	8b 81       	ldd	r24, Y+3	; 0x03
    279c:	9c 81       	ldd	r25, Y+4	; 0x04
    279e:	90 93 a9 06 	sts	0x06A9, r25
    27a2:	80 93 a8 06 	sts	0x06A8, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
    27a6:	eb 81       	ldd	r30, Y+3	; 0x03
    27a8:	fc 81       	ldd	r31, Y+4	; 0x04
    27aa:	96 89       	ldd	r25, Z+22	; 0x16
    27ac:	80 91 ad 06 	lds	r24, 0x06AD
    27b0:	89 17       	cp	r24, r25
    27b2:	28 f4       	brcc	.+10     	; 0x27be <xTaskGenericCreate+0x130>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
    27b4:	eb 81       	ldd	r30, Y+3	; 0x03
    27b6:	fc 81       	ldd	r31, Y+4	; 0x04
    27b8:	86 89       	ldd	r24, Z+22	; 0x16
    27ba:	80 93 ad 06 	sts	0x06AD, r24
			{
				/* Add a counter into the TCB for tracing only. */
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif
			uxTaskNumber++;
    27be:	80 91 b4 06 	lds	r24, 0x06B4
    27c2:	8f 5f       	subi	r24, 0xFF	; 255
    27c4:	80 93 b4 06 	sts	0x06B4, r24

			prvAddTaskToReadyQueue( pxNewTCB );
    27c8:	eb 81       	ldd	r30, Y+3	; 0x03
    27ca:	fc 81       	ldd	r31, Y+4	; 0x04
    27cc:	96 89       	ldd	r25, Z+22	; 0x16
    27ce:	80 91 ae 06 	lds	r24, 0x06AE
    27d2:	89 17       	cp	r24, r25
    27d4:	28 f4       	brcc	.+10     	; 0x27e0 <xTaskGenericCreate+0x152>
    27d6:	eb 81       	ldd	r30, Y+3	; 0x03
    27d8:	fc 81       	ldd	r31, Y+4	; 0x04
    27da:	86 89       	ldd	r24, Z+22	; 0x16
    27dc:	80 93 ae 06 	sts	0x06AE, r24
    27e0:	eb 81       	ldd	r30, Y+3	; 0x03
    27e2:	fc 81       	ldd	r31, Y+4	; 0x04
    27e4:	86 89       	ldd	r24, Z+22	; 0x16
    27e6:	28 2f       	mov	r18, r24
    27e8:	30 e0       	ldi	r19, 0x00	; 0
    27ea:	c9 01       	movw	r24, r18
    27ec:	88 0f       	add	r24, r24
    27ee:	99 1f       	adc	r25, r25
    27f0:	88 0f       	add	r24, r24
    27f2:	99 1f       	adc	r25, r25
    27f4:	88 0f       	add	r24, r24
    27f6:	99 1f       	adc	r25, r25
    27f8:	82 0f       	add	r24, r18
    27fa:	93 1f       	adc	r25, r19
    27fc:	ac 01       	movw	r20, r24
    27fe:	4b 54       	subi	r20, 0x4B	; 75
    2800:	59 4f       	sbci	r21, 0xF9	; 249
    2802:	8b 81       	ldd	r24, Y+3	; 0x03
    2804:	9c 81       	ldd	r25, Y+4	; 0x04
    2806:	9c 01       	movw	r18, r24
    2808:	2e 5f       	subi	r18, 0xFE	; 254
    280a:	3f 4f       	sbci	r19, 0xFF	; 255
    280c:	ca 01       	movw	r24, r20
    280e:	b9 01       	movw	r22, r18
    2810:	0e 94 95 0a 	call	0x152a	; 0x152a <vListInsertEnd>

			xReturn = pdPASS;
    2814:	81 e0       	ldi	r24, 0x01	; 1
    2816:	8d 83       	std	Y+5, r24	; 0x05
			traceTASK_CREATE( pxNewTCB );
		}
		taskEXIT_CRITICAL();
    2818:	0f 90       	pop	r0
    281a:	0f be       	out	0x3f, r0	; 63
    281c:	02 c0       	rjmp	.+4      	; 0x2822 <xTaskGenericCreate+0x194>
	}
	else
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
    281e:	8f ef       	ldi	r24, 0xFF	; 255
    2820:	8d 83       	std	Y+5, r24	; 0x05
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
    2822:	8d 81       	ldd	r24, Y+5	; 0x05
    2824:	81 30       	cpi	r24, 0x01	; 1
    2826:	71 f4       	brne	.+28     	; 0x2844 <xTaskGenericCreate+0x1b6>
	{
		if( xSchedulerRunning != pdFALSE )
    2828:	80 91 af 06 	lds	r24, 0x06AF
    282c:	88 23       	and	r24, r24
    282e:	51 f0       	breq	.+20     	; 0x2844 <xTaskGenericCreate+0x1b6>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
    2830:	e0 91 a8 06 	lds	r30, 0x06A8
    2834:	f0 91 a9 06 	lds	r31, 0x06A9
    2838:	96 89       	ldd	r25, Z+22	; 0x16
    283a:	8e 85       	ldd	r24, Y+14	; 0x0e
    283c:	98 17       	cp	r25, r24
    283e:	10 f4       	brcc	.+4      	; 0x2844 <xTaskGenericCreate+0x1b6>
			{
				portYIELD_WITHIN_API();
    2840:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <vPortYield>
			}
		}
	}

	return xReturn;
    2844:	8d 81       	ldd	r24, Y+5	; 0x05
}
    2846:	64 96       	adiw	r28, 0x14	; 20
    2848:	0f b6       	in	r0, 0x3f	; 63
    284a:	f8 94       	cli
    284c:	de bf       	out	0x3e, r29	; 62
    284e:	0f be       	out	0x3f, r0	; 63
    2850:	cd bf       	out	0x3d, r28	; 61
    2852:	cf 91       	pop	r28
    2854:	df 91       	pop	r29
    2856:	1f 91       	pop	r17
    2858:	0f 91       	pop	r16
    285a:	ff 90       	pop	r15
    285c:	ef 90       	pop	r14
    285e:	df 90       	pop	r13
    2860:	cf 90       	pop	r12
    2862:	bf 90       	pop	r11
    2864:	af 90       	pop	r10
    2866:	08 95       	ret

00002868 <vTaskDelayUntil>:
 *----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
    2868:	df 93       	push	r29
    286a:	cf 93       	push	r28
    286c:	cd b7       	in	r28, 0x3d	; 61
    286e:	de b7       	in	r29, 0x3e	; 62
    2870:	28 97       	sbiw	r28, 0x08	; 8
    2872:	0f b6       	in	r0, 0x3f	; 63
    2874:	f8 94       	cli
    2876:	de bf       	out	0x3e, r29	; 62
    2878:	0f be       	out	0x3f, r0	; 63
    287a:	cd bf       	out	0x3d, r28	; 61
    287c:	9e 83       	std	Y+6, r25	; 0x06
    287e:	8d 83       	std	Y+5, r24	; 0x05
    2880:	78 87       	std	Y+8, r23	; 0x08
    2882:	6f 83       	std	Y+7, r22	; 0x07
	portTickType xTimeToWake;
	portBASE_TYPE xAlreadyYielded, xShouldDelay = pdFALSE;
    2884:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( pxPreviousWakeTime );
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
    2886:	0e 94 32 17 	call	0x2e64	; 0x2e64 <vTaskSuspendAll>
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
    288a:	ed 81       	ldd	r30, Y+5	; 0x05
    288c:	fe 81       	ldd	r31, Y+6	; 0x06
    288e:	20 81       	ld	r18, Z
    2890:	31 81       	ldd	r19, Z+1	; 0x01
    2892:	8f 81       	ldd	r24, Y+7	; 0x07
    2894:	98 85       	ldd	r25, Y+8	; 0x08
    2896:	82 0f       	add	r24, r18
    2898:	93 1f       	adc	r25, r19
    289a:	9c 83       	std	Y+4, r25	; 0x04
    289c:	8b 83       	std	Y+3, r24	; 0x03

			if( xTickCount < *pxPreviousWakeTime )
    289e:	ed 81       	ldd	r30, Y+5	; 0x05
    28a0:	fe 81       	ldd	r31, Y+6	; 0x06
    28a2:	20 81       	ld	r18, Z
    28a4:	31 81       	ldd	r19, Z+1	; 0x01
    28a6:	80 91 ab 06 	lds	r24, 0x06AB
    28aa:	90 91 ac 06 	lds	r25, 0x06AC
    28ae:	82 17       	cp	r24, r18
    28b0:	93 07       	cpc	r25, r19
    28b2:	a8 f4       	brcc	.+42     	; 0x28de <vTaskDelayUntil+0x76>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
    28b4:	ed 81       	ldd	r30, Y+5	; 0x05
    28b6:	fe 81       	ldd	r31, Y+6	; 0x06
    28b8:	20 81       	ld	r18, Z
    28ba:	31 81       	ldd	r19, Z+1	; 0x01
    28bc:	8b 81       	ldd	r24, Y+3	; 0x03
    28be:	9c 81       	ldd	r25, Y+4	; 0x04
    28c0:	82 17       	cp	r24, r18
    28c2:	93 07       	cpc	r25, r19
    28c4:	00 f5       	brcc	.+64     	; 0x2906 <vTaskDelayUntil+0x9e>
    28c6:	20 91 ab 06 	lds	r18, 0x06AB
    28ca:	30 91 ac 06 	lds	r19, 0x06AC
    28ce:	8b 81       	ldd	r24, Y+3	; 0x03
    28d0:	9c 81       	ldd	r25, Y+4	; 0x04
    28d2:	28 17       	cp	r18, r24
    28d4:	39 07       	cpc	r19, r25
    28d6:	b8 f4       	brcc	.+46     	; 0x2906 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    28d8:	81 e0       	ldi	r24, 0x01	; 1
    28da:	89 83       	std	Y+1, r24	; 0x01
    28dc:	14 c0       	rjmp	.+40     	; 0x2906 <vTaskDelayUntil+0x9e>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
    28de:	ed 81       	ldd	r30, Y+5	; 0x05
    28e0:	fe 81       	ldd	r31, Y+6	; 0x06
    28e2:	20 81       	ld	r18, Z
    28e4:	31 81       	ldd	r19, Z+1	; 0x01
    28e6:	8b 81       	ldd	r24, Y+3	; 0x03
    28e8:	9c 81       	ldd	r25, Y+4	; 0x04
    28ea:	82 17       	cp	r24, r18
    28ec:	93 07       	cpc	r25, r19
    28ee:	48 f0       	brcs	.+18     	; 0x2902 <vTaskDelayUntil+0x9a>
    28f0:	20 91 ab 06 	lds	r18, 0x06AB
    28f4:	30 91 ac 06 	lds	r19, 0x06AC
    28f8:	8b 81       	ldd	r24, Y+3	; 0x03
    28fa:	9c 81       	ldd	r25, Y+4	; 0x04
    28fc:	28 17       	cp	r18, r24
    28fe:	39 07       	cpc	r19, r25
    2900:	10 f4       	brcc	.+4      	; 0x2906 <vTaskDelayUntil+0x9e>
				{
					xShouldDelay = pdTRUE;
    2902:	81 e0       	ldi	r24, 0x01	; 1
    2904:	89 83       	std	Y+1, r24	; 0x01
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
    2906:	ed 81       	ldd	r30, Y+5	; 0x05
    2908:	fe 81       	ldd	r31, Y+6	; 0x06
    290a:	8b 81       	ldd	r24, Y+3	; 0x03
    290c:	9c 81       	ldd	r25, Y+4	; 0x04
    290e:	91 83       	std	Z+1, r25	; 0x01
    2910:	80 83       	st	Z, r24

			if( xShouldDelay != pdFALSE )
    2912:	89 81       	ldd	r24, Y+1	; 0x01
    2914:	88 23       	and	r24, r24
    2916:	59 f0       	breq	.+22     	; 0x292e <vTaskDelayUntil+0xc6>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2918:	80 91 a8 06 	lds	r24, 0x06A8
    291c:	90 91 a9 06 	lds	r25, 0x06A9
    2920:	02 96       	adiw	r24, 0x02	; 2
    2922:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2926:	8b 81       	ldd	r24, Y+3	; 0x03
    2928:	9c 81       	ldd	r25, Y+4	; 0x04
    292a:	0e 94 4e 1b 	call	0x369c	; 0x369c <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
    292e:	0e 94 3e 17 	call	0x2e7c	; 0x2e7c <xTaskResumeAll>
    2932:	8a 83       	std	Y+2, r24	; 0x02

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    2934:	8a 81       	ldd	r24, Y+2	; 0x02
    2936:	88 23       	and	r24, r24
    2938:	11 f4       	brne	.+4      	; 0x293e <vTaskDelayUntil+0xd6>
		{
			portYIELD_WITHIN_API();
    293a:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <vPortYield>
		}
	}
    293e:	28 96       	adiw	r28, 0x08	; 8
    2940:	0f b6       	in	r0, 0x3f	; 63
    2942:	f8 94       	cli
    2944:	de bf       	out	0x3e, r29	; 62
    2946:	0f be       	out	0x3f, r0	; 63
    2948:	cd bf       	out	0x3d, r28	; 61
    294a:	cf 91       	pop	r28
    294c:	df 91       	pop	r29
    294e:	08 95       	ret

00002950 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
    2950:	df 93       	push	r29
    2952:	cf 93       	push	r28
    2954:	00 d0       	rcall	.+0      	; 0x2956 <vTaskDelay+0x6>
    2956:	00 d0       	rcall	.+0      	; 0x2958 <vTaskDelay+0x8>
    2958:	0f 92       	push	r0
    295a:	cd b7       	in	r28, 0x3d	; 61
    295c:	de b7       	in	r29, 0x3e	; 62
    295e:	9d 83       	std	Y+5, r25	; 0x05
    2960:	8c 83       	std	Y+4, r24	; 0x04
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2962:	19 82       	std	Y+1, r1	; 0x01

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
    2964:	8c 81       	ldd	r24, Y+4	; 0x04
    2966:	9d 81       	ldd	r25, Y+5	; 0x05
    2968:	00 97       	sbiw	r24, 0x00	; 0
    296a:	d1 f0       	breq	.+52     	; 0x29a0 <vTaskDelay+0x50>
		{
			vTaskSuspendAll();
    296c:	0e 94 32 17 	call	0x2e64	; 0x2e64 <vTaskSuspendAll>
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
    2970:	20 91 ab 06 	lds	r18, 0x06AB
    2974:	30 91 ac 06 	lds	r19, 0x06AC
    2978:	8c 81       	ldd	r24, Y+4	; 0x04
    297a:	9d 81       	ldd	r25, Y+5	; 0x05
    297c:	82 0f       	add	r24, r18
    297e:	93 1f       	adc	r25, r19
    2980:	9b 83       	std	Y+3, r25	; 0x03
    2982:	8a 83       	std	Y+2, r24	; 0x02

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    2984:	80 91 a8 06 	lds	r24, 0x06A8
    2988:	90 91 a9 06 	lds	r25, 0x06A9
    298c:	02 96       	adiw	r24, 0x02	; 2
    298e:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>
				prvAddCurrentTaskToDelayedList( xTimeToWake );
    2992:	8a 81       	ldd	r24, Y+2	; 0x02
    2994:	9b 81       	ldd	r25, Y+3	; 0x03
    2996:	0e 94 4e 1b 	call	0x369c	; 0x369c <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
    299a:	0e 94 3e 17 	call	0x2e7c	; 0x2e7c <xTaskResumeAll>
    299e:	89 83       	std	Y+1, r24	; 0x01
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
    29a0:	89 81       	ldd	r24, Y+1	; 0x01
    29a2:	88 23       	and	r24, r24
    29a4:	11 f4       	brne	.+4      	; 0x29aa <vTaskDelay+0x5a>
		{
			portYIELD_WITHIN_API();
    29a6:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <vPortYield>
		}
	}
    29aa:	0f 90       	pop	r0
    29ac:	0f 90       	pop	r0
    29ae:	0f 90       	pop	r0
    29b0:	0f 90       	pop	r0
    29b2:	0f 90       	pop	r0
    29b4:	cf 91       	pop	r28
    29b6:	df 91       	pop	r29
    29b8:	08 95       	ret

000029ba <vTaskPrioritySet>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskPrioritySet == 1 )

	void vTaskPrioritySet( xTaskHandle pxTask, unsigned portBASE_TYPE uxNewPriority )
	{
    29ba:	df 93       	push	r29
    29bc:	cf 93       	push	r28
    29be:	cd b7       	in	r28, 0x3d	; 61
    29c0:	de b7       	in	r29, 0x3e	; 62
    29c2:	29 97       	sbiw	r28, 0x09	; 9
    29c4:	0f b6       	in	r0, 0x3f	; 63
    29c6:	f8 94       	cli
    29c8:	de bf       	out	0x3e, r29	; 62
    29ca:	0f be       	out	0x3f, r0	; 63
    29cc:	cd bf       	out	0x3d, r28	; 61
    29ce:	9e 83       	std	Y+6, r25	; 0x06
    29d0:	8d 83       	std	Y+5, r24	; 0x05
    29d2:	6f 83       	std	Y+7, r22	; 0x07
	tskTCB *pxTCB;
	unsigned portBASE_TYPE uxCurrentPriority;
	portBASE_TYPE xYieldRequired = pdFALSE;
    29d4:	19 82       	std	Y+1, r1	; 0x01

		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );

		/* Ensure the new priority is valid. */
		if( uxNewPriority >= configMAX_PRIORITIES )
    29d6:	8f 81       	ldd	r24, Y+7	; 0x07
    29d8:	85 30       	cpi	r24, 0x05	; 5
    29da:	10 f0       	brcs	.+4      	; 0x29e0 <vTaskPrioritySet+0x26>
		{
			uxNewPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    29dc:	84 e0       	ldi	r24, 0x04	; 4
    29de:	8f 83       	std	Y+7, r24	; 0x07
		}

		taskENTER_CRITICAL();
    29e0:	0f b6       	in	r0, 0x3f	; 63
    29e2:	f8 94       	cli
    29e4:	0f 92       	push	r0
		{
			if( pxTask == pxCurrentTCB )
    29e6:	20 91 a8 06 	lds	r18, 0x06A8
    29ea:	30 91 a9 06 	lds	r19, 0x06A9
    29ee:	8d 81       	ldd	r24, Y+5	; 0x05
    29f0:	9e 81       	ldd	r25, Y+6	; 0x06
    29f2:	82 17       	cp	r24, r18
    29f4:	93 07       	cpc	r25, r19
    29f6:	11 f4       	brne	.+4      	; 0x29fc <vTaskPrioritySet+0x42>
			{
				pxTask = NULL;
    29f8:	1e 82       	std	Y+6, r1	; 0x06
    29fa:	1d 82       	std	Y+5, r1	; 0x05
			}

			/* If null is passed in here then we are changing the
			priority of the calling function. */
			pxTCB = prvGetTCBFromHandle( pxTask );
    29fc:	8d 81       	ldd	r24, Y+5	; 0x05
    29fe:	9e 81       	ldd	r25, Y+6	; 0x06
    2a00:	00 97       	sbiw	r24, 0x00	; 0
    2a02:	39 f4       	brne	.+14     	; 0x2a12 <vTaskPrioritySet+0x58>
    2a04:	80 91 a8 06 	lds	r24, 0x06A8
    2a08:	90 91 a9 06 	lds	r25, 0x06A9
    2a0c:	99 87       	std	Y+9, r25	; 0x09
    2a0e:	88 87       	std	Y+8, r24	; 0x08
    2a10:	04 c0       	rjmp	.+8      	; 0x2a1a <vTaskPrioritySet+0x60>
    2a12:	8d 81       	ldd	r24, Y+5	; 0x05
    2a14:	9e 81       	ldd	r25, Y+6	; 0x06
    2a16:	99 87       	std	Y+9, r25	; 0x09
    2a18:	88 87       	std	Y+8, r24	; 0x08
    2a1a:	88 85       	ldd	r24, Y+8	; 0x08
    2a1c:	99 85       	ldd	r25, Y+9	; 0x09
    2a1e:	9c 83       	std	Y+4, r25	; 0x04
    2a20:	8b 83       	std	Y+3, r24	; 0x03
			{
				uxCurrentPriority = pxTCB->uxBasePriority;
			}
			#else
			{
				uxCurrentPriority = pxTCB->uxPriority;
    2a22:	eb 81       	ldd	r30, Y+3	; 0x03
    2a24:	fc 81       	ldd	r31, Y+4	; 0x04
    2a26:	86 89       	ldd	r24, Z+22	; 0x16
    2a28:	8a 83       	std	Y+2, r24	; 0x02
			}
			#endif

			if( uxCurrentPriority != uxNewPriority )
    2a2a:	9a 81       	ldd	r25, Y+2	; 0x02
    2a2c:	8f 81       	ldd	r24, Y+7	; 0x07
    2a2e:	98 17       	cp	r25, r24
    2a30:	09 f4       	brne	.+2      	; 0x2a34 <vTaskPrioritySet+0x7a>
    2a32:	65 c0       	rjmp	.+202    	; 0x2afe <vTaskPrioritySet+0x144>
			{
				/* The priority change may have readied a task of higher
				priority than the calling task. */
				if( uxNewPriority > uxCurrentPriority )
    2a34:	9f 81       	ldd	r25, Y+7	; 0x07
    2a36:	8a 81       	ldd	r24, Y+2	; 0x02
    2a38:	89 17       	cp	r24, r25
    2a3a:	38 f4       	brcc	.+14     	; 0x2a4a <vTaskPrioritySet+0x90>
				{
					if( pxTask != NULL )
    2a3c:	8d 81       	ldd	r24, Y+5	; 0x05
    2a3e:	9e 81       	ldd	r25, Y+6	; 0x06
    2a40:	00 97       	sbiw	r24, 0x00	; 0
    2a42:	49 f0       	breq	.+18     	; 0x2a56 <vTaskPrioritySet+0x9c>
					{
						/* The priority of another task is being raised.  If we
						were raising the priority of the currently running task
						there would be no need to switch as it must have already
						been the highest priority task. */
						xYieldRequired = pdTRUE;
    2a44:	81 e0       	ldi	r24, 0x01	; 1
    2a46:	89 83       	std	Y+1, r24	; 0x01
    2a48:	06 c0       	rjmp	.+12     	; 0x2a56 <vTaskPrioritySet+0x9c>
					}
				}
				else if( pxTask == NULL )
    2a4a:	8d 81       	ldd	r24, Y+5	; 0x05
    2a4c:	9e 81       	ldd	r25, Y+6	; 0x06
    2a4e:	00 97       	sbiw	r24, 0x00	; 0
    2a50:	11 f4       	brne	.+4      	; 0x2a56 <vTaskPrioritySet+0x9c>
				{
					/* Setting our own priority down means there may now be another
					task of higher priority that is ready to execute. */
					xYieldRequired = pdTRUE;
    2a52:	81 e0       	ldi	r24, 0x01	; 1
    2a54:	89 83       	std	Y+1, r24	; 0x01
					/* The base priority gets set whatever. */
					pxTCB->uxBasePriority = uxNewPriority;
				}
				#else
				{
					pxTCB->uxPriority = uxNewPriority;
    2a56:	eb 81       	ldd	r30, Y+3	; 0x03
    2a58:	fc 81       	ldd	r31, Y+4	; 0x04
    2a5a:	8f 81       	ldd	r24, Y+7	; 0x07
    2a5c:	86 8b       	std	Z+22, r24	; 0x16
				}
				#endif

				listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( configMAX_PRIORITIES - ( portTickType ) uxNewPriority ) );
    2a5e:	8f 81       	ldd	r24, Y+7	; 0x07
    2a60:	28 2f       	mov	r18, r24
    2a62:	30 e0       	ldi	r19, 0x00	; 0
    2a64:	85 e0       	ldi	r24, 0x05	; 5
    2a66:	90 e0       	ldi	r25, 0x00	; 0
    2a68:	82 1b       	sub	r24, r18
    2a6a:	93 0b       	sbc	r25, r19
    2a6c:	eb 81       	ldd	r30, Y+3	; 0x03
    2a6e:	fc 81       	ldd	r31, Y+4	; 0x04
    2a70:	95 87       	std	Z+13, r25	; 0x0d
    2a72:	84 87       	std	Z+12, r24	; 0x0c

				/* If the task is in the blocked or suspended list we need do
				nothing more than change it's priority variable. However, if
				the task is in a ready list it needs to be removed and placed
				in the queue appropriate to its new priority. */
				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxCurrentPriority ] ), &( pxTCB->xGenericListItem ) ) )
    2a74:	eb 81       	ldd	r30, Y+3	; 0x03
    2a76:	fc 81       	ldd	r31, Y+4	; 0x04
    2a78:	42 85       	ldd	r20, Z+10	; 0x0a
    2a7a:	53 85       	ldd	r21, Z+11	; 0x0b
    2a7c:	8a 81       	ldd	r24, Y+2	; 0x02
    2a7e:	28 2f       	mov	r18, r24
    2a80:	30 e0       	ldi	r19, 0x00	; 0
    2a82:	c9 01       	movw	r24, r18
    2a84:	88 0f       	add	r24, r24
    2a86:	99 1f       	adc	r25, r25
    2a88:	88 0f       	add	r24, r24
    2a8a:	99 1f       	adc	r25, r25
    2a8c:	88 0f       	add	r24, r24
    2a8e:	99 1f       	adc	r25, r25
    2a90:	82 0f       	add	r24, r18
    2a92:	93 1f       	adc	r25, r19
    2a94:	8b 54       	subi	r24, 0x4B	; 75
    2a96:	99 4f       	sbci	r25, 0xF9	; 249
    2a98:	48 17       	cp	r20, r24
    2a9a:	59 07       	cpc	r21, r25
    2a9c:	59 f5       	brne	.+86     	; 0x2af4 <vTaskPrioritySet+0x13a>
				{
					/* The task is currently in its ready list - remove before adding
					it to it's new ready list.  As we are in a critical section we
					can do this even if the scheduler is suspended. */
					vListRemove( &( pxTCB->xGenericListItem ) );
    2a9e:	8b 81       	ldd	r24, Y+3	; 0x03
    2aa0:	9c 81       	ldd	r25, Y+4	; 0x04
    2aa2:	02 96       	adiw	r24, 0x02	; 2
    2aa4:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2aa8:	eb 81       	ldd	r30, Y+3	; 0x03
    2aaa:	fc 81       	ldd	r31, Y+4	; 0x04
    2aac:	96 89       	ldd	r25, Z+22	; 0x16
    2aae:	80 91 ae 06 	lds	r24, 0x06AE
    2ab2:	89 17       	cp	r24, r25
    2ab4:	28 f4       	brcc	.+10     	; 0x2ac0 <vTaskPrioritySet+0x106>
    2ab6:	eb 81       	ldd	r30, Y+3	; 0x03
    2ab8:	fc 81       	ldd	r31, Y+4	; 0x04
    2aba:	86 89       	ldd	r24, Z+22	; 0x16
    2abc:	80 93 ae 06 	sts	0x06AE, r24
    2ac0:	eb 81       	ldd	r30, Y+3	; 0x03
    2ac2:	fc 81       	ldd	r31, Y+4	; 0x04
    2ac4:	86 89       	ldd	r24, Z+22	; 0x16
    2ac6:	28 2f       	mov	r18, r24
    2ac8:	30 e0       	ldi	r19, 0x00	; 0
    2aca:	c9 01       	movw	r24, r18
    2acc:	88 0f       	add	r24, r24
    2ace:	99 1f       	adc	r25, r25
    2ad0:	88 0f       	add	r24, r24
    2ad2:	99 1f       	adc	r25, r25
    2ad4:	88 0f       	add	r24, r24
    2ad6:	99 1f       	adc	r25, r25
    2ad8:	82 0f       	add	r24, r18
    2ada:	93 1f       	adc	r25, r19
    2adc:	ac 01       	movw	r20, r24
    2ade:	4b 54       	subi	r20, 0x4B	; 75
    2ae0:	59 4f       	sbci	r21, 0xF9	; 249
    2ae2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ae4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ae6:	9c 01       	movw	r18, r24
    2ae8:	2e 5f       	subi	r18, 0xFE	; 254
    2aea:	3f 4f       	sbci	r19, 0xFF	; 255
    2aec:	ca 01       	movw	r24, r20
    2aee:	b9 01       	movw	r22, r18
    2af0:	0e 94 95 0a 	call	0x152a	; 0x152a <vListInsertEnd>
				}

				if( xYieldRequired == pdTRUE )
    2af4:	89 81       	ldd	r24, Y+1	; 0x01
    2af6:	81 30       	cpi	r24, 0x01	; 1
    2af8:	11 f4       	brne	.+4      	; 0x2afe <vTaskPrioritySet+0x144>
				{
					portYIELD_WITHIN_API();
    2afa:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <vPortYield>
				}
			}
		}
		taskEXIT_CRITICAL();
    2afe:	0f 90       	pop	r0
    2b00:	0f be       	out	0x3f, r0	; 63
	}
    2b02:	29 96       	adiw	r28, 0x09	; 9
    2b04:	0f b6       	in	r0, 0x3f	; 63
    2b06:	f8 94       	cli
    2b08:	de bf       	out	0x3e, r29	; 62
    2b0a:	0f be       	out	0x3f, r0	; 63
    2b0c:	cd bf       	out	0x3d, r28	; 61
    2b0e:	cf 91       	pop	r28
    2b10:	df 91       	pop	r29
    2b12:	08 95       	ret

00002b14 <vTaskSuspend>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskSuspend( xTaskHandle pxTaskToSuspend )
	{
    2b14:	df 93       	push	r29
    2b16:	cf 93       	push	r28
    2b18:	00 d0       	rcall	.+0      	; 0x2b1a <vTaskSuspend+0x6>
    2b1a:	00 d0       	rcall	.+0      	; 0x2b1c <vTaskSuspend+0x8>
    2b1c:	00 d0       	rcall	.+0      	; 0x2b1e <vTaskSuspend+0xa>
    2b1e:	cd b7       	in	r28, 0x3d	; 61
    2b20:	de b7       	in	r29, 0x3e	; 62
    2b22:	9c 83       	std	Y+4, r25	; 0x04
    2b24:	8b 83       	std	Y+3, r24	; 0x03
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
    2b26:	0f b6       	in	r0, 0x3f	; 63
    2b28:	f8 94       	cli
    2b2a:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			suspended. */
			if( pxTaskToSuspend == pxCurrentTCB )
    2b2c:	20 91 a8 06 	lds	r18, 0x06A8
    2b30:	30 91 a9 06 	lds	r19, 0x06A9
    2b34:	8b 81       	ldd	r24, Y+3	; 0x03
    2b36:	9c 81       	ldd	r25, Y+4	; 0x04
    2b38:	82 17       	cp	r24, r18
    2b3a:	93 07       	cpc	r25, r19
    2b3c:	11 f4       	brne	.+4      	; 0x2b42 <vTaskSuspend+0x2e>
			{
				pxTaskToSuspend = NULL;
    2b3e:	1c 82       	std	Y+4, r1	; 0x04
    2b40:	1b 82       	std	Y+3, r1	; 0x03
			}

			/* If null is passed in here then we are suspending ourselves. */
			pxTCB = prvGetTCBFromHandle( pxTaskToSuspend );
    2b42:	8b 81       	ldd	r24, Y+3	; 0x03
    2b44:	9c 81       	ldd	r25, Y+4	; 0x04
    2b46:	00 97       	sbiw	r24, 0x00	; 0
    2b48:	39 f4       	brne	.+14     	; 0x2b58 <vTaskSuspend+0x44>
    2b4a:	80 91 a8 06 	lds	r24, 0x06A8
    2b4e:	90 91 a9 06 	lds	r25, 0x06A9
    2b52:	9e 83       	std	Y+6, r25	; 0x06
    2b54:	8d 83       	std	Y+5, r24	; 0x05
    2b56:	04 c0       	rjmp	.+8      	; 0x2b60 <vTaskSuspend+0x4c>
    2b58:	8b 81       	ldd	r24, Y+3	; 0x03
    2b5a:	9c 81       	ldd	r25, Y+4	; 0x04
    2b5c:	9e 83       	std	Y+6, r25	; 0x06
    2b5e:	8d 83       	std	Y+5, r24	; 0x05
    2b60:	8d 81       	ldd	r24, Y+5	; 0x05
    2b62:	9e 81       	ldd	r25, Y+6	; 0x06
    2b64:	9a 83       	std	Y+2, r25	; 0x02
    2b66:	89 83       	std	Y+1, r24	; 0x01

			traceTASK_SUSPEND( pxTCB );

			/* Remove task from the ready/delayed list and place in the	suspended list. */
			vListRemove( &( pxTCB->xGenericListItem ) );
    2b68:	89 81       	ldd	r24, Y+1	; 0x01
    2b6a:	9a 81       	ldd	r25, Y+2	; 0x02
    2b6c:	02 96       	adiw	r24, 0x02	; 2
    2b6e:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
    2b72:	e9 81       	ldd	r30, Y+1	; 0x01
    2b74:	fa 81       	ldd	r31, Y+2	; 0x02
    2b76:	84 89       	ldd	r24, Z+20	; 0x14
    2b78:	95 89       	ldd	r25, Z+21	; 0x15
    2b7a:	00 97       	sbiw	r24, 0x00	; 0
    2b7c:	29 f0       	breq	.+10     	; 0x2b88 <vTaskSuspend+0x74>
			{
				vListRemove( &( pxTCB->xEventListItem ) );
    2b7e:	89 81       	ldd	r24, Y+1	; 0x01
    2b80:	9a 81       	ldd	r25, Y+2	; 0x02
    2b82:	0c 96       	adiw	r24, 0x0c	; 12
    2b84:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>
			}

			vListInsertEnd( ( xList * ) &xSuspendedTaskList, &( pxTCB->xGenericListItem ) );
    2b88:	89 81       	ldd	r24, Y+1	; 0x01
    2b8a:	9a 81       	ldd	r25, Y+2	; 0x02
    2b8c:	9c 01       	movw	r18, r24
    2b8e:	2e 5f       	subi	r18, 0xFE	; 254
    2b90:	3f 4f       	sbci	r19, 0xFF	; 255
    2b92:	81 e0       	ldi	r24, 0x01	; 1
    2b94:	97 e0       	ldi	r25, 0x07	; 7
    2b96:	b9 01       	movw	r22, r18
    2b98:	0e 94 95 0a 	call	0x152a	; 0x152a <vListInsertEnd>
		}
		taskEXIT_CRITICAL();
    2b9c:	0f 90       	pop	r0
    2b9e:	0f be       	out	0x3f, r0	; 63

		if( ( void * ) pxTaskToSuspend == NULL )
    2ba0:	8b 81       	ldd	r24, Y+3	; 0x03
    2ba2:	9c 81       	ldd	r25, Y+4	; 0x04
    2ba4:	00 97       	sbiw	r24, 0x00	; 0
    2ba6:	a1 f4       	brne	.+40     	; 0x2bd0 <vTaskSuspend+0xbc>
		{
			if( xSchedulerRunning != pdFALSE )
    2ba8:	80 91 af 06 	lds	r24, 0x06AF
    2bac:	88 23       	and	r24, r24
    2bae:	19 f0       	breq	.+6      	; 0x2bb6 <vTaskSuspend+0xa2>
			{
				/* We have just suspended the current task. */
				portYIELD_WITHIN_API();
    2bb0:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <vPortYield>
    2bb4:	0d c0       	rjmp	.+26     	; 0x2bd0 <vTaskSuspend+0xbc>
			else
			{
				/* The scheduler is not running, but the task that was pointed
				to by pxCurrentTCB has just been suspended and pxCurrentTCB
				must be adjusted to point to a different task. */
				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
    2bb6:	90 91 01 07 	lds	r25, 0x0701
    2bba:	80 91 aa 06 	lds	r24, 0x06AA
    2bbe:	98 17       	cp	r25, r24
    2bc0:	29 f4       	brne	.+10     	; 0x2bcc <vTaskSuspend+0xb8>
				{
					/* No other tasks are ready, so set pxCurrentTCB back to
					NULL so when the next task is created pxCurrentTCB will
					be set to point to it no matter what its relative priority
					is. */
					pxCurrentTCB = NULL;
    2bc2:	10 92 a9 06 	sts	0x06A9, r1
    2bc6:	10 92 a8 06 	sts	0x06A8, r1
    2bca:	02 c0       	rjmp	.+4      	; 0x2bd0 <vTaskSuspend+0xbc>
				}
				else
				{
					vTaskSwitchContext();
    2bcc:	0e 94 d0 18 	call	0x31a0	; 0x31a0 <vTaskSwitchContext>
				}
			}
		}
	}
    2bd0:	26 96       	adiw	r28, 0x06	; 6
    2bd2:	0f b6       	in	r0, 0x3f	; 63
    2bd4:	f8 94       	cli
    2bd6:	de bf       	out	0x3e, r29	; 62
    2bd8:	0f be       	out	0x3f, r0	; 63
    2bda:	cd bf       	out	0x3d, r28	; 61
    2bdc:	cf 91       	pop	r28
    2bde:	df 91       	pop	r29
    2be0:	08 95       	ret

00002be2 <xTaskIsTaskSuspended>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	signed portBASE_TYPE xTaskIsTaskSuspended( xTaskHandle xTask )
	{
    2be2:	df 93       	push	r29
    2be4:	cf 93       	push	r28
    2be6:	00 d0       	rcall	.+0      	; 0x2be8 <xTaskIsTaskSuspended+0x6>
    2be8:	00 d0       	rcall	.+0      	; 0x2bea <xTaskIsTaskSuspended+0x8>
    2bea:	0f 92       	push	r0
    2bec:	cd b7       	in	r28, 0x3d	; 61
    2bee:	de b7       	in	r29, 0x3e	; 62
    2bf0:	9d 83       	std	Y+5, r25	; 0x05
    2bf2:	8c 83       	std	Y+4, r24	; 0x04
	portBASE_TYPE xReturn = pdFALSE;
    2bf4:	1b 82       	std	Y+3, r1	; 0x03
	const tskTCB * const pxTCB = ( tskTCB * ) xTask;
    2bf6:	8c 81       	ldd	r24, Y+4	; 0x04
    2bf8:	9d 81       	ldd	r25, Y+5	; 0x05
    2bfa:	9a 83       	std	Y+2, r25	; 0x02
    2bfc:	89 83       	std	Y+1, r24	; 0x01
		/* It does not make sense to check if the calling task is suspended. */
		configASSERT( xTask );

		/* Is the task we are attempting to resume actually in the
		suspended list? */
		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xGenericListItem ) ) != pdFALSE )
    2bfe:	e9 81       	ldd	r30, Y+1	; 0x01
    2c00:	fa 81       	ldd	r31, Y+2	; 0x02
    2c02:	82 85       	ldd	r24, Z+10	; 0x0a
    2c04:	93 85       	ldd	r25, Z+11	; 0x0b
    2c06:	27 e0       	ldi	r18, 0x07	; 7
    2c08:	81 30       	cpi	r24, 0x01	; 1
    2c0a:	92 07       	cpc	r25, r18
    2c0c:	81 f4       	brne	.+32     	; 0x2c2e <xTaskIsTaskSuspended+0x4c>
		{
			/* Has the task already been resumed from within an ISR? */
			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) != pdTRUE )
    2c0e:	e9 81       	ldd	r30, Y+1	; 0x01
    2c10:	fa 81       	ldd	r31, Y+2	; 0x02
    2c12:	84 89       	ldd	r24, Z+20	; 0x14
    2c14:	95 89       	ldd	r25, Z+21	; 0x15
    2c16:	26 e0       	ldi	r18, 0x06	; 6
    2c18:	88 3f       	cpi	r24, 0xF8	; 248
    2c1a:	92 07       	cpc	r25, r18
    2c1c:	41 f0       	breq	.+16     	; 0x2c2e <xTaskIsTaskSuspended+0x4c>
			{
				/* Is it in the suspended list because it is in the
				Suspended state?  It is possible to be in the suspended
				list because it is blocked on a task with no timeout
				specified. */
				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) == pdTRUE )
    2c1e:	e9 81       	ldd	r30, Y+1	; 0x01
    2c20:	fa 81       	ldd	r31, Y+2	; 0x02
    2c22:	84 89       	ldd	r24, Z+20	; 0x14
    2c24:	95 89       	ldd	r25, Z+21	; 0x15
    2c26:	00 97       	sbiw	r24, 0x00	; 0
    2c28:	11 f4       	brne	.+4      	; 0x2c2e <xTaskIsTaskSuspended+0x4c>
				{
					xReturn = pdTRUE;
    2c2a:	81 e0       	ldi	r24, 0x01	; 1
    2c2c:	8b 83       	std	Y+3, r24	; 0x03
				}
			}
		}

		return xReturn;
    2c2e:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    2c30:	0f 90       	pop	r0
    2c32:	0f 90       	pop	r0
    2c34:	0f 90       	pop	r0
    2c36:	0f 90       	pop	r0
    2c38:	0f 90       	pop	r0
    2c3a:	cf 91       	pop	r28
    2c3c:	df 91       	pop	r29
    2c3e:	08 95       	ret

00002c40 <vTaskResume>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskSuspend == 1 )

	void vTaskResume( xTaskHandle pxTaskToResume )
	{
    2c40:	df 93       	push	r29
    2c42:	cf 93       	push	r28
    2c44:	00 d0       	rcall	.+0      	; 0x2c46 <vTaskResume+0x6>
    2c46:	00 d0       	rcall	.+0      	; 0x2c48 <vTaskResume+0x8>
    2c48:	cd b7       	in	r28, 0x3d	; 61
    2c4a:	de b7       	in	r29, 0x3e	; 62
    2c4c:	9c 83       	std	Y+4, r25	; 0x04
    2c4e:	8b 83       	std	Y+3, r24	; 0x03
		/* It does not make sense to resume the calling task. */
		configASSERT( pxTaskToResume );

		/* Remove the task from whichever list it is currently in, and place
		it in the ready list. */
		pxTCB = ( tskTCB * ) pxTaskToResume;
    2c50:	8b 81       	ldd	r24, Y+3	; 0x03
    2c52:	9c 81       	ldd	r25, Y+4	; 0x04
    2c54:	9a 83       	std	Y+2, r25	; 0x02
    2c56:	89 83       	std	Y+1, r24	; 0x01

		/* The parameter cannot be NULL as it is impossible to resume the
		currently executing task. */
		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
    2c58:	89 81       	ldd	r24, Y+1	; 0x01
    2c5a:	9a 81       	ldd	r25, Y+2	; 0x02
    2c5c:	00 97       	sbiw	r24, 0x00	; 0
    2c5e:	09 f4       	brne	.+2      	; 0x2c62 <vTaskResume+0x22>
    2c60:	4c c0       	rjmp	.+152    	; 0x2cfa <vTaskResume+0xba>
    2c62:	20 91 a8 06 	lds	r18, 0x06A8
    2c66:	30 91 a9 06 	lds	r19, 0x06A9
    2c6a:	89 81       	ldd	r24, Y+1	; 0x01
    2c6c:	9a 81       	ldd	r25, Y+2	; 0x02
    2c6e:	82 17       	cp	r24, r18
    2c70:	93 07       	cpc	r25, r19
    2c72:	09 f4       	brne	.+2      	; 0x2c76 <vTaskResume+0x36>
    2c74:	42 c0       	rjmp	.+132    	; 0x2cfa <vTaskResume+0xba>
		{
			taskENTER_CRITICAL();
    2c76:	0f b6       	in	r0, 0x3f	; 63
    2c78:	f8 94       	cli
    2c7a:	0f 92       	push	r0
			{
				if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    2c7c:	89 81       	ldd	r24, Y+1	; 0x01
    2c7e:	9a 81       	ldd	r25, Y+2	; 0x02
    2c80:	0e 94 f1 15 	call	0x2be2	; 0x2be2 <xTaskIsTaskSuspended>
    2c84:	81 30       	cpi	r24, 0x01	; 1
    2c86:	b9 f5       	brne	.+110    	; 0x2cf6 <vTaskResume+0xb6>
				{
					traceTASK_RESUME( pxTCB );

					/* As we are in a critical section we can access the ready
					lists even if the scheduler is suspended. */
					vListRemove(  &( pxTCB->xGenericListItem ) );
    2c88:	89 81       	ldd	r24, Y+1	; 0x01
    2c8a:	9a 81       	ldd	r25, Y+2	; 0x02
    2c8c:	02 96       	adiw	r24, 0x02	; 2
    2c8e:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2c92:	e9 81       	ldd	r30, Y+1	; 0x01
    2c94:	fa 81       	ldd	r31, Y+2	; 0x02
    2c96:	96 89       	ldd	r25, Z+22	; 0x16
    2c98:	80 91 ae 06 	lds	r24, 0x06AE
    2c9c:	89 17       	cp	r24, r25
    2c9e:	28 f4       	brcc	.+10     	; 0x2caa <vTaskResume+0x6a>
    2ca0:	e9 81       	ldd	r30, Y+1	; 0x01
    2ca2:	fa 81       	ldd	r31, Y+2	; 0x02
    2ca4:	86 89       	ldd	r24, Z+22	; 0x16
    2ca6:	80 93 ae 06 	sts	0x06AE, r24
    2caa:	e9 81       	ldd	r30, Y+1	; 0x01
    2cac:	fa 81       	ldd	r31, Y+2	; 0x02
    2cae:	86 89       	ldd	r24, Z+22	; 0x16
    2cb0:	28 2f       	mov	r18, r24
    2cb2:	30 e0       	ldi	r19, 0x00	; 0
    2cb4:	c9 01       	movw	r24, r18
    2cb6:	88 0f       	add	r24, r24
    2cb8:	99 1f       	adc	r25, r25
    2cba:	88 0f       	add	r24, r24
    2cbc:	99 1f       	adc	r25, r25
    2cbe:	88 0f       	add	r24, r24
    2cc0:	99 1f       	adc	r25, r25
    2cc2:	82 0f       	add	r24, r18
    2cc4:	93 1f       	adc	r25, r19
    2cc6:	ac 01       	movw	r20, r24
    2cc8:	4b 54       	subi	r20, 0x4B	; 75
    2cca:	59 4f       	sbci	r21, 0xF9	; 249
    2ccc:	89 81       	ldd	r24, Y+1	; 0x01
    2cce:	9a 81       	ldd	r25, Y+2	; 0x02
    2cd0:	9c 01       	movw	r18, r24
    2cd2:	2e 5f       	subi	r18, 0xFE	; 254
    2cd4:	3f 4f       	sbci	r19, 0xFF	; 255
    2cd6:	ca 01       	movw	r24, r20
    2cd8:	b9 01       	movw	r22, r18
    2cda:	0e 94 95 0a 	call	0x152a	; 0x152a <vListInsertEnd>

					/* We may have just resumed a higher priority task. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2cde:	e9 81       	ldd	r30, Y+1	; 0x01
    2ce0:	fa 81       	ldd	r31, Y+2	; 0x02
    2ce2:	96 89       	ldd	r25, Z+22	; 0x16
    2ce4:	e0 91 a8 06 	lds	r30, 0x06A8
    2ce8:	f0 91 a9 06 	lds	r31, 0x06A9
    2cec:	86 89       	ldd	r24, Z+22	; 0x16
    2cee:	98 17       	cp	r25, r24
    2cf0:	10 f0       	brcs	.+4      	; 0x2cf6 <vTaskResume+0xb6>
					{
						/* This yield may not cause the task just resumed to run, but
						will leave the lists in the correct state for the next yield. */
						portYIELD_WITHIN_API();
    2cf2:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <vPortYield>
					}
				}
			}
			taskEXIT_CRITICAL();
    2cf6:	0f 90       	pop	r0
    2cf8:	0f be       	out	0x3f, r0	; 63
		}
	}
    2cfa:	0f 90       	pop	r0
    2cfc:	0f 90       	pop	r0
    2cfe:	0f 90       	pop	r0
    2d00:	0f 90       	pop	r0
    2d02:	cf 91       	pop	r28
    2d04:	df 91       	pop	r29
    2d06:	08 95       	ret

00002d08 <xTaskResumeFromISR>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) )

	portBASE_TYPE xTaskResumeFromISR( xTaskHandle pxTaskToResume )
	{
    2d08:	df 93       	push	r29
    2d0a:	cf 93       	push	r28
    2d0c:	00 d0       	rcall	.+0      	; 0x2d0e <xTaskResumeFromISR+0x6>
    2d0e:	00 d0       	rcall	.+0      	; 0x2d10 <xTaskResumeFromISR+0x8>
    2d10:	0f 92       	push	r0
    2d12:	cd b7       	in	r28, 0x3d	; 61
    2d14:	de b7       	in	r29, 0x3e	; 62
    2d16:	9d 83       	std	Y+5, r25	; 0x05
    2d18:	8c 83       	std	Y+4, r24	; 0x04
	portBASE_TYPE xYieldRequired = pdFALSE;
    2d1a:	1b 82       	std	Y+3, r1	; 0x03
	tskTCB *pxTCB;

		configASSERT( pxTaskToResume );

		pxTCB = ( tskTCB * ) pxTaskToResume;
    2d1c:	8c 81       	ldd	r24, Y+4	; 0x04
    2d1e:	9d 81       	ldd	r25, Y+5	; 0x05
    2d20:	9a 83       	std	Y+2, r25	; 0x02
    2d22:	89 83       	std	Y+1, r24	; 0x01

		if( xTaskIsTaskSuspended( pxTCB ) == pdTRUE )
    2d24:	89 81       	ldd	r24, Y+1	; 0x01
    2d26:	9a 81       	ldd	r25, Y+2	; 0x02
    2d28:	0e 94 f1 15 	call	0x2be2	; 0x2be2 <xTaskIsTaskSuspended>
    2d2c:	81 30       	cpi	r24, 0x01	; 1
    2d2e:	09 f0       	breq	.+2      	; 0x2d32 <xTaskResumeFromISR+0x2a>
    2d30:	47 c0       	rjmp	.+142    	; 0x2dc0 <xTaskResumeFromISR+0xb8>
		{
			traceTASK_RESUME_FROM_ISR( pxTCB );

			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2d32:	80 91 b0 06 	lds	r24, 0x06B0
    2d36:	88 23       	and	r24, r24
    2d38:	c9 f5       	brne	.+114    	; 0x2dac <xTaskResumeFromISR+0xa4>
			{
				xYieldRequired = ( pxTCB->uxPriority >= pxCurrentTCB->uxPriority );
    2d3a:	e9 81       	ldd	r30, Y+1	; 0x01
    2d3c:	fa 81       	ldd	r31, Y+2	; 0x02
    2d3e:	96 89       	ldd	r25, Z+22	; 0x16
    2d40:	e0 91 a8 06 	lds	r30, 0x06A8
    2d44:	f0 91 a9 06 	lds	r31, 0x06A9
    2d48:	86 89       	ldd	r24, Z+22	; 0x16
    2d4a:	1b 82       	std	Y+3, r1	; 0x03
    2d4c:	98 17       	cp	r25, r24
    2d4e:	10 f0       	brcs	.+4      	; 0x2d54 <xTaskResumeFromISR+0x4c>
    2d50:	81 e0       	ldi	r24, 0x01	; 1
    2d52:	8b 83       	std	Y+3, r24	; 0x03
				vListRemove(  &( pxTCB->xGenericListItem ) );
    2d54:	89 81       	ldd	r24, Y+1	; 0x01
    2d56:	9a 81       	ldd	r25, Y+2	; 0x02
    2d58:	02 96       	adiw	r24, 0x02	; 2
    2d5a:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>
				prvAddTaskToReadyQueue( pxTCB );
    2d5e:	e9 81       	ldd	r30, Y+1	; 0x01
    2d60:	fa 81       	ldd	r31, Y+2	; 0x02
    2d62:	96 89       	ldd	r25, Z+22	; 0x16
    2d64:	80 91 ae 06 	lds	r24, 0x06AE
    2d68:	89 17       	cp	r24, r25
    2d6a:	28 f4       	brcc	.+10     	; 0x2d76 <xTaskResumeFromISR+0x6e>
    2d6c:	e9 81       	ldd	r30, Y+1	; 0x01
    2d6e:	fa 81       	ldd	r31, Y+2	; 0x02
    2d70:	86 89       	ldd	r24, Z+22	; 0x16
    2d72:	80 93 ae 06 	sts	0x06AE, r24
    2d76:	e9 81       	ldd	r30, Y+1	; 0x01
    2d78:	fa 81       	ldd	r31, Y+2	; 0x02
    2d7a:	86 89       	ldd	r24, Z+22	; 0x16
    2d7c:	28 2f       	mov	r18, r24
    2d7e:	30 e0       	ldi	r19, 0x00	; 0
    2d80:	c9 01       	movw	r24, r18
    2d82:	88 0f       	add	r24, r24
    2d84:	99 1f       	adc	r25, r25
    2d86:	88 0f       	add	r24, r24
    2d88:	99 1f       	adc	r25, r25
    2d8a:	88 0f       	add	r24, r24
    2d8c:	99 1f       	adc	r25, r25
    2d8e:	82 0f       	add	r24, r18
    2d90:	93 1f       	adc	r25, r19
    2d92:	ac 01       	movw	r20, r24
    2d94:	4b 54       	subi	r20, 0x4B	; 75
    2d96:	59 4f       	sbci	r21, 0xF9	; 249
    2d98:	89 81       	ldd	r24, Y+1	; 0x01
    2d9a:	9a 81       	ldd	r25, Y+2	; 0x02
    2d9c:	9c 01       	movw	r18, r24
    2d9e:	2e 5f       	subi	r18, 0xFE	; 254
    2da0:	3f 4f       	sbci	r19, 0xFF	; 255
    2da2:	ca 01       	movw	r24, r20
    2da4:	b9 01       	movw	r22, r18
    2da6:	0e 94 95 0a 	call	0x152a	; 0x152a <vListInsertEnd>
    2daa:	0a c0       	rjmp	.+20     	; 0x2dc0 <xTaskResumeFromISR+0xb8>
			else
			{
				/* We cannot access the delayed or ready lists, so will hold this
				task pending until the scheduler is resumed, at which point a
				yield will be performed if necessary. */
				vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
    2dac:	89 81       	ldd	r24, Y+1	; 0x01
    2dae:	9a 81       	ldd	r25, Y+2	; 0x02
    2db0:	9c 01       	movw	r18, r24
    2db2:	24 5f       	subi	r18, 0xF4	; 244
    2db4:	3f 4f       	sbci	r19, 0xFF	; 255
    2db6:	88 ef       	ldi	r24, 0xF8	; 248
    2db8:	96 e0       	ldi	r25, 0x06	; 6
    2dba:	b9 01       	movw	r22, r18
    2dbc:	0e 94 95 0a 	call	0x152a	; 0x152a <vListInsertEnd>
			}
		}

		return xYieldRequired;
    2dc0:	8b 81       	ldd	r24, Y+3	; 0x03
	}
    2dc2:	0f 90       	pop	r0
    2dc4:	0f 90       	pop	r0
    2dc6:	0f 90       	pop	r0
    2dc8:	0f 90       	pop	r0
    2dca:	0f 90       	pop	r0
    2dcc:	cf 91       	pop	r28
    2dce:	df 91       	pop	r29
    2dd0:	08 95       	ret

00002dd2 <vTaskStartScheduler>:
 * PUBLIC SCHEDULER CONTROL documented in task.h
 *----------------------------------------------------------*/


void vTaskStartScheduler( void )
{
    2dd2:	af 92       	push	r10
    2dd4:	bf 92       	push	r11
    2dd6:	cf 92       	push	r12
    2dd8:	df 92       	push	r13
    2dda:	ef 92       	push	r14
    2ddc:	ff 92       	push	r15
    2dde:	0f 93       	push	r16
    2de0:	df 93       	push	r29
    2de2:	cf 93       	push	r28
    2de4:	0f 92       	push	r0
    2de6:	cd b7       	in	r28, 0x3d	; 61
    2de8:	de b7       	in	r29, 0x3e	; 62
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    2dea:	20 e6       	ldi	r18, 0x60	; 96
    2dec:	30 e0       	ldi	r19, 0x00	; 0
    2dee:	87 ea       	ldi	r24, 0xA7	; 167
    2df0:	9a e1       	ldi	r25, 0x1A	; 26
    2df2:	b9 01       	movw	r22, r18
    2df4:	45 e5       	ldi	r20, 0x55	; 85
    2df6:	50 e0       	ldi	r21, 0x00	; 0
    2df8:	20 e0       	ldi	r18, 0x00	; 0
    2dfa:	30 e0       	ldi	r19, 0x00	; 0
    2dfc:	00 e0       	ldi	r16, 0x00	; 0
    2dfe:	ee 24       	eor	r14, r14
    2e00:	ff 24       	eor	r15, r15
    2e02:	cc 24       	eor	r12, r12
    2e04:	dd 24       	eor	r13, r13
    2e06:	aa 24       	eor	r10, r10
    2e08:	bb 24       	eor	r11, r11
    2e0a:	0e 94 47 13 	call	0x268e	; 0x268e <xTaskGenericCreate>
    2e0e:	89 83       	std	Y+1, r24	; 0x01
	}
	#endif

	#if ( configUSE_TIMERS == 1 )
	{
		if( xReturn == pdPASS )
    2e10:	89 81       	ldd	r24, Y+1	; 0x01
    2e12:	81 30       	cpi	r24, 0x01	; 1
    2e14:	19 f4       	brne	.+6      	; 0x2e1c <vTaskStartScheduler+0x4a>
		{
			xReturn = xTimerCreateTimerTask();
    2e16:	0e 94 00 1c 	call	0x3800	; 0x3800 <xTimerCreateTimerTask>
    2e1a:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	#endif

	if( xReturn == pdPASS )
    2e1c:	89 81       	ldd	r24, Y+1	; 0x01
    2e1e:	81 30       	cpi	r24, 0x01	; 1
    2e20:	51 f4       	brne	.+20     	; 0x2e36 <vTaskStartScheduler+0x64>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    2e22:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    2e24:	81 e0       	ldi	r24, 0x01	; 1
    2e26:	80 93 af 06 	sts	0x06AF, r24
		xTickCount = ( portTickType ) 0U;
    2e2a:	10 92 ac 06 	sts	0x06AC, r1
    2e2e:	10 92 ab 06 	sts	0x06AB, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
		
		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    2e32:	0e 94 19 0d 	call	0x1a32	; 0x1a32 <xPortStartScheduler>
		}
	}

	/* This line will only be reached if the kernel could not be started. */
	configASSERT( xReturn );
}
    2e36:	0f 90       	pop	r0
    2e38:	cf 91       	pop	r28
    2e3a:	df 91       	pop	r29
    2e3c:	0f 91       	pop	r16
    2e3e:	ff 90       	pop	r15
    2e40:	ef 90       	pop	r14
    2e42:	df 90       	pop	r13
    2e44:	cf 90       	pop	r12
    2e46:	bf 90       	pop	r11
    2e48:	af 90       	pop	r10
    2e4a:	08 95       	ret

00002e4c <vTaskEndScheduler>:
/*-----------------------------------------------------------*/

void vTaskEndScheduler( void )
{
    2e4c:	df 93       	push	r29
    2e4e:	cf 93       	push	r28
    2e50:	cd b7       	in	r28, 0x3d	; 61
    2e52:	de b7       	in	r29, 0x3e	; 62
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
    2e54:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
    2e56:	10 92 af 06 	sts	0x06AF, r1
	vPortEndScheduler();
    2e5a:	0e 94 4e 0d 	call	0x1a9c	; 0x1a9c <vPortEndScheduler>
}
    2e5e:	cf 91       	pop	r28
    2e60:	df 91       	pop	r29
    2e62:	08 95       	ret

00002e64 <vTaskSuspendAll>:
/*----------------------------------------------------------*/

void vTaskSuspendAll( void )
{
    2e64:	df 93       	push	r29
    2e66:	cf 93       	push	r28
    2e68:	cd b7       	in	r28, 0x3d	; 61
    2e6a:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
    2e6c:	80 91 b0 06 	lds	r24, 0x06B0
    2e70:	8f 5f       	subi	r24, 0xFF	; 255
    2e72:	80 93 b0 06 	sts	0x06B0, r24
}
    2e76:	cf 91       	pop	r28
    2e78:	df 91       	pop	r29
    2e7a:	08 95       	ret

00002e7c <xTaskResumeAll>:
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
    2e7c:	df 93       	push	r29
    2e7e:	cf 93       	push	r28
    2e80:	00 d0       	rcall	.+0      	; 0x2e82 <xTaskResumeAll+0x6>
    2e82:	00 d0       	rcall	.+0      	; 0x2e84 <xTaskResumeAll+0x8>
    2e84:	cd b7       	in	r28, 0x3d	; 61
    2e86:	de b7       	in	r29, 0x3e	; 62
register tskTCB *pxTCB;
signed portBASE_TYPE xAlreadyYielded = pdFALSE;
    2e88:	1a 82       	std	Y+2, r1	; 0x02
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
    2e8a:	0f b6       	in	r0, 0x3f	; 63
    2e8c:	f8 94       	cli
    2e8e:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
    2e90:	80 91 b0 06 	lds	r24, 0x06B0
    2e94:	81 50       	subi	r24, 0x01	; 1
    2e96:	80 93 b0 06 	sts	0x06B0, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    2e9a:	80 91 b0 06 	lds	r24, 0x06B0
    2e9e:	88 23       	and	r24, r24
    2ea0:	09 f0       	breq	.+2      	; 0x2ea4 <xTaskResumeAll+0x28>
    2ea2:	6a c0       	rjmp	.+212    	; 0x2f78 <xTaskResumeAll+0xfc>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
    2ea4:	80 91 aa 06 	lds	r24, 0x06AA
    2ea8:	88 23       	and	r24, r24
    2eaa:	09 f4       	brne	.+2      	; 0x2eae <xTaskResumeAll+0x32>
    2eac:	65 c0       	rjmp	.+202    	; 0x2f78 <xTaskResumeAll+0xfc>
			{
				portBASE_TYPE xYieldRequired = pdFALSE;
    2eae:	19 82       	std	Y+1, r1	; 0x01
    2eb0:	41 c0       	rjmp	.+130    	; 0x2f34 <xTaskResumeAll+0xb8>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
    2eb2:	e0 91 fd 06 	lds	r30, 0x06FD
    2eb6:	f0 91 fe 06 	lds	r31, 0x06FE
    2eba:	86 81       	ldd	r24, Z+6	; 0x06
    2ebc:	97 81       	ldd	r25, Z+7	; 0x07
    2ebe:	9c 83       	std	Y+4, r25	; 0x04
    2ec0:	8b 83       	std	Y+3, r24	; 0x03
					vListRemove( &( pxTCB->xEventListItem ) );
    2ec2:	8b 81       	ldd	r24, Y+3	; 0x03
    2ec4:	9c 81       	ldd	r25, Y+4	; 0x04
    2ec6:	0c 96       	adiw	r24, 0x0c	; 12
    2ec8:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>
					vListRemove( &( pxTCB->xGenericListItem ) );
    2ecc:	8b 81       	ldd	r24, Y+3	; 0x03
    2ece:	9c 81       	ldd	r25, Y+4	; 0x04
    2ed0:	02 96       	adiw	r24, 0x02	; 2
    2ed2:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>
					prvAddTaskToReadyQueue( pxTCB );
    2ed6:	eb 81       	ldd	r30, Y+3	; 0x03
    2ed8:	fc 81       	ldd	r31, Y+4	; 0x04
    2eda:	96 89       	ldd	r25, Z+22	; 0x16
    2edc:	80 91 ae 06 	lds	r24, 0x06AE
    2ee0:	89 17       	cp	r24, r25
    2ee2:	28 f4       	brcc	.+10     	; 0x2eee <xTaskResumeAll+0x72>
    2ee4:	eb 81       	ldd	r30, Y+3	; 0x03
    2ee6:	fc 81       	ldd	r31, Y+4	; 0x04
    2ee8:	86 89       	ldd	r24, Z+22	; 0x16
    2eea:	80 93 ae 06 	sts	0x06AE, r24
    2eee:	eb 81       	ldd	r30, Y+3	; 0x03
    2ef0:	fc 81       	ldd	r31, Y+4	; 0x04
    2ef2:	86 89       	ldd	r24, Z+22	; 0x16
    2ef4:	28 2f       	mov	r18, r24
    2ef6:	30 e0       	ldi	r19, 0x00	; 0
    2ef8:	c9 01       	movw	r24, r18
    2efa:	88 0f       	add	r24, r24
    2efc:	99 1f       	adc	r25, r25
    2efe:	88 0f       	add	r24, r24
    2f00:	99 1f       	adc	r25, r25
    2f02:	88 0f       	add	r24, r24
    2f04:	99 1f       	adc	r25, r25
    2f06:	82 0f       	add	r24, r18
    2f08:	93 1f       	adc	r25, r19
    2f0a:	8b 54       	subi	r24, 0x4B	; 75
    2f0c:	99 4f       	sbci	r25, 0xF9	; 249
    2f0e:	2b 81       	ldd	r18, Y+3	; 0x03
    2f10:	3c 81       	ldd	r19, Y+4	; 0x04
    2f12:	2e 5f       	subi	r18, 0xFE	; 254
    2f14:	3f 4f       	sbci	r19, 0xFF	; 255
    2f16:	b9 01       	movw	r22, r18
    2f18:	0e 94 95 0a 	call	0x152a	; 0x152a <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
    2f1c:	eb 81       	ldd	r30, Y+3	; 0x03
    2f1e:	fc 81       	ldd	r31, Y+4	; 0x04
    2f20:	96 89       	ldd	r25, Z+22	; 0x16
    2f22:	e0 91 a8 06 	lds	r30, 0x06A8
    2f26:	f0 91 a9 06 	lds	r31, 0x06A9
    2f2a:	86 89       	ldd	r24, Z+22	; 0x16
    2f2c:	98 17       	cp	r25, r24
    2f2e:	10 f0       	brcs	.+4      	; 0x2f34 <xTaskResumeAll+0xb8>
					{
						xYieldRequired = pdTRUE;
    2f30:	81 e0       	ldi	r24, 0x01	; 1
    2f32:	89 83       	std	Y+1, r24	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
    2f34:	80 91 f8 06 	lds	r24, 0x06F8
    2f38:	88 23       	and	r24, r24
    2f3a:	09 f0       	breq	.+2      	; 0x2f3e <xTaskResumeAll+0xc2>
    2f3c:	ba cf       	rjmp	.-140    	; 0x2eb2 <xTaskResumeAll+0x36>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2f3e:	80 91 b1 06 	lds	r24, 0x06B1
    2f42:	88 23       	and	r24, r24
    2f44:	61 f0       	breq	.+24     	; 0x2f5e <xTaskResumeAll+0xe2>
    2f46:	07 c0       	rjmp	.+14     	; 0x2f56 <xTaskResumeAll+0xda>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
    2f48:	0e 94 fb 17 	call	0x2ff6	; 0x2ff6 <vTaskIncrementTick>
						--uxMissedTicks;
    2f4c:	80 91 b1 06 	lds	r24, 0x06B1
    2f50:	81 50       	subi	r24, 0x01	; 1
    2f52:	80 93 b1 06 	sts	0x06B1, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
    2f56:	80 91 b1 06 	lds	r24, 0x06B1
    2f5a:	88 23       	and	r24, r24
    2f5c:	a9 f7       	brne	.-22     	; 0x2f48 <xTaskResumeAll+0xcc>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
    2f5e:	89 81       	ldd	r24, Y+1	; 0x01
    2f60:	81 30       	cpi	r24, 0x01	; 1
    2f62:	21 f0       	breq	.+8      	; 0x2f6c <xTaskResumeAll+0xf0>
    2f64:	80 91 b2 06 	lds	r24, 0x06B2
    2f68:	81 30       	cpi	r24, 0x01	; 1
    2f6a:	31 f4       	brne	.+12     	; 0x2f78 <xTaskResumeAll+0xfc>
				{
					xAlreadyYielded = pdTRUE;
    2f6c:	81 e0       	ldi	r24, 0x01	; 1
    2f6e:	8a 83       	std	Y+2, r24	; 0x02
					xMissedYield = pdFALSE;
    2f70:	10 92 b2 06 	sts	0x06B2, r1
					portYIELD_WITHIN_API();
    2f74:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <vPortYield>
				}
			}
		}
	}
	taskEXIT_CRITICAL();
    2f78:	0f 90       	pop	r0
    2f7a:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
    2f7c:	8a 81       	ldd	r24, Y+2	; 0x02
}
    2f7e:	0f 90       	pop	r0
    2f80:	0f 90       	pop	r0
    2f82:	0f 90       	pop	r0
    2f84:	0f 90       	pop	r0
    2f86:	cf 91       	pop	r28
    2f88:	df 91       	pop	r29
    2f8a:	08 95       	ret

00002f8c <xTaskGetTickCount>:
 *----------------------------------------------------------*/



portTickType xTaskGetTickCount( void )
{
    2f8c:	df 93       	push	r29
    2f8e:	cf 93       	push	r28
    2f90:	00 d0       	rcall	.+0      	; 0x2f92 <xTaskGetTickCount+0x6>
    2f92:	cd b7       	in	r28, 0x3d	; 61
    2f94:	de b7       	in	r29, 0x3e	; 62
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
    2f96:	0f b6       	in	r0, 0x3f	; 63
    2f98:	f8 94       	cli
    2f9a:	0f 92       	push	r0
	{
		xTicks = xTickCount;
    2f9c:	80 91 ab 06 	lds	r24, 0x06AB
    2fa0:	90 91 ac 06 	lds	r25, 0x06AC
    2fa4:	9a 83       	std	Y+2, r25	; 0x02
    2fa6:	89 83       	std	Y+1, r24	; 0x01
	}
	taskEXIT_CRITICAL();
    2fa8:	0f 90       	pop	r0
    2faa:	0f be       	out	0x3f, r0	; 63

	return xTicks;
    2fac:	89 81       	ldd	r24, Y+1	; 0x01
    2fae:	9a 81       	ldd	r25, Y+2	; 0x02
}
    2fb0:	0f 90       	pop	r0
    2fb2:	0f 90       	pop	r0
    2fb4:	cf 91       	pop	r28
    2fb6:	df 91       	pop	r29
    2fb8:	08 95       	ret

00002fba <xTaskGetTickCountFromISR>:
/*-----------------------------------------------------------*/

portTickType xTaskGetTickCountFromISR( void )
{
    2fba:	df 93       	push	r29
    2fbc:	cf 93       	push	r28
    2fbe:	00 d0       	rcall	.+0      	; 0x2fc0 <xTaskGetTickCountFromISR+0x6>
    2fc0:	0f 92       	push	r0
    2fc2:	cd b7       	in	r28, 0x3d	; 61
    2fc4:	de b7       	in	r29, 0x3e	; 62
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
    2fc6:	19 82       	std	Y+1, r1	; 0x01
	xReturn = xTickCount;
    2fc8:	80 91 ab 06 	lds	r24, 0x06AB
    2fcc:	90 91 ac 06 	lds	r25, 0x06AC
    2fd0:	9b 83       	std	Y+3, r25	; 0x03
    2fd2:	8a 83       	std	Y+2, r24	; 0x02
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
    2fd4:	8a 81       	ldd	r24, Y+2	; 0x02
    2fd6:	9b 81       	ldd	r25, Y+3	; 0x03
}
    2fd8:	0f 90       	pop	r0
    2fda:	0f 90       	pop	r0
    2fdc:	0f 90       	pop	r0
    2fde:	cf 91       	pop	r28
    2fe0:	df 91       	pop	r29
    2fe2:	08 95       	ret

00002fe4 <uxTaskGetNumberOfTasks>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
    2fe4:	df 93       	push	r29
    2fe6:	cf 93       	push	r28
    2fe8:	cd b7       	in	r28, 0x3d	; 61
    2fea:	de b7       	in	r29, 0x3e	; 62
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
    2fec:	80 91 aa 06 	lds	r24, 0x06AA
}
    2ff0:	cf 91       	pop	r28
    2ff2:	df 91       	pop	r29
    2ff4:	08 95       	ret

00002ff6 <vTaskIncrementTick>:
 * SCHEDULER INTERNALS AVAILABLE FOR PORTING PURPOSES
 * documented in task.h
 *----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
    2ff6:	df 93       	push	r29
    2ff8:	cf 93       	push	r28
    2ffa:	00 d0       	rcall	.+0      	; 0x2ffc <vTaskIncrementTick+0x6>
    2ffc:	00 d0       	rcall	.+0      	; 0x2ffe <vTaskIncrementTick+0x8>
    2ffe:	00 d0       	rcall	.+0      	; 0x3000 <vTaskIncrementTick+0xa>
    3000:	cd b7       	in	r28, 0x3d	; 61
    3002:	de b7       	in	r29, 0x3e	; 62
tskTCB * pxTCB;

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    3004:	80 91 b0 06 	lds	r24, 0x06B0
    3008:	88 23       	and	r24, r24
    300a:	09 f0       	breq	.+2      	; 0x300e <vTaskIncrementTick+0x18>
    300c:	bb c0       	rjmp	.+374    	; 0x3184 <vTaskIncrementTick+0x18e>
	{
		++xTickCount;
    300e:	80 91 ab 06 	lds	r24, 0x06AB
    3012:	90 91 ac 06 	lds	r25, 0x06AC
    3016:	01 96       	adiw	r24, 0x01	; 1
    3018:	90 93 ac 06 	sts	0x06AC, r25
    301c:	80 93 ab 06 	sts	0x06AB, r24
		if( xTickCount == ( portTickType ) 0U )
    3020:	80 91 ab 06 	lds	r24, 0x06AB
    3024:	90 91 ac 06 	lds	r25, 0x06AC
    3028:	00 97       	sbiw	r24, 0x00	; 0
    302a:	d1 f5       	brne	.+116    	; 0x30a0 <vTaskIncrementTick+0xaa>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );
			
			pxTemp = pxDelayedTaskList;
    302c:	80 91 f4 06 	lds	r24, 0x06F4
    3030:	90 91 f5 06 	lds	r25, 0x06F5
    3034:	9c 83       	std	Y+4, r25	; 0x04
    3036:	8b 83       	std	Y+3, r24	; 0x03
			pxDelayedTaskList = pxOverflowDelayedTaskList;
    3038:	80 91 f6 06 	lds	r24, 0x06F6
    303c:	90 91 f7 06 	lds	r25, 0x06F7
    3040:	90 93 f5 06 	sts	0x06F5, r25
    3044:	80 93 f4 06 	sts	0x06F4, r24
			pxOverflowDelayedTaskList = pxTemp;
    3048:	8b 81       	ldd	r24, Y+3	; 0x03
    304a:	9c 81       	ldd	r25, Y+4	; 0x04
    304c:	90 93 f7 06 	sts	0x06F7, r25
    3050:	80 93 f6 06 	sts	0x06F6, r24
			xNumOfOverflows++;
    3054:	80 91 b3 06 	lds	r24, 0x06B3
    3058:	8f 5f       	subi	r24, 0xFF	; 255
    305a:	80 93 b3 06 	sts	0x06B3, r24
	
			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
    305e:	e0 91 f4 06 	lds	r30, 0x06F4
    3062:	f0 91 f5 06 	lds	r31, 0x06F5
    3066:	80 81       	ld	r24, Z
    3068:	88 23       	and	r24, r24
    306a:	39 f4       	brne	.+14     	; 0x307a <vTaskIncrementTick+0x84>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the	
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
    306c:	8f ef       	ldi	r24, 0xFF	; 255
    306e:	9f ef       	ldi	r25, 0xFF	; 255
    3070:	90 93 a0 01 	sts	0x01A0, r25
    3074:	80 93 9f 01 	sts	0x019F, r24
    3078:	13 c0       	rjmp	.+38     	; 0x30a0 <vTaskIncrementTick+0xaa>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
    307a:	e0 91 f4 06 	lds	r30, 0x06F4
    307e:	f0 91 f5 06 	lds	r31, 0x06F5
    3082:	05 80       	ldd	r0, Z+5	; 0x05
    3084:	f6 81       	ldd	r31, Z+6	; 0x06
    3086:	e0 2d       	mov	r30, r0
    3088:	86 81       	ldd	r24, Z+6	; 0x06
    308a:	97 81       	ldd	r25, Z+7	; 0x07
    308c:	9e 83       	std	Y+6, r25	; 0x06
    308e:	8d 83       	std	Y+5, r24	; 0x05
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
    3090:	ed 81       	ldd	r30, Y+5	; 0x05
    3092:	fe 81       	ldd	r31, Y+6	; 0x06
    3094:	82 81       	ldd	r24, Z+2	; 0x02
    3096:	93 81       	ldd	r25, Z+3	; 0x03
    3098:	90 93 a0 01 	sts	0x01A0, r25
    309c:	80 93 9f 01 	sts	0x019F, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
    30a0:	20 91 ab 06 	lds	r18, 0x06AB
    30a4:	30 91 ac 06 	lds	r19, 0x06AC
    30a8:	80 91 9f 01 	lds	r24, 0x019F
    30ac:	90 91 a0 01 	lds	r25, 0x01A0
    30b0:	28 17       	cp	r18, r24
    30b2:	39 07       	cpc	r19, r25
    30b4:	08 f4       	brcc	.+2      	; 0x30b8 <vTaskIncrementTick+0xc2>
    30b6:	6b c0       	rjmp	.+214    	; 0x318e <vTaskIncrementTick+0x198>
    30b8:	e0 91 f4 06 	lds	r30, 0x06F4
    30bc:	f0 91 f5 06 	lds	r31, 0x06F5
    30c0:	80 81       	ld	r24, Z
    30c2:	88 23       	and	r24, r24
    30c4:	39 f4       	brne	.+14     	; 0x30d4 <vTaskIncrementTick+0xde>
    30c6:	8f ef       	ldi	r24, 0xFF	; 255
    30c8:	9f ef       	ldi	r25, 0xFF	; 255
    30ca:	90 93 a0 01 	sts	0x01A0, r25
    30ce:	80 93 9f 01 	sts	0x019F, r24
    30d2:	5d c0       	rjmp	.+186    	; 0x318e <vTaskIncrementTick+0x198>
    30d4:	e0 91 f4 06 	lds	r30, 0x06F4
    30d8:	f0 91 f5 06 	lds	r31, 0x06F5
    30dc:	05 80       	ldd	r0, Z+5	; 0x05
    30de:	f6 81       	ldd	r31, Z+6	; 0x06
    30e0:	e0 2d       	mov	r30, r0
    30e2:	86 81       	ldd	r24, Z+6	; 0x06
    30e4:	97 81       	ldd	r25, Z+7	; 0x07
    30e6:	9e 83       	std	Y+6, r25	; 0x06
    30e8:	8d 83       	std	Y+5, r24	; 0x05
    30ea:	ed 81       	ldd	r30, Y+5	; 0x05
    30ec:	fe 81       	ldd	r31, Y+6	; 0x06
    30ee:	82 81       	ldd	r24, Z+2	; 0x02
    30f0:	93 81       	ldd	r25, Z+3	; 0x03
    30f2:	9a 83       	std	Y+2, r25	; 0x02
    30f4:	89 83       	std	Y+1, r24	; 0x01
    30f6:	20 91 ab 06 	lds	r18, 0x06AB
    30fa:	30 91 ac 06 	lds	r19, 0x06AC
    30fe:	89 81       	ldd	r24, Y+1	; 0x01
    3100:	9a 81       	ldd	r25, Y+2	; 0x02
    3102:	28 17       	cp	r18, r24
    3104:	39 07       	cpc	r19, r25
    3106:	38 f4       	brcc	.+14     	; 0x3116 <vTaskIncrementTick+0x120>
    3108:	89 81       	ldd	r24, Y+1	; 0x01
    310a:	9a 81       	ldd	r25, Y+2	; 0x02
    310c:	90 93 a0 01 	sts	0x01A0, r25
    3110:	80 93 9f 01 	sts	0x019F, r24
    3114:	3c c0       	rjmp	.+120    	; 0x318e <vTaskIncrementTick+0x198>
    3116:	8d 81       	ldd	r24, Y+5	; 0x05
    3118:	9e 81       	ldd	r25, Y+6	; 0x06
    311a:	02 96       	adiw	r24, 0x02	; 2
    311c:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>
    3120:	ed 81       	ldd	r30, Y+5	; 0x05
    3122:	fe 81       	ldd	r31, Y+6	; 0x06
    3124:	84 89       	ldd	r24, Z+20	; 0x14
    3126:	95 89       	ldd	r25, Z+21	; 0x15
    3128:	00 97       	sbiw	r24, 0x00	; 0
    312a:	29 f0       	breq	.+10     	; 0x3136 <vTaskIncrementTick+0x140>
    312c:	8d 81       	ldd	r24, Y+5	; 0x05
    312e:	9e 81       	ldd	r25, Y+6	; 0x06
    3130:	0c 96       	adiw	r24, 0x0c	; 12
    3132:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>
    3136:	ed 81       	ldd	r30, Y+5	; 0x05
    3138:	fe 81       	ldd	r31, Y+6	; 0x06
    313a:	96 89       	ldd	r25, Z+22	; 0x16
    313c:	80 91 ae 06 	lds	r24, 0x06AE
    3140:	89 17       	cp	r24, r25
    3142:	28 f4       	brcc	.+10     	; 0x314e <vTaskIncrementTick+0x158>
    3144:	ed 81       	ldd	r30, Y+5	; 0x05
    3146:	fe 81       	ldd	r31, Y+6	; 0x06
    3148:	86 89       	ldd	r24, Z+22	; 0x16
    314a:	80 93 ae 06 	sts	0x06AE, r24
    314e:	ed 81       	ldd	r30, Y+5	; 0x05
    3150:	fe 81       	ldd	r31, Y+6	; 0x06
    3152:	86 89       	ldd	r24, Z+22	; 0x16
    3154:	28 2f       	mov	r18, r24
    3156:	30 e0       	ldi	r19, 0x00	; 0
    3158:	c9 01       	movw	r24, r18
    315a:	88 0f       	add	r24, r24
    315c:	99 1f       	adc	r25, r25
    315e:	88 0f       	add	r24, r24
    3160:	99 1f       	adc	r25, r25
    3162:	88 0f       	add	r24, r24
    3164:	99 1f       	adc	r25, r25
    3166:	82 0f       	add	r24, r18
    3168:	93 1f       	adc	r25, r19
    316a:	ac 01       	movw	r20, r24
    316c:	4b 54       	subi	r20, 0x4B	; 75
    316e:	59 4f       	sbci	r21, 0xF9	; 249
    3170:	8d 81       	ldd	r24, Y+5	; 0x05
    3172:	9e 81       	ldd	r25, Y+6	; 0x06
    3174:	9c 01       	movw	r18, r24
    3176:	2e 5f       	subi	r18, 0xFE	; 254
    3178:	3f 4f       	sbci	r19, 0xFF	; 255
    317a:	ca 01       	movw	r24, r20
    317c:	b9 01       	movw	r22, r18
    317e:	0e 94 95 0a 	call	0x152a	; 0x152a <vListInsertEnd>
    3182:	9a cf       	rjmp	.-204    	; 0x30b8 <vTaskIncrementTick+0xc2>
	}
	else
	{
		++uxMissedTicks;
    3184:	80 91 b1 06 	lds	r24, 0x06B1
    3188:	8f 5f       	subi	r24, 0xFF	; 255
    318a:	80 93 b1 06 	sts	0x06B1, r24
		}
	}
	#endif

	traceTASK_INCREMENT_TICK( xTickCount );
}
    318e:	26 96       	adiw	r28, 0x06	; 6
    3190:	0f b6       	in	r0, 0x3f	; 63
    3192:	f8 94       	cli
    3194:	de bf       	out	0x3e, r29	; 62
    3196:	0f be       	out	0x3f, r0	; 63
    3198:	cd bf       	out	0x3d, r28	; 61
    319a:	cf 91       	pop	r28
    319c:	df 91       	pop	r29
    319e:	08 95       	ret

000031a0 <vTaskSwitchContext>:

#endif
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
    31a0:	df 93       	push	r29
    31a2:	cf 93       	push	r28
    31a4:	00 d0       	rcall	.+0      	; 0x31a6 <vTaskSwitchContext+0x6>
    31a6:	cd b7       	in	r28, 0x3d	; 61
    31a8:	de b7       	in	r29, 0x3e	; 62
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
    31aa:	80 91 b0 06 	lds	r24, 0x06B0
    31ae:	88 23       	and	r24, r24
    31b0:	49 f0       	breq	.+18     	; 0x31c4 <vTaskSwitchContext+0x24>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
    31b2:	81 e0       	ldi	r24, 0x01	; 1
    31b4:	80 93 b2 06 	sts	0x06B2, r24
    31b8:	54 c0       	rjmp	.+168    	; 0x3262 <vTaskSwitchContext+0xc2>
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
		{
			configASSERT( uxTopReadyPriority );
			--uxTopReadyPriority;
    31ba:	80 91 ae 06 	lds	r24, 0x06AE
    31be:	81 50       	subi	r24, 0x01	; 1
    31c0:	80 93 ae 06 	sts	0x06AE, r24
	
		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();
	
		/* Find the highest priority queue that contains ready tasks. */
		while( listLIST_IS_EMPTY( &( pxReadyTasksLists[ uxTopReadyPriority ] ) ) )
    31c4:	80 91 ae 06 	lds	r24, 0x06AE
    31c8:	28 2f       	mov	r18, r24
    31ca:	30 e0       	ldi	r19, 0x00	; 0
    31cc:	c9 01       	movw	r24, r18
    31ce:	88 0f       	add	r24, r24
    31d0:	99 1f       	adc	r25, r25
    31d2:	88 0f       	add	r24, r24
    31d4:	99 1f       	adc	r25, r25
    31d6:	88 0f       	add	r24, r24
    31d8:	99 1f       	adc	r25, r25
    31da:	82 0f       	add	r24, r18
    31dc:	93 1f       	adc	r25, r19
    31de:	fc 01       	movw	r30, r24
    31e0:	eb 54       	subi	r30, 0x4B	; 75
    31e2:	f9 4f       	sbci	r31, 0xF9	; 249
    31e4:	80 81       	ld	r24, Z
    31e6:	88 23       	and	r24, r24
    31e8:	41 f3       	breq	.-48     	; 0x31ba <vTaskSwitchContext+0x1a>
			--uxTopReadyPriority;
		}
	
		/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the tasks of the
		same priority get an equal share of the processor time. */
		listGET_OWNER_OF_NEXT_ENTRY( pxCurrentTCB, &( pxReadyTasksLists[ uxTopReadyPriority ] ) );
    31ea:	80 91 ae 06 	lds	r24, 0x06AE
    31ee:	28 2f       	mov	r18, r24
    31f0:	30 e0       	ldi	r19, 0x00	; 0
    31f2:	c9 01       	movw	r24, r18
    31f4:	88 0f       	add	r24, r24
    31f6:	99 1f       	adc	r25, r25
    31f8:	88 0f       	add	r24, r24
    31fa:	99 1f       	adc	r25, r25
    31fc:	88 0f       	add	r24, r24
    31fe:	99 1f       	adc	r25, r25
    3200:	82 0f       	add	r24, r18
    3202:	93 1f       	adc	r25, r19
    3204:	8b 54       	subi	r24, 0x4B	; 75
    3206:	99 4f       	sbci	r25, 0xF9	; 249
    3208:	9a 83       	std	Y+2, r25	; 0x02
    320a:	89 83       	std	Y+1, r24	; 0x01
    320c:	e9 81       	ldd	r30, Y+1	; 0x01
    320e:	fa 81       	ldd	r31, Y+2	; 0x02
    3210:	01 80       	ldd	r0, Z+1	; 0x01
    3212:	f2 81       	ldd	r31, Z+2	; 0x02
    3214:	e0 2d       	mov	r30, r0
    3216:	82 81       	ldd	r24, Z+2	; 0x02
    3218:	93 81       	ldd	r25, Z+3	; 0x03
    321a:	e9 81       	ldd	r30, Y+1	; 0x01
    321c:	fa 81       	ldd	r31, Y+2	; 0x02
    321e:	92 83       	std	Z+2, r25	; 0x02
    3220:	81 83       	std	Z+1, r24	; 0x01
    3222:	e9 81       	ldd	r30, Y+1	; 0x01
    3224:	fa 81       	ldd	r31, Y+2	; 0x02
    3226:	21 81       	ldd	r18, Z+1	; 0x01
    3228:	32 81       	ldd	r19, Z+2	; 0x02
    322a:	89 81       	ldd	r24, Y+1	; 0x01
    322c:	9a 81       	ldd	r25, Y+2	; 0x02
    322e:	03 96       	adiw	r24, 0x03	; 3
    3230:	28 17       	cp	r18, r24
    3232:	39 07       	cpc	r19, r25
    3234:	59 f4       	brne	.+22     	; 0x324c <vTaskSwitchContext+0xac>
    3236:	e9 81       	ldd	r30, Y+1	; 0x01
    3238:	fa 81       	ldd	r31, Y+2	; 0x02
    323a:	01 80       	ldd	r0, Z+1	; 0x01
    323c:	f2 81       	ldd	r31, Z+2	; 0x02
    323e:	e0 2d       	mov	r30, r0
    3240:	82 81       	ldd	r24, Z+2	; 0x02
    3242:	93 81       	ldd	r25, Z+3	; 0x03
    3244:	e9 81       	ldd	r30, Y+1	; 0x01
    3246:	fa 81       	ldd	r31, Y+2	; 0x02
    3248:	92 83       	std	Z+2, r25	; 0x02
    324a:	81 83       	std	Z+1, r24	; 0x01
    324c:	e9 81       	ldd	r30, Y+1	; 0x01
    324e:	fa 81       	ldd	r31, Y+2	; 0x02
    3250:	01 80       	ldd	r0, Z+1	; 0x01
    3252:	f2 81       	ldd	r31, Z+2	; 0x02
    3254:	e0 2d       	mov	r30, r0
    3256:	86 81       	ldd	r24, Z+6	; 0x06
    3258:	97 81       	ldd	r25, Z+7	; 0x07
    325a:	90 93 a9 06 	sts	0x06A9, r25
    325e:	80 93 a8 06 	sts	0x06A8, r24
	
		traceTASK_SWITCHED_IN();
		vWriteTraceToBuffer();
	}
}
    3262:	0f 90       	pop	r0
    3264:	0f 90       	pop	r0
    3266:	cf 91       	pop	r28
    3268:	df 91       	pop	r29
    326a:	08 95       	ret

0000326c <vTaskPlaceOnEventList>:
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
    326c:	df 93       	push	r29
    326e:	cf 93       	push	r28
    3270:	00 d0       	rcall	.+0      	; 0x3272 <vTaskPlaceOnEventList+0x6>
    3272:	00 d0       	rcall	.+0      	; 0x3274 <vTaskPlaceOnEventList+0x8>
    3274:	00 d0       	rcall	.+0      	; 0x3276 <vTaskPlaceOnEventList+0xa>
    3276:	cd b7       	in	r28, 0x3d	; 61
    3278:	de b7       	in	r29, 0x3e	; 62
    327a:	9c 83       	std	Y+4, r25	; 0x04
    327c:	8b 83       	std	Y+3, r24	; 0x03
    327e:	7e 83       	std	Y+6, r23	; 0x06
    3280:	6d 83       	std	Y+5, r22	; 0x05
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    3282:	4b 81       	ldd	r20, Y+3	; 0x03
    3284:	5c 81       	ldd	r21, Y+4	; 0x04
    3286:	80 91 a8 06 	lds	r24, 0x06A8
    328a:	90 91 a9 06 	lds	r25, 0x06A9
    328e:	9c 01       	movw	r18, r24
    3290:	24 5f       	subi	r18, 0xF4	; 244
    3292:	3f 4f       	sbci	r19, 0xFF	; 255
    3294:	ca 01       	movw	r24, r20
    3296:	b9 01       	movw	r22, r18
    3298:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    329c:	80 91 a8 06 	lds	r24, 0x06A8
    32a0:	90 91 a9 06 	lds	r25, 0x06A9
    32a4:	02 96       	adiw	r24, 0x02	; 2
    32a6:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>


	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		if( xTicksToWait == portMAX_DELAY )
    32aa:	8d 81       	ldd	r24, Y+5	; 0x05
    32ac:	9e 81       	ldd	r25, Y+6	; 0x06
    32ae:	2f ef       	ldi	r18, 0xFF	; 255
    32b0:	8f 3f       	cpi	r24, 0xFF	; 255
    32b2:	92 07       	cpc	r25, r18
    32b4:	69 f4       	brne	.+26     	; 0x32d0 <vTaskPlaceOnEventList+0x64>
		{
			/* Add ourselves to the suspended task list instead of a delayed task
			list to ensure we are not woken by a timing event.  We will block
			indefinitely. */
			vListInsertEnd( ( xList * ) &xSuspendedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    32b6:	80 91 a8 06 	lds	r24, 0x06A8
    32ba:	90 91 a9 06 	lds	r25, 0x06A9
    32be:	9c 01       	movw	r18, r24
    32c0:	2e 5f       	subi	r18, 0xFE	; 254
    32c2:	3f 4f       	sbci	r19, 0xFF	; 255
    32c4:	81 e0       	ldi	r24, 0x01	; 1
    32c6:	97 e0       	ldi	r25, 0x07	; 7
    32c8:	b9 01       	movw	r22, r18
    32ca:	0e 94 95 0a 	call	0x152a	; 0x152a <vListInsertEnd>
    32ce:	0e c0       	rjmp	.+28     	; 0x32ec <vTaskPlaceOnEventList+0x80>
		}
		else
		{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
    32d0:	20 91 ab 06 	lds	r18, 0x06AB
    32d4:	30 91 ac 06 	lds	r19, 0x06AC
    32d8:	8d 81       	ldd	r24, Y+5	; 0x05
    32da:	9e 81       	ldd	r25, Y+6	; 0x06
    32dc:	82 0f       	add	r24, r18
    32de:	93 1f       	adc	r25, r19
    32e0:	9a 83       	std	Y+2, r25	; 0x02
    32e2:	89 83       	std	Y+1, r24	; 0x01
			prvAddCurrentTaskToDelayedList( xTimeToWake );
    32e4:	89 81       	ldd	r24, Y+1	; 0x01
    32e6:	9a 81       	ldd	r25, Y+2	; 0x02
    32e8:	0e 94 4e 1b 	call	0x369c	; 0x369c <prvAddCurrentTaskToDelayedList>
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
			prvAddCurrentTaskToDelayedList( xTimeToWake );
	}
	#endif
}
    32ec:	26 96       	adiw	r28, 0x06	; 6
    32ee:	0f b6       	in	r0, 0x3f	; 63
    32f0:	f8 94       	cli
    32f2:	de bf       	out	0x3e, r29	; 62
    32f4:	0f be       	out	0x3f, r0	; 63
    32f6:	cd bf       	out	0x3d, r28	; 61
    32f8:	cf 91       	pop	r28
    32fa:	df 91       	pop	r29
    32fc:	08 95       	ret

000032fe <vTaskPlaceOnEventListRestricted>:
/*-----------------------------------------------------------*/

#if configUSE_TIMERS == 1

	void vTaskPlaceOnEventListRestricted( const xList * const pxEventList, portTickType xTicksToWait )
	{
    32fe:	df 93       	push	r29
    3300:	cf 93       	push	r28
    3302:	00 d0       	rcall	.+0      	; 0x3304 <vTaskPlaceOnEventListRestricted+0x6>
    3304:	00 d0       	rcall	.+0      	; 0x3306 <vTaskPlaceOnEventListRestricted+0x8>
    3306:	00 d0       	rcall	.+0      	; 0x3308 <vTaskPlaceOnEventListRestricted+0xa>
    3308:	cd b7       	in	r28, 0x3d	; 61
    330a:	de b7       	in	r29, 0x3e	; 62
    330c:	9c 83       	std	Y+4, r25	; 0x04
    330e:	8b 83       	std	Y+3, r24	; 0x03
    3310:	7e 83       	std	Y+6, r23	; 0x06
    3312:	6d 83       	std	Y+5, r22	; 0x05
	
		/* Place the event list item of the TCB in the appropriate event list.
		In this case it is assume that this is the only task that is going to
		be waiting on this event list, so the faster vListInsertEnd() function
		can be used in place of vListInsert. */
		vListInsertEnd( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
    3314:	4b 81       	ldd	r20, Y+3	; 0x03
    3316:	5c 81       	ldd	r21, Y+4	; 0x04
    3318:	80 91 a8 06 	lds	r24, 0x06A8
    331c:	90 91 a9 06 	lds	r25, 0x06A9
    3320:	9c 01       	movw	r18, r24
    3322:	24 5f       	subi	r18, 0xF4	; 244
    3324:	3f 4f       	sbci	r19, 0xFF	; 255
    3326:	ca 01       	movw	r24, r20
    3328:	b9 01       	movw	r22, r18
    332a:	0e 94 95 0a 	call	0x152a	; 0x152a <vListInsertEnd>

		/* We must remove this task from the ready list before adding it to the
		blocked list as the same list item is used for both lists.  This
		function is called form a critical section. */
		vListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    332e:	80 91 a8 06 	lds	r24, 0x06A8
    3332:	90 91 a9 06 	lds	r25, 0x06A9
    3336:	02 96       	adiw	r24, 0x02	; 2
    3338:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>

		/* Calculate the time at which the task should be woken if the event does
		not occur.  This may overflow but this doesn't matter. */
		xTimeToWake = xTickCount + xTicksToWait;
    333c:	20 91 ab 06 	lds	r18, 0x06AB
    3340:	30 91 ac 06 	lds	r19, 0x06AC
    3344:	8d 81       	ldd	r24, Y+5	; 0x05
    3346:	9e 81       	ldd	r25, Y+6	; 0x06
    3348:	82 0f       	add	r24, r18
    334a:	93 1f       	adc	r25, r19
    334c:	9a 83       	std	Y+2, r25	; 0x02
    334e:	89 83       	std	Y+1, r24	; 0x01
		prvAddCurrentTaskToDelayedList( xTimeToWake );
    3350:	89 81       	ldd	r24, Y+1	; 0x01
    3352:	9a 81       	ldd	r25, Y+2	; 0x02
    3354:	0e 94 4e 1b 	call	0x369c	; 0x369c <prvAddCurrentTaskToDelayedList>
	}
    3358:	26 96       	adiw	r28, 0x06	; 6
    335a:	0f b6       	in	r0, 0x3f	; 63
    335c:	f8 94       	cli
    335e:	de bf       	out	0x3e, r29	; 62
    3360:	0f be       	out	0x3f, r0	; 63
    3362:	cd bf       	out	0x3d, r28	; 61
    3364:	cf 91       	pop	r28
    3366:	df 91       	pop	r29
    3368:	08 95       	ret

0000336a <xTaskRemoveFromEventList>:
	
#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
    336a:	df 93       	push	r29
    336c:	cf 93       	push	r28
    336e:	00 d0       	rcall	.+0      	; 0x3370 <xTaskRemoveFromEventList+0x6>
    3370:	00 d0       	rcall	.+0      	; 0x3372 <xTaskRemoveFromEventList+0x8>
    3372:	0f 92       	push	r0
    3374:	cd b7       	in	r28, 0x3d	; 61
    3376:	de b7       	in	r29, 0x3e	; 62
    3378:	9d 83       	std	Y+5, r25	; 0x05
    337a:	8c 83       	std	Y+4, r24	; 0x04
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.
	
	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    337c:	ec 81       	ldd	r30, Y+4	; 0x04
    337e:	fd 81       	ldd	r31, Y+5	; 0x05
    3380:	05 80       	ldd	r0, Z+5	; 0x05
    3382:	f6 81       	ldd	r31, Z+6	; 0x06
    3384:	e0 2d       	mov	r30, r0
    3386:	86 81       	ldd	r24, Z+6	; 0x06
    3388:	97 81       	ldd	r25, Z+7	; 0x07
    338a:	9b 83       	std	Y+3, r25	; 0x03
    338c:	8a 83       	std	Y+2, r24	; 0x02
	configASSERT( pxUnblockedTCB );
	vListRemove( &( pxUnblockedTCB->xEventListItem ) );
    338e:	8a 81       	ldd	r24, Y+2	; 0x02
    3390:	9b 81       	ldd	r25, Y+3	; 0x03
    3392:	0c 96       	adiw	r24, 0x0c	; 12
    3394:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    3398:	80 91 b0 06 	lds	r24, 0x06B0
    339c:	88 23       	and	r24, r24
    339e:	61 f5       	brne	.+88     	; 0x33f8 <xTaskRemoveFromEventList+0x8e>
	{
		vListRemove( &( pxUnblockedTCB->xGenericListItem ) );
    33a0:	8a 81       	ldd	r24, Y+2	; 0x02
    33a2:	9b 81       	ldd	r25, Y+3	; 0x03
    33a4:	02 96       	adiw	r24, 0x02	; 2
    33a6:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
    33aa:	ea 81       	ldd	r30, Y+2	; 0x02
    33ac:	fb 81       	ldd	r31, Y+3	; 0x03
    33ae:	96 89       	ldd	r25, Z+22	; 0x16
    33b0:	80 91 ae 06 	lds	r24, 0x06AE
    33b4:	89 17       	cp	r24, r25
    33b6:	28 f4       	brcc	.+10     	; 0x33c2 <xTaskRemoveFromEventList+0x58>
    33b8:	ea 81       	ldd	r30, Y+2	; 0x02
    33ba:	fb 81       	ldd	r31, Y+3	; 0x03
    33bc:	86 89       	ldd	r24, Z+22	; 0x16
    33be:	80 93 ae 06 	sts	0x06AE, r24
    33c2:	ea 81       	ldd	r30, Y+2	; 0x02
    33c4:	fb 81       	ldd	r31, Y+3	; 0x03
    33c6:	86 89       	ldd	r24, Z+22	; 0x16
    33c8:	28 2f       	mov	r18, r24
    33ca:	30 e0       	ldi	r19, 0x00	; 0
    33cc:	c9 01       	movw	r24, r18
    33ce:	88 0f       	add	r24, r24
    33d0:	99 1f       	adc	r25, r25
    33d2:	88 0f       	add	r24, r24
    33d4:	99 1f       	adc	r25, r25
    33d6:	88 0f       	add	r24, r24
    33d8:	99 1f       	adc	r25, r25
    33da:	82 0f       	add	r24, r18
    33dc:	93 1f       	adc	r25, r19
    33de:	ac 01       	movw	r20, r24
    33e0:	4b 54       	subi	r20, 0x4B	; 75
    33e2:	59 4f       	sbci	r21, 0xF9	; 249
    33e4:	8a 81       	ldd	r24, Y+2	; 0x02
    33e6:	9b 81       	ldd	r25, Y+3	; 0x03
    33e8:	9c 01       	movw	r18, r24
    33ea:	2e 5f       	subi	r18, 0xFE	; 254
    33ec:	3f 4f       	sbci	r19, 0xFF	; 255
    33ee:	ca 01       	movw	r24, r20
    33f0:	b9 01       	movw	r22, r18
    33f2:	0e 94 95 0a 	call	0x152a	; 0x152a <vListInsertEnd>
    33f6:	0a c0       	rjmp	.+20     	; 0x340c <xTaskRemoveFromEventList+0xa2>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
    33f8:	8a 81       	ldd	r24, Y+2	; 0x02
    33fa:	9b 81       	ldd	r25, Y+3	; 0x03
    33fc:	9c 01       	movw	r18, r24
    33fe:	24 5f       	subi	r18, 0xF4	; 244
    3400:	3f 4f       	sbci	r19, 0xFF	; 255
    3402:	88 ef       	ldi	r24, 0xF8	; 248
    3404:	96 e0       	ldi	r25, 0x06	; 6
    3406:	b9 01       	movw	r22, r18
    3408:	0e 94 95 0a 	call	0x152a	; 0x152a <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
    340c:	ea 81       	ldd	r30, Y+2	; 0x02
    340e:	fb 81       	ldd	r31, Y+3	; 0x03
    3410:	96 89       	ldd	r25, Z+22	; 0x16
    3412:	e0 91 a8 06 	lds	r30, 0x06A8
    3416:	f0 91 a9 06 	lds	r31, 0x06A9
    341a:	86 89       	ldd	r24, Z+22	; 0x16
    341c:	98 17       	cp	r25, r24
    341e:	18 f0       	brcs	.+6      	; 0x3426 <xTaskRemoveFromEventList+0xbc>
	{
		/* Return true if the task removed from the event list has
		a higher priority than the calling task.  This allows
		the calling task to know if it should force a context
		switch now. */
		xReturn = pdTRUE;
    3420:	81 e0       	ldi	r24, 0x01	; 1
    3422:	89 83       	std	Y+1, r24	; 0x01
    3424:	01 c0       	rjmp	.+2      	; 0x3428 <xTaskRemoveFromEventList+0xbe>
	}
	else
	{
		xReturn = pdFALSE;
    3426:	19 82       	std	Y+1, r1	; 0x01
	}

	return xReturn;
    3428:	89 81       	ldd	r24, Y+1	; 0x01
}
    342a:	0f 90       	pop	r0
    342c:	0f 90       	pop	r0
    342e:	0f 90       	pop	r0
    3430:	0f 90       	pop	r0
    3432:	0f 90       	pop	r0
    3434:	cf 91       	pop	r28
    3436:	df 91       	pop	r29
    3438:	08 95       	ret

0000343a <vTaskSetTimeOutState>:
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
    343a:	df 93       	push	r29
    343c:	cf 93       	push	r28
    343e:	00 d0       	rcall	.+0      	; 0x3440 <vTaskSetTimeOutState+0x6>
    3440:	cd b7       	in	r28, 0x3d	; 61
    3442:	de b7       	in	r29, 0x3e	; 62
    3444:	9a 83       	std	Y+2, r25	; 0x02
    3446:	89 83       	std	Y+1, r24	; 0x01
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
    3448:	80 91 b3 06 	lds	r24, 0x06B3
    344c:	e9 81       	ldd	r30, Y+1	; 0x01
    344e:	fa 81       	ldd	r31, Y+2	; 0x02
    3450:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
    3452:	80 91 ab 06 	lds	r24, 0x06AB
    3456:	90 91 ac 06 	lds	r25, 0x06AC
    345a:	e9 81       	ldd	r30, Y+1	; 0x01
    345c:	fa 81       	ldd	r31, Y+2	; 0x02
    345e:	92 83       	std	Z+2, r25	; 0x02
    3460:	81 83       	std	Z+1, r24	; 0x01
}
    3462:	0f 90       	pop	r0
    3464:	0f 90       	pop	r0
    3466:	cf 91       	pop	r28
    3468:	df 91       	pop	r29
    346a:	08 95       	ret

0000346c <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
    346c:	df 93       	push	r29
    346e:	cf 93       	push	r28
    3470:	00 d0       	rcall	.+0      	; 0x3472 <xTaskCheckForTimeOut+0x6>
    3472:	00 d0       	rcall	.+0      	; 0x3474 <xTaskCheckForTimeOut+0x8>
    3474:	0f 92       	push	r0
    3476:	cd b7       	in	r28, 0x3d	; 61
    3478:	de b7       	in	r29, 0x3e	; 62
    347a:	9b 83       	std	Y+3, r25	; 0x03
    347c:	8a 83       	std	Y+2, r24	; 0x02
    347e:	7d 83       	std	Y+5, r23	; 0x05
    3480:	6c 83       	std	Y+4, r22	; 0x04
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
    3482:	0f b6       	in	r0, 0x3f	; 63
    3484:	f8 94       	cli
    3486:	0f 92       	push	r0
	{
		#if ( INCLUDE_vTaskSuspend == 1 )
			/* If INCLUDE_vTaskSuspend is set to 1 and the block time specified is
			the maximum block time then the task should block indefinitely, and
			therefore never time out. */
			if( *pxTicksToWait == portMAX_DELAY )
    3488:	ec 81       	ldd	r30, Y+4	; 0x04
    348a:	fd 81       	ldd	r31, Y+5	; 0x05
    348c:	80 81       	ld	r24, Z
    348e:	91 81       	ldd	r25, Z+1	; 0x01
    3490:	2f ef       	ldi	r18, 0xFF	; 255
    3492:	8f 3f       	cpi	r24, 0xFF	; 255
    3494:	92 07       	cpc	r25, r18
    3496:	11 f4       	brne	.+4      	; 0x349c <xTaskCheckForTimeOut+0x30>
			{
				xReturn = pdFALSE;
    3498:	19 82       	std	Y+1, r1	; 0x01
    349a:	44 c0       	rjmp	.+136    	; 0x3524 <xTaskCheckForTimeOut+0xb8>
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
    349c:	ea 81       	ldd	r30, Y+2	; 0x02
    349e:	fb 81       	ldd	r31, Y+3	; 0x03
    34a0:	90 81       	ld	r25, Z
    34a2:	80 91 b3 06 	lds	r24, 0x06B3
    34a6:	98 17       	cp	r25, r24
    34a8:	71 f0       	breq	.+28     	; 0x34c6 <xTaskCheckForTimeOut+0x5a>
    34aa:	ea 81       	ldd	r30, Y+2	; 0x02
    34ac:	fb 81       	ldd	r31, Y+3	; 0x03
    34ae:	21 81       	ldd	r18, Z+1	; 0x01
    34b0:	32 81       	ldd	r19, Z+2	; 0x02
    34b2:	80 91 ab 06 	lds	r24, 0x06AB
    34b6:	90 91 ac 06 	lds	r25, 0x06AC
    34ba:	82 17       	cp	r24, r18
    34bc:	93 07       	cpc	r25, r19
    34be:	18 f0       	brcs	.+6      	; 0x34c6 <xTaskCheckForTimeOut+0x5a>
		{
			/* The tick count is greater than the time at which vTaskSetTimeout()
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
    34c0:	81 e0       	ldi	r24, 0x01	; 1
    34c2:	89 83       	std	Y+1, r24	; 0x01
    34c4:	2f c0       	rjmp	.+94     	; 0x3524 <xTaskCheckForTimeOut+0xb8>
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
    34c6:	20 91 ab 06 	lds	r18, 0x06AB
    34ca:	30 91 ac 06 	lds	r19, 0x06AC
    34ce:	ea 81       	ldd	r30, Y+2	; 0x02
    34d0:	fb 81       	ldd	r31, Y+3	; 0x03
    34d2:	81 81       	ldd	r24, Z+1	; 0x01
    34d4:	92 81       	ldd	r25, Z+2	; 0x02
    34d6:	28 1b       	sub	r18, r24
    34d8:	39 0b       	sbc	r19, r25
    34da:	ec 81       	ldd	r30, Y+4	; 0x04
    34dc:	fd 81       	ldd	r31, Y+5	; 0x05
    34de:	80 81       	ld	r24, Z
    34e0:	91 81       	ldd	r25, Z+1	; 0x01
    34e2:	28 17       	cp	r18, r24
    34e4:	39 07       	cpc	r19, r25
    34e6:	e0 f4       	brcc	.+56     	; 0x3520 <xTaskCheckForTimeOut+0xb4>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
    34e8:	ec 81       	ldd	r30, Y+4	; 0x04
    34ea:	fd 81       	ldd	r31, Y+5	; 0x05
    34ec:	40 81       	ld	r20, Z
    34ee:	51 81       	ldd	r21, Z+1	; 0x01
    34f0:	ea 81       	ldd	r30, Y+2	; 0x02
    34f2:	fb 81       	ldd	r31, Y+3	; 0x03
    34f4:	21 81       	ldd	r18, Z+1	; 0x01
    34f6:	32 81       	ldd	r19, Z+2	; 0x02
    34f8:	80 91 ab 06 	lds	r24, 0x06AB
    34fc:	90 91 ac 06 	lds	r25, 0x06AC
    3500:	b9 01       	movw	r22, r18
    3502:	68 1b       	sub	r22, r24
    3504:	79 0b       	sbc	r23, r25
    3506:	cb 01       	movw	r24, r22
    3508:	84 0f       	add	r24, r20
    350a:	95 1f       	adc	r25, r21
    350c:	ec 81       	ldd	r30, Y+4	; 0x04
    350e:	fd 81       	ldd	r31, Y+5	; 0x05
    3510:	91 83       	std	Z+1, r25	; 0x01
    3512:	80 83       	st	Z, r24
			vTaskSetTimeOutState( pxTimeOut );
    3514:	8a 81       	ldd	r24, Y+2	; 0x02
    3516:	9b 81       	ldd	r25, Y+3	; 0x03
    3518:	0e 94 1d 1a 	call	0x343a	; 0x343a <vTaskSetTimeOutState>
			xReturn = pdFALSE;
    351c:	19 82       	std	Y+1, r1	; 0x01
    351e:	02 c0       	rjmp	.+4      	; 0x3524 <xTaskCheckForTimeOut+0xb8>
		}
		else
		{
			xReturn = pdTRUE;
    3520:	81 e0       	ldi	r24, 0x01	; 1
    3522:	89 83       	std	Y+1, r24	; 0x01
		}
	}
	taskEXIT_CRITICAL();
    3524:	0f 90       	pop	r0
    3526:	0f be       	out	0x3f, r0	; 63

	return xReturn;
    3528:	89 81       	ldd	r24, Y+1	; 0x01
}
    352a:	0f 90       	pop	r0
    352c:	0f 90       	pop	r0
    352e:	0f 90       	pop	r0
    3530:	0f 90       	pop	r0
    3532:	0f 90       	pop	r0
    3534:	cf 91       	pop	r28
    3536:	df 91       	pop	r29
    3538:	08 95       	ret

0000353a <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
    353a:	df 93       	push	r29
    353c:	cf 93       	push	r28
    353e:	cd b7       	in	r28, 0x3d	; 61
    3540:	de b7       	in	r29, 0x3e	; 62
	xMissedYield = pdTRUE;
    3542:	81 e0       	ldi	r24, 0x01	; 1
    3544:	80 93 b2 06 	sts	0x06B2, r24
}
    3548:	cf 91       	pop	r28
    354a:	df 91       	pop	r29
    354c:	08 95       	ret

0000354e <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
    354e:	df 93       	push	r29
    3550:	cf 93       	push	r28
    3552:	00 d0       	rcall	.+0      	; 0x3554 <prvIdleTask+0x6>
    3554:	cd b7       	in	r28, 0x3d	; 61
    3556:	de b7       	in	r29, 0x3e	; 62
    3558:	9a 83       	std	Y+2, r25	; 0x02
    355a:	89 83       	std	Y+1, r24	; 0x01
	( void ) pvParameters;

	for( ;; )
	{
		/* See if any tasks have been deleted. */
		prvCheckTasksWaitingTermination();
    355c:	0e 94 47 1b 	call	0x368e	; 0x368e <prvCheckTasksWaitingTermination>
		{
			/* If we are not using preemption we keep forcing a task switch to
			see if any other task has become available.  If we are using
			preemption we don't need to do this as any task becoming available
			will automatically get the processor anyway. */
			taskYIELD();
    3560:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <vPortYield>
    3564:	fb cf       	rjmp	.-10     	; 0x355c <prvIdleTask+0xe>

00003566 <prvInitialiseTCBVariables>:
 *----------------------------------------------------------*/



static void prvInitialiseTCBVariables( tskTCB *pxTCB, const signed char * const pcName, unsigned portBASE_TYPE uxPriority, const xMemoryRegion * const xRegions, unsigned short usStackDepth )
{
    3566:	0f 93       	push	r16
    3568:	1f 93       	push	r17
    356a:	df 93       	push	r29
    356c:	cf 93       	push	r28
    356e:	cd b7       	in	r28, 0x3d	; 61
    3570:	de b7       	in	r29, 0x3e	; 62
    3572:	29 97       	sbiw	r28, 0x09	; 9
    3574:	0f b6       	in	r0, 0x3f	; 63
    3576:	f8 94       	cli
    3578:	de bf       	out	0x3e, r29	; 62
    357a:	0f be       	out	0x3f, r0	; 63
    357c:	cd bf       	out	0x3d, r28	; 61
    357e:	9a 83       	std	Y+2, r25	; 0x02
    3580:	89 83       	std	Y+1, r24	; 0x01
    3582:	7c 83       	std	Y+4, r23	; 0x04
    3584:	6b 83       	std	Y+3, r22	; 0x03
    3586:	4d 83       	std	Y+5, r20	; 0x05
    3588:	3f 83       	std	Y+7, r19	; 0x07
    358a:	2e 83       	std	Y+6, r18	; 0x06
    358c:	19 87       	std	Y+9, r17	; 0x09
    358e:	08 87       	std	Y+8, r16	; 0x08
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
    3590:	89 81       	ldd	r24, Y+1	; 0x01
    3592:	9a 81       	ldd	r25, Y+2	; 0x02
    3594:	49 96       	adiw	r24, 0x19	; 25
    3596:	2b 81       	ldd	r18, Y+3	; 0x03
    3598:	3c 81       	ldd	r19, Y+4	; 0x04
    359a:	b9 01       	movw	r22, r18
    359c:	48 e0       	ldi	r20, 0x08	; 8
    359e:	50 e0       	ldi	r21, 0x00	; 0
    35a0:	0e 94 16 32 	call	0x642c	; 0x642c <strncpy>
	}
	#endif
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
    35a4:	e9 81       	ldd	r30, Y+1	; 0x01
    35a6:	fa 81       	ldd	r31, Y+2	; 0x02
    35a8:	10 a2       	std	Z+32, r1	; 0x20

	/* This is used as an array index so must ensure it's not too large.  First
	remove the privilege bit if one is present. */
	if( uxPriority >= configMAX_PRIORITIES )
    35aa:	8d 81       	ldd	r24, Y+5	; 0x05
    35ac:	85 30       	cpi	r24, 0x05	; 5
    35ae:	10 f0       	brcs	.+4      	; 0x35b4 <prvInitialiseTCBVariables+0x4e>
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
    35b0:	84 e0       	ldi	r24, 0x04	; 4
    35b2:	8d 83       	std	Y+5, r24	; 0x05
	}

	pxTCB->uxPriority = uxPriority;
    35b4:	e9 81       	ldd	r30, Y+1	; 0x01
    35b6:	fa 81       	ldd	r31, Y+2	; 0x02
    35b8:	8d 81       	ldd	r24, Y+5	; 0x05
    35ba:	86 8b       	std	Z+22, r24	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
    35bc:	89 81       	ldd	r24, Y+1	; 0x01
    35be:	9a 81       	ldd	r25, Y+2	; 0x02
    35c0:	02 96       	adiw	r24, 0x02	; 2
    35c2:	0e 94 85 0a 	call	0x150a	; 0x150a <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
    35c6:	89 81       	ldd	r24, Y+1	; 0x01
    35c8:	9a 81       	ldd	r25, Y+2	; 0x02
    35ca:	0c 96       	adiw	r24, 0x0c	; 12
    35cc:	0e 94 85 0a 	call	0x150a	; 0x150a <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
    35d0:	e9 81       	ldd	r30, Y+1	; 0x01
    35d2:	fa 81       	ldd	r31, Y+2	; 0x02
    35d4:	89 81       	ldd	r24, Y+1	; 0x01
    35d6:	9a 81       	ldd	r25, Y+2	; 0x02
    35d8:	91 87       	std	Z+9, r25	; 0x09
    35da:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    35dc:	8d 81       	ldd	r24, Y+5	; 0x05
    35de:	28 2f       	mov	r18, r24
    35e0:	30 e0       	ldi	r19, 0x00	; 0
    35e2:	85 e0       	ldi	r24, 0x05	; 5
    35e4:	90 e0       	ldi	r25, 0x00	; 0
    35e6:	82 1b       	sub	r24, r18
    35e8:	93 0b       	sbc	r25, r19
    35ea:	e9 81       	ldd	r30, Y+1	; 0x01
    35ec:	fa 81       	ldd	r31, Y+2	; 0x02
    35ee:	95 87       	std	Z+13, r25	; 0x0d
    35f0:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
    35f2:	e9 81       	ldd	r30, Y+1	; 0x01
    35f4:	fa 81       	ldd	r31, Y+2	; 0x02
    35f6:	89 81       	ldd	r24, Y+1	; 0x01
    35f8:	9a 81       	ldd	r25, Y+2	; 0x02
    35fa:	93 8b       	std	Z+19, r25	; 0x13
    35fc:	82 8b       	std	Z+18, r24	; 0x12
	{
		( void ) xRegions;
		( void ) usStackDepth;
	}
	#endif
}
    35fe:	29 96       	adiw	r28, 0x09	; 9
    3600:	0f b6       	in	r0, 0x3f	; 63
    3602:	f8 94       	cli
    3604:	de bf       	out	0x3e, r29	; 62
    3606:	0f be       	out	0x3f, r0	; 63
    3608:	cd bf       	out	0x3d, r28	; 61
    360a:	cf 91       	pop	r28
    360c:	df 91       	pop	r29
    360e:	1f 91       	pop	r17
    3610:	0f 91       	pop	r16
    3612:	08 95       	ret

00003614 <prvInitialiseTaskLists>:
	}
	/*-----------------------------------------------------------*/
#endif

static void prvInitialiseTaskLists( void )
{
    3614:	df 93       	push	r29
    3616:	cf 93       	push	r28
    3618:	0f 92       	push	r0
    361a:	cd b7       	in	r28, 0x3d	; 61
    361c:	de b7       	in	r29, 0x3e	; 62
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    361e:	19 82       	std	Y+1, r1	; 0x01
    3620:	13 c0       	rjmp	.+38     	; 0x3648 <prvInitialiseTaskLists+0x34>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
    3622:	89 81       	ldd	r24, Y+1	; 0x01
    3624:	28 2f       	mov	r18, r24
    3626:	30 e0       	ldi	r19, 0x00	; 0
    3628:	c9 01       	movw	r24, r18
    362a:	88 0f       	add	r24, r24
    362c:	99 1f       	adc	r25, r25
    362e:	88 0f       	add	r24, r24
    3630:	99 1f       	adc	r25, r25
    3632:	88 0f       	add	r24, r24
    3634:	99 1f       	adc	r25, r25
    3636:	82 0f       	add	r24, r18
    3638:	93 1f       	adc	r25, r19
    363a:	8b 54       	subi	r24, 0x4B	; 75
    363c:	99 4f       	sbci	r25, 0xF9	; 249
    363e:	0e 94 5b 0a 	call	0x14b6	; 0x14b6 <vListInitialise>

static void prvInitialiseTaskLists( void )
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
    3642:	89 81       	ldd	r24, Y+1	; 0x01
    3644:	8f 5f       	subi	r24, 0xFF	; 255
    3646:	89 83       	std	Y+1, r24	; 0x01
    3648:	89 81       	ldd	r24, Y+1	; 0x01
    364a:	85 30       	cpi	r24, 0x05	; 5
    364c:	50 f3       	brcs	.-44     	; 0x3622 <prvInitialiseTaskLists+0xe>
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
    364e:	82 ee       	ldi	r24, 0xE2	; 226
    3650:	96 e0       	ldi	r25, 0x06	; 6
    3652:	0e 94 5b 0a 	call	0x14b6	; 0x14b6 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
    3656:	8b ee       	ldi	r24, 0xEB	; 235
    3658:	96 e0       	ldi	r25, 0x06	; 6
    365a:	0e 94 5b 0a 	call	0x14b6	; 0x14b6 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
    365e:	88 ef       	ldi	r24, 0xF8	; 248
    3660:	96 e0       	ldi	r25, 0x06	; 6
    3662:	0e 94 5b 0a 	call	0x14b6	; 0x14b6 <vListInitialise>
	}
	#endif

	#if ( INCLUDE_vTaskSuspend == 1 )
	{
		vListInitialise( ( xList * ) &xSuspendedTaskList );
    3666:	81 e0       	ldi	r24, 0x01	; 1
    3668:	97 e0       	ldi	r25, 0x07	; 7
    366a:	0e 94 5b 0a 	call	0x14b6	; 0x14b6 <vListInitialise>
	}
	#endif

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
    366e:	82 ee       	ldi	r24, 0xE2	; 226
    3670:	96 e0       	ldi	r25, 0x06	; 6
    3672:	90 93 f5 06 	sts	0x06F5, r25
    3676:	80 93 f4 06 	sts	0x06F4, r24
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
    367a:	8b ee       	ldi	r24, 0xEB	; 235
    367c:	96 e0       	ldi	r25, 0x06	; 6
    367e:	90 93 f7 06 	sts	0x06F7, r25
    3682:	80 93 f6 06 	sts	0x06F6, r24
}
    3686:	0f 90       	pop	r0
    3688:	cf 91       	pop	r28
    368a:	df 91       	pop	r29
    368c:	08 95       	ret

0000368e <prvCheckTasksWaitingTermination>:
/*-----------------------------------------------------------*/

static void prvCheckTasksWaitingTermination( void )
{
    368e:	df 93       	push	r29
    3690:	cf 93       	push	r28
    3692:	cd b7       	in	r28, 0x3d	; 61
    3694:	de b7       	in	r29, 0x3e	; 62
				prvDeleteTCB( pxTCB );
			}
		}
	}
	#endif
}
    3696:	cf 91       	pop	r28
    3698:	df 91       	pop	r29
    369a:	08 95       	ret

0000369c <prvAddCurrentTaskToDelayedList>:
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
    369c:	df 93       	push	r29
    369e:	cf 93       	push	r28
    36a0:	00 d0       	rcall	.+0      	; 0x36a2 <prvAddCurrentTaskToDelayedList+0x6>
    36a2:	cd b7       	in	r28, 0x3d	; 61
    36a4:	de b7       	in	r29, 0x3e	; 62
    36a6:	9a 83       	std	Y+2, r25	; 0x02
    36a8:	89 83       	std	Y+1, r24	; 0x01
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
    36aa:	e0 91 a8 06 	lds	r30, 0x06A8
    36ae:	f0 91 a9 06 	lds	r31, 0x06A9
    36b2:	89 81       	ldd	r24, Y+1	; 0x01
    36b4:	9a 81       	ldd	r25, Y+2	; 0x02
    36b6:	93 83       	std	Z+3, r25	; 0x03
    36b8:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
    36ba:	20 91 ab 06 	lds	r18, 0x06AB
    36be:	30 91 ac 06 	lds	r19, 0x06AC
    36c2:	89 81       	ldd	r24, Y+1	; 0x01
    36c4:	9a 81       	ldd	r25, Y+2	; 0x02
    36c6:	82 17       	cp	r24, r18
    36c8:	93 07       	cpc	r25, r19
    36ca:	70 f4       	brcc	.+28     	; 0x36e8 <prvAddCurrentTaskToDelayedList+0x4c>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    36cc:	80 91 f6 06 	lds	r24, 0x06F6
    36d0:	90 91 f7 06 	lds	r25, 0x06F7
    36d4:	20 91 a8 06 	lds	r18, 0x06A8
    36d8:	30 91 a9 06 	lds	r19, 0x06A9
    36dc:	2e 5f       	subi	r18, 0xFE	; 254
    36de:	3f 4f       	sbci	r19, 0xFF	; 255
    36e0:	b9 01       	movw	r22, r18
    36e2:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <vListInsert>
    36e6:	1e c0       	rjmp	.+60     	; 0x3724 <prvAddCurrentTaskToDelayedList+0x88>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
    36e8:	40 91 f4 06 	lds	r20, 0x06F4
    36ec:	50 91 f5 06 	lds	r21, 0x06F5
    36f0:	80 91 a8 06 	lds	r24, 0x06A8
    36f4:	90 91 a9 06 	lds	r25, 0x06A9
    36f8:	9c 01       	movw	r18, r24
    36fa:	2e 5f       	subi	r18, 0xFE	; 254
    36fc:	3f 4f       	sbci	r19, 0xFF	; 255
    36fe:	ca 01       	movw	r24, r20
    3700:	b9 01       	movw	r22, r18
    3702:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
    3706:	20 91 9f 01 	lds	r18, 0x019F
    370a:	30 91 a0 01 	lds	r19, 0x01A0
    370e:	89 81       	ldd	r24, Y+1	; 0x01
    3710:	9a 81       	ldd	r25, Y+2	; 0x02
    3712:	82 17       	cp	r24, r18
    3714:	93 07       	cpc	r25, r19
    3716:	30 f4       	brcc	.+12     	; 0x3724 <prvAddCurrentTaskToDelayedList+0x88>
		{
			xNextTaskUnblockTime = xTimeToWake;
    3718:	89 81       	ldd	r24, Y+1	; 0x01
    371a:	9a 81       	ldd	r25, Y+2	; 0x02
    371c:	90 93 a0 01 	sts	0x01A0, r25
    3720:	80 93 9f 01 	sts	0x019F, r24
		}
	}
}
    3724:	0f 90       	pop	r0
    3726:	0f 90       	pop	r0
    3728:	cf 91       	pop	r28
    372a:	df 91       	pop	r29
    372c:	08 95       	ret

0000372e <prvAllocateTCBAndStack>:
/*-----------------------------------------------------------*/

static tskTCB *prvAllocateTCBAndStack( unsigned short usStackDepth, portSTACK_TYPE *puxStackBuffer )
{
    372e:	df 93       	push	r29
    3730:	cf 93       	push	r28
    3732:	cd b7       	in	r28, 0x3d	; 61
    3734:	de b7       	in	r29, 0x3e	; 62
    3736:	28 97       	sbiw	r28, 0x08	; 8
    3738:	0f b6       	in	r0, 0x3f	; 63
    373a:	f8 94       	cli
    373c:	de bf       	out	0x3e, r29	; 62
    373e:	0f be       	out	0x3f, r0	; 63
    3740:	cd bf       	out	0x3d, r28	; 61
    3742:	9c 83       	std	Y+4, r25	; 0x04
    3744:	8b 83       	std	Y+3, r24	; 0x03
    3746:	7e 83       	std	Y+6, r23	; 0x06
    3748:	6d 83       	std	Y+5, r22	; 0x05
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
    374a:	81 e2       	ldi	r24, 0x21	; 33
    374c:	90 e0       	ldi	r25, 0x00	; 0
    374e:	0e 94 ef 09 	call	0x13de	; 0x13de <pvPortMalloc>
    3752:	9a 83       	std	Y+2, r25	; 0x02
    3754:	89 83       	std	Y+1, r24	; 0x01

	if( pxNewTCB != NULL )
    3756:	89 81       	ldd	r24, Y+1	; 0x01
    3758:	9a 81       	ldd	r25, Y+2	; 0x02
    375a:	00 97       	sbiw	r24, 0x00	; 0
    375c:	69 f1       	breq	.+90     	; 0x37b8 <prvAllocateTCBAndStack+0x8a>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
    375e:	8d 81       	ldd	r24, Y+5	; 0x05
    3760:	9e 81       	ldd	r25, Y+6	; 0x06
    3762:	00 97       	sbiw	r24, 0x00	; 0
    3764:	39 f4       	brne	.+14     	; 0x3774 <prvAllocateTCBAndStack+0x46>
    3766:	8b 81       	ldd	r24, Y+3	; 0x03
    3768:	9c 81       	ldd	r25, Y+4	; 0x04
    376a:	0e 94 ef 09 	call	0x13de	; 0x13de <pvPortMalloc>
    376e:	98 87       	std	Y+8, r25	; 0x08
    3770:	8f 83       	std	Y+7, r24	; 0x07
    3772:	04 c0       	rjmp	.+8      	; 0x377c <prvAllocateTCBAndStack+0x4e>
    3774:	8d 81       	ldd	r24, Y+5	; 0x05
    3776:	9e 81       	ldd	r25, Y+6	; 0x06
    3778:	98 87       	std	Y+8, r25	; 0x08
    377a:	8f 83       	std	Y+7, r24	; 0x07
    377c:	e9 81       	ldd	r30, Y+1	; 0x01
    377e:	fa 81       	ldd	r31, Y+2	; 0x02
    3780:	8f 81       	ldd	r24, Y+7	; 0x07
    3782:	98 85       	ldd	r25, Y+8	; 0x08
    3784:	90 8f       	std	Z+24, r25	; 0x18
    3786:	87 8b       	std	Z+23, r24	; 0x17

		if( pxNewTCB->pxStack == NULL )
    3788:	e9 81       	ldd	r30, Y+1	; 0x01
    378a:	fa 81       	ldd	r31, Y+2	; 0x02
    378c:	87 89       	ldd	r24, Z+23	; 0x17
    378e:	90 8d       	ldd	r25, Z+24	; 0x18
    3790:	00 97       	sbiw	r24, 0x00	; 0
    3792:	39 f4       	brne	.+14     	; 0x37a2 <prvAllocateTCBAndStack+0x74>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
    3794:	89 81       	ldd	r24, Y+1	; 0x01
    3796:	9a 81       	ldd	r25, Y+2	; 0x02
    3798:	0e 94 35 0a 	call	0x146a	; 0x146a <vPortFree>
			pxNewTCB = NULL;
    379c:	1a 82       	std	Y+2, r1	; 0x02
    379e:	19 82       	std	Y+1, r1	; 0x01
    37a0:	0b c0       	rjmp	.+22     	; 0x37b8 <prvAllocateTCBAndStack+0x8a>
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
    37a2:	e9 81       	ldd	r30, Y+1	; 0x01
    37a4:	fa 81       	ldd	r31, Y+2	; 0x02
    37a6:	87 89       	ldd	r24, Z+23	; 0x17
    37a8:	90 8d       	ldd	r25, Z+24	; 0x18
    37aa:	2b 81       	ldd	r18, Y+3	; 0x03
    37ac:	3c 81       	ldd	r19, Y+4	; 0x04
    37ae:	65 ea       	ldi	r22, 0xA5	; 165
    37b0:	70 e0       	ldi	r23, 0x00	; 0
    37b2:	a9 01       	movw	r20, r18
    37b4:	0e 94 0f 32 	call	0x641e	; 0x641e <memset>
		}
	}

	return pxNewTCB;
    37b8:	89 81       	ldd	r24, Y+1	; 0x01
    37ba:	9a 81       	ldd	r25, Y+2	; 0x02
}
    37bc:	28 96       	adiw	r28, 0x08	; 8
    37be:	0f b6       	in	r0, 0x3f	; 63
    37c0:	f8 94       	cli
    37c2:	de bf       	out	0x3e, r29	; 62
    37c4:	0f be       	out	0x3f, r0	; 63
    37c6:	cd bf       	out	0x3d, r28	; 61
    37c8:	cf 91       	pop	r28
    37ca:	df 91       	pop	r29
    37cc:	08 95       	ret

000037ce <xTaskGetSchedulerState>:
/*-----------------------------------------------------------*/

#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )

	portBASE_TYPE xTaskGetSchedulerState( void )
	{
    37ce:	df 93       	push	r29
    37d0:	cf 93       	push	r28
    37d2:	0f 92       	push	r0
    37d4:	cd b7       	in	r28, 0x3d	; 61
    37d6:	de b7       	in	r29, 0x3e	; 62
	portBASE_TYPE xReturn;

		if( xSchedulerRunning == pdFALSE )
    37d8:	80 91 af 06 	lds	r24, 0x06AF
    37dc:	88 23       	and	r24, r24
    37de:	11 f4       	brne	.+4      	; 0x37e4 <xTaskGetSchedulerState+0x16>
		{
			xReturn = taskSCHEDULER_NOT_STARTED;
    37e0:	19 82       	std	Y+1, r1	; 0x01
    37e2:	09 c0       	rjmp	.+18     	; 0x37f6 <xTaskGetSchedulerState+0x28>
		}
		else
		{
			if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
    37e4:	80 91 b0 06 	lds	r24, 0x06B0
    37e8:	88 23       	and	r24, r24
    37ea:	19 f4       	brne	.+6      	; 0x37f2 <xTaskGetSchedulerState+0x24>
			{
				xReturn = taskSCHEDULER_RUNNING;
    37ec:	81 e0       	ldi	r24, 0x01	; 1
    37ee:	89 83       	std	Y+1, r24	; 0x01
    37f0:	02 c0       	rjmp	.+4      	; 0x37f6 <xTaskGetSchedulerState+0x28>
			}
			else
			{
				xReturn = taskSCHEDULER_SUSPENDED;
    37f2:	82 e0       	ldi	r24, 0x02	; 2
    37f4:	89 83       	std	Y+1, r24	; 0x01
			}
		}

		return xReturn;
    37f6:	89 81       	ldd	r24, Y+1	; 0x01
	}
    37f8:	0f 90       	pop	r0
    37fa:	cf 91       	pop	r28
    37fc:	df 91       	pop	r29
    37fe:	08 95       	ret

00003800 <xTimerCreateTimerTask>:
static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty ) PRIVILEGED_FUNCTION;

/*-----------------------------------------------------------*/

portBASE_TYPE xTimerCreateTimerTask( void )
{
    3800:	af 92       	push	r10
    3802:	bf 92       	push	r11
    3804:	cf 92       	push	r12
    3806:	df 92       	push	r13
    3808:	ef 92       	push	r14
    380a:	ff 92       	push	r15
    380c:	0f 93       	push	r16
    380e:	df 93       	push	r29
    3810:	cf 93       	push	r28
    3812:	0f 92       	push	r0
    3814:	cd b7       	in	r28, 0x3d	; 61
    3816:	de b7       	in	r29, 0x3e	; 62
portBASE_TYPE xReturn = pdFAIL;
    3818:	19 82       	std	Y+1, r1	; 0x01

	/* This function is called when the scheduler is started if
	configUSE_TIMERS is set to 1.  Check that the infrastructure used by the
	timer service task has been created/initialised.  If timers have already
	been created then the initialisation will already have been performed. */
	prvCheckForValidListAndQueue();
    381a:	0e 94 cb 1f 	call	0x3f96	; 0x3f96 <prvCheckForValidListAndQueue>

	if( xTimerQueue != NULL )
    381e:	80 91 0a 07 	lds	r24, 0x070A
    3822:	90 91 0b 07 	lds	r25, 0x070B
    3826:	00 97       	sbiw	r24, 0x00	; 0
    3828:	99 f0       	breq	.+38     	; 0x3850 <xTimerCreateTimerTask+0x50>
			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY, &xTimerTaskHandle );
		}
		#else
		{
			/* Create the timer task without storing its handle. */
			xReturn = xTaskCreate( prvTimerTask, ( const signed char * ) "Tmr Svc", ( unsigned short ) configTIMER_TASK_STACK_DEPTH, NULL, ( unsigned portBASE_TYPE ) configTIMER_TASK_PRIORITY, NULL);
    382a:	25 e6       	ldi	r18, 0x65	; 101
    382c:	30 e0       	ldi	r19, 0x00	; 0
    382e:	8c e4       	ldi	r24, 0x4C	; 76
    3830:	9d e1       	ldi	r25, 0x1D	; 29
    3832:	b9 01       	movw	r22, r18
    3834:	45 e5       	ldi	r20, 0x55	; 85
    3836:	50 e0       	ldi	r21, 0x00	; 0
    3838:	20 e0       	ldi	r18, 0x00	; 0
    383a:	30 e0       	ldi	r19, 0x00	; 0
    383c:	04 e0       	ldi	r16, 0x04	; 4
    383e:	ee 24       	eor	r14, r14
    3840:	ff 24       	eor	r15, r15
    3842:	cc 24       	eor	r12, r12
    3844:	dd 24       	eor	r13, r13
    3846:	aa 24       	eor	r10, r10
    3848:	bb 24       	eor	r11, r11
    384a:	0e 94 47 13 	call	0x268e	; 0x268e <xTaskGenericCreate>
    384e:	89 83       	std	Y+1, r24	; 0x01
		}
		#endif
	}

	configASSERT( xReturn );
	return xReturn;
    3850:	89 81       	ldd	r24, Y+1	; 0x01
}
    3852:	0f 90       	pop	r0
    3854:	cf 91       	pop	r28
    3856:	df 91       	pop	r29
    3858:	0f 91       	pop	r16
    385a:	ff 90       	pop	r15
    385c:	ef 90       	pop	r14
    385e:	df 90       	pop	r13
    3860:	cf 90       	pop	r12
    3862:	bf 90       	pop	r11
    3864:	af 90       	pop	r10
    3866:	08 95       	ret

00003868 <xTimerCreate>:
/*-----------------------------------------------------------*/

xTimerHandle xTimerCreate( const signed char *pcTimerName, portTickType xTimerPeriodInTicks, unsigned portBASE_TYPE uxAutoReload, void *pvTimerID, tmrTIMER_CALLBACK pxCallbackFunction )
{
    3868:	0f 93       	push	r16
    386a:	1f 93       	push	r17
    386c:	df 93       	push	r29
    386e:	cf 93       	push	r28
    3870:	cd b7       	in	r28, 0x3d	; 61
    3872:	de b7       	in	r29, 0x3e	; 62
    3874:	2b 97       	sbiw	r28, 0x0b	; 11
    3876:	0f b6       	in	r0, 0x3f	; 63
    3878:	f8 94       	cli
    387a:	de bf       	out	0x3e, r29	; 62
    387c:	0f be       	out	0x3f, r0	; 63
    387e:	cd bf       	out	0x3d, r28	; 61
    3880:	9c 83       	std	Y+4, r25	; 0x04
    3882:	8b 83       	std	Y+3, r24	; 0x03
    3884:	7e 83       	std	Y+6, r23	; 0x06
    3886:	6d 83       	std	Y+5, r22	; 0x05
    3888:	4f 83       	std	Y+7, r20	; 0x07
    388a:	39 87       	std	Y+9, r19	; 0x09
    388c:	28 87       	std	Y+8, r18	; 0x08
    388e:	1b 87       	std	Y+11, r17	; 0x0b
    3890:	0a 87       	std	Y+10, r16	; 0x0a
xTIMER *pxNewTimer;

	/* Allocate the timer structure. */
	if( xTimerPeriodInTicks == ( portTickType ) 0U )
    3892:	8d 81       	ldd	r24, Y+5	; 0x05
    3894:	9e 81       	ldd	r25, Y+6	; 0x06
    3896:	00 97       	sbiw	r24, 0x00	; 0
    3898:	19 f4       	brne	.+6      	; 0x38a0 <xTimerCreate+0x38>
	{
		pxNewTimer = NULL;
    389a:	1a 82       	std	Y+2, r1	; 0x02
    389c:	19 82       	std	Y+1, r1	; 0x01
    389e:	2d c0       	rjmp	.+90     	; 0x38fa <xTimerCreate+0x92>
		configASSERT( ( xTimerPeriodInTicks > 0 ) );
	}
	else
	{
		pxNewTimer = ( xTIMER * ) pvPortMalloc( sizeof( xTIMER ) );
    38a0:	83 e1       	ldi	r24, 0x13	; 19
    38a2:	90 e0       	ldi	r25, 0x00	; 0
    38a4:	0e 94 ef 09 	call	0x13de	; 0x13de <pvPortMalloc>
    38a8:	9a 83       	std	Y+2, r25	; 0x02
    38aa:	89 83       	std	Y+1, r24	; 0x01
		if( pxNewTimer != NULL )
    38ac:	89 81       	ldd	r24, Y+1	; 0x01
    38ae:	9a 81       	ldd	r25, Y+2	; 0x02
    38b0:	00 97       	sbiw	r24, 0x00	; 0
    38b2:	19 f1       	breq	.+70     	; 0x38fa <xTimerCreate+0x92>
		{
			/* Ensure the infrastructure used by the timer service task has been
			created/initialised. */
			prvCheckForValidListAndQueue();
    38b4:	0e 94 cb 1f 	call	0x3f96	; 0x3f96 <prvCheckForValidListAndQueue>

			/* Initialise the timer structure members using the function parameters. */
			pxNewTimer->pcTimerName = pcTimerName;
    38b8:	e9 81       	ldd	r30, Y+1	; 0x01
    38ba:	fa 81       	ldd	r31, Y+2	; 0x02
    38bc:	8b 81       	ldd	r24, Y+3	; 0x03
    38be:	9c 81       	ldd	r25, Y+4	; 0x04
    38c0:	91 83       	std	Z+1, r25	; 0x01
    38c2:	80 83       	st	Z, r24
			pxNewTimer->xTimerPeriodInTicks = xTimerPeriodInTicks;
    38c4:	e9 81       	ldd	r30, Y+1	; 0x01
    38c6:	fa 81       	ldd	r31, Y+2	; 0x02
    38c8:	8d 81       	ldd	r24, Y+5	; 0x05
    38ca:	9e 81       	ldd	r25, Y+6	; 0x06
    38cc:	95 87       	std	Z+13, r25	; 0x0d
    38ce:	84 87       	std	Z+12, r24	; 0x0c
			pxNewTimer->uxAutoReload = uxAutoReload;
    38d0:	e9 81       	ldd	r30, Y+1	; 0x01
    38d2:	fa 81       	ldd	r31, Y+2	; 0x02
    38d4:	8f 81       	ldd	r24, Y+7	; 0x07
    38d6:	86 87       	std	Z+14, r24	; 0x0e
			pxNewTimer->pvTimerID = pvTimerID;
    38d8:	e9 81       	ldd	r30, Y+1	; 0x01
    38da:	fa 81       	ldd	r31, Y+2	; 0x02
    38dc:	88 85       	ldd	r24, Y+8	; 0x08
    38de:	99 85       	ldd	r25, Y+9	; 0x09
    38e0:	90 8b       	std	Z+16, r25	; 0x10
    38e2:	87 87       	std	Z+15, r24	; 0x0f
			pxNewTimer->pxCallbackFunction = pxCallbackFunction;
    38e4:	e9 81       	ldd	r30, Y+1	; 0x01
    38e6:	fa 81       	ldd	r31, Y+2	; 0x02
    38e8:	8a 85       	ldd	r24, Y+10	; 0x0a
    38ea:	9b 85       	ldd	r25, Y+11	; 0x0b
    38ec:	92 8b       	std	Z+18, r25	; 0x12
    38ee:	81 8b       	std	Z+17, r24	; 0x11
			vListInitialiseItem( &( pxNewTimer->xTimerListItem ) );
    38f0:	89 81       	ldd	r24, Y+1	; 0x01
    38f2:	9a 81       	ldd	r25, Y+2	; 0x02
    38f4:	02 96       	adiw	r24, 0x02	; 2
    38f6:	0e 94 85 0a 	call	0x150a	; 0x150a <vListInitialiseItem>
		{
			traceTIMER_CREATE_FAILED();
		}
	}

	return ( xTimerHandle ) pxNewTimer;
    38fa:	89 81       	ldd	r24, Y+1	; 0x01
    38fc:	9a 81       	ldd	r25, Y+2	; 0x02
}
    38fe:	2b 96       	adiw	r28, 0x0b	; 11
    3900:	0f b6       	in	r0, 0x3f	; 63
    3902:	f8 94       	cli
    3904:	de bf       	out	0x3e, r29	; 62
    3906:	0f be       	out	0x3f, r0	; 63
    3908:	cd bf       	out	0x3d, r28	; 61
    390a:	cf 91       	pop	r28
    390c:	df 91       	pop	r29
    390e:	1f 91       	pop	r17
    3910:	0f 91       	pop	r16
    3912:	08 95       	ret

00003914 <xTimerGenericCommand>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerGenericCommand( xTimerHandle xTimer, portBASE_TYPE xCommandID, portTickType xOptionalValue, portBASE_TYPE *pxHigherPriorityTaskWoken, portTickType xBlockTime )
{
    3914:	0f 93       	push	r16
    3916:	1f 93       	push	r17
    3918:	df 93       	push	r29
    391a:	cf 93       	push	r28
    391c:	cd b7       	in	r28, 0x3d	; 61
    391e:	de b7       	in	r29, 0x3e	; 62
    3920:	2f 97       	sbiw	r28, 0x0f	; 15
    3922:	0f b6       	in	r0, 0x3f	; 63
    3924:	f8 94       	cli
    3926:	de bf       	out	0x3e, r29	; 62
    3928:	0f be       	out	0x3f, r0	; 63
    392a:	cd bf       	out	0x3d, r28	; 61
    392c:	98 87       	std	Y+8, r25	; 0x08
    392e:	8f 83       	std	Y+7, r24	; 0x07
    3930:	69 87       	std	Y+9, r22	; 0x09
    3932:	5b 87       	std	Y+11, r21	; 0x0b
    3934:	4a 87       	std	Y+10, r20	; 0x0a
    3936:	3d 87       	std	Y+13, r19	; 0x0d
    3938:	2c 87       	std	Y+12, r18	; 0x0c
    393a:	1f 87       	std	Y+15, r17	; 0x0f
    393c:	0e 87       	std	Y+14, r16	; 0x0e
portBASE_TYPE xReturn = pdFAIL;
    393e:	19 82       	std	Y+1, r1	; 0x01
xTIMER_MESSAGE xMessage;

	/* Send a message to the timer service task to perform a particular action
	on a particular timer definition. */
	if( xTimerQueue != NULL )
    3940:	80 91 0a 07 	lds	r24, 0x070A
    3944:	90 91 0b 07 	lds	r25, 0x070B
    3948:	00 97       	sbiw	r24, 0x00	; 0
    394a:	09 f4       	brne	.+2      	; 0x394e <xTimerGenericCommand+0x3a>
    394c:	3e c0       	rjmp	.+124    	; 0x39ca <xTimerGenericCommand+0xb6>
	{
		/* Send a command to the timer service task to start the xTimer timer. */
		xMessage.xMessageID = xCommandID;
    394e:	89 85       	ldd	r24, Y+9	; 0x09
    3950:	8a 83       	std	Y+2, r24	; 0x02
		xMessage.xMessageValue = xOptionalValue;
    3952:	8a 85       	ldd	r24, Y+10	; 0x0a
    3954:	9b 85       	ldd	r25, Y+11	; 0x0b
    3956:	9c 83       	std	Y+4, r25	; 0x04
    3958:	8b 83       	std	Y+3, r24	; 0x03
		xMessage.pxTimer = ( xTIMER * ) xTimer;
    395a:	8f 81       	ldd	r24, Y+7	; 0x07
    395c:	98 85       	ldd	r25, Y+8	; 0x08
    395e:	9e 83       	std	Y+6, r25	; 0x06
    3960:	8d 83       	std	Y+5, r24	; 0x05

		if( pxHigherPriorityTaskWoken == NULL )
    3962:	8c 85       	ldd	r24, Y+12	; 0x0c
    3964:	9d 85       	ldd	r25, Y+13	; 0x0d
    3966:	00 97       	sbiw	r24, 0x00	; 0
    3968:	11 f5       	brne	.+68     	; 0x39ae <xTimerGenericCommand+0x9a>
		{
			if( xTaskGetSchedulerState() == taskSCHEDULER_RUNNING )
    396a:	0e 94 e7 1b 	call	0x37ce	; 0x37ce <xTaskGetSchedulerState>
    396e:	81 30       	cpi	r24, 0x01	; 1
    3970:	79 f4       	brne	.+30     	; 0x3990 <xTimerGenericCommand+0x7c>
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, xBlockTime );
    3972:	80 91 0a 07 	lds	r24, 0x070A
    3976:	90 91 0b 07 	lds	r25, 0x070B
    397a:	9e 01       	movw	r18, r28
    397c:	2e 5f       	subi	r18, 0xFE	; 254
    397e:	3f 4f       	sbci	r19, 0xFF	; 255
    3980:	4e 85       	ldd	r20, Y+14	; 0x0e
    3982:	5f 85       	ldd	r21, Y+15	; 0x0f
    3984:	b9 01       	movw	r22, r18
    3986:	20 e0       	ldi	r18, 0x00	; 0
    3988:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <xQueueGenericSend>
    398c:	89 83       	std	Y+1, r24	; 0x01
    398e:	1d c0       	rjmp	.+58     	; 0x39ca <xTimerGenericCommand+0xb6>
			}
			else
			{
				xReturn = xQueueSendToBack( xTimerQueue, &xMessage, tmrNO_DELAY );
    3990:	80 91 0a 07 	lds	r24, 0x070A
    3994:	90 91 0b 07 	lds	r25, 0x070B
    3998:	9e 01       	movw	r18, r28
    399a:	2e 5f       	subi	r18, 0xFE	; 254
    399c:	3f 4f       	sbci	r19, 0xFF	; 255
    399e:	b9 01       	movw	r22, r18
    39a0:	40 e0       	ldi	r20, 0x00	; 0
    39a2:	50 e0       	ldi	r21, 0x00	; 0
    39a4:	20 e0       	ldi	r18, 0x00	; 0
    39a6:	0e 94 38 0f 	call	0x1e70	; 0x1e70 <xQueueGenericSend>
    39aa:	89 83       	std	Y+1, r24	; 0x01
    39ac:	0e c0       	rjmp	.+28     	; 0x39ca <xTimerGenericCommand+0xb6>
			}
		}
		else
		{
			xReturn = xQueueSendToBackFromISR( xTimerQueue, &xMessage, pxHigherPriorityTaskWoken );
    39ae:	80 91 0a 07 	lds	r24, 0x070A
    39b2:	90 91 0b 07 	lds	r25, 0x070B
    39b6:	4c 85       	ldd	r20, Y+12	; 0x0c
    39b8:	5d 85       	ldd	r21, Y+13	; 0x0d
    39ba:	9e 01       	movw	r18, r28
    39bc:	2e 5f       	subi	r18, 0xFE	; 254
    39be:	3f 4f       	sbci	r19, 0xFF	; 255
    39c0:	b9 01       	movw	r22, r18
    39c2:	20 e0       	ldi	r18, 0x00	; 0
    39c4:	0e 94 d6 0f 	call	0x1fac	; 0x1fac <xQueueGenericSendFromISR>
    39c8:	89 83       	std	Y+1, r24	; 0x01
		}

		traceTIMER_COMMAND_SEND( xTimer, xCommandID, xOptionalValue, xReturn );
	}

	return xReturn;
    39ca:	89 81       	ldd	r24, Y+1	; 0x01
}
    39cc:	2f 96       	adiw	r28, 0x0f	; 15
    39ce:	0f b6       	in	r0, 0x3f	; 63
    39d0:	f8 94       	cli
    39d2:	de bf       	out	0x3e, r29	; 62
    39d4:	0f be       	out	0x3f, r0	; 63
    39d6:	cd bf       	out	0x3d, r28	; 61
    39d8:	cf 91       	pop	r28
    39da:	df 91       	pop	r29
    39dc:	1f 91       	pop	r17
    39de:	0f 91       	pop	r16
    39e0:	08 95       	ret

000039e2 <prvProcessExpiredTimer>:

#endif
/*-----------------------------------------------------------*/

static void prvProcessExpiredTimer( portTickType xNextExpireTime, portTickType xTimeNow )
{
    39e2:	0f 93       	push	r16
    39e4:	1f 93       	push	r17
    39e6:	df 93       	push	r29
    39e8:	cf 93       	push	r28
    39ea:	cd b7       	in	r28, 0x3d	; 61
    39ec:	de b7       	in	r29, 0x3e	; 62
    39ee:	27 97       	sbiw	r28, 0x07	; 7
    39f0:	0f b6       	in	r0, 0x3f	; 63
    39f2:	f8 94       	cli
    39f4:	de bf       	out	0x3e, r29	; 62
    39f6:	0f be       	out	0x3f, r0	; 63
    39f8:	cd bf       	out	0x3d, r28	; 61
    39fa:	9d 83       	std	Y+5, r25	; 0x05
    39fc:	8c 83       	std	Y+4, r24	; 0x04
    39fe:	7f 83       	std	Y+7, r23	; 0x07
    3a00:	6e 83       	std	Y+6, r22	; 0x06
xTIMER *pxTimer;
portBASE_TYPE xResult;

	/* Remove the timer from the list of active timers.  A check has already
	been performed to ensure the list is not empty. */
	pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    3a02:	e0 91 20 07 	lds	r30, 0x0720
    3a06:	f0 91 21 07 	lds	r31, 0x0721
    3a0a:	05 80       	ldd	r0, Z+5	; 0x05
    3a0c:	f6 81       	ldd	r31, Z+6	; 0x06
    3a0e:	e0 2d       	mov	r30, r0
    3a10:	86 81       	ldd	r24, Z+6	; 0x06
    3a12:	97 81       	ldd	r25, Z+7	; 0x07
    3a14:	9b 83       	std	Y+3, r25	; 0x03
    3a16:	8a 83       	std	Y+2, r24	; 0x02
	vListRemove( &( pxTimer->xTimerListItem ) );
    3a18:	8a 81       	ldd	r24, Y+2	; 0x02
    3a1a:	9b 81       	ldd	r25, Y+3	; 0x03
    3a1c:	02 96       	adiw	r24, 0x02	; 2
    3a1e:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>
	traceTIMER_EXPIRED( pxTimer );

	/* If the timer is an auto reload timer then calculate the next
	expiry time and re-insert the timer in the list of active timers. */
	if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
    3a22:	ea 81       	ldd	r30, Y+2	; 0x02
    3a24:	fb 81       	ldd	r31, Y+3	; 0x03
    3a26:	86 85       	ldd	r24, Z+14	; 0x0e
    3a28:	81 30       	cpi	r24, 0x01	; 1
    3a2a:	19 f5       	brne	.+70     	; 0x3a72 <prvProcessExpiredTimer+0x90>
		a time relative to anything other than the current time.  It
		will therefore be inserted into the correct list relative to
		the time this task thinks it is now, even if a command to
		switch lists due to a tick count overflow is already waiting in
		the timer queue. */
		if( prvInsertTimerInActiveList( pxTimer, ( xNextExpireTime + pxTimer->xTimerPeriodInTicks ), xTimeNow, xNextExpireTime ) == pdTRUE )
    3a2c:	ea 81       	ldd	r30, Y+2	; 0x02
    3a2e:	fb 81       	ldd	r31, Y+3	; 0x03
    3a30:	24 85       	ldd	r18, Z+12	; 0x0c
    3a32:	35 85       	ldd	r19, Z+13	; 0x0d
    3a34:	8c 81       	ldd	r24, Y+4	; 0x04
    3a36:	9d 81       	ldd	r25, Y+5	; 0x05
    3a38:	a9 01       	movw	r20, r18
    3a3a:	48 0f       	add	r20, r24
    3a3c:	59 1f       	adc	r21, r25
    3a3e:	8a 81       	ldd	r24, Y+2	; 0x02
    3a40:	9b 81       	ldd	r25, Y+3	; 0x03
    3a42:	2e 81       	ldd	r18, Y+6	; 0x06
    3a44:	3f 81       	ldd	r19, Y+7	; 0x07
    3a46:	ec 81       	ldd	r30, Y+4	; 0x04
    3a48:	fd 81       	ldd	r31, Y+5	; 0x05
    3a4a:	ba 01       	movw	r22, r20
    3a4c:	a9 01       	movw	r20, r18
    3a4e:	9f 01       	movw	r18, r30
    3a50:	0e 94 13 1e 	call	0x3c26	; 0x3c26 <prvInsertTimerInActiveList>
    3a54:	81 30       	cpi	r24, 0x01	; 1
    3a56:	69 f4       	brne	.+26     	; 0x3a72 <prvProcessExpiredTimer+0x90>
		{
			/* The timer expired before it was added to the active timer
			list.  Reload it now.  */
			xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
    3a58:	8a 81       	ldd	r24, Y+2	; 0x02
    3a5a:	9b 81       	ldd	r25, Y+3	; 0x03
    3a5c:	2c 81       	ldd	r18, Y+4	; 0x04
    3a5e:	3d 81       	ldd	r19, Y+5	; 0x05
    3a60:	60 e0       	ldi	r22, 0x00	; 0
    3a62:	a9 01       	movw	r20, r18
    3a64:	20 e0       	ldi	r18, 0x00	; 0
    3a66:	30 e0       	ldi	r19, 0x00	; 0
    3a68:	00 e0       	ldi	r16, 0x00	; 0
    3a6a:	10 e0       	ldi	r17, 0x00	; 0
    3a6c:	0e 94 8a 1c 	call	0x3914	; 0x3914 <xTimerGenericCommand>
    3a70:	89 83       	std	Y+1, r24	; 0x01
			( void ) xResult;
		}
	}

	/* Call the timer callback. */
	pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
    3a72:	ea 81       	ldd	r30, Y+2	; 0x02
    3a74:	fb 81       	ldd	r31, Y+3	; 0x03
    3a76:	01 88       	ldd	r0, Z+17	; 0x11
    3a78:	f2 89       	ldd	r31, Z+18	; 0x12
    3a7a:	e0 2d       	mov	r30, r0
    3a7c:	8a 81       	ldd	r24, Y+2	; 0x02
    3a7e:	9b 81       	ldd	r25, Y+3	; 0x03
    3a80:	09 95       	icall
}
    3a82:	27 96       	adiw	r28, 0x07	; 7
    3a84:	0f b6       	in	r0, 0x3f	; 63
    3a86:	f8 94       	cli
    3a88:	de bf       	out	0x3e, r29	; 62
    3a8a:	0f be       	out	0x3f, r0	; 63
    3a8c:	cd bf       	out	0x3d, r28	; 61
    3a8e:	cf 91       	pop	r28
    3a90:	df 91       	pop	r29
    3a92:	1f 91       	pop	r17
    3a94:	0f 91       	pop	r16
    3a96:	08 95       	ret

00003a98 <prvTimerTask>:
/*-----------------------------------------------------------*/

static void prvTimerTask( void *pvParameters )
{
    3a98:	df 93       	push	r29
    3a9a:	cf 93       	push	r28
    3a9c:	00 d0       	rcall	.+0      	; 0x3a9e <prvTimerTask+0x6>
    3a9e:	00 d0       	rcall	.+0      	; 0x3aa0 <prvTimerTask+0x8>
    3aa0:	0f 92       	push	r0
    3aa2:	cd b7       	in	r28, 0x3d	; 61
    3aa4:	de b7       	in	r29, 0x3e	; 62
    3aa6:	9d 83       	std	Y+5, r25	; 0x05
    3aa8:	8c 83       	std	Y+4, r24	; 0x04

	for( ;; )
	{
		/* Query the timers list to see if it contains any timers, and if so,
		obtain the time at which the next timer will expire. */
		xNextExpireTime = prvGetNextExpireTime( &xListWasEmpty );
    3aaa:	ce 01       	movw	r24, r28
    3aac:	03 96       	adiw	r24, 0x03	; 3
    3aae:	0e 94 ad 1d 	call	0x3b5a	; 0x3b5a <prvGetNextExpireTime>
    3ab2:	9a 83       	std	Y+2, r25	; 0x02
    3ab4:	89 83       	std	Y+1, r24	; 0x01

		/* If a timer has expired, process it.  Otherwise, block this task
		until either a timer does expire, or a command is received. */
		prvProcessTimerOrBlockTask( xNextExpireTime, xListWasEmpty );
    3ab6:	2b 81       	ldd	r18, Y+3	; 0x03
    3ab8:	89 81       	ldd	r24, Y+1	; 0x01
    3aba:	9a 81       	ldd	r25, Y+2	; 0x02
    3abc:	62 2f       	mov	r22, r18
    3abe:	0e 94 64 1d 	call	0x3ac8	; 0x3ac8 <prvProcessTimerOrBlockTask>

		/* Empty the command queue. */
		prvProcessReceivedCommands();
    3ac2:	0e 94 7b 1e 	call	0x3cf6	; 0x3cf6 <prvProcessReceivedCommands>
    3ac6:	f1 cf       	rjmp	.-30     	; 0x3aaa <prvTimerTask+0x12>

00003ac8 <prvProcessTimerOrBlockTask>:
	}
}
/*-----------------------------------------------------------*/

static void prvProcessTimerOrBlockTask( portTickType xNextExpireTime, portBASE_TYPE xListWasEmpty )
{
    3ac8:	df 93       	push	r29
    3aca:	cf 93       	push	r28
    3acc:	00 d0       	rcall	.+0      	; 0x3ace <prvProcessTimerOrBlockTask+0x6>
    3ace:	00 d0       	rcall	.+0      	; 0x3ad0 <prvProcessTimerOrBlockTask+0x8>
    3ad0:	00 d0       	rcall	.+0      	; 0x3ad2 <prvProcessTimerOrBlockTask+0xa>
    3ad2:	cd b7       	in	r28, 0x3d	; 61
    3ad4:	de b7       	in	r29, 0x3e	; 62
    3ad6:	9d 83       	std	Y+5, r25	; 0x05
    3ad8:	8c 83       	std	Y+4, r24	; 0x04
    3ada:	6e 83       	std	Y+6, r22	; 0x06
portTickType xTimeNow;
portBASE_TYPE xTimerListsWereSwitched;

	vTaskSuspendAll();
    3adc:	0e 94 32 17 	call	0x2e64	; 0x2e64 <vTaskSuspendAll>
		/* Obtain the time now to make an assessment as to whether the timer
		has expired or not.  If obtaining the time causes the lists to switch
		then don't process this timer as any timers that remained in the list
		when the lists were switched will have been processed within the
		prvSampelTimeNow() function. */
		xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3ae0:	ce 01       	movw	r24, r28
    3ae2:	03 96       	adiw	r24, 0x03	; 3
    3ae4:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <prvSampleTimeNow>
    3ae8:	9a 83       	std	Y+2, r25	; 0x02
    3aea:	89 83       	std	Y+1, r24	; 0x01
		if( xTimerListsWereSwitched == pdFALSE )
    3aec:	8b 81       	ldd	r24, Y+3	; 0x03
    3aee:	88 23       	and	r24, r24
    3af0:	49 f5       	brne	.+82     	; 0x3b44 <prvProcessTimerOrBlockTask+0x7c>
		{
			/* The tick count has not overflowed, has the timer expired? */
			if( ( xListWasEmpty == pdFALSE ) && ( xNextExpireTime <= xTimeNow ) )
    3af2:	8e 81       	ldd	r24, Y+6	; 0x06
    3af4:	88 23       	and	r24, r24
    3af6:	89 f4       	brne	.+34     	; 0x3b1a <prvProcessTimerOrBlockTask+0x52>
    3af8:	2c 81       	ldd	r18, Y+4	; 0x04
    3afa:	3d 81       	ldd	r19, Y+5	; 0x05
    3afc:	89 81       	ldd	r24, Y+1	; 0x01
    3afe:	9a 81       	ldd	r25, Y+2	; 0x02
    3b00:	82 17       	cp	r24, r18
    3b02:	93 07       	cpc	r25, r19
    3b04:	50 f0       	brcs	.+20     	; 0x3b1a <prvProcessTimerOrBlockTask+0x52>
			{
				xTaskResumeAll();
    3b06:	0e 94 3e 17 	call	0x2e7c	; 0x2e7c <xTaskResumeAll>
				prvProcessExpiredTimer( xNextExpireTime, xTimeNow );
    3b0a:	8c 81       	ldd	r24, Y+4	; 0x04
    3b0c:	9d 81       	ldd	r25, Y+5	; 0x05
    3b0e:	29 81       	ldd	r18, Y+1	; 0x01
    3b10:	3a 81       	ldd	r19, Y+2	; 0x02
    3b12:	b9 01       	movw	r22, r18
    3b14:	0e 94 f1 1c 	call	0x39e2	; 0x39e2 <prvProcessExpiredTimer>
    3b18:	17 c0       	rjmp	.+46     	; 0x3b48 <prvProcessTimerOrBlockTask+0x80>
				time has not been reached yet.  This task should therefore
				block to wait for the next expire time or a command to be
				received - whichever comes first.  The following line cannot
				be reached unless xNextExpireTime > xTimeNow, except in the
				case when the current timer list is empty. */
				vQueueWaitForMessageRestricted( xTimerQueue, ( xNextExpireTime - xTimeNow ) );
    3b1a:	40 91 0a 07 	lds	r20, 0x070A
    3b1e:	50 91 0b 07 	lds	r21, 0x070B
    3b22:	2c 81       	ldd	r18, Y+4	; 0x04
    3b24:	3d 81       	ldd	r19, Y+5	; 0x05
    3b26:	89 81       	ldd	r24, Y+1	; 0x01
    3b28:	9a 81       	ldd	r25, Y+2	; 0x02
    3b2a:	28 1b       	sub	r18, r24
    3b2c:	39 0b       	sbc	r19, r25
    3b2e:	ca 01       	movw	r24, r20
    3b30:	b9 01       	movw	r22, r18
    3b32:	0e 94 10 13 	call	0x2620	; 0x2620 <vQueueWaitForMessageRestricted>

				if( xTaskResumeAll() == pdFALSE )
    3b36:	0e 94 3e 17 	call	0x2e7c	; 0x2e7c <xTaskResumeAll>
    3b3a:	88 23       	and	r24, r24
    3b3c:	29 f4       	brne	.+10     	; 0x3b48 <prvProcessTimerOrBlockTask+0x80>
				{
					/* Yield to wait for either a command to arrive, or the block time
					to expire.  If a command arrived between the critical section being
					exited and this yield then the yield will not cause the task
					to block. */
					portYIELD_WITHIN_API();
    3b3e:	0e 94 55 0d 	call	0x1aaa	; 0x1aaa <vPortYield>
    3b42:	02 c0       	rjmp	.+4      	; 0x3b48 <prvProcessTimerOrBlockTask+0x80>
				}
			}
		}
		else
		{
			xTaskResumeAll();
    3b44:	0e 94 3e 17 	call	0x2e7c	; 0x2e7c <xTaskResumeAll>
		}
	}
}
    3b48:	26 96       	adiw	r28, 0x06	; 6
    3b4a:	0f b6       	in	r0, 0x3f	; 63
    3b4c:	f8 94       	cli
    3b4e:	de bf       	out	0x3e, r29	; 62
    3b50:	0f be       	out	0x3f, r0	; 63
    3b52:	cd bf       	out	0x3d, r28	; 61
    3b54:	cf 91       	pop	r28
    3b56:	df 91       	pop	r29
    3b58:	08 95       	ret

00003b5a <prvGetNextExpireTime>:
/*-----------------------------------------------------------*/

static portTickType prvGetNextExpireTime( portBASE_TYPE *pxListWasEmpty )
{
    3b5a:	df 93       	push	r29
    3b5c:	cf 93       	push	r28
    3b5e:	00 d0       	rcall	.+0      	; 0x3b60 <prvGetNextExpireTime+0x6>
    3b60:	00 d0       	rcall	.+0      	; 0x3b62 <prvGetNextExpireTime+0x8>
    3b62:	0f 92       	push	r0
    3b64:	cd b7       	in	r28, 0x3d	; 61
    3b66:	de b7       	in	r29, 0x3e	; 62
    3b68:	9c 83       	std	Y+4, r25	; 0x04
    3b6a:	8b 83       	std	Y+3, r24	; 0x03
	the timer with the nearest expiry time will expire.  If there are no
	active timers then just set the next expire time to 0.  That will cause
	this task to unblock when the tick count overflows, at which point the
	timer lists will be switched and the next expiry time can be
	re-assessed.  */
	*pxListWasEmpty = listLIST_IS_EMPTY( pxCurrentTimerList );
    3b6c:	e0 91 20 07 	lds	r30, 0x0720
    3b70:	f0 91 21 07 	lds	r31, 0x0721
    3b74:	80 81       	ld	r24, Z
    3b76:	1d 82       	std	Y+5, r1	; 0x05
    3b78:	88 23       	and	r24, r24
    3b7a:	11 f4       	brne	.+4      	; 0x3b80 <prvGetNextExpireTime+0x26>
    3b7c:	81 e0       	ldi	r24, 0x01	; 1
    3b7e:	8d 83       	std	Y+5, r24	; 0x05
    3b80:	eb 81       	ldd	r30, Y+3	; 0x03
    3b82:	fc 81       	ldd	r31, Y+4	; 0x04
    3b84:	8d 81       	ldd	r24, Y+5	; 0x05
    3b86:	80 83       	st	Z, r24
	if( *pxListWasEmpty == pdFALSE )
    3b88:	eb 81       	ldd	r30, Y+3	; 0x03
    3b8a:	fc 81       	ldd	r31, Y+4	; 0x04
    3b8c:	80 81       	ld	r24, Z
    3b8e:	88 23       	and	r24, r24
    3b90:	61 f4       	brne	.+24     	; 0x3baa <prvGetNextExpireTime+0x50>
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    3b92:	e0 91 20 07 	lds	r30, 0x0720
    3b96:	f0 91 21 07 	lds	r31, 0x0721
    3b9a:	05 80       	ldd	r0, Z+5	; 0x05
    3b9c:	f6 81       	ldd	r31, Z+6	; 0x06
    3b9e:	e0 2d       	mov	r30, r0
    3ba0:	80 81       	ld	r24, Z
    3ba2:	91 81       	ldd	r25, Z+1	; 0x01
    3ba4:	9a 83       	std	Y+2, r25	; 0x02
    3ba6:	89 83       	std	Y+1, r24	; 0x01
    3ba8:	02 c0       	rjmp	.+4      	; 0x3bae <prvGetNextExpireTime+0x54>
	}
	else
	{
		/* Ensure the task unblocks when the tick count rolls over. */
		xNextExpireTime = ( portTickType ) 0U;
    3baa:	1a 82       	std	Y+2, r1	; 0x02
    3bac:	19 82       	std	Y+1, r1	; 0x01
	}

	return xNextExpireTime;
    3bae:	89 81       	ldd	r24, Y+1	; 0x01
    3bb0:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3bb2:	0f 90       	pop	r0
    3bb4:	0f 90       	pop	r0
    3bb6:	0f 90       	pop	r0
    3bb8:	0f 90       	pop	r0
    3bba:	0f 90       	pop	r0
    3bbc:	cf 91       	pop	r28
    3bbe:	df 91       	pop	r29
    3bc0:	08 95       	ret

00003bc2 <prvSampleTimeNow>:
/*-----------------------------------------------------------*/

static portTickType prvSampleTimeNow( portBASE_TYPE *pxTimerListsWereSwitched )
{
    3bc2:	df 93       	push	r29
    3bc4:	cf 93       	push	r28
    3bc6:	00 d0       	rcall	.+0      	; 0x3bc8 <prvSampleTimeNow+0x6>
    3bc8:	00 d0       	rcall	.+0      	; 0x3bca <prvSampleTimeNow+0x8>
    3bca:	cd b7       	in	r28, 0x3d	; 61
    3bcc:	de b7       	in	r29, 0x3e	; 62
    3bce:	9c 83       	std	Y+4, r25	; 0x04
    3bd0:	8b 83       	std	Y+3, r24	; 0x03
portTickType xTimeNow;
static portTickType xLastTime = ( portTickType ) 0U;

	xTimeNow = xTaskGetTickCount();
    3bd2:	0e 94 c6 17 	call	0x2f8c	; 0x2f8c <xTaskGetTickCount>
    3bd6:	9a 83       	std	Y+2, r25	; 0x02
    3bd8:	89 83       	std	Y+1, r24	; 0x01

	if( xTimeNow < xLastTime )
    3bda:	20 91 0c 07 	lds	r18, 0x070C
    3bde:	30 91 0d 07 	lds	r19, 0x070D
    3be2:	89 81       	ldd	r24, Y+1	; 0x01
    3be4:	9a 81       	ldd	r25, Y+2	; 0x02
    3be6:	82 17       	cp	r24, r18
    3be8:	93 07       	cpc	r25, r19
    3bea:	58 f4       	brcc	.+22     	; 0x3c02 <prvSampleTimeNow+0x40>
	{
		prvSwitchTimerLists( xLastTime );
    3bec:	80 91 0c 07 	lds	r24, 0x070C
    3bf0:	90 91 0d 07 	lds	r25, 0x070D
    3bf4:	0e 94 35 1f 	call	0x3e6a	; 0x3e6a <prvSwitchTimerLists>
		*pxTimerListsWereSwitched = pdTRUE;
    3bf8:	eb 81       	ldd	r30, Y+3	; 0x03
    3bfa:	fc 81       	ldd	r31, Y+4	; 0x04
    3bfc:	81 e0       	ldi	r24, 0x01	; 1
    3bfe:	80 83       	st	Z, r24
    3c00:	03 c0       	rjmp	.+6      	; 0x3c08 <prvSampleTimeNow+0x46>
	}
	else
	{
		*pxTimerListsWereSwitched = pdFALSE;
    3c02:	eb 81       	ldd	r30, Y+3	; 0x03
    3c04:	fc 81       	ldd	r31, Y+4	; 0x04
    3c06:	10 82       	st	Z, r1
	}

	xLastTime = xTimeNow;
    3c08:	89 81       	ldd	r24, Y+1	; 0x01
    3c0a:	9a 81       	ldd	r25, Y+2	; 0x02
    3c0c:	90 93 0d 07 	sts	0x070D, r25
    3c10:	80 93 0c 07 	sts	0x070C, r24

	return xTimeNow;
    3c14:	89 81       	ldd	r24, Y+1	; 0x01
    3c16:	9a 81       	ldd	r25, Y+2	; 0x02
}
    3c18:	0f 90       	pop	r0
    3c1a:	0f 90       	pop	r0
    3c1c:	0f 90       	pop	r0
    3c1e:	0f 90       	pop	r0
    3c20:	cf 91       	pop	r28
    3c22:	df 91       	pop	r29
    3c24:	08 95       	ret

00003c26 <prvInsertTimerInActiveList>:
/*-----------------------------------------------------------*/

static portBASE_TYPE prvInsertTimerInActiveList( xTIMER *pxTimer, portTickType xNextExpiryTime, portTickType xTimeNow, portTickType xCommandTime )
{
    3c26:	df 93       	push	r29
    3c28:	cf 93       	push	r28
    3c2a:	cd b7       	in	r28, 0x3d	; 61
    3c2c:	de b7       	in	r29, 0x3e	; 62
    3c2e:	29 97       	sbiw	r28, 0x09	; 9
    3c30:	0f b6       	in	r0, 0x3f	; 63
    3c32:	f8 94       	cli
    3c34:	de bf       	out	0x3e, r29	; 62
    3c36:	0f be       	out	0x3f, r0	; 63
    3c38:	cd bf       	out	0x3d, r28	; 61
    3c3a:	9b 83       	std	Y+3, r25	; 0x03
    3c3c:	8a 83       	std	Y+2, r24	; 0x02
    3c3e:	7d 83       	std	Y+5, r23	; 0x05
    3c40:	6c 83       	std	Y+4, r22	; 0x04
    3c42:	5f 83       	std	Y+7, r21	; 0x07
    3c44:	4e 83       	std	Y+6, r20	; 0x06
    3c46:	39 87       	std	Y+9, r19	; 0x09
    3c48:	28 87       	std	Y+8, r18	; 0x08
portBASE_TYPE xProcessTimerNow = pdFALSE;
    3c4a:	19 82       	std	Y+1, r1	; 0x01

	listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xNextExpiryTime );
    3c4c:	ea 81       	ldd	r30, Y+2	; 0x02
    3c4e:	fb 81       	ldd	r31, Y+3	; 0x03
    3c50:	8c 81       	ldd	r24, Y+4	; 0x04
    3c52:	9d 81       	ldd	r25, Y+5	; 0x05
    3c54:	93 83       	std	Z+3, r25	; 0x03
    3c56:	82 83       	std	Z+2, r24	; 0x02
	listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    3c58:	ea 81       	ldd	r30, Y+2	; 0x02
    3c5a:	fb 81       	ldd	r31, Y+3	; 0x03
    3c5c:	8a 81       	ldd	r24, Y+2	; 0x02
    3c5e:	9b 81       	ldd	r25, Y+3	; 0x03
    3c60:	91 87       	std	Z+9, r25	; 0x09
    3c62:	80 87       	std	Z+8, r24	; 0x08

	if( xNextExpiryTime <= xTimeNow )
    3c64:	2c 81       	ldd	r18, Y+4	; 0x04
    3c66:	3d 81       	ldd	r19, Y+5	; 0x05
    3c68:	8e 81       	ldd	r24, Y+6	; 0x06
    3c6a:	9f 81       	ldd	r25, Y+7	; 0x07
    3c6c:	82 17       	cp	r24, r18
    3c6e:	93 07       	cpc	r25, r19
    3c70:	e0 f0       	brcs	.+56     	; 0x3caa <prvInsertTimerInActiveList+0x84>
	{
		/* Has the expiry time elapsed between the command to start/reset a
		timer was issued, and the time the command was processed? */
		if( ( ( portTickType ) ( xTimeNow - xCommandTime ) ) >= pxTimer->xTimerPeriodInTicks )
    3c72:	2e 81       	ldd	r18, Y+6	; 0x06
    3c74:	3f 81       	ldd	r19, Y+7	; 0x07
    3c76:	88 85       	ldd	r24, Y+8	; 0x08
    3c78:	99 85       	ldd	r25, Y+9	; 0x09
    3c7a:	28 1b       	sub	r18, r24
    3c7c:	39 0b       	sbc	r19, r25
    3c7e:	ea 81       	ldd	r30, Y+2	; 0x02
    3c80:	fb 81       	ldd	r31, Y+3	; 0x03
    3c82:	84 85       	ldd	r24, Z+12	; 0x0c
    3c84:	95 85       	ldd	r25, Z+13	; 0x0d
    3c86:	28 17       	cp	r18, r24
    3c88:	39 07       	cpc	r19, r25
    3c8a:	18 f0       	brcs	.+6      	; 0x3c92 <prvInsertTimerInActiveList+0x6c>
		{
			/* The time between a command being issued and the command being
			processed actually exceeds the timers period.  */
			xProcessTimerNow = pdTRUE;
    3c8c:	81 e0       	ldi	r24, 0x01	; 1
    3c8e:	89 83       	std	Y+1, r24	; 0x01
    3c90:	28 c0       	rjmp	.+80     	; 0x3ce2 <prvInsertTimerInActiveList+0xbc>
		}
		else
		{
			vListInsert( pxOverflowTimerList, &( pxTimer->xTimerListItem ) );
    3c92:	80 91 22 07 	lds	r24, 0x0722
    3c96:	90 91 23 07 	lds	r25, 0x0723
    3c9a:	2a 81       	ldd	r18, Y+2	; 0x02
    3c9c:	3b 81       	ldd	r19, Y+3	; 0x03
    3c9e:	2e 5f       	subi	r18, 0xFE	; 254
    3ca0:	3f 4f       	sbci	r19, 0xFF	; 255
    3ca2:	b9 01       	movw	r22, r18
    3ca4:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <vListInsert>
    3ca8:	1c c0       	rjmp	.+56     	; 0x3ce2 <prvInsertTimerInActiveList+0xbc>
		}
	}
	else
	{
		if( ( xTimeNow < xCommandTime ) && ( xNextExpiryTime >= xCommandTime ) )
    3caa:	2e 81       	ldd	r18, Y+6	; 0x06
    3cac:	3f 81       	ldd	r19, Y+7	; 0x07
    3cae:	88 85       	ldd	r24, Y+8	; 0x08
    3cb0:	99 85       	ldd	r25, Y+9	; 0x09
    3cb2:	28 17       	cp	r18, r24
    3cb4:	39 07       	cpc	r19, r25
    3cb6:	50 f4       	brcc	.+20     	; 0x3ccc <prvInsertTimerInActiveList+0xa6>
    3cb8:	2c 81       	ldd	r18, Y+4	; 0x04
    3cba:	3d 81       	ldd	r19, Y+5	; 0x05
    3cbc:	88 85       	ldd	r24, Y+8	; 0x08
    3cbe:	99 85       	ldd	r25, Y+9	; 0x09
    3cc0:	28 17       	cp	r18, r24
    3cc2:	39 07       	cpc	r19, r25
    3cc4:	18 f0       	brcs	.+6      	; 0x3ccc <prvInsertTimerInActiveList+0xa6>
		{
			/* If, since the command was issued, the tick count has overflowed
			but the expiry time has not, then the timer must have already passed
			its expiry time and should be processed immediately. */
			xProcessTimerNow = pdTRUE;
    3cc6:	81 e0       	ldi	r24, 0x01	; 1
    3cc8:	89 83       	std	Y+1, r24	; 0x01
    3cca:	0b c0       	rjmp	.+22     	; 0x3ce2 <prvInsertTimerInActiveList+0xbc>
		}
		else
		{
			vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    3ccc:	80 91 20 07 	lds	r24, 0x0720
    3cd0:	90 91 21 07 	lds	r25, 0x0721
    3cd4:	2a 81       	ldd	r18, Y+2	; 0x02
    3cd6:	3b 81       	ldd	r19, Y+3	; 0x03
    3cd8:	2e 5f       	subi	r18, 0xFE	; 254
    3cda:	3f 4f       	sbci	r19, 0xFF	; 255
    3cdc:	b9 01       	movw	r22, r18
    3cde:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <vListInsert>
		}
	}

	return xProcessTimerNow;
    3ce2:	89 81       	ldd	r24, Y+1	; 0x01
}
    3ce4:	29 96       	adiw	r28, 0x09	; 9
    3ce6:	0f b6       	in	r0, 0x3f	; 63
    3ce8:	f8 94       	cli
    3cea:	de bf       	out	0x3e, r29	; 62
    3cec:	0f be       	out	0x3f, r0	; 63
    3cee:	cd bf       	out	0x3d, r28	; 61
    3cf0:	cf 91       	pop	r28
    3cf2:	df 91       	pop	r29
    3cf4:	08 95       	ret

00003cf6 <prvProcessReceivedCommands>:
/*-----------------------------------------------------------*/

static void	prvProcessReceivedCommands( void )
{
    3cf6:	0f 93       	push	r16
    3cf8:	1f 93       	push	r17
    3cfa:	df 93       	push	r29
    3cfc:	cf 93       	push	r28
    3cfe:	cd b7       	in	r28, 0x3d	; 61
    3d00:	de b7       	in	r29, 0x3e	; 62
    3d02:	2d 97       	sbiw	r28, 0x0d	; 13
    3d04:	0f b6       	in	r0, 0x3f	; 63
    3d06:	f8 94       	cli
    3d08:	de bf       	out	0x3e, r29	; 62
    3d0a:	0f be       	out	0x3f, r0	; 63
    3d0c:	cd bf       	out	0x3d, r28	; 61
portBASE_TYPE xTimerListsWereSwitched, xResult;
portTickType xTimeNow;

	/* In this case the xTimerListsWereSwitched parameter is not used, but it
	must be present in the function call. */
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );
    3d0e:	ce 01       	movw	r24, r28
    3d10:	0b 96       	adiw	r24, 0x0b	; 11
    3d12:	0e 94 e1 1d 	call	0x3bc2	; 0x3bc2 <prvSampleTimeNow>
    3d16:	9a 83       	std	Y+2, r25	; 0x02
    3d18:	89 83       	std	Y+1, r24	; 0x01
    3d1a:	8c c0       	rjmp	.+280    	; 0x3e34 <prvProcessReceivedCommands+0x13e>

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
	{
		pxTimer = xMessage.pxTimer;
    3d1c:	89 85       	ldd	r24, Y+9	; 0x09
    3d1e:	9a 85       	ldd	r25, Y+10	; 0x0a
    3d20:	9d 83       	std	Y+5, r25	; 0x05
    3d22:	8c 83       	std	Y+4, r24	; 0x04

		/* Is the timer already in a list of active timers?  When the command
		is trmCOMMAND_PROCESS_TIMER_OVERFLOW, the timer will be NULL as the
		command is to the task rather than to an individual timer. */
		if( pxTimer != NULL )
    3d24:	8c 81       	ldd	r24, Y+4	; 0x04
    3d26:	9d 81       	ldd	r25, Y+5	; 0x05
    3d28:	00 97       	sbiw	r24, 0x00	; 0
    3d2a:	59 f0       	breq	.+22     	; 0x3d42 <prvProcessReceivedCommands+0x4c>
		{
			if( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) == pdFALSE )
    3d2c:	ec 81       	ldd	r30, Y+4	; 0x04
    3d2e:	fd 81       	ldd	r31, Y+5	; 0x05
    3d30:	82 85       	ldd	r24, Z+10	; 0x0a
    3d32:	93 85       	ldd	r25, Z+11	; 0x0b
    3d34:	00 97       	sbiw	r24, 0x00	; 0
    3d36:	29 f0       	breq	.+10     	; 0x3d42 <prvProcessReceivedCommands+0x4c>
			{
				/* The timer is in a list, remove it. */
				vListRemove( &( pxTimer->xTimerListItem ) );
    3d38:	8c 81       	ldd	r24, Y+4	; 0x04
    3d3a:	9d 81       	ldd	r25, Y+5	; 0x05
    3d3c:	02 96       	adiw	r24, 0x02	; 2
    3d3e:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>
			}
		}

		traceTIMER_COMMAND_RECEIVED( pxTimer, xMessage.xMessageID, xMessage.xMessageValue );

		switch( xMessage.xMessageID )
    3d42:	8e 81       	ldd	r24, Y+6	; 0x06
    3d44:	28 2f       	mov	r18, r24
    3d46:	30 e0       	ldi	r19, 0x00	; 0
    3d48:	3d 87       	std	Y+13, r19	; 0x0d
    3d4a:	2c 87       	std	Y+12, r18	; 0x0c
    3d4c:	8c 85       	ldd	r24, Y+12	; 0x0c
    3d4e:	9d 85       	ldd	r25, Y+13	; 0x0d
    3d50:	81 30       	cpi	r24, 0x01	; 1
    3d52:	91 05       	cpc	r25, r1
    3d54:	09 f4       	brne	.+2      	; 0x3d58 <prvProcessReceivedCommands+0x62>
    3d56:	6e c0       	rjmp	.+220    	; 0x3e34 <prvProcessReceivedCommands+0x13e>
    3d58:	2c 85       	ldd	r18, Y+12	; 0x0c
    3d5a:	3d 85       	ldd	r19, Y+13	; 0x0d
    3d5c:	22 30       	cpi	r18, 0x02	; 2
    3d5e:	31 05       	cpc	r19, r1
    3d60:	2c f4       	brge	.+10     	; 0x3d6c <prvProcessReceivedCommands+0x76>
    3d62:	8c 85       	ldd	r24, Y+12	; 0x0c
    3d64:	9d 85       	ldd	r25, Y+13	; 0x0d
    3d66:	00 97       	sbiw	r24, 0x00	; 0
    3d68:	71 f0       	breq	.+28     	; 0x3d86 <prvProcessReceivedCommands+0x90>
    3d6a:	64 c0       	rjmp	.+200    	; 0x3e34 <prvProcessReceivedCommands+0x13e>
    3d6c:	2c 85       	ldd	r18, Y+12	; 0x0c
    3d6e:	3d 85       	ldd	r19, Y+13	; 0x0d
    3d70:	22 30       	cpi	r18, 0x02	; 2
    3d72:	31 05       	cpc	r19, r1
    3d74:	09 f4       	brne	.+2      	; 0x3d78 <prvProcessReceivedCommands+0x82>
    3d76:	3f c0       	rjmp	.+126    	; 0x3df6 <prvProcessReceivedCommands+0x100>
    3d78:	8c 85       	ldd	r24, Y+12	; 0x0c
    3d7a:	9d 85       	ldd	r25, Y+13	; 0x0d
    3d7c:	83 30       	cpi	r24, 0x03	; 3
    3d7e:	91 05       	cpc	r25, r1
    3d80:	09 f4       	brne	.+2      	; 0x3d84 <prvProcessReceivedCommands+0x8e>
    3d82:	54 c0       	rjmp	.+168    	; 0x3e2c <prvProcessReceivedCommands+0x136>
    3d84:	57 c0       	rjmp	.+174    	; 0x3e34 <prvProcessReceivedCommands+0x13e>
		{
			case tmrCOMMAND_START :
				/* Start or restart a timer. */
				if( prvInsertTimerInActiveList( pxTimer,  xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, xTimeNow, xMessage.xMessageValue ) == pdTRUE )
    3d86:	2f 81       	ldd	r18, Y+7	; 0x07
    3d88:	38 85       	ldd	r19, Y+8	; 0x08
    3d8a:	ec 81       	ldd	r30, Y+4	; 0x04
    3d8c:	fd 81       	ldd	r31, Y+5	; 0x05
    3d8e:	84 85       	ldd	r24, Z+12	; 0x0c
    3d90:	95 85       	ldd	r25, Z+13	; 0x0d
    3d92:	a9 01       	movw	r20, r18
    3d94:	48 0f       	add	r20, r24
    3d96:	59 1f       	adc	r21, r25
    3d98:	ef 81       	ldd	r30, Y+7	; 0x07
    3d9a:	f8 85       	ldd	r31, Y+8	; 0x08
    3d9c:	8c 81       	ldd	r24, Y+4	; 0x04
    3d9e:	9d 81       	ldd	r25, Y+5	; 0x05
    3da0:	29 81       	ldd	r18, Y+1	; 0x01
    3da2:	3a 81       	ldd	r19, Y+2	; 0x02
    3da4:	ba 01       	movw	r22, r20
    3da6:	a9 01       	movw	r20, r18
    3da8:	9f 01       	movw	r18, r30
    3daa:	0e 94 13 1e 	call	0x3c26	; 0x3c26 <prvInsertTimerInActiveList>
    3dae:	81 30       	cpi	r24, 0x01	; 1
    3db0:	09 f0       	breq	.+2      	; 0x3db4 <prvProcessReceivedCommands+0xbe>
    3db2:	40 c0       	rjmp	.+128    	; 0x3e34 <prvProcessReceivedCommands+0x13e>
				{
					/* The timer expired before it was added to the active timer
					list.  Process it now. */
					pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
    3db4:	ec 81       	ldd	r30, Y+4	; 0x04
    3db6:	fd 81       	ldd	r31, Y+5	; 0x05
    3db8:	01 88       	ldd	r0, Z+17	; 0x11
    3dba:	f2 89       	ldd	r31, Z+18	; 0x12
    3dbc:	e0 2d       	mov	r30, r0
    3dbe:	8c 81       	ldd	r24, Y+4	; 0x04
    3dc0:	9d 81       	ldd	r25, Y+5	; 0x05
    3dc2:	09 95       	icall

					if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
    3dc4:	ec 81       	ldd	r30, Y+4	; 0x04
    3dc6:	fd 81       	ldd	r31, Y+5	; 0x05
    3dc8:	86 85       	ldd	r24, Z+14	; 0x0e
    3dca:	81 30       	cpi	r24, 0x01	; 1
    3dcc:	99 f5       	brne	.+102    	; 0x3e34 <prvProcessReceivedCommands+0x13e>
					{
						xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xMessage.xMessageValue + pxTimer->xTimerPeriodInTicks, NULL, tmrNO_DELAY );
    3dce:	2f 81       	ldd	r18, Y+7	; 0x07
    3dd0:	38 85       	ldd	r19, Y+8	; 0x08
    3dd2:	ec 81       	ldd	r30, Y+4	; 0x04
    3dd4:	fd 81       	ldd	r31, Y+5	; 0x05
    3dd6:	84 85       	ldd	r24, Z+12	; 0x0c
    3dd8:	95 85       	ldd	r25, Z+13	; 0x0d
    3dda:	28 0f       	add	r18, r24
    3ddc:	39 1f       	adc	r19, r25
    3dde:	8c 81       	ldd	r24, Y+4	; 0x04
    3de0:	9d 81       	ldd	r25, Y+5	; 0x05
    3de2:	60 e0       	ldi	r22, 0x00	; 0
    3de4:	a9 01       	movw	r20, r18
    3de6:	20 e0       	ldi	r18, 0x00	; 0
    3de8:	30 e0       	ldi	r19, 0x00	; 0
    3dea:	00 e0       	ldi	r16, 0x00	; 0
    3dec:	10 e0       	ldi	r17, 0x00	; 0
    3dee:	0e 94 8a 1c 	call	0x3914	; 0x3914 <xTimerGenericCommand>
    3df2:	8b 83       	std	Y+3, r24	; 0x03
    3df4:	1f c0       	rjmp	.+62     	; 0x3e34 <prvProcessReceivedCommands+0x13e>
				/* The timer has already been removed from the active list.
				There is nothing to do here. */
				break;

			case tmrCOMMAND_CHANGE_PERIOD :
				pxTimer->xTimerPeriodInTicks = xMessage.xMessageValue;
    3df6:	8f 81       	ldd	r24, Y+7	; 0x07
    3df8:	98 85       	ldd	r25, Y+8	; 0x08
    3dfa:	ec 81       	ldd	r30, Y+4	; 0x04
    3dfc:	fd 81       	ldd	r31, Y+5	; 0x05
    3dfe:	95 87       	std	Z+13, r25	; 0x0d
    3e00:	84 87       	std	Z+12, r24	; 0x0c
				configASSERT( ( pxTimer->xTimerPeriodInTicks > 0 ) );
				prvInsertTimerInActiveList( pxTimer, ( xTimeNow + pxTimer->xTimerPeriodInTicks ), xTimeNow, xTimeNow );
    3e02:	ec 81       	ldd	r30, Y+4	; 0x04
    3e04:	fd 81       	ldd	r31, Y+5	; 0x05
    3e06:	24 85       	ldd	r18, Z+12	; 0x0c
    3e08:	35 85       	ldd	r19, Z+13	; 0x0d
    3e0a:	89 81       	ldd	r24, Y+1	; 0x01
    3e0c:	9a 81       	ldd	r25, Y+2	; 0x02
    3e0e:	a9 01       	movw	r20, r18
    3e10:	48 0f       	add	r20, r24
    3e12:	59 1f       	adc	r21, r25
    3e14:	8c 81       	ldd	r24, Y+4	; 0x04
    3e16:	9d 81       	ldd	r25, Y+5	; 0x05
    3e18:	29 81       	ldd	r18, Y+1	; 0x01
    3e1a:	3a 81       	ldd	r19, Y+2	; 0x02
    3e1c:	e9 81       	ldd	r30, Y+1	; 0x01
    3e1e:	fa 81       	ldd	r31, Y+2	; 0x02
    3e20:	ba 01       	movw	r22, r20
    3e22:	a9 01       	movw	r20, r18
    3e24:	9f 01       	movw	r18, r30
    3e26:	0e 94 13 1e 	call	0x3c26	; 0x3c26 <prvInsertTimerInActiveList>
    3e2a:	04 c0       	rjmp	.+8      	; 0x3e34 <prvProcessReceivedCommands+0x13e>
				break;

			case tmrCOMMAND_DELETE :
				/* The timer has already been removed from the active list,
				just free up the memory. */
				vPortFree( pxTimer );
    3e2c:	8c 81       	ldd	r24, Y+4	; 0x04
    3e2e:	9d 81       	ldd	r25, Y+5	; 0x05
    3e30:	0e 94 35 0a 	call	0x146a	; 0x146a <vPortFree>

	/* In this case the xTimerListsWereSwitched parameter is not used, but it
	must be present in the function call. */
	xTimeNow = prvSampleTimeNow( &xTimerListsWereSwitched );

	while( xQueueReceive( xTimerQueue, &xMessage, tmrNO_DELAY ) != pdFAIL )
    3e34:	80 91 0a 07 	lds	r24, 0x070A
    3e38:	90 91 0b 07 	lds	r25, 0x070B
    3e3c:	9e 01       	movw	r18, r28
    3e3e:	2a 5f       	subi	r18, 0xFA	; 250
    3e40:	3f 4f       	sbci	r19, 0xFF	; 255
    3e42:	b9 01       	movw	r22, r18
    3e44:	40 e0       	ldi	r20, 0x00	; 0
    3e46:	50 e0       	ldi	r21, 0x00	; 0
    3e48:	20 e0       	ldi	r18, 0x00	; 0
    3e4a:	0e 94 23 10 	call	0x2046	; 0x2046 <xQueueGenericReceive>
    3e4e:	88 23       	and	r24, r24
    3e50:	09 f0       	breq	.+2      	; 0x3e54 <prvProcessReceivedCommands+0x15e>
    3e52:	64 cf       	rjmp	.-312    	; 0x3d1c <prvProcessReceivedCommands+0x26>
			default	:
				/* Don't expect to get here. */
				break;
		}
	}
}
    3e54:	2d 96       	adiw	r28, 0x0d	; 13
    3e56:	0f b6       	in	r0, 0x3f	; 63
    3e58:	f8 94       	cli
    3e5a:	de bf       	out	0x3e, r29	; 62
    3e5c:	0f be       	out	0x3f, r0	; 63
    3e5e:	cd bf       	out	0x3d, r28	; 61
    3e60:	cf 91       	pop	r28
    3e62:	df 91       	pop	r29
    3e64:	1f 91       	pop	r17
    3e66:	0f 91       	pop	r16
    3e68:	08 95       	ret

00003e6a <prvSwitchTimerLists>:
/*-----------------------------------------------------------*/

static void prvSwitchTimerLists( portTickType xLastTime )
{
    3e6a:	0f 93       	push	r16
    3e6c:	1f 93       	push	r17
    3e6e:	df 93       	push	r29
    3e70:	cf 93       	push	r28
    3e72:	cd b7       	in	r28, 0x3d	; 61
    3e74:	de b7       	in	r29, 0x3e	; 62
    3e76:	2b 97       	sbiw	r28, 0x0b	; 11
    3e78:	0f b6       	in	r0, 0x3f	; 63
    3e7a:	f8 94       	cli
    3e7c:	de bf       	out	0x3e, r29	; 62
    3e7e:	0f be       	out	0x3f, r0	; 63
    3e80:	cd bf       	out	0x3d, r28	; 61
    3e82:	9b 87       	std	Y+11, r25	; 0x0b
    3e84:	8a 87       	std	Y+10, r24	; 0x0a
    3e86:	60 c0       	rjmp	.+192    	; 0x3f48 <prvSwitchTimerLists+0xde>
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
	{
		xNextExpireTime = listGET_ITEM_VALUE_OF_HEAD_ENTRY( pxCurrentTimerList );
    3e88:	e0 91 20 07 	lds	r30, 0x0720
    3e8c:	f0 91 21 07 	lds	r31, 0x0721
    3e90:	05 80       	ldd	r0, Z+5	; 0x05
    3e92:	f6 81       	ldd	r31, Z+6	; 0x06
    3e94:	e0 2d       	mov	r30, r0
    3e96:	80 81       	ld	r24, Z
    3e98:	91 81       	ldd	r25, Z+1	; 0x01
    3e9a:	99 87       	std	Y+9, r25	; 0x09
    3e9c:	88 87       	std	Y+8, r24	; 0x08

		/* Remove the timer from the list. */
		pxTimer = ( xTIMER * ) listGET_OWNER_OF_HEAD_ENTRY( pxCurrentTimerList );
    3e9e:	e0 91 20 07 	lds	r30, 0x0720
    3ea2:	f0 91 21 07 	lds	r31, 0x0721
    3ea6:	05 80       	ldd	r0, Z+5	; 0x05
    3ea8:	f6 81       	ldd	r31, Z+6	; 0x06
    3eaa:	e0 2d       	mov	r30, r0
    3eac:	86 81       	ldd	r24, Z+6	; 0x06
    3eae:	97 81       	ldd	r25, Z+7	; 0x07
    3eb0:	9b 83       	std	Y+3, r25	; 0x03
    3eb2:	8a 83       	std	Y+2, r24	; 0x02
		vListRemove( &( pxTimer->xTimerListItem ) );
    3eb4:	8a 81       	ldd	r24, Y+2	; 0x02
    3eb6:	9b 81       	ldd	r25, Y+3	; 0x03
    3eb8:	02 96       	adiw	r24, 0x02	; 2
    3eba:	0e 94 4d 0b 	call	0x169a	; 0x169a <vListRemove>

		/* Execute its callback, then send a command to restart the timer if
		it is an auto-reload timer.  It cannot be restarted here as the lists
		have not yet been switched. */
		pxTimer->pxCallbackFunction( ( xTimerHandle ) pxTimer );
    3ebe:	ea 81       	ldd	r30, Y+2	; 0x02
    3ec0:	fb 81       	ldd	r31, Y+3	; 0x03
    3ec2:	01 88       	ldd	r0, Z+17	; 0x11
    3ec4:	f2 89       	ldd	r31, Z+18	; 0x12
    3ec6:	e0 2d       	mov	r30, r0
    3ec8:	8a 81       	ldd	r24, Y+2	; 0x02
    3eca:	9b 81       	ldd	r25, Y+3	; 0x03
    3ecc:	09 95       	icall

		if( pxTimer->uxAutoReload == ( unsigned portBASE_TYPE ) pdTRUE )
    3ece:	ea 81       	ldd	r30, Y+2	; 0x02
    3ed0:	fb 81       	ldd	r31, Y+3	; 0x03
    3ed2:	86 85       	ldd	r24, Z+14	; 0x0e
    3ed4:	81 30       	cpi	r24, 0x01	; 1
    3ed6:	c1 f5       	brne	.+112    	; 0x3f48 <prvSwitchTimerLists+0xde>
			the timer going into the same timer list then it has already expired
			and the timer should be re-inserted into the current list so it is
			processed again within this loop.  Otherwise a command should be sent
			to restart the timer to ensure it is only inserted into a list after
			the lists have been swapped. */
			xReloadTime = ( xNextExpireTime + pxTimer->xTimerPeriodInTicks );
    3ed8:	ea 81       	ldd	r30, Y+2	; 0x02
    3eda:	fb 81       	ldd	r31, Y+3	; 0x03
    3edc:	24 85       	ldd	r18, Z+12	; 0x0c
    3ede:	35 85       	ldd	r19, Z+13	; 0x0d
    3ee0:	88 85       	ldd	r24, Y+8	; 0x08
    3ee2:	99 85       	ldd	r25, Y+9	; 0x09
    3ee4:	82 0f       	add	r24, r18
    3ee6:	93 1f       	adc	r25, r19
    3ee8:	9f 83       	std	Y+7, r25	; 0x07
    3eea:	8e 83       	std	Y+6, r24	; 0x06
			if( xReloadTime > xNextExpireTime )
    3eec:	2e 81       	ldd	r18, Y+6	; 0x06
    3eee:	3f 81       	ldd	r19, Y+7	; 0x07
    3ef0:	88 85       	ldd	r24, Y+8	; 0x08
    3ef2:	99 85       	ldd	r25, Y+9	; 0x09
    3ef4:	82 17       	cp	r24, r18
    3ef6:	93 07       	cpc	r25, r19
    3ef8:	d0 f4       	brcc	.+52     	; 0x3f2e <prvSwitchTimerLists+0xc4>
			{
				listSET_LIST_ITEM_VALUE( &( pxTimer->xTimerListItem ), xReloadTime );
    3efa:	ea 81       	ldd	r30, Y+2	; 0x02
    3efc:	fb 81       	ldd	r31, Y+3	; 0x03
    3efe:	8e 81       	ldd	r24, Y+6	; 0x06
    3f00:	9f 81       	ldd	r25, Y+7	; 0x07
    3f02:	93 83       	std	Z+3, r25	; 0x03
    3f04:	82 83       	std	Z+2, r24	; 0x02
				listSET_LIST_ITEM_OWNER( &( pxTimer->xTimerListItem ), pxTimer );
    3f06:	ea 81       	ldd	r30, Y+2	; 0x02
    3f08:	fb 81       	ldd	r31, Y+3	; 0x03
    3f0a:	8a 81       	ldd	r24, Y+2	; 0x02
    3f0c:	9b 81       	ldd	r25, Y+3	; 0x03
    3f0e:	91 87       	std	Z+9, r25	; 0x09
    3f10:	80 87       	std	Z+8, r24	; 0x08
				vListInsert( pxCurrentTimerList, &( pxTimer->xTimerListItem ) );
    3f12:	40 91 20 07 	lds	r20, 0x0720
    3f16:	50 91 21 07 	lds	r21, 0x0721
    3f1a:	8a 81       	ldd	r24, Y+2	; 0x02
    3f1c:	9b 81       	ldd	r25, Y+3	; 0x03
    3f1e:	9c 01       	movw	r18, r24
    3f20:	2e 5f       	subi	r18, 0xFE	; 254
    3f22:	3f 4f       	sbci	r19, 0xFF	; 255
    3f24:	ca 01       	movw	r24, r20
    3f26:	b9 01       	movw	r22, r18
    3f28:	0e 94 e1 0a 	call	0x15c2	; 0x15c2 <vListInsert>
    3f2c:	0d c0       	rjmp	.+26     	; 0x3f48 <prvSwitchTimerLists+0xde>
			}
			else
			{
				xResult = xTimerGenericCommand( pxTimer, tmrCOMMAND_START, xNextExpireTime, NULL, tmrNO_DELAY );
    3f2e:	8a 81       	ldd	r24, Y+2	; 0x02
    3f30:	9b 81       	ldd	r25, Y+3	; 0x03
    3f32:	28 85       	ldd	r18, Y+8	; 0x08
    3f34:	39 85       	ldd	r19, Y+9	; 0x09
    3f36:	60 e0       	ldi	r22, 0x00	; 0
    3f38:	a9 01       	movw	r20, r18
    3f3a:	20 e0       	ldi	r18, 0x00	; 0
    3f3c:	30 e0       	ldi	r19, 0x00	; 0
    3f3e:	00 e0       	ldi	r16, 0x00	; 0
    3f40:	10 e0       	ldi	r17, 0x00	; 0
    3f42:	0e 94 8a 1c 	call	0x3914	; 0x3914 <xTimerGenericCommand>
    3f46:	89 83       	std	Y+1, r24	; 0x01

	/* The tick count has overflowed.  The timer lists must be switched.
	If there are any timers still referenced from the current timer list
	then they must have expired and should be processed before the lists
	are switched. */
	while( listLIST_IS_EMPTY( pxCurrentTimerList ) == pdFALSE )
    3f48:	e0 91 20 07 	lds	r30, 0x0720
    3f4c:	f0 91 21 07 	lds	r31, 0x0721
    3f50:	80 81       	ld	r24, Z
    3f52:	88 23       	and	r24, r24
    3f54:	09 f0       	breq	.+2      	; 0x3f58 <prvSwitchTimerLists+0xee>
    3f56:	98 cf       	rjmp	.-208    	; 0x3e88 <prvSwitchTimerLists+0x1e>
				( void ) xResult;
			}
		}
	}

	pxTemp = pxCurrentTimerList;
    3f58:	80 91 20 07 	lds	r24, 0x0720
    3f5c:	90 91 21 07 	lds	r25, 0x0721
    3f60:	9d 83       	std	Y+5, r25	; 0x05
    3f62:	8c 83       	std	Y+4, r24	; 0x04
	pxCurrentTimerList = pxOverflowTimerList;
    3f64:	80 91 22 07 	lds	r24, 0x0722
    3f68:	90 91 23 07 	lds	r25, 0x0723
    3f6c:	90 93 21 07 	sts	0x0721, r25
    3f70:	80 93 20 07 	sts	0x0720, r24
	pxOverflowTimerList = pxTemp;
    3f74:	8c 81       	ldd	r24, Y+4	; 0x04
    3f76:	9d 81       	ldd	r25, Y+5	; 0x05
    3f78:	90 93 23 07 	sts	0x0723, r25
    3f7c:	80 93 22 07 	sts	0x0722, r24
}
    3f80:	2b 96       	adiw	r28, 0x0b	; 11
    3f82:	0f b6       	in	r0, 0x3f	; 63
    3f84:	f8 94       	cli
    3f86:	de bf       	out	0x3e, r29	; 62
    3f88:	0f be       	out	0x3f, r0	; 63
    3f8a:	cd bf       	out	0x3d, r28	; 61
    3f8c:	cf 91       	pop	r28
    3f8e:	df 91       	pop	r29
    3f90:	1f 91       	pop	r17
    3f92:	0f 91       	pop	r16
    3f94:	08 95       	ret

00003f96 <prvCheckForValidListAndQueue>:
/*-----------------------------------------------------------*/

static void prvCheckForValidListAndQueue( void )
{
    3f96:	df 93       	push	r29
    3f98:	cf 93       	push	r28
    3f9a:	cd b7       	in	r28, 0x3d	; 61
    3f9c:	de b7       	in	r29, 0x3e	; 62
	/* Check that the list from which active timers are referenced, and the
	queue used to communicate with the timer service, have been
	initialised. */
	taskENTER_CRITICAL();
    3f9e:	0f b6       	in	r0, 0x3f	; 63
    3fa0:	f8 94       	cli
    3fa2:	0f 92       	push	r0
	{
		if( xTimerQueue == NULL )
    3fa4:	80 91 0a 07 	lds	r24, 0x070A
    3fa8:	90 91 0b 07 	lds	r25, 0x070B
    3fac:	00 97       	sbiw	r24, 0x00	; 0
    3fae:	e1 f4       	brne	.+56     	; 0x3fe8 <prvCheckForValidListAndQueue+0x52>
		{
			vListInitialise( &xActiveTimerList1 );
    3fb0:	8e e0       	ldi	r24, 0x0E	; 14
    3fb2:	97 e0       	ldi	r25, 0x07	; 7
    3fb4:	0e 94 5b 0a 	call	0x14b6	; 0x14b6 <vListInitialise>
			vListInitialise( &xActiveTimerList2 );
    3fb8:	87 e1       	ldi	r24, 0x17	; 23
    3fba:	97 e0       	ldi	r25, 0x07	; 7
    3fbc:	0e 94 5b 0a 	call	0x14b6	; 0x14b6 <vListInitialise>
			pxCurrentTimerList = &xActiveTimerList1;
    3fc0:	8e e0       	ldi	r24, 0x0E	; 14
    3fc2:	97 e0       	ldi	r25, 0x07	; 7
    3fc4:	90 93 21 07 	sts	0x0721, r25
    3fc8:	80 93 20 07 	sts	0x0720, r24
			pxOverflowTimerList = &xActiveTimerList2;
    3fcc:	87 e1       	ldi	r24, 0x17	; 23
    3fce:	97 e0       	ldi	r25, 0x07	; 7
    3fd0:	90 93 23 07 	sts	0x0723, r25
    3fd4:	80 93 22 07 	sts	0x0722, r24
			xTimerQueue = xQueueCreate( ( unsigned portBASE_TYPE ) configTIMER_QUEUE_LENGTH, sizeof( xTIMER_MESSAGE ) );
    3fd8:	8a e0       	ldi	r24, 0x0A	; 10
    3fda:	65 e0       	ldi	r22, 0x05	; 5
    3fdc:	0e 94 8f 0e 	call	0x1d1e	; 0x1d1e <xQueueCreate>
    3fe0:	90 93 0b 07 	sts	0x070B, r25
    3fe4:	80 93 0a 07 	sts	0x070A, r24
		}
	}
	taskEXIT_CRITICAL();
    3fe8:	0f 90       	pop	r0
    3fea:	0f be       	out	0x3f, r0	; 63
}
    3fec:	cf 91       	pop	r28
    3fee:	df 91       	pop	r29
    3ff0:	08 95       	ret

00003ff2 <xTimerIsTimerActive>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTimerIsTimerActive( xTimerHandle xTimer )
{
    3ff2:	df 93       	push	r29
    3ff4:	cf 93       	push	r28
    3ff6:	00 d0       	rcall	.+0      	; 0x3ff8 <xTimerIsTimerActive+0x6>
    3ff8:	00 d0       	rcall	.+0      	; 0x3ffa <xTimerIsTimerActive+0x8>
    3ffa:	0f 92       	push	r0
    3ffc:	cd b7       	in	r28, 0x3d	; 61
    3ffe:	de b7       	in	r29, 0x3e	; 62
    4000:	9d 83       	std	Y+5, r25	; 0x05
    4002:	8c 83       	std	Y+4, r24	; 0x04
portBASE_TYPE xTimerIsInActiveList;
xTIMER *pxTimer = ( xTIMER * ) xTimer;
    4004:	8c 81       	ldd	r24, Y+4	; 0x04
    4006:	9d 81       	ldd	r25, Y+5	; 0x05
    4008:	9a 83       	std	Y+2, r25	; 0x02
    400a:	89 83       	std	Y+1, r24	; 0x01

	/* Is the timer in the list of active timers? */
	taskENTER_CRITICAL();
    400c:	0f b6       	in	r0, 0x3f	; 63
    400e:	f8 94       	cli
    4010:	0f 92       	push	r0
	{
		/* Checking to see if it is in the NULL list in effect checks to see if
		it is referenced from either the current or the overflow timer lists in
		one go, but the logic has to be reversed, hence the '!'. */
		xTimerIsInActiveList = !( listIS_CONTAINED_WITHIN( NULL, &( pxTimer->xTimerListItem ) ) );
    4012:	e9 81       	ldd	r30, Y+1	; 0x01
    4014:	fa 81       	ldd	r31, Y+2	; 0x02
    4016:	82 85       	ldd	r24, Z+10	; 0x0a
    4018:	93 85       	ldd	r25, Z+11	; 0x0b
    401a:	1b 82       	std	Y+3, r1	; 0x03
    401c:	00 97       	sbiw	r24, 0x00	; 0
    401e:	11 f0       	breq	.+4      	; 0x4024 <xTimerIsTimerActive+0x32>
    4020:	81 e0       	ldi	r24, 0x01	; 1
    4022:	8b 83       	std	Y+3, r24	; 0x03
	}
	taskEXIT_CRITICAL();
    4024:	0f 90       	pop	r0
    4026:	0f be       	out	0x3f, r0	; 63

	return xTimerIsInActiveList;
    4028:	8b 81       	ldd	r24, Y+3	; 0x03
}
    402a:	0f 90       	pop	r0
    402c:	0f 90       	pop	r0
    402e:	0f 90       	pop	r0
    4030:	0f 90       	pop	r0
    4032:	0f 90       	pop	r0
    4034:	cf 91       	pop	r28
    4036:	df 91       	pop	r29
    4038:	08 95       	ret

0000403a <pvTimerGetTimerID>:
/*-----------------------------------------------------------*/

void *pvTimerGetTimerID( xTimerHandle xTimer )
{
    403a:	df 93       	push	r29
    403c:	cf 93       	push	r28
    403e:	00 d0       	rcall	.+0      	; 0x4040 <pvTimerGetTimerID+0x6>
    4040:	00 d0       	rcall	.+0      	; 0x4042 <pvTimerGetTimerID+0x8>
    4042:	cd b7       	in	r28, 0x3d	; 61
    4044:	de b7       	in	r29, 0x3e	; 62
    4046:	9c 83       	std	Y+4, r25	; 0x04
    4048:	8b 83       	std	Y+3, r24	; 0x03
xTIMER *pxTimer = ( xTIMER * ) xTimer;
    404a:	8b 81       	ldd	r24, Y+3	; 0x03
    404c:	9c 81       	ldd	r25, Y+4	; 0x04
    404e:	9a 83       	std	Y+2, r25	; 0x02
    4050:	89 83       	std	Y+1, r24	; 0x01

	return pxTimer->pvTimerID;
    4052:	e9 81       	ldd	r30, Y+1	; 0x01
    4054:	fa 81       	ldd	r31, Y+2	; 0x02
    4056:	87 85       	ldd	r24, Z+15	; 0x0f
    4058:	90 89       	ldd	r25, Z+16	; 0x10
}
    405a:	0f 90       	pop	r0
    405c:	0f 90       	pop	r0
    405e:	0f 90       	pop	r0
    4060:	0f 90       	pop	r0
    4062:	cf 91       	pop	r28
    4064:	df 91       	pop	r29
    4066:	08 95       	ret

00004068 <task1>:
int num=60;
int mode = 0;
int avgTemp = 0;

void task1()
{
    4068:	0f 93       	push	r16
    406a:	1f 93       	push	r17
    406c:	df 93       	push	r29
    406e:	cf 93       	push	r28
    4070:	cd b7       	in	r28, 0x3d	; 61
    4072:	de b7       	in	r29, 0x3e	; 62
	while (1)
		{

			if (BUTTON_udtbuttonStatus(BUTTON1)==PRESSED)
    4074:	81 e0       	ldi	r24, 0x01	; 1
    4076:	0e 94 94 2a 	call	0x5528	; 0x5528 <BUTTON_udtbuttonStatus>
    407a:	81 30       	cpi	r24, 0x01	; 1
    407c:	09 f0       	breq	.+2      	; 0x4080 <task1+0x18>
    407e:	4c c0       	rjmp	.+152    	; 0x4118 <task1+0xb0>
			{
				if (mode==0)
    4080:	80 91 30 07 	lds	r24, 0x0730
    4084:	90 91 31 07 	lds	r25, 0x0731
    4088:	00 97       	sbiw	r24, 0x00	; 0
    408a:	d9 f4       	brne	.+54     	; 0x40c2 <task1+0x5a>
				{
					vTaskDelay(250);
    408c:	8a ef       	ldi	r24, 0xFA	; 250
    408e:	90 e0       	ldi	r25, 0x00	; 0
    4090:	0e 94 a8 14 	call	0x2950	; 0x2950 <vTaskDelay>
					mode=1;
    4094:	81 e0       	ldi	r24, 0x01	; 1
    4096:	90 e0       	ldi	r25, 0x00	; 0
    4098:	90 93 31 07 	sts	0x0731, r25
    409c:	80 93 30 07 	sts	0x0730, r24
					xTimerReset(timer1handler,0);
    40a0:	00 91 2e 07 	lds	r16, 0x072E
    40a4:	10 91 2f 07 	lds	r17, 0x072F
    40a8:	0e 94 c6 17 	call	0x2f8c	; 0x2f8c <xTaskGetTickCount>
    40ac:	9c 01       	movw	r18, r24
    40ae:	c8 01       	movw	r24, r16
    40b0:	60 e0       	ldi	r22, 0x00	; 0
    40b2:	a9 01       	movw	r20, r18
    40b4:	20 e0       	ldi	r18, 0x00	; 0
    40b6:	30 e0       	ldi	r19, 0x00	; 0
    40b8:	00 e0       	ldi	r16, 0x00	; 0
    40ba:	10 e0       	ldi	r17, 0x00	; 0
    40bc:	0e 94 8a 1c 	call	0x3914	; 0x3914 <xTimerGenericCommand>
    40c0:	2b c0       	rjmp	.+86     	; 0x4118 <task1+0xb0>
				}
				else if (mode==1)
    40c2:	80 91 30 07 	lds	r24, 0x0730
    40c6:	90 91 31 07 	lds	r25, 0x0731
    40ca:	81 30       	cpi	r24, 0x01	; 1
    40cc:	91 05       	cpc	r25, r1
    40ce:	21 f5       	brne	.+72     	; 0x4118 <task1+0xb0>
				{
					vTaskDelay(250);
    40d0:	8a ef       	ldi	r24, 0xFA	; 250
    40d2:	90 e0       	ldi	r25, 0x00	; 0
    40d4:	0e 94 a8 14 	call	0x2950	; 0x2950 <vTaskDelay>
					if (num>25)
    40d8:	80 91 a1 01 	lds	r24, 0x01A1
    40dc:	90 91 a2 01 	lds	r25, 0x01A2
    40e0:	8a 31       	cpi	r24, 0x1A	; 26
    40e2:	91 05       	cpc	r25, r1
    40e4:	4c f0       	brlt	.+18     	; 0x40f8 <task1+0x90>
					{
						num=num-5;
    40e6:	80 91 a1 01 	lds	r24, 0x01A1
    40ea:	90 91 a2 01 	lds	r25, 0x01A2
    40ee:	05 97       	sbiw	r24, 0x05	; 5
    40f0:	90 93 a2 01 	sts	0x01A2, r25
    40f4:	80 93 a1 01 	sts	0x01A1, r24
					}
					xTimerReset(timer1handler,0);
    40f8:	00 91 2e 07 	lds	r16, 0x072E
    40fc:	10 91 2f 07 	lds	r17, 0x072F
    4100:	0e 94 c6 17 	call	0x2f8c	; 0x2f8c <xTaskGetTickCount>
    4104:	9c 01       	movw	r18, r24
    4106:	c8 01       	movw	r24, r16
    4108:	60 e0       	ldi	r22, 0x00	; 0
    410a:	a9 01       	movw	r20, r18
    410c:	20 e0       	ldi	r18, 0x00	; 0
    410e:	30 e0       	ldi	r19, 0x00	; 0
    4110:	00 e0       	ldi	r16, 0x00	; 0
    4112:	10 e0       	ldi	r17, 0x00	; 0
    4114:	0e 94 8a 1c 	call	0x3914	; 0x3914 <xTimerGenericCommand>
				}
			}
			vTaskDelay(100);
    4118:	84 e6       	ldi	r24, 0x64	; 100
    411a:	90 e0       	ldi	r25, 0x00	; 0
    411c:	0e 94 a8 14 	call	0x2950	; 0x2950 <vTaskDelay>
    4120:	a9 cf       	rjmp	.-174    	; 0x4074 <task1+0xc>

00004122 <task2>:
		}
}
void task2()
{
    4122:	0f 93       	push	r16
    4124:	1f 93       	push	r17
    4126:	df 93       	push	r29
    4128:	cf 93       	push	r28
    412a:	cd b7       	in	r28, 0x3d	; 61
    412c:	de b7       	in	r29, 0x3e	; 62
	while (1)
	{
		if (BUTTON_udtbuttonStatus(BUTTON0)==PRESSED)
    412e:	80 e0       	ldi	r24, 0x00	; 0
    4130:	0e 94 94 2a 	call	0x5528	; 0x5528 <BUTTON_udtbuttonStatus>
    4134:	81 30       	cpi	r24, 0x01	; 1
    4136:	09 f0       	breq	.+2      	; 0x413a <task2+0x18>
    4138:	4c c0       	rjmp	.+152    	; 0x41d2 <task2+0xb0>
		{
			if (mode==0)
    413a:	80 91 30 07 	lds	r24, 0x0730
    413e:	90 91 31 07 	lds	r25, 0x0731
    4142:	00 97       	sbiw	r24, 0x00	; 0
    4144:	d9 f4       	brne	.+54     	; 0x417c <task2+0x5a>
			{
				vTaskDelay(250);
    4146:	8a ef       	ldi	r24, 0xFA	; 250
    4148:	90 e0       	ldi	r25, 0x00	; 0
    414a:	0e 94 a8 14 	call	0x2950	; 0x2950 <vTaskDelay>
				mode=1;
    414e:	81 e0       	ldi	r24, 0x01	; 1
    4150:	90 e0       	ldi	r25, 0x00	; 0
    4152:	90 93 31 07 	sts	0x0731, r25
    4156:	80 93 30 07 	sts	0x0730, r24
				xTimerReset(timer1handler,0);
    415a:	00 91 2e 07 	lds	r16, 0x072E
    415e:	10 91 2f 07 	lds	r17, 0x072F
    4162:	0e 94 c6 17 	call	0x2f8c	; 0x2f8c <xTaskGetTickCount>
    4166:	9c 01       	movw	r18, r24
    4168:	c8 01       	movw	r24, r16
    416a:	60 e0       	ldi	r22, 0x00	; 0
    416c:	a9 01       	movw	r20, r18
    416e:	20 e0       	ldi	r18, 0x00	; 0
    4170:	30 e0       	ldi	r19, 0x00	; 0
    4172:	00 e0       	ldi	r16, 0x00	; 0
    4174:	10 e0       	ldi	r17, 0x00	; 0
    4176:	0e 94 8a 1c 	call	0x3914	; 0x3914 <xTimerGenericCommand>
    417a:	2b c0       	rjmp	.+86     	; 0x41d2 <task2+0xb0>
			}
			else if (mode==1)
    417c:	80 91 30 07 	lds	r24, 0x0730
    4180:	90 91 31 07 	lds	r25, 0x0731
    4184:	81 30       	cpi	r24, 0x01	; 1
    4186:	91 05       	cpc	r25, r1
    4188:	21 f5       	brne	.+72     	; 0x41d2 <task2+0xb0>
			{
				vTaskDelay(250);
    418a:	8a ef       	ldi	r24, 0xFA	; 250
    418c:	90 e0       	ldi	r25, 0x00	; 0
    418e:	0e 94 a8 14 	call	0x2950	; 0x2950 <vTaskDelay>
				if (num<75)
    4192:	80 91 a1 01 	lds	r24, 0x01A1
    4196:	90 91 a2 01 	lds	r25, 0x01A2
    419a:	8b 34       	cpi	r24, 0x4B	; 75
    419c:	91 05       	cpc	r25, r1
    419e:	4c f4       	brge	.+18     	; 0x41b2 <task2+0x90>
				{
					num=num+5;
    41a0:	80 91 a1 01 	lds	r24, 0x01A1
    41a4:	90 91 a2 01 	lds	r25, 0x01A2
    41a8:	05 96       	adiw	r24, 0x05	; 5
    41aa:	90 93 a2 01 	sts	0x01A2, r25
    41ae:	80 93 a1 01 	sts	0x01A1, r24
				}
				xTimerReset(timer1handler,0);
    41b2:	00 91 2e 07 	lds	r16, 0x072E
    41b6:	10 91 2f 07 	lds	r17, 0x072F
    41ba:	0e 94 c6 17 	call	0x2f8c	; 0x2f8c <xTaskGetTickCount>
    41be:	9c 01       	movw	r18, r24
    41c0:	c8 01       	movw	r24, r16
    41c2:	60 e0       	ldi	r22, 0x00	; 0
    41c4:	a9 01       	movw	r20, r18
    41c6:	20 e0       	ldi	r18, 0x00	; 0
    41c8:	30 e0       	ldi	r19, 0x00	; 0
    41ca:	00 e0       	ldi	r16, 0x00	; 0
    41cc:	10 e0       	ldi	r17, 0x00	; 0
    41ce:	0e 94 8a 1c 	call	0x3914	; 0x3914 <xTimerGenericCommand>
			}
		}
		vTaskDelay(100);
    41d2:	84 e6       	ldi	r24, 0x64	; 100
    41d4:	90 e0       	ldi	r25, 0x00	; 0
    41d6:	0e 94 a8 14 	call	0x2950	; 0x2950 <vTaskDelay>
    41da:	a9 cf       	rjmp	.-174    	; 0x412e <task2+0xc>

000041dc <task3>:
	}
}
void task3()
{
    41dc:	df 93       	push	r29
    41de:	cf 93       	push	r28
    41e0:	cd b7       	in	r28, 0x3d	; 61
    41e2:	de b7       	in	r29, 0x3e	; 62
		while (1)
		{
			if (mode == 1)
    41e4:	80 91 30 07 	lds	r24, 0x0730
    41e8:	90 91 31 07 	lds	r25, 0x0731
    41ec:	81 30       	cpi	r24, 0x01	; 1
    41ee:	91 05       	cpc	r25, r1
    41f0:	79 f4       	brne	.+30     	; 0x4210 <task3+0x34>
			{
				SSD_vidDelayDisplay(num,1000);
    41f2:	80 91 a1 01 	lds	r24, 0x01A1
    41f6:	90 91 a2 01 	lds	r25, 0x01A2
    41fa:	68 ee       	ldi	r22, 0xE8	; 232
    41fc:	73 e0       	ldi	r23, 0x03	; 3
    41fe:	0e 94 06 23 	call	0x460c	; 0x460c <SSD_vidDelayDisplay>
				SSD_vidDisableSSD();
    4202:	0e 94 f5 22 	call	0x45ea	; 0x45ea <SSD_vidDisableSSD>
				vTaskDelay(1000);
    4206:	88 ee       	ldi	r24, 0xE8	; 232
    4208:	93 e0       	ldi	r25, 0x03	; 3
    420a:	0e 94 a8 14 	call	0x2950	; 0x2950 <vTaskDelay>
    420e:	ea cf       	rjmp	.-44     	; 0x41e4 <task3+0x8>
			}
			else if (mode==0)
    4210:	80 91 30 07 	lds	r24, 0x0730
    4214:	90 91 31 07 	lds	r25, 0x0731
    4218:	00 97       	sbiw	r24, 0x00	; 0
    421a:	21 f7       	brne	.-56     	; 0x41e4 <task3+0x8>
			{
				SSD_viddispNum(avgTemp);
    421c:	80 91 32 07 	lds	r24, 0x0732
    4220:	90 91 33 07 	lds	r25, 0x0733
    4224:	0e 94 b1 22 	call	0x4562	; 0x4562 <SSD_viddispNum>
    4228:	dd cf       	rjmp	.-70     	; 0x41e4 <task3+0x8>

0000422a <task4>:
			}
		}
}

void task4()
{
    422a:	df 93       	push	r29
    422c:	cf 93       	push	r28
    422e:	cd b7       	in	r28, 0x3d	; 61
    4230:	de b7       	in	r29, 0x3e	; 62
	while (1)
	{
		if (avgTemp<=(num-5))
    4232:	80 91 a1 01 	lds	r24, 0x01A1
    4236:	90 91 a2 01 	lds	r25, 0x01A2
    423a:	9c 01       	movw	r18, r24
    423c:	25 50       	subi	r18, 0x05	; 5
    423e:	30 40       	sbci	r19, 0x00	; 0
    4240:	80 91 32 07 	lds	r24, 0x0732
    4244:	90 91 33 07 	lds	r25, 0x0733
    4248:	28 17       	cp	r18, r24
    424a:	39 07       	cpc	r19, r25
    424c:	4c f0       	brlt	.+18     	; 0x4260 <task4+0x36>
		{
			RELAY_vidrelayOn();
    424e:	0e 94 57 23 	call	0x46ae	; 0x46ae <RELAY_vidrelayOn>
			LED_vidledOn(LED0);
    4252:	80 e0       	ldi	r24, 0x00	; 0
    4254:	0e 94 dd 23 	call	0x47ba	; 0x47ba <LED_vidledOn>
			LED_vidledOff(LED1);
    4258:	81 e0       	ldi	r24, 0x01	; 1
    425a:	0e 94 0e 24 	call	0x481c	; 0x481c <LED_vidledOff>
    425e:	16 c0       	rjmp	.+44     	; 0x428c <task4+0x62>
		}
		else if (avgTemp>(num+5))
    4260:	80 91 a1 01 	lds	r24, 0x01A1
    4264:	90 91 a2 01 	lds	r25, 0x01A2
    4268:	9c 01       	movw	r18, r24
    426a:	2b 5f       	subi	r18, 0xFB	; 251
    426c:	3f 4f       	sbci	r19, 0xFF	; 255
    426e:	80 91 32 07 	lds	r24, 0x0732
    4272:	90 91 33 07 	lds	r25, 0x0733
    4276:	28 17       	cp	r18, r24
    4278:	39 07       	cpc	r19, r25
    427a:	44 f4       	brge	.+16     	; 0x428c <task4+0x62>
		{
			RELAY_vidrelayOff();
    427c:	0e 94 63 23 	call	0x46c6	; 0x46c6 <RELAY_vidrelayOff>
			LED_vidledOff(LED0);
    4280:	80 e0       	ldi	r24, 0x00	; 0
    4282:	0e 94 0e 24 	call	0x481c	; 0x481c <LED_vidledOff>
			LED_vidledOn(LED1);
    4286:	81 e0       	ldi	r24, 0x01	; 1
    4288:	0e 94 dd 23 	call	0x47ba	; 0x47ba <LED_vidledOn>
		}
		vTaskDelay(1000);
    428c:	88 ee       	ldi	r24, 0xE8	; 232
    428e:	93 e0       	ldi	r25, 0x03	; 3
    4290:	0e 94 a8 14 	call	0x2950	; 0x2950 <vTaskDelay>
    4294:	ce cf       	rjmp	.-100    	; 0x4232 <task4+0x8>

00004296 <task5>:
	}
}
int task5(void)
{
    4296:	0f 93       	push	r16
    4298:	1f 93       	push	r17
    429a:	df 93       	push	r29
    429c:	cf 93       	push	r28
    429e:	cd b7       	in	r28, 0x3d	; 61
    42a0:	de b7       	in	r29, 0x3e	; 62
    42a2:	2d 97       	sbiw	r28, 0x0d	; 13
    42a4:	0f b6       	in	r0, 0x3f	; 63
    42a6:	f8 94       	cli
    42a8:	de bf       	out	0x3e, r29	; 62
    42aa:	0f be       	out	0x3f, r0	; 63
    42ac:	cd bf       	out	0x3d, r28	; 61
	u16 temp;
	u8 tempArr[10] = {};
    42ae:	8a e0       	ldi	r24, 0x0A	; 10
    42b0:	fe 01       	movw	r30, r28
    42b2:	34 96       	adiw	r30, 0x04	; 4
    42b4:	df 01       	movw	r26, r30
    42b6:	98 2f       	mov	r25, r24
    42b8:	1d 92       	st	X+, r1
    42ba:	9a 95       	dec	r25
    42bc:	e9 f7       	brne	.-6      	; 0x42b8 <task5+0x22>

	while (1)
	{
		temp = 0;
    42be:	1b 82       	std	Y+3, r1	; 0x03
    42c0:	1a 82       	std	Y+2, r1	; 0x02
		for (u8 i = 0;i < 10;i++)
    42c2:	19 82       	std	Y+1, r1	; 0x01
    42c4:	2c c0       	rjmp	.+88     	; 0x431e <task5+0x88>
		{
			tempArr[i] = H_LM35_Void_LM35Read();
    42c6:	89 81       	ldd	r24, Y+1	; 0x01
    42c8:	08 2f       	mov	r16, r24
    42ca:	10 e0       	ldi	r17, 0x00	; 0
    42cc:	0e 94 78 23 	call	0x46f0	; 0x46f0 <H_LM35_Void_LM35Read>
    42d0:	dc 01       	movw	r26, r24
    42d2:	cb 01       	movw	r24, r22
    42d4:	bc 01       	movw	r22, r24
    42d6:	cd 01       	movw	r24, r26
    42d8:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    42dc:	dc 01       	movw	r26, r24
    42de:	cb 01       	movw	r24, r22
    42e0:	28 2f       	mov	r18, r24
    42e2:	ce 01       	movw	r24, r28
    42e4:	04 96       	adiw	r24, 0x04	; 4
    42e6:	fc 01       	movw	r30, r24
    42e8:	e0 0f       	add	r30, r16
    42ea:	f1 1f       	adc	r31, r17
    42ec:	20 83       	st	Z, r18
			temp = temp + tempArr[i];
    42ee:	89 81       	ldd	r24, Y+1	; 0x01
    42f0:	28 2f       	mov	r18, r24
    42f2:	30 e0       	ldi	r19, 0x00	; 0
    42f4:	ce 01       	movw	r24, r28
    42f6:	04 96       	adiw	r24, 0x04	; 4
    42f8:	fc 01       	movw	r30, r24
    42fa:	e2 0f       	add	r30, r18
    42fc:	f3 1f       	adc	r31, r19
    42fe:	80 81       	ld	r24, Z
    4300:	28 2f       	mov	r18, r24
    4302:	30 e0       	ldi	r19, 0x00	; 0
    4304:	8a 81       	ldd	r24, Y+2	; 0x02
    4306:	9b 81       	ldd	r25, Y+3	; 0x03
    4308:	82 0f       	add	r24, r18
    430a:	93 1f       	adc	r25, r19
    430c:	9b 83       	std	Y+3, r25	; 0x03
    430e:	8a 83       	std	Y+2, r24	; 0x02
			vTaskDelay(100);
    4310:	84 e6       	ldi	r24, 0x64	; 100
    4312:	90 e0       	ldi	r25, 0x00	; 0
    4314:	0e 94 a8 14 	call	0x2950	; 0x2950 <vTaskDelay>
	u8 tempArr[10] = {};

	while (1)
	{
		temp = 0;
		for (u8 i = 0;i < 10;i++)
    4318:	89 81       	ldd	r24, Y+1	; 0x01
    431a:	8f 5f       	subi	r24, 0xFF	; 255
    431c:	89 83       	std	Y+1, r24	; 0x01
    431e:	89 81       	ldd	r24, Y+1	; 0x01
    4320:	8a 30       	cpi	r24, 0x0A	; 10
    4322:	88 f2       	brcs	.-94     	; 0x42c6 <task5+0x30>
		{
			tempArr[i] = H_LM35_Void_LM35Read();
			temp = temp + tempArr[i];
			vTaskDelay(100);
		}
		avgTemp = temp/10;
    4324:	8a 81       	ldd	r24, Y+2	; 0x02
    4326:	9b 81       	ldd	r25, Y+3	; 0x03
    4328:	2a e0       	ldi	r18, 0x0A	; 10
    432a:	30 e0       	ldi	r19, 0x00	; 0
    432c:	b9 01       	movw	r22, r18
    432e:	0e 94 99 31 	call	0x6332	; 0x6332 <__udivmodhi4>
    4332:	cb 01       	movw	r24, r22
    4334:	90 93 33 07 	sts	0x0733, r25
    4338:	80 93 32 07 	sts	0x0732, r24
		temp=0;
    433c:	1b 82       	std	Y+3, r1	; 0x03
    433e:	1a 82       	std	Y+2, r1	; 0x02
    4340:	be cf       	rjmp	.-132    	; 0x42be <task5+0x28>

00004342 <vTimerCallback>:

}


 void vTimerCallback( xTimerHandle xTimer )
 {
    4342:	df 93       	push	r29
    4344:	cf 93       	push	r28
    4346:	00 d0       	rcall	.+0      	; 0x4348 <vTimerCallback+0x6>
    4348:	cd b7       	in	r28, 0x3d	; 61
    434a:	de b7       	in	r29, 0x3e	; 62
    434c:	9a 83       	std	Y+2, r25	; 0x02
    434e:	89 83       	std	Y+1, r24	; 0x01
	 mode=0;
    4350:	10 92 31 07 	sts	0x0731, r1
    4354:	10 92 30 07 	sts	0x0730, r1
 }
    4358:	0f 90       	pop	r0
    435a:	0f 90       	pop	r0
    435c:	cf 91       	pop	r28
    435e:	df 91       	pop	r29
    4360:	08 95       	ret

00004362 <main>:



int main(void)
{
    4362:	af 92       	push	r10
    4364:	bf 92       	push	r11
    4366:	cf 92       	push	r12
    4368:	df 92       	push	r13
    436a:	ef 92       	push	r14
    436c:	ff 92       	push	r15
    436e:	0f 93       	push	r16
    4370:	1f 93       	push	r17
    4372:	df 93       	push	r29
    4374:	cf 93       	push	r28
    4376:	cd b7       	in	r28, 0x3d	; 61
    4378:	de b7       	in	r29, 0x3e	; 62
	RELAY_vidrelayInit();
    437a:	0e 94 4b 23 	call	0x4696	; 0x4696 <RELAY_vidrelayInit>
	SSD_vidssdInit();
    437e:	0e 94 8c 22 	call	0x4518	; 0x4518 <SSD_vidssdInit>
	LED_vidledInit();
    4382:	0e 94 c7 23 	call	0x478e	; 0x478e <LED_vidledInit>
	BUTTON_vidbuttonInit();
    4386:	0e 94 7e 2a 	call	0x54fc	; 0x54fc <BUTTON_vidbuttonInit>
	ADC_Init();
    438a:	0e 94 1a 31 	call	0x6234	; 0x6234 <ADC_Init>


	task1handler=xTaskCreate(task1,"task1",85,NULL,2,task1handler);
    438e:	24 e3       	ldi	r18, 0x34	; 52
    4390:	30 e2       	ldi	r19, 0x20	; 32
    4392:	4d e6       	ldi	r20, 0x6D	; 109
    4394:	50 e0       	ldi	r21, 0x00	; 0
    4396:	80 91 24 07 	lds	r24, 0x0724
    439a:	90 91 25 07 	lds	r25, 0x0725
    439e:	fc 01       	movw	r30, r24
    43a0:	c9 01       	movw	r24, r18
    43a2:	ba 01       	movw	r22, r20
    43a4:	45 e5       	ldi	r20, 0x55	; 85
    43a6:	50 e0       	ldi	r21, 0x00	; 0
    43a8:	20 e0       	ldi	r18, 0x00	; 0
    43aa:	30 e0       	ldi	r19, 0x00	; 0
    43ac:	02 e0       	ldi	r16, 0x02	; 2
    43ae:	7f 01       	movw	r14, r30
    43b0:	cc 24       	eor	r12, r12
    43b2:	dd 24       	eor	r13, r13
    43b4:	aa 24       	eor	r10, r10
    43b6:	bb 24       	eor	r11, r11
    43b8:	0e 94 47 13 	call	0x268e	; 0x268e <xTaskGenericCreate>
    43bc:	99 27       	eor	r25, r25
    43be:	87 fd       	sbrc	r24, 7
    43c0:	90 95       	com	r25
    43c2:	90 93 25 07 	sts	0x0725, r25
    43c6:	80 93 24 07 	sts	0x0724, r24
	task2handler=xTaskCreate(task2,"task2",85,NULL,2,task2handler);
    43ca:	21 e9       	ldi	r18, 0x91	; 145
    43cc:	30 e2       	ldi	r19, 0x20	; 32
    43ce:	43 e7       	ldi	r20, 0x73	; 115
    43d0:	50 e0       	ldi	r21, 0x00	; 0
    43d2:	80 91 26 07 	lds	r24, 0x0726
    43d6:	90 91 27 07 	lds	r25, 0x0727
    43da:	fc 01       	movw	r30, r24
    43dc:	c9 01       	movw	r24, r18
    43de:	ba 01       	movw	r22, r20
    43e0:	45 e5       	ldi	r20, 0x55	; 85
    43e2:	50 e0       	ldi	r21, 0x00	; 0
    43e4:	20 e0       	ldi	r18, 0x00	; 0
    43e6:	30 e0       	ldi	r19, 0x00	; 0
    43e8:	02 e0       	ldi	r16, 0x02	; 2
    43ea:	7f 01       	movw	r14, r30
    43ec:	cc 24       	eor	r12, r12
    43ee:	dd 24       	eor	r13, r13
    43f0:	aa 24       	eor	r10, r10
    43f2:	bb 24       	eor	r11, r11
    43f4:	0e 94 47 13 	call	0x268e	; 0x268e <xTaskGenericCreate>
    43f8:	99 27       	eor	r25, r25
    43fa:	87 fd       	sbrc	r24, 7
    43fc:	90 95       	com	r25
    43fe:	90 93 27 07 	sts	0x0727, r25
    4402:	80 93 26 07 	sts	0x0726, r24
	task3handler=xTaskCreate(task3,"task3",85,NULL,4,task3handler);
    4406:	2e ee       	ldi	r18, 0xEE	; 238
    4408:	30 e2       	ldi	r19, 0x20	; 32
    440a:	49 e7       	ldi	r20, 0x79	; 121
    440c:	50 e0       	ldi	r21, 0x00	; 0
    440e:	80 91 28 07 	lds	r24, 0x0728
    4412:	90 91 29 07 	lds	r25, 0x0729
    4416:	fc 01       	movw	r30, r24
    4418:	c9 01       	movw	r24, r18
    441a:	ba 01       	movw	r22, r20
    441c:	45 e5       	ldi	r20, 0x55	; 85
    441e:	50 e0       	ldi	r21, 0x00	; 0
    4420:	20 e0       	ldi	r18, 0x00	; 0
    4422:	30 e0       	ldi	r19, 0x00	; 0
    4424:	04 e0       	ldi	r16, 0x04	; 4
    4426:	7f 01       	movw	r14, r30
    4428:	cc 24       	eor	r12, r12
    442a:	dd 24       	eor	r13, r13
    442c:	aa 24       	eor	r10, r10
    442e:	bb 24       	eor	r11, r11
    4430:	0e 94 47 13 	call	0x268e	; 0x268e <xTaskGenericCreate>
    4434:	99 27       	eor	r25, r25
    4436:	87 fd       	sbrc	r24, 7
    4438:	90 95       	com	r25
    443a:	90 93 29 07 	sts	0x0729, r25
    443e:	80 93 28 07 	sts	0x0728, r24
	task4handler=xTaskCreate(task4,"task4",85,NULL,1,task4handler);
    4442:	25 e1       	ldi	r18, 0x15	; 21
    4444:	31 e2       	ldi	r19, 0x21	; 33
    4446:	4f e7       	ldi	r20, 0x7F	; 127
    4448:	50 e0       	ldi	r21, 0x00	; 0
    444a:	80 91 2a 07 	lds	r24, 0x072A
    444e:	90 91 2b 07 	lds	r25, 0x072B
    4452:	fc 01       	movw	r30, r24
    4454:	c9 01       	movw	r24, r18
    4456:	ba 01       	movw	r22, r20
    4458:	45 e5       	ldi	r20, 0x55	; 85
    445a:	50 e0       	ldi	r21, 0x00	; 0
    445c:	20 e0       	ldi	r18, 0x00	; 0
    445e:	30 e0       	ldi	r19, 0x00	; 0
    4460:	01 e0       	ldi	r16, 0x01	; 1
    4462:	7f 01       	movw	r14, r30
    4464:	cc 24       	eor	r12, r12
    4466:	dd 24       	eor	r13, r13
    4468:	aa 24       	eor	r10, r10
    446a:	bb 24       	eor	r11, r11
    446c:	0e 94 47 13 	call	0x268e	; 0x268e <xTaskGenericCreate>
    4470:	99 27       	eor	r25, r25
    4472:	87 fd       	sbrc	r24, 7
    4474:	90 95       	com	r25
    4476:	90 93 2b 07 	sts	0x072B, r25
    447a:	80 93 2a 07 	sts	0x072A, r24
	task5handler=xTaskCreate(task5,"task5",85,NULL,5,task5handler);
    447e:	2b e4       	ldi	r18, 0x4B	; 75
    4480:	31 e2       	ldi	r19, 0x21	; 33
    4482:	45 e8       	ldi	r20, 0x85	; 133
    4484:	50 e0       	ldi	r21, 0x00	; 0
    4486:	80 91 2c 07 	lds	r24, 0x072C
    448a:	90 91 2d 07 	lds	r25, 0x072D
    448e:	fc 01       	movw	r30, r24
    4490:	c9 01       	movw	r24, r18
    4492:	ba 01       	movw	r22, r20
    4494:	45 e5       	ldi	r20, 0x55	; 85
    4496:	50 e0       	ldi	r21, 0x00	; 0
    4498:	20 e0       	ldi	r18, 0x00	; 0
    449a:	30 e0       	ldi	r19, 0x00	; 0
    449c:	05 e0       	ldi	r16, 0x05	; 5
    449e:	7f 01       	movw	r14, r30
    44a0:	cc 24       	eor	r12, r12
    44a2:	dd 24       	eor	r13, r13
    44a4:	aa 24       	eor	r10, r10
    44a6:	bb 24       	eor	r11, r11
    44a8:	0e 94 47 13 	call	0x268e	; 0x268e <xTaskGenericCreate>
    44ac:	99 27       	eor	r25, r25
    44ae:	87 fd       	sbrc	r24, 7
    44b0:	90 95       	com	r25
    44b2:	90 93 2d 07 	sts	0x072D, r25
    44b6:	80 93 2c 07 	sts	0x072C, r24
	timer1handler = xTimerCreate("Timer",5000,pdFALSE,( void * ) 1,vTimerCallback);
    44ba:	8b e8       	ldi	r24, 0x8B	; 139
    44bc:	90 e0       	ldi	r25, 0x00	; 0
    44be:	e1 ea       	ldi	r30, 0xA1	; 161
    44c0:	f1 e2       	ldi	r31, 0x21	; 33
    44c2:	68 e8       	ldi	r22, 0x88	; 136
    44c4:	73 e1       	ldi	r23, 0x13	; 19
    44c6:	40 e0       	ldi	r20, 0x00	; 0
    44c8:	21 e0       	ldi	r18, 0x01	; 1
    44ca:	30 e0       	ldi	r19, 0x00	; 0
    44cc:	8f 01       	movw	r16, r30
    44ce:	0e 94 34 1c 	call	0x3868	; 0x3868 <xTimerCreate>
    44d2:	90 93 2f 07 	sts	0x072F, r25
    44d6:	80 93 2e 07 	sts	0x072E, r24
	xTimerStart(timer1handler,0);
    44da:	00 91 2e 07 	lds	r16, 0x072E
    44de:	10 91 2f 07 	lds	r17, 0x072F
    44e2:	0e 94 c6 17 	call	0x2f8c	; 0x2f8c <xTaskGetTickCount>
    44e6:	9c 01       	movw	r18, r24
    44e8:	c8 01       	movw	r24, r16
    44ea:	60 e0       	ldi	r22, 0x00	; 0
    44ec:	a9 01       	movw	r20, r18
    44ee:	20 e0       	ldi	r18, 0x00	; 0
    44f0:	30 e0       	ldi	r19, 0x00	; 0
    44f2:	00 e0       	ldi	r16, 0x00	; 0
    44f4:	10 e0       	ldi	r17, 0x00	; 0
    44f6:	0e 94 8a 1c 	call	0x3914	; 0x3914 <xTimerGenericCommand>


	vTaskStartScheduler();
    44fa:	0e 94 e9 16 	call	0x2dd2	; 0x2dd2 <vTaskStartScheduler>
    44fe:	80 e0       	ldi	r24, 0x00	; 0
    4500:	90 e0       	ldi	r25, 0x00	; 0
}
    4502:	cf 91       	pop	r28
    4504:	df 91       	pop	r29
    4506:	1f 91       	pop	r17
    4508:	0f 91       	pop	r16
    450a:	ff 90       	pop	r15
    450c:	ef 90       	pop	r14
    450e:	df 90       	pop	r13
    4510:	cf 90       	pop	r12
    4512:	bf 90       	pop	r11
    4514:	af 90       	pop	r10
    4516:	08 95       	ret

00004518 <SSD_vidssdInit>:
#include "FreeRTOS.h"
#include "FreeRTOSConfig.h"
#include <util/delay.h>

void SSD_vidssdInit(void)
{
    4518:	df 93       	push	r29
    451a:	cf 93       	push	r28
    451c:	cd b7       	in	r28, 0x3d	; 61
    451e:	de b7       	in	r29, 0x3e	; 62
	Dio_vidconfigChannel(DIO_PORTB,DIO_PIN1,DIO_OUTPUT);
    4520:	81 e0       	ldi	r24, 0x01	; 1
    4522:	61 e0       	ldi	r22, 0x01	; 1
    4524:	41 e0       	ldi	r20, 0x01	; 1
    4526:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTB,DIO_PIN2,DIO_OUTPUT);
    452a:	81 e0       	ldi	r24, 0x01	; 1
    452c:	62 e0       	ldi	r22, 0x02	; 2
    452e:	41 e0       	ldi	r20, 0x01	; 1
    4530:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>

	Dio_vidconfigChannel(DIO_PORTA,DIO_PIN4,DIO_OUTPUT);
    4534:	80 e0       	ldi	r24, 0x00	; 0
    4536:	64 e0       	ldi	r22, 0x04	; 4
    4538:	41 e0       	ldi	r20, 0x01	; 1
    453a:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTA,DIO_PIN5,DIO_OUTPUT);
    453e:	80 e0       	ldi	r24, 0x00	; 0
    4540:	65 e0       	ldi	r22, 0x05	; 5
    4542:	41 e0       	ldi	r20, 0x01	; 1
    4544:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTA,DIO_PIN6,DIO_OUTPUT);
    4548:	80 e0       	ldi	r24, 0x00	; 0
    454a:	66 e0       	ldi	r22, 0x06	; 6
    454c:	41 e0       	ldi	r20, 0x01	; 1
    454e:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTA,DIO_PIN7,DIO_OUTPUT);
    4552:	80 e0       	ldi	r24, 0x00	; 0
    4554:	67 e0       	ldi	r22, 0x07	; 7
    4556:	41 e0       	ldi	r20, 0x01	; 1
    4558:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>
}
    455c:	cf 91       	pop	r28
    455e:	df 91       	pop	r29
    4560:	08 95       	ret

00004562 <SSD_viddispNum>:
void SSD_viddispNum(u8 num)
{
    4562:	df 93       	push	r29
    4564:	cf 93       	push	r28
    4566:	00 d0       	rcall	.+0      	; 0x4568 <SSD_viddispNum+0x6>
    4568:	0f 92       	push	r0
    456a:	cd b7       	in	r28, 0x3d	; 61
    456c:	de b7       	in	r29, 0x3e	; 62
    456e:	8b 83       	std	Y+3, r24	; 0x03
	u8 loc_firstDigit =  (num/10)<<4;
    4570:	8b 81       	ldd	r24, Y+3	; 0x03
    4572:	9a e0       	ldi	r25, 0x0A	; 10
    4574:	69 2f       	mov	r22, r25
    4576:	0e 94 8d 31 	call	0x631a	; 0x631a <__udivmodqi4>
    457a:	82 95       	swap	r24
    457c:	80 7f       	andi	r24, 0xF0	; 240
    457e:	8a 83       	std	Y+2, r24	; 0x02
	u8 loc_secondDigit = (num%10)<<4;
    4580:	8b 81       	ldd	r24, Y+3	; 0x03
    4582:	9a e0       	ldi	r25, 0x0A	; 10
    4584:	69 2f       	mov	r22, r25
    4586:	0e 94 8d 31 	call	0x631a	; 0x631a <__udivmodqi4>
    458a:	89 2f       	mov	r24, r25
    458c:	82 95       	swap	r24
    458e:	80 7f       	andi	r24, 0xF0	; 240
    4590:	89 83       	std	Y+1, r24	; 0x01

	/* Enable SSD1 */
	Dio_vidwriteChannel(DIO_PORTB,DIO_PIN1,DIO_HIGH);
    4592:	81 e0       	ldi	r24, 0x01	; 1
    4594:	61 e0       	ldi	r22, 0x01	; 1
    4596:	41 e0       	ldi	r20, 0x01	; 1
    4598:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
	/* Disable SSD2 */
	Dio_vidwriteChannel(DIO_PORTB,DIO_PIN2,DIO_LOW);
    459c:	81 e0       	ldi	r24, 0x01	; 1
    459e:	62 e0       	ldi	r22, 0x02	; 2
    45a0:	40 e0       	ldi	r20, 0x00	; 0
    45a2:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
	/* Write first digit */
	Dio_vidwriteChannelGroup(DIO_PORTA,loc_secondDigit,SSD_MASK);
    45a6:	80 e0       	ldi	r24, 0x00	; 0
    45a8:	69 81       	ldd	r22, Y+1	; 0x01
    45aa:	4f e0       	ldi	r20, 0x0F	; 15
    45ac:	0e 94 be 30 	call	0x617c	; 0x617c <Dio_vidwriteChannelGroup>

	vTaskDelay(10);
    45b0:	8a e0       	ldi	r24, 0x0A	; 10
    45b2:	90 e0       	ldi	r25, 0x00	; 0
    45b4:	0e 94 a8 14 	call	0x2950	; 0x2950 <vTaskDelay>

	/* Enable SSD2 */
	Dio_vidwriteChannel(DIO_PORTB,DIO_PIN2,DIO_HIGH);
    45b8:	81 e0       	ldi	r24, 0x01	; 1
    45ba:	62 e0       	ldi	r22, 0x02	; 2
    45bc:	41 e0       	ldi	r20, 0x01	; 1
    45be:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
	/* Disable SSD1 */
	Dio_vidwriteChannel(DIO_PORTB,DIO_PIN1,DIO_LOW);
    45c2:	81 e0       	ldi	r24, 0x01	; 1
    45c4:	61 e0       	ldi	r22, 0x01	; 1
    45c6:	40 e0       	ldi	r20, 0x00	; 0
    45c8:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
	/* Write second digit */
	Dio_vidwriteChannelGroup(DIO_PORTA,loc_firstDigit,SSD_MASK);
    45cc:	80 e0       	ldi	r24, 0x00	; 0
    45ce:	6a 81       	ldd	r22, Y+2	; 0x02
    45d0:	4f e0       	ldi	r20, 0x0F	; 15
    45d2:	0e 94 be 30 	call	0x617c	; 0x617c <Dio_vidwriteChannelGroup>

	vTaskDelay(10);
    45d6:	8a e0       	ldi	r24, 0x0A	; 10
    45d8:	90 e0       	ldi	r25, 0x00	; 0
    45da:	0e 94 a8 14 	call	0x2950	; 0x2950 <vTaskDelay>
}
    45de:	0f 90       	pop	r0
    45e0:	0f 90       	pop	r0
    45e2:	0f 90       	pop	r0
    45e4:	cf 91       	pop	r28
    45e6:	df 91       	pop	r29
    45e8:	08 95       	ret

000045ea <SSD_vidDisableSSD>:

void SSD_vidDisableSSD(void)
{
    45ea:	df 93       	push	r29
    45ec:	cf 93       	push	r28
    45ee:	cd b7       	in	r28, 0x3d	; 61
    45f0:	de b7       	in	r29, 0x3e	; 62
	Dio_vidwriteChannel(DIO_PORTB,DIO_PIN2,DIO_LOW);
    45f2:	81 e0       	ldi	r24, 0x01	; 1
    45f4:	62 e0       	ldi	r22, 0x02	; 2
    45f6:	40 e0       	ldi	r20, 0x00	; 0
    45f8:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
	Dio_vidwriteChannel(DIO_PORTB,DIO_PIN1,DIO_LOW);
    45fc:	81 e0       	ldi	r24, 0x01	; 1
    45fe:	61 e0       	ldi	r22, 0x01	; 1
    4600:	40 e0       	ldi	r20, 0x00	; 0
    4602:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
}
    4606:	cf 91       	pop	r28
    4608:	df 91       	pop	r29
    460a:	08 95       	ret

0000460c <SSD_vidDelayDisplay>:

void SSD_vidDelayDisplay(u8 num,u16 delay)
{
    460c:	df 93       	push	r29
    460e:	cf 93       	push	r28
    4610:	cd b7       	in	r28, 0x3d	; 61
    4612:	de b7       	in	r29, 0x3e	; 62
    4614:	27 97       	sbiw	r28, 0x07	; 7
    4616:	0f b6       	in	r0, 0x3f	; 63
    4618:	f8 94       	cli
    461a:	de bf       	out	0x3e, r29	; 62
    461c:	0f be       	out	0x3f, r0	; 63
    461e:	cd bf       	out	0x3d, r28	; 61
    4620:	8d 83       	std	Y+5, r24	; 0x05
    4622:	7f 83       	std	Y+7, r23	; 0x07
    4624:	6e 83       	std	Y+6, r22	; 0x06
	u16 counter;
	u16 real_delay = delay*0.049;
    4626:	8e 81       	ldd	r24, Y+6	; 0x06
    4628:	9f 81       	ldd	r25, Y+7	; 0x07
    462a:	cc 01       	movw	r24, r24
    462c:	a0 e0       	ldi	r26, 0x00	; 0
    462e:	b0 e0       	ldi	r27, 0x00	; 0
    4630:	bc 01       	movw	r22, r24
    4632:	cd 01       	movw	r24, r26
    4634:	0e 94 a9 04 	call	0x952	; 0x952 <__floatunsisf>
    4638:	dc 01       	movw	r26, r24
    463a:	cb 01       	movw	r24, r22
    463c:	bc 01       	movw	r22, r24
    463e:	cd 01       	movw	r24, r26
    4640:	29 e3       	ldi	r18, 0x39	; 57
    4642:	34 eb       	ldi	r19, 0xB4	; 180
    4644:	48 e4       	ldi	r20, 0x48	; 72
    4646:	5d e3       	ldi	r21, 0x3D	; 61
    4648:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    464c:	dc 01       	movw	r26, r24
    464e:	cb 01       	movw	r24, r22
    4650:	bc 01       	movw	r22, r24
    4652:	cd 01       	movw	r24, r26
    4654:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4658:	dc 01       	movw	r26, r24
    465a:	cb 01       	movw	r24, r22
    465c:	9a 83       	std	Y+2, r25	; 0x02
    465e:	89 83       	std	Y+1, r24	; 0x01
	for (counter = 0; counter < real_delay;counter++)
    4660:	1c 82       	std	Y+4, r1	; 0x04
    4662:	1b 82       	std	Y+3, r1	; 0x03
    4664:	08 c0       	rjmp	.+16     	; 0x4676 <SSD_vidDelayDisplay+0x6a>
	{
		SSD_viddispNum(num);
    4666:	8d 81       	ldd	r24, Y+5	; 0x05
    4668:	0e 94 b1 22 	call	0x4562	; 0x4562 <SSD_viddispNum>

void SSD_vidDelayDisplay(u8 num,u16 delay)
{
	u16 counter;
	u16 real_delay = delay*0.049;
	for (counter = 0; counter < real_delay;counter++)
    466c:	8b 81       	ldd	r24, Y+3	; 0x03
    466e:	9c 81       	ldd	r25, Y+4	; 0x04
    4670:	01 96       	adiw	r24, 0x01	; 1
    4672:	9c 83       	std	Y+4, r25	; 0x04
    4674:	8b 83       	std	Y+3, r24	; 0x03
    4676:	2b 81       	ldd	r18, Y+3	; 0x03
    4678:	3c 81       	ldd	r19, Y+4	; 0x04
    467a:	89 81       	ldd	r24, Y+1	; 0x01
    467c:	9a 81       	ldd	r25, Y+2	; 0x02
    467e:	28 17       	cp	r18, r24
    4680:	39 07       	cpc	r19, r25
    4682:	88 f3       	brcs	.-30     	; 0x4666 <SSD_vidDelayDisplay+0x5a>
	{
		SSD_viddispNum(num);
	}
}
    4684:	27 96       	adiw	r28, 0x07	; 7
    4686:	0f b6       	in	r0, 0x3f	; 63
    4688:	f8 94       	cli
    468a:	de bf       	out	0x3e, r29	; 62
    468c:	0f be       	out	0x3f, r0	; 63
    468e:	cd bf       	out	0x3d, r28	; 61
    4690:	cf 91       	pop	r28
    4692:	df 91       	pop	r29
    4694:	08 95       	ret

00004696 <RELAY_vidrelayInit>:
 *      Author: Khaled
 */
#include "RELAY.h"

void RELAY_vidrelayInit(void)
{
    4696:	df 93       	push	r29
    4698:	cf 93       	push	r28
    469a:	cd b7       	in	r28, 0x3d	; 61
    469c:	de b7       	in	r29, 0x3e	; 62
	Dio_vidconfigChannel(DIO_PORTA,DIO_PIN2,DIO_OUTPUT);
    469e:	80 e0       	ldi	r24, 0x00	; 0
    46a0:	62 e0       	ldi	r22, 0x02	; 2
    46a2:	41 e0       	ldi	r20, 0x01	; 1
    46a4:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>
}
    46a8:	cf 91       	pop	r28
    46aa:	df 91       	pop	r29
    46ac:	08 95       	ret

000046ae <RELAY_vidrelayOn>:

void RELAY_vidrelayOn(void)
{
    46ae:	df 93       	push	r29
    46b0:	cf 93       	push	r28
    46b2:	cd b7       	in	r28, 0x3d	; 61
    46b4:	de b7       	in	r29, 0x3e	; 62
	Dio_vidwriteChannel(DIO_PORTA,DIO_PIN2,DIO_HIGH);
    46b6:	80 e0       	ldi	r24, 0x00	; 0
    46b8:	62 e0       	ldi	r22, 0x02	; 2
    46ba:	41 e0       	ldi	r20, 0x01	; 1
    46bc:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
}
    46c0:	cf 91       	pop	r28
    46c2:	df 91       	pop	r29
    46c4:	08 95       	ret

000046c6 <RELAY_vidrelayOff>:

void RELAY_vidrelayOff(void)
{
    46c6:	df 93       	push	r29
    46c8:	cf 93       	push	r28
    46ca:	cd b7       	in	r28, 0x3d	; 61
    46cc:	de b7       	in	r29, 0x3e	; 62
	Dio_vidwriteChannel(DIO_PORTA,DIO_PIN2,DIO_LOW);
    46ce:	80 e0       	ldi	r24, 0x00	; 0
    46d0:	62 e0       	ldi	r22, 0x02	; 2
    46d2:	40 e0       	ldi	r20, 0x00	; 0
    46d4:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
}
    46d8:	cf 91       	pop	r28
    46da:	df 91       	pop	r29
    46dc:	08 95       	ret

000046de <Lm35_Init>:
 */
#include "LM35.h"
#include "ADC.h"

void Lm35_Init(void)
{
    46de:	df 93       	push	r29
    46e0:	cf 93       	push	r28
    46e2:	cd b7       	in	r28, 0x3d	; 61
    46e4:	de b7       	in	r29, 0x3e	; 62
	ADC_Init();
    46e6:	0e 94 1a 31 	call	0x6234	; 0x6234 <ADC_Init>
}
    46ea:	cf 91       	pop	r28
    46ec:	df 91       	pop	r29
    46ee:	08 95       	ret

000046f0 <H_LM35_Void_LM35Read>:
f64  H_LM35_Void_LM35Read(void)
{
    46f0:	df 93       	push	r29
    46f2:	cf 93       	push	r28
    46f4:	cd b7       	in	r28, 0x3d	; 61
    46f6:	de b7       	in	r29, 0x3e	; 62
    46f8:	28 97       	sbiw	r28, 0x08	; 8
    46fa:	0f b6       	in	r0, 0x3f	; 63
    46fc:	f8 94       	cli
    46fe:	de bf       	out	0x3e, r29	; 62
    4700:	0f be       	out	0x3f, r0	; 63
    4702:	cd bf       	out	0x3d, r28	; 61
	 f64 Local_U16_AdcValue = ADC_Read(ADC_CHNL0);
    4704:	80 e0       	ldi	r24, 0x00	; 0
    4706:	0e 94 2c 31 	call	0x6258	; 0x6258 <ADC_Read>
    470a:	cc 01       	movw	r24, r24
    470c:	a0 e0       	ldi	r26, 0x00	; 0
    470e:	b0 e0       	ldi	r27, 0x00	; 0
    4710:	bc 01       	movw	r22, r24
    4712:	cd 01       	movw	r24, r26
    4714:	0e 94 a9 04 	call	0x952	; 0x952 <__floatunsisf>
    4718:	dc 01       	movw	r26, r24
    471a:	cb 01       	movw	r24, r22
    471c:	8d 83       	std	Y+5, r24	; 0x05
    471e:	9e 83       	std	Y+6, r25	; 0x06
    4720:	af 83       	std	Y+7, r26	; 0x07
    4722:	b8 87       	std	Y+8, r27	; 0x08
	 f64 temp = ((u32)Local_U16_AdcValue * 500) / 1023;
    4724:	6d 81       	ldd	r22, Y+5	; 0x05
    4726:	7e 81       	ldd	r23, Y+6	; 0x06
    4728:	8f 81       	ldd	r24, Y+7	; 0x07
    472a:	98 85       	ldd	r25, Y+8	; 0x08
    472c:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4730:	dc 01       	movw	r26, r24
    4732:	cb 01       	movw	r24, r22
    4734:	24 ef       	ldi	r18, 0xF4	; 244
    4736:	31 e0       	ldi	r19, 0x01	; 1
    4738:	40 e0       	ldi	r20, 0x00	; 0
    473a:	50 e0       	ldi	r21, 0x00	; 0
    473c:	bc 01       	movw	r22, r24
    473e:	cd 01       	movw	r24, r26
    4740:	0e 94 6e 31 	call	0x62dc	; 0x62dc <__mulsi3>
    4744:	dc 01       	movw	r26, r24
    4746:	cb 01       	movw	r24, r22
    4748:	2f ef       	ldi	r18, 0xFF	; 255
    474a:	33 e0       	ldi	r19, 0x03	; 3
    474c:	40 e0       	ldi	r20, 0x00	; 0
    474e:	50 e0       	ldi	r21, 0x00	; 0
    4750:	bc 01       	movw	r22, r24
    4752:	cd 01       	movw	r24, r26
    4754:	0e 94 ad 31 	call	0x635a	; 0x635a <__udivmodsi4>
    4758:	da 01       	movw	r26, r20
    475a:	c9 01       	movw	r24, r18
    475c:	bc 01       	movw	r22, r24
    475e:	cd 01       	movw	r24, r26
    4760:	0e 94 a9 04 	call	0x952	; 0x952 <__floatunsisf>
    4764:	dc 01       	movw	r26, r24
    4766:	cb 01       	movw	r24, r22
    4768:	89 83       	std	Y+1, r24	; 0x01
    476a:	9a 83       	std	Y+2, r25	; 0x02
    476c:	ab 83       	std	Y+3, r26	; 0x03
    476e:	bc 83       	std	Y+4, r27	; 0x04
	 return temp;
    4770:	89 81       	ldd	r24, Y+1	; 0x01
    4772:	9a 81       	ldd	r25, Y+2	; 0x02
    4774:	ab 81       	ldd	r26, Y+3	; 0x03
    4776:	bc 81       	ldd	r27, Y+4	; 0x04
}
    4778:	bc 01       	movw	r22, r24
    477a:	cd 01       	movw	r24, r26
    477c:	28 96       	adiw	r28, 0x08	; 8
    477e:	0f b6       	in	r0, 0x3f	; 63
    4780:	f8 94       	cli
    4782:	de bf       	out	0x3e, r29	; 62
    4784:	0f be       	out	0x3f, r0	; 63
    4786:	cd bf       	out	0x3d, r28	; 61
    4788:	cf 91       	pop	r28
    478a:	df 91       	pop	r29
    478c:	08 95       	ret

0000478e <LED_vidledInit>:
 */
#include "LED.h"
#include "Dio.h"

void LED_vidledInit(void)
{
    478e:	df 93       	push	r29
    4790:	cf 93       	push	r28
    4792:	cd b7       	in	r28, 0x3d	; 61
    4794:	de b7       	in	r29, 0x3e	; 62
	Dio_vidconfigChannel(DIO_PORTC,DIO_PIN7,DIO_OUTPUT);
    4796:	82 e0       	ldi	r24, 0x02	; 2
    4798:	67 e0       	ldi	r22, 0x07	; 7
    479a:	41 e0       	ldi	r20, 0x01	; 1
    479c:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTC,DIO_PIN2,DIO_OUTPUT);
    47a0:	82 e0       	ldi	r24, 0x02	; 2
    47a2:	62 e0       	ldi	r22, 0x02	; 2
    47a4:	41 e0       	ldi	r20, 0x01	; 1
    47a6:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTD,DIO_PIN3,DIO_OUTPUT);
    47aa:	83 e0       	ldi	r24, 0x03	; 3
    47ac:	63 e0       	ldi	r22, 0x03	; 3
    47ae:	41 e0       	ldi	r20, 0x01	; 1
    47b0:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>
}
    47b4:	cf 91       	pop	r28
    47b6:	df 91       	pop	r29
    47b8:	08 95       	ret

000047ba <LED_vidledOn>:

void LED_vidledOn(led_ledId_t led)
{
    47ba:	df 93       	push	r29
    47bc:	cf 93       	push	r28
    47be:	00 d0       	rcall	.+0      	; 0x47c0 <LED_vidledOn+0x6>
    47c0:	0f 92       	push	r0
    47c2:	cd b7       	in	r28, 0x3d	; 61
    47c4:	de b7       	in	r29, 0x3e	; 62
    47c6:	89 83       	std	Y+1, r24	; 0x01
	switch(led)
    47c8:	89 81       	ldd	r24, Y+1	; 0x01
    47ca:	28 2f       	mov	r18, r24
    47cc:	30 e0       	ldi	r19, 0x00	; 0
    47ce:	3b 83       	std	Y+3, r19	; 0x03
    47d0:	2a 83       	std	Y+2, r18	; 0x02
    47d2:	8a 81       	ldd	r24, Y+2	; 0x02
    47d4:	9b 81       	ldd	r25, Y+3	; 0x03
    47d6:	81 30       	cpi	r24, 0x01	; 1
    47d8:	91 05       	cpc	r25, r1
    47da:	79 f0       	breq	.+30     	; 0x47fa <LED_vidledOn+0x40>
    47dc:	2a 81       	ldd	r18, Y+2	; 0x02
    47de:	3b 81       	ldd	r19, Y+3	; 0x03
    47e0:	22 30       	cpi	r18, 0x02	; 2
    47e2:	31 05       	cpc	r19, r1
    47e4:	81 f0       	breq	.+32     	; 0x4806 <LED_vidledOn+0x4c>
    47e6:	8a 81       	ldd	r24, Y+2	; 0x02
    47e8:	9b 81       	ldd	r25, Y+3	; 0x03
    47ea:	00 97       	sbiw	r24, 0x00	; 0
    47ec:	89 f4       	brne	.+34     	; 0x4810 <LED_vidledOn+0x56>
	{
	case LED0:
	{
		Dio_vidwriteChannel(DIO_PORTC,DIO_PIN2,DIO_HIGH);
    47ee:	82 e0       	ldi	r24, 0x02	; 2
    47f0:	62 e0       	ldi	r22, 0x02	; 2
    47f2:	41 e0       	ldi	r20, 0x01	; 1
    47f4:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
    47f8:	0b c0       	rjmp	.+22     	; 0x4810 <LED_vidledOn+0x56>
		break;
	}
	case LED1:
	{
		Dio_vidwriteChannel(DIO_PORTC,DIO_PIN7,DIO_HIGH);
    47fa:	82 e0       	ldi	r24, 0x02	; 2
    47fc:	67 e0       	ldi	r22, 0x07	; 7
    47fe:	41 e0       	ldi	r20, 0x01	; 1
    4800:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
    4804:	05 c0       	rjmp	.+10     	; 0x4810 <LED_vidledOn+0x56>
		break;
	}
	case LED2:
	{
		Dio_vidwriteChannel(DIO_PORTD,DIO_PIN3,DIO_HIGH);
    4806:	83 e0       	ldi	r24, 0x03	; 3
    4808:	63 e0       	ldi	r22, 0x03	; 3
    480a:	41 e0       	ldi	r20, 0x01	; 1
    480c:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
		break;
	}
	}
}
    4810:	0f 90       	pop	r0
    4812:	0f 90       	pop	r0
    4814:	0f 90       	pop	r0
    4816:	cf 91       	pop	r28
    4818:	df 91       	pop	r29
    481a:	08 95       	ret

0000481c <LED_vidledOff>:

void LED_vidledOff(led_ledId_t led)
{
    481c:	df 93       	push	r29
    481e:	cf 93       	push	r28
    4820:	00 d0       	rcall	.+0      	; 0x4822 <LED_vidledOff+0x6>
    4822:	0f 92       	push	r0
    4824:	cd b7       	in	r28, 0x3d	; 61
    4826:	de b7       	in	r29, 0x3e	; 62
    4828:	89 83       	std	Y+1, r24	; 0x01
	switch(led)
    482a:	89 81       	ldd	r24, Y+1	; 0x01
    482c:	28 2f       	mov	r18, r24
    482e:	30 e0       	ldi	r19, 0x00	; 0
    4830:	3b 83       	std	Y+3, r19	; 0x03
    4832:	2a 83       	std	Y+2, r18	; 0x02
    4834:	8a 81       	ldd	r24, Y+2	; 0x02
    4836:	9b 81       	ldd	r25, Y+3	; 0x03
    4838:	81 30       	cpi	r24, 0x01	; 1
    483a:	91 05       	cpc	r25, r1
    483c:	79 f0       	breq	.+30     	; 0x485c <LED_vidledOff+0x40>
    483e:	2a 81       	ldd	r18, Y+2	; 0x02
    4840:	3b 81       	ldd	r19, Y+3	; 0x03
    4842:	22 30       	cpi	r18, 0x02	; 2
    4844:	31 05       	cpc	r19, r1
    4846:	81 f0       	breq	.+32     	; 0x4868 <LED_vidledOff+0x4c>
    4848:	8a 81       	ldd	r24, Y+2	; 0x02
    484a:	9b 81       	ldd	r25, Y+3	; 0x03
    484c:	00 97       	sbiw	r24, 0x00	; 0
    484e:	89 f4       	brne	.+34     	; 0x4872 <LED_vidledOff+0x56>
	{
	case LED0:
	{
		Dio_vidwriteChannel(DIO_PORTC,DIO_PIN2,DIO_LOW);
    4850:	82 e0       	ldi	r24, 0x02	; 2
    4852:	62 e0       	ldi	r22, 0x02	; 2
    4854:	40 e0       	ldi	r20, 0x00	; 0
    4856:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
    485a:	0b c0       	rjmp	.+22     	; 0x4872 <LED_vidledOff+0x56>
		break;
	}
	case LED1:
	{
		Dio_vidwriteChannel(DIO_PORTC,DIO_PIN7,DIO_LOW);
    485c:	82 e0       	ldi	r24, 0x02	; 2
    485e:	67 e0       	ldi	r22, 0x07	; 7
    4860:	40 e0       	ldi	r20, 0x00	; 0
    4862:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
    4866:	05 c0       	rjmp	.+10     	; 0x4872 <LED_vidledOff+0x56>
		break;
	}
	case LED2:
	{
		Dio_vidwriteChannel(DIO_PORTD,DIO_PIN3,DIO_LOW);
    4868:	83 e0       	ldi	r24, 0x03	; 3
    486a:	63 e0       	ldi	r22, 0x03	; 3
    486c:	40 e0       	ldi	r20, 0x00	; 0
    486e:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
		break;
	}
	}
}
    4872:	0f 90       	pop	r0
    4874:	0f 90       	pop	r0
    4876:	0f 90       	pop	r0
    4878:	cf 91       	pop	r28
    487a:	df 91       	pop	r29
    487c:	08 95       	ret

0000487e <LED_vidledToggle>:

void LED_vidledToggle(led_ledId_t led)
{
    487e:	df 93       	push	r29
    4880:	cf 93       	push	r28
    4882:	00 d0       	rcall	.+0      	; 0x4884 <LED_vidledToggle+0x6>
    4884:	0f 92       	push	r0
    4886:	cd b7       	in	r28, 0x3d	; 61
    4888:	de b7       	in	r29, 0x3e	; 62
    488a:	89 83       	std	Y+1, r24	; 0x01
	switch(led)
    488c:	89 81       	ldd	r24, Y+1	; 0x01
    488e:	28 2f       	mov	r18, r24
    4890:	30 e0       	ldi	r19, 0x00	; 0
    4892:	3b 83       	std	Y+3, r19	; 0x03
    4894:	2a 83       	std	Y+2, r18	; 0x02
    4896:	8a 81       	ldd	r24, Y+2	; 0x02
    4898:	9b 81       	ldd	r25, Y+3	; 0x03
    489a:	81 30       	cpi	r24, 0x01	; 1
    489c:	91 05       	cpc	r25, r1
    489e:	71 f0       	breq	.+28     	; 0x48bc <LED_vidledToggle+0x3e>
    48a0:	2a 81       	ldd	r18, Y+2	; 0x02
    48a2:	3b 81       	ldd	r19, Y+3	; 0x03
    48a4:	22 30       	cpi	r18, 0x02	; 2
    48a6:	31 05       	cpc	r19, r1
    48a8:	71 f0       	breq	.+28     	; 0x48c6 <LED_vidledToggle+0x48>
    48aa:	8a 81       	ldd	r24, Y+2	; 0x02
    48ac:	9b 81       	ldd	r25, Y+3	; 0x03
    48ae:	00 97       	sbiw	r24, 0x00	; 0
    48b0:	71 f4       	brne	.+28     	; 0x48ce <LED_vidledToggle+0x50>
	{
	case LED0:
	{
		Dio_vidflipChannel(DIO_PORTC,DIO_PIN2);
    48b2:	82 e0       	ldi	r24, 0x02	; 2
    48b4:	62 e0       	ldi	r22, 0x02	; 2
    48b6:	0e 94 41 30 	call	0x6082	; 0x6082 <Dio_vidflipChannel>
    48ba:	09 c0       	rjmp	.+18     	; 0x48ce <LED_vidledToggle+0x50>
		break;
	}
	case LED1:
	{
		Dio_vidflipChannel(DIO_PORTC,DIO_PIN7);
    48bc:	82 e0       	ldi	r24, 0x02	; 2
    48be:	67 e0       	ldi	r22, 0x07	; 7
    48c0:	0e 94 41 30 	call	0x6082	; 0x6082 <Dio_vidflipChannel>
    48c4:	04 c0       	rjmp	.+8      	; 0x48ce <LED_vidledToggle+0x50>
		break;
	}
	case LED2:
	{
		Dio_vidflipChannel(DIO_PORTD,DIO_PIN3);
    48c6:	83 e0       	ldi	r24, 0x03	; 3
    48c8:	63 e0       	ldi	r22, 0x03	; 3
    48ca:	0e 94 41 30 	call	0x6082	; 0x6082 <Dio_vidflipChannel>
		break;
	}
	}
}
    48ce:	0f 90       	pop	r0
    48d0:	0f 90       	pop	r0
    48d2:	0f 90       	pop	r0
    48d4:	cf 91       	pop	r28
    48d6:	df 91       	pop	r29
    48d8:	08 95       	ret

000048da <LCD_vidEnablePulse>:
#include "Dio.h"
#include <util/delay.h>
#include <stdio.h>

static void LCD_vidEnablePulse(void)
{
    48da:	df 93       	push	r29
    48dc:	cf 93       	push	r28
    48de:	cd b7       	in	r28, 0x3d	; 61
    48e0:	de b7       	in	r29, 0x3e	; 62
    48e2:	a6 97       	sbiw	r28, 0x26	; 38
    48e4:	0f b6       	in	r0, 0x3f	; 63
    48e6:	f8 94       	cli
    48e8:	de bf       	out	0x3e, r29	; 62
    48ea:	0f be       	out	0x3f, r0	; 63
    48ec:	cd bf       	out	0x3d, r28	; 61
	/* Send Enable Pulse */
	Dio_vidwriteChannel(DIO_PORTB,DIO_PIN3,DIO_HIGH);
    48ee:	81 e0       	ldi	r24, 0x01	; 1
    48f0:	63 e0       	ldi	r22, 0x03	; 3
    48f2:	41 e0       	ldi	r20, 0x01	; 1
    48f4:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
    48f8:	80 e0       	ldi	r24, 0x00	; 0
    48fa:	90 e0       	ldi	r25, 0x00	; 0
    48fc:	a0 e8       	ldi	r26, 0x80	; 128
    48fe:	bf e3       	ldi	r27, 0x3F	; 63
    4900:	8b a3       	std	Y+35, r24	; 0x23
    4902:	9c a3       	std	Y+36, r25	; 0x24
    4904:	ad a3       	std	Y+37, r26	; 0x25
    4906:	be a3       	std	Y+38, r27	; 0x26
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    4908:	6b a1       	ldd	r22, Y+35	; 0x23
    490a:	7c a1       	ldd	r23, Y+36	; 0x24
    490c:	8d a1       	ldd	r24, Y+37	; 0x25
    490e:	9e a1       	ldd	r25, Y+38	; 0x26
    4910:	2b ea       	ldi	r18, 0xAB	; 171
    4912:	3a ea       	ldi	r19, 0xAA	; 170
    4914:	4a ea       	ldi	r20, 0xAA	; 170
    4916:	50 e4       	ldi	r21, 0x40	; 64
    4918:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    491c:	dc 01       	movw	r26, r24
    491e:	cb 01       	movw	r24, r22
    4920:	8f 8f       	std	Y+31, r24	; 0x1f
    4922:	98 a3       	std	Y+32, r25	; 0x20
    4924:	a9 a3       	std	Y+33, r26	; 0x21
    4926:	ba a3       	std	Y+34, r27	; 0x22
	if (__tmp < 1.0)
    4928:	6f 8d       	ldd	r22, Y+31	; 0x1f
    492a:	78 a1       	ldd	r23, Y+32	; 0x20
    492c:	89 a1       	ldd	r24, Y+33	; 0x21
    492e:	9a a1       	ldd	r25, Y+34	; 0x22
    4930:	20 e0       	ldi	r18, 0x00	; 0
    4932:	30 e0       	ldi	r19, 0x00	; 0
    4934:	40 e8       	ldi	r20, 0x80	; 128
    4936:	5f e3       	ldi	r21, 0x3F	; 63
    4938:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    493c:	88 23       	and	r24, r24
    493e:	1c f4       	brge	.+6      	; 0x4946 <LCD_vidEnablePulse+0x6c>
		__ticks = 1;
    4940:	81 e0       	ldi	r24, 0x01	; 1
    4942:	8e 8f       	std	Y+30, r24	; 0x1e
    4944:	91 c0       	rjmp	.+290    	; 0x4a68 <LCD_vidEnablePulse+0x18e>
	else if (__tmp > 255)
    4946:	6f 8d       	ldd	r22, Y+31	; 0x1f
    4948:	78 a1       	ldd	r23, Y+32	; 0x20
    494a:	89 a1       	ldd	r24, Y+33	; 0x21
    494c:	9a a1       	ldd	r25, Y+34	; 0x22
    494e:	20 e0       	ldi	r18, 0x00	; 0
    4950:	30 e0       	ldi	r19, 0x00	; 0
    4952:	4f e7       	ldi	r20, 0x7F	; 127
    4954:	53 e4       	ldi	r21, 0x43	; 67
    4956:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    495a:	18 16       	cp	r1, r24
    495c:	0c f0       	brlt	.+2      	; 0x4960 <LCD_vidEnablePulse+0x86>
    495e:	7b c0       	rjmp	.+246    	; 0x4a56 <LCD_vidEnablePulse+0x17c>
	{
		_delay_ms(__us / 1000.0);
    4960:	6b a1       	ldd	r22, Y+35	; 0x23
    4962:	7c a1       	ldd	r23, Y+36	; 0x24
    4964:	8d a1       	ldd	r24, Y+37	; 0x25
    4966:	9e a1       	ldd	r25, Y+38	; 0x26
    4968:	20 e0       	ldi	r18, 0x00	; 0
    496a:	30 e0       	ldi	r19, 0x00	; 0
    496c:	4a e7       	ldi	r20, 0x7A	; 122
    496e:	54 e4       	ldi	r21, 0x44	; 68
    4970:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    4974:	dc 01       	movw	r26, r24
    4976:	cb 01       	movw	r24, r22
    4978:	8a 8f       	std	Y+26, r24	; 0x1a
    497a:	9b 8f       	std	Y+27, r25	; 0x1b
    497c:	ac 8f       	std	Y+28, r26	; 0x1c
    497e:	bd 8f       	std	Y+29, r27	; 0x1d
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4980:	6a 8d       	ldd	r22, Y+26	; 0x1a
    4982:	7b 8d       	ldd	r23, Y+27	; 0x1b
    4984:	8c 8d       	ldd	r24, Y+28	; 0x1c
    4986:	9d 8d       	ldd	r25, Y+29	; 0x1d
    4988:	20 e0       	ldi	r18, 0x00	; 0
    498a:	30 e0       	ldi	r19, 0x00	; 0
    498c:	4a e7       	ldi	r20, 0x7A	; 122
    498e:	55 e4       	ldi	r21, 0x45	; 69
    4990:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4994:	dc 01       	movw	r26, r24
    4996:	cb 01       	movw	r24, r22
    4998:	8e 8b       	std	Y+22, r24	; 0x16
    499a:	9f 8b       	std	Y+23, r25	; 0x17
    499c:	a8 8f       	std	Y+24, r26	; 0x18
    499e:	b9 8f       	std	Y+25, r27	; 0x19
	if (__tmp < 1.0)
    49a0:	6e 89       	ldd	r22, Y+22	; 0x16
    49a2:	7f 89       	ldd	r23, Y+23	; 0x17
    49a4:	88 8d       	ldd	r24, Y+24	; 0x18
    49a6:	99 8d       	ldd	r25, Y+25	; 0x19
    49a8:	20 e0       	ldi	r18, 0x00	; 0
    49aa:	30 e0       	ldi	r19, 0x00	; 0
    49ac:	40 e8       	ldi	r20, 0x80	; 128
    49ae:	5f e3       	ldi	r21, 0x3F	; 63
    49b0:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    49b4:	88 23       	and	r24, r24
    49b6:	2c f4       	brge	.+10     	; 0x49c2 <LCD_vidEnablePulse+0xe8>
		__ticks = 1;
    49b8:	81 e0       	ldi	r24, 0x01	; 1
    49ba:	90 e0       	ldi	r25, 0x00	; 0
    49bc:	9d 8b       	std	Y+21, r25	; 0x15
    49be:	8c 8b       	std	Y+20, r24	; 0x14
    49c0:	3f c0       	rjmp	.+126    	; 0x4a40 <LCD_vidEnablePulse+0x166>
	else if (__tmp > 65535)
    49c2:	6e 89       	ldd	r22, Y+22	; 0x16
    49c4:	7f 89       	ldd	r23, Y+23	; 0x17
    49c6:	88 8d       	ldd	r24, Y+24	; 0x18
    49c8:	99 8d       	ldd	r25, Y+25	; 0x19
    49ca:	20 e0       	ldi	r18, 0x00	; 0
    49cc:	3f ef       	ldi	r19, 0xFF	; 255
    49ce:	4f e7       	ldi	r20, 0x7F	; 127
    49d0:	57 e4       	ldi	r21, 0x47	; 71
    49d2:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    49d6:	18 16       	cp	r1, r24
    49d8:	4c f5       	brge	.+82     	; 0x4a2c <LCD_vidEnablePulse+0x152>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    49da:	6a 8d       	ldd	r22, Y+26	; 0x1a
    49dc:	7b 8d       	ldd	r23, Y+27	; 0x1b
    49de:	8c 8d       	ldd	r24, Y+28	; 0x1c
    49e0:	9d 8d       	ldd	r25, Y+29	; 0x1d
    49e2:	20 e0       	ldi	r18, 0x00	; 0
    49e4:	30 e0       	ldi	r19, 0x00	; 0
    49e6:	40 e2       	ldi	r20, 0x20	; 32
    49e8:	51 e4       	ldi	r21, 0x41	; 65
    49ea:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    49ee:	dc 01       	movw	r26, r24
    49f0:	cb 01       	movw	r24, r22
    49f2:	bc 01       	movw	r22, r24
    49f4:	cd 01       	movw	r24, r26
    49f6:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    49fa:	dc 01       	movw	r26, r24
    49fc:	cb 01       	movw	r24, r22
    49fe:	9d 8b       	std	Y+21, r25	; 0x15
    4a00:	8c 8b       	std	Y+20, r24	; 0x14
    4a02:	0f c0       	rjmp	.+30     	; 0x4a22 <LCD_vidEnablePulse+0x148>
    4a04:	80 e9       	ldi	r24, 0x90	; 144
    4a06:	91 e0       	ldi	r25, 0x01	; 1
    4a08:	9b 8b       	std	Y+19, r25	; 0x13
    4a0a:	8a 8b       	std	Y+18, r24	; 0x12
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4a0c:	8a 89       	ldd	r24, Y+18	; 0x12
    4a0e:	9b 89       	ldd	r25, Y+19	; 0x13
    4a10:	01 97       	sbiw	r24, 0x01	; 1
    4a12:	f1 f7       	brne	.-4      	; 0x4a10 <LCD_vidEnablePulse+0x136>
    4a14:	9b 8b       	std	Y+19, r25	; 0x13
    4a16:	8a 8b       	std	Y+18, r24	; 0x12
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4a18:	8c 89       	ldd	r24, Y+20	; 0x14
    4a1a:	9d 89       	ldd	r25, Y+21	; 0x15
    4a1c:	01 97       	sbiw	r24, 0x01	; 1
    4a1e:	9d 8b       	std	Y+21, r25	; 0x15
    4a20:	8c 8b       	std	Y+20, r24	; 0x14
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4a22:	8c 89       	ldd	r24, Y+20	; 0x14
    4a24:	9d 89       	ldd	r25, Y+21	; 0x15
    4a26:	00 97       	sbiw	r24, 0x00	; 0
    4a28:	69 f7       	brne	.-38     	; 0x4a04 <LCD_vidEnablePulse+0x12a>
    4a2a:	24 c0       	rjmp	.+72     	; 0x4a74 <LCD_vidEnablePulse+0x19a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4a2c:	6e 89       	ldd	r22, Y+22	; 0x16
    4a2e:	7f 89       	ldd	r23, Y+23	; 0x17
    4a30:	88 8d       	ldd	r24, Y+24	; 0x18
    4a32:	99 8d       	ldd	r25, Y+25	; 0x19
    4a34:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4a38:	dc 01       	movw	r26, r24
    4a3a:	cb 01       	movw	r24, r22
    4a3c:	9d 8b       	std	Y+21, r25	; 0x15
    4a3e:	8c 8b       	std	Y+20, r24	; 0x14
    4a40:	8c 89       	ldd	r24, Y+20	; 0x14
    4a42:	9d 89       	ldd	r25, Y+21	; 0x15
    4a44:	99 8b       	std	Y+17, r25	; 0x11
    4a46:	88 8b       	std	Y+16, r24	; 0x10
    4a48:	88 89       	ldd	r24, Y+16	; 0x10
    4a4a:	99 89       	ldd	r25, Y+17	; 0x11
    4a4c:	01 97       	sbiw	r24, 0x01	; 1
    4a4e:	f1 f7       	brne	.-4      	; 0x4a4c <LCD_vidEnablePulse+0x172>
    4a50:	99 8b       	std	Y+17, r25	; 0x11
    4a52:	88 8b       	std	Y+16, r24	; 0x10
    4a54:	0f c0       	rjmp	.+30     	; 0x4a74 <LCD_vidEnablePulse+0x19a>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4a56:	6f 8d       	ldd	r22, Y+31	; 0x1f
    4a58:	78 a1       	ldd	r23, Y+32	; 0x20
    4a5a:	89 a1       	ldd	r24, Y+33	; 0x21
    4a5c:	9a a1       	ldd	r25, Y+34	; 0x22
    4a5e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4a62:	dc 01       	movw	r26, r24
    4a64:	cb 01       	movw	r24, r22
    4a66:	8e 8f       	std	Y+30, r24	; 0x1e
    4a68:	8e 8d       	ldd	r24, Y+30	; 0x1e
    4a6a:	8f 87       	std	Y+15, r24	; 0x0f
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4a6c:	8f 85       	ldd	r24, Y+15	; 0x0f
    4a6e:	8a 95       	dec	r24
    4a70:	f1 f7       	brne	.-4      	; 0x4a6e <LCD_vidEnablePulse+0x194>
    4a72:	8f 87       	std	Y+15, r24	; 0x0f
	_delay_us(1);
	Dio_vidwriteChannel(DIO_PORTB,DIO_PIN3,DIO_LOW);
    4a74:	81 e0       	ldi	r24, 0x01	; 1
    4a76:	63 e0       	ldi	r22, 0x03	; 3
    4a78:	40 e0       	ldi	r20, 0x00	; 0
    4a7a:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
    4a7e:	80 e0       	ldi	r24, 0x00	; 0
    4a80:	90 e0       	ldi	r25, 0x00	; 0
    4a82:	a0 e0       	ldi	r26, 0x00	; 0
    4a84:	b0 e4       	ldi	r27, 0x40	; 64
    4a86:	8b 87       	std	Y+11, r24	; 0x0b
    4a88:	9c 87       	std	Y+12, r25	; 0x0c
    4a8a:	ad 87       	std	Y+13, r26	; 0x0d
    4a8c:	be 87       	std	Y+14, r27	; 0x0e
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4a8e:	6b 85       	ldd	r22, Y+11	; 0x0b
    4a90:	7c 85       	ldd	r23, Y+12	; 0x0c
    4a92:	8d 85       	ldd	r24, Y+13	; 0x0d
    4a94:	9e 85       	ldd	r25, Y+14	; 0x0e
    4a96:	20 e0       	ldi	r18, 0x00	; 0
    4a98:	30 e0       	ldi	r19, 0x00	; 0
    4a9a:	4a e7       	ldi	r20, 0x7A	; 122
    4a9c:	55 e4       	ldi	r21, 0x45	; 69
    4a9e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4aa2:	dc 01       	movw	r26, r24
    4aa4:	cb 01       	movw	r24, r22
    4aa6:	8f 83       	std	Y+7, r24	; 0x07
    4aa8:	98 87       	std	Y+8, r25	; 0x08
    4aaa:	a9 87       	std	Y+9, r26	; 0x09
    4aac:	ba 87       	std	Y+10, r27	; 0x0a
	if (__tmp < 1.0)
    4aae:	6f 81       	ldd	r22, Y+7	; 0x07
    4ab0:	78 85       	ldd	r23, Y+8	; 0x08
    4ab2:	89 85       	ldd	r24, Y+9	; 0x09
    4ab4:	9a 85       	ldd	r25, Y+10	; 0x0a
    4ab6:	20 e0       	ldi	r18, 0x00	; 0
    4ab8:	30 e0       	ldi	r19, 0x00	; 0
    4aba:	40 e8       	ldi	r20, 0x80	; 128
    4abc:	5f e3       	ldi	r21, 0x3F	; 63
    4abe:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4ac2:	88 23       	and	r24, r24
    4ac4:	2c f4       	brge	.+10     	; 0x4ad0 <LCD_vidEnablePulse+0x1f6>
		__ticks = 1;
    4ac6:	81 e0       	ldi	r24, 0x01	; 1
    4ac8:	90 e0       	ldi	r25, 0x00	; 0
    4aca:	9e 83       	std	Y+6, r25	; 0x06
    4acc:	8d 83       	std	Y+5, r24	; 0x05
    4ace:	3f c0       	rjmp	.+126    	; 0x4b4e <LCD_vidEnablePulse+0x274>
	else if (__tmp > 65535)
    4ad0:	6f 81       	ldd	r22, Y+7	; 0x07
    4ad2:	78 85       	ldd	r23, Y+8	; 0x08
    4ad4:	89 85       	ldd	r24, Y+9	; 0x09
    4ad6:	9a 85       	ldd	r25, Y+10	; 0x0a
    4ad8:	20 e0       	ldi	r18, 0x00	; 0
    4ada:	3f ef       	ldi	r19, 0xFF	; 255
    4adc:	4f e7       	ldi	r20, 0x7F	; 127
    4ade:	57 e4       	ldi	r21, 0x47	; 71
    4ae0:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4ae4:	18 16       	cp	r1, r24
    4ae6:	4c f5       	brge	.+82     	; 0x4b3a <LCD_vidEnablePulse+0x260>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4ae8:	6b 85       	ldd	r22, Y+11	; 0x0b
    4aea:	7c 85       	ldd	r23, Y+12	; 0x0c
    4aec:	8d 85       	ldd	r24, Y+13	; 0x0d
    4aee:	9e 85       	ldd	r25, Y+14	; 0x0e
    4af0:	20 e0       	ldi	r18, 0x00	; 0
    4af2:	30 e0       	ldi	r19, 0x00	; 0
    4af4:	40 e2       	ldi	r20, 0x20	; 32
    4af6:	51 e4       	ldi	r21, 0x41	; 65
    4af8:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4afc:	dc 01       	movw	r26, r24
    4afe:	cb 01       	movw	r24, r22
    4b00:	bc 01       	movw	r22, r24
    4b02:	cd 01       	movw	r24, r26
    4b04:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4b08:	dc 01       	movw	r26, r24
    4b0a:	cb 01       	movw	r24, r22
    4b0c:	9e 83       	std	Y+6, r25	; 0x06
    4b0e:	8d 83       	std	Y+5, r24	; 0x05
    4b10:	0f c0       	rjmp	.+30     	; 0x4b30 <LCD_vidEnablePulse+0x256>
    4b12:	80 e9       	ldi	r24, 0x90	; 144
    4b14:	91 e0       	ldi	r25, 0x01	; 1
    4b16:	9c 83       	std	Y+4, r25	; 0x04
    4b18:	8b 83       	std	Y+3, r24	; 0x03
    milliseconds can be achieved.
 */
void
_delay_loop_2(uint16_t __count)
{
	__asm__ volatile (
    4b1a:	8b 81       	ldd	r24, Y+3	; 0x03
    4b1c:	9c 81       	ldd	r25, Y+4	; 0x04
    4b1e:	01 97       	sbiw	r24, 0x01	; 1
    4b20:	f1 f7       	brne	.-4      	; 0x4b1e <LCD_vidEnablePulse+0x244>
    4b22:	9c 83       	std	Y+4, r25	; 0x04
    4b24:	8b 83       	std	Y+3, r24	; 0x03
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4b26:	8d 81       	ldd	r24, Y+5	; 0x05
    4b28:	9e 81       	ldd	r25, Y+6	; 0x06
    4b2a:	01 97       	sbiw	r24, 0x01	; 1
    4b2c:	9e 83       	std	Y+6, r25	; 0x06
    4b2e:	8d 83       	std	Y+5, r24	; 0x05
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4b30:	8d 81       	ldd	r24, Y+5	; 0x05
    4b32:	9e 81       	ldd	r25, Y+6	; 0x06
    4b34:	00 97       	sbiw	r24, 0x00	; 0
    4b36:	69 f7       	brne	.-38     	; 0x4b12 <LCD_vidEnablePulse+0x238>
    4b38:	14 c0       	rjmp	.+40     	; 0x4b62 <LCD_vidEnablePulse+0x288>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4b3a:	6f 81       	ldd	r22, Y+7	; 0x07
    4b3c:	78 85       	ldd	r23, Y+8	; 0x08
    4b3e:	89 85       	ldd	r24, Y+9	; 0x09
    4b40:	9a 85       	ldd	r25, Y+10	; 0x0a
    4b42:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4b46:	dc 01       	movw	r26, r24
    4b48:	cb 01       	movw	r24, r22
    4b4a:	9e 83       	std	Y+6, r25	; 0x06
    4b4c:	8d 83       	std	Y+5, r24	; 0x05
    4b4e:	8d 81       	ldd	r24, Y+5	; 0x05
    4b50:	9e 81       	ldd	r25, Y+6	; 0x06
    4b52:	9a 83       	std	Y+2, r25	; 0x02
    4b54:	89 83       	std	Y+1, r24	; 0x01
    4b56:	89 81       	ldd	r24, Y+1	; 0x01
    4b58:	9a 81       	ldd	r25, Y+2	; 0x02
    4b5a:	01 97       	sbiw	r24, 0x01	; 1
    4b5c:	f1 f7       	brne	.-4      	; 0x4b5a <LCD_vidEnablePulse+0x280>
    4b5e:	9a 83       	std	Y+2, r25	; 0x02
    4b60:	89 83       	std	Y+1, r24	; 0x01
	_delay_ms(2);
}
    4b62:	a6 96       	adiw	r28, 0x26	; 38
    4b64:	0f b6       	in	r0, 0x3f	; 63
    4b66:	f8 94       	cli
    4b68:	de bf       	out	0x3e, r29	; 62
    4b6a:	0f be       	out	0x3f, r0	; 63
    4b6c:	cd bf       	out	0x3d, r28	; 61
    4b6e:	cf 91       	pop	r28
    4b70:	df 91       	pop	r29
    4b72:	08 95       	ret

00004b74 <LCD_vidInit>:

void LCD_vidInit(void)
{
    4b74:	df 93       	push	r29
    4b76:	cf 93       	push	r28
    4b78:	cd b7       	in	r28, 0x3d	; 61
    4b7a:	de b7       	in	r29, 0x3e	; 62
    4b7c:	c2 54       	subi	r28, 0x42	; 66
    4b7e:	d0 40       	sbci	r29, 0x00	; 0
    4b80:	0f b6       	in	r0, 0x3f	; 63
    4b82:	f8 94       	cli
    4b84:	de bf       	out	0x3e, r29	; 62
    4b86:	0f be       	out	0x3f, r0	; 63
    4b88:	cd bf       	out	0x3d, r28	; 61
	/* Configure control pins as output */
	Dio_vidconfigChannel(DIO_PORTB,DIO_PIN1,DIO_OUTPUT);
    4b8a:	81 e0       	ldi	r24, 0x01	; 1
    4b8c:	61 e0       	ldi	r22, 0x01	; 1
    4b8e:	41 e0       	ldi	r20, 0x01	; 1
    4b90:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTB,DIO_PIN2,DIO_OUTPUT);
    4b94:	81 e0       	ldi	r24, 0x01	; 1
    4b96:	62 e0       	ldi	r22, 0x02	; 2
    4b98:	41 e0       	ldi	r20, 0x01	; 1
    4b9a:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTB,DIO_PIN3,DIO_OUTPUT);
    4b9e:	81 e0       	ldi	r24, 0x01	; 1
    4ba0:	63 e0       	ldi	r22, 0x03	; 3
    4ba2:	41 e0       	ldi	r20, 0x01	; 1
    4ba4:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>

	/* Configure data pins as output */
	Dio_vidconfigChannel(DIO_PORTA,DIO_PIN4,DIO_OUTPUT);
    4ba8:	80 e0       	ldi	r24, 0x00	; 0
    4baa:	64 e0       	ldi	r22, 0x04	; 4
    4bac:	41 e0       	ldi	r20, 0x01	; 1
    4bae:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTA,DIO_PIN5,DIO_OUTPUT);
    4bb2:	80 e0       	ldi	r24, 0x00	; 0
    4bb4:	65 e0       	ldi	r22, 0x05	; 5
    4bb6:	41 e0       	ldi	r20, 0x01	; 1
    4bb8:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTA,DIO_PIN6,DIO_OUTPUT);
    4bbc:	80 e0       	ldi	r24, 0x00	; 0
    4bbe:	66 e0       	ldi	r22, 0x06	; 6
    4bc0:	41 e0       	ldi	r20, 0x01	; 1
    4bc2:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTA,DIO_PIN7,DIO_OUTPUT);
    4bc6:	80 e0       	ldi	r24, 0x00	; 0
    4bc8:	67 e0       	ldi	r22, 0x07	; 7
    4bca:	41 e0       	ldi	r20, 0x01	; 1
    4bcc:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>

	Dio_vidwriteChannel(DIO_PORTB,DIO_PIN2,DIO_LOW);
    4bd0:	81 e0       	ldi	r24, 0x01	; 1
    4bd2:	62 e0       	ldi	r22, 0x02	; 2
    4bd4:	40 e0       	ldi	r20, 0x00	; 0
    4bd6:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
    4bda:	80 e0       	ldi	r24, 0x00	; 0
    4bdc:	90 e0       	ldi	r25, 0x00	; 0
    4bde:	a0 e7       	ldi	r26, 0x70	; 112
    4be0:	b1 e4       	ldi	r27, 0x41	; 65
    4be2:	89 ab       	std	Y+49, r24	; 0x31
    4be4:	9a ab       	std	Y+50, r25	; 0x32
    4be6:	ab ab       	std	Y+51, r26	; 0x33
    4be8:	bc ab       	std	Y+52, r27	; 0x34
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4bea:	69 a9       	ldd	r22, Y+49	; 0x31
    4bec:	7a a9       	ldd	r23, Y+50	; 0x32
    4bee:	8b a9       	ldd	r24, Y+51	; 0x33
    4bf0:	9c a9       	ldd	r25, Y+52	; 0x34
    4bf2:	20 e0       	ldi	r18, 0x00	; 0
    4bf4:	30 e0       	ldi	r19, 0x00	; 0
    4bf6:	4a e7       	ldi	r20, 0x7A	; 122
    4bf8:	55 e4       	ldi	r21, 0x45	; 69
    4bfa:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4bfe:	dc 01       	movw	r26, r24
    4c00:	cb 01       	movw	r24, r22
    4c02:	8d a7       	std	Y+45, r24	; 0x2d
    4c04:	9e a7       	std	Y+46, r25	; 0x2e
    4c06:	af a7       	std	Y+47, r26	; 0x2f
    4c08:	b8 ab       	std	Y+48, r27	; 0x30
	if (__tmp < 1.0)
    4c0a:	6d a5       	ldd	r22, Y+45	; 0x2d
    4c0c:	7e a5       	ldd	r23, Y+46	; 0x2e
    4c0e:	8f a5       	ldd	r24, Y+47	; 0x2f
    4c10:	98 a9       	ldd	r25, Y+48	; 0x30
    4c12:	20 e0       	ldi	r18, 0x00	; 0
    4c14:	30 e0       	ldi	r19, 0x00	; 0
    4c16:	40 e8       	ldi	r20, 0x80	; 128
    4c18:	5f e3       	ldi	r21, 0x3F	; 63
    4c1a:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4c1e:	88 23       	and	r24, r24
    4c20:	2c f4       	brge	.+10     	; 0x4c2c <LCD_vidInit+0xb8>
		__ticks = 1;
    4c22:	81 e0       	ldi	r24, 0x01	; 1
    4c24:	90 e0       	ldi	r25, 0x00	; 0
    4c26:	9c a7       	std	Y+44, r25	; 0x2c
    4c28:	8b a7       	std	Y+43, r24	; 0x2b
    4c2a:	3f c0       	rjmp	.+126    	; 0x4caa <LCD_vidInit+0x136>
	else if (__tmp > 65535)
    4c2c:	6d a5       	ldd	r22, Y+45	; 0x2d
    4c2e:	7e a5       	ldd	r23, Y+46	; 0x2e
    4c30:	8f a5       	ldd	r24, Y+47	; 0x2f
    4c32:	98 a9       	ldd	r25, Y+48	; 0x30
    4c34:	20 e0       	ldi	r18, 0x00	; 0
    4c36:	3f ef       	ldi	r19, 0xFF	; 255
    4c38:	4f e7       	ldi	r20, 0x7F	; 127
    4c3a:	57 e4       	ldi	r21, 0x47	; 71
    4c3c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4c40:	18 16       	cp	r1, r24
    4c42:	4c f5       	brge	.+82     	; 0x4c96 <LCD_vidInit+0x122>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4c44:	69 a9       	ldd	r22, Y+49	; 0x31
    4c46:	7a a9       	ldd	r23, Y+50	; 0x32
    4c48:	8b a9       	ldd	r24, Y+51	; 0x33
    4c4a:	9c a9       	ldd	r25, Y+52	; 0x34
    4c4c:	20 e0       	ldi	r18, 0x00	; 0
    4c4e:	30 e0       	ldi	r19, 0x00	; 0
    4c50:	40 e2       	ldi	r20, 0x20	; 32
    4c52:	51 e4       	ldi	r21, 0x41	; 65
    4c54:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4c58:	dc 01       	movw	r26, r24
    4c5a:	cb 01       	movw	r24, r22
    4c5c:	bc 01       	movw	r22, r24
    4c5e:	cd 01       	movw	r24, r26
    4c60:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4c64:	dc 01       	movw	r26, r24
    4c66:	cb 01       	movw	r24, r22
    4c68:	9c a7       	std	Y+44, r25	; 0x2c
    4c6a:	8b a7       	std	Y+43, r24	; 0x2b
    4c6c:	0f c0       	rjmp	.+30     	; 0x4c8c <LCD_vidInit+0x118>
    4c6e:	80 e9       	ldi	r24, 0x90	; 144
    4c70:	91 e0       	ldi	r25, 0x01	; 1
    4c72:	9a a7       	std	Y+42, r25	; 0x2a
    4c74:	89 a7       	std	Y+41, r24	; 0x29
    4c76:	89 a5       	ldd	r24, Y+41	; 0x29
    4c78:	9a a5       	ldd	r25, Y+42	; 0x2a
    4c7a:	01 97       	sbiw	r24, 0x01	; 1
    4c7c:	f1 f7       	brne	.-4      	; 0x4c7a <LCD_vidInit+0x106>
    4c7e:	9a a7       	std	Y+42, r25	; 0x2a
    4c80:	89 a7       	std	Y+41, r24	; 0x29
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4c82:	8b a5       	ldd	r24, Y+43	; 0x2b
    4c84:	9c a5       	ldd	r25, Y+44	; 0x2c
    4c86:	01 97       	sbiw	r24, 0x01	; 1
    4c88:	9c a7       	std	Y+44, r25	; 0x2c
    4c8a:	8b a7       	std	Y+43, r24	; 0x2b
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4c8c:	8b a5       	ldd	r24, Y+43	; 0x2b
    4c8e:	9c a5       	ldd	r25, Y+44	; 0x2c
    4c90:	00 97       	sbiw	r24, 0x00	; 0
    4c92:	69 f7       	brne	.-38     	; 0x4c6e <LCD_vidInit+0xfa>
    4c94:	14 c0       	rjmp	.+40     	; 0x4cbe <LCD_vidInit+0x14a>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4c96:	6d a5       	ldd	r22, Y+45	; 0x2d
    4c98:	7e a5       	ldd	r23, Y+46	; 0x2e
    4c9a:	8f a5       	ldd	r24, Y+47	; 0x2f
    4c9c:	98 a9       	ldd	r25, Y+48	; 0x30
    4c9e:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4ca2:	dc 01       	movw	r26, r24
    4ca4:	cb 01       	movw	r24, r22
    4ca6:	9c a7       	std	Y+44, r25	; 0x2c
    4ca8:	8b a7       	std	Y+43, r24	; 0x2b
    4caa:	8b a5       	ldd	r24, Y+43	; 0x2b
    4cac:	9c a5       	ldd	r25, Y+44	; 0x2c
    4cae:	98 a7       	std	Y+40, r25	; 0x28
    4cb0:	8f a3       	std	Y+39, r24	; 0x27
    4cb2:	8f a1       	ldd	r24, Y+39	; 0x27
    4cb4:	98 a5       	ldd	r25, Y+40	; 0x28
    4cb6:	01 97       	sbiw	r24, 0x01	; 1
    4cb8:	f1 f7       	brne	.-4      	; 0x4cb6 <LCD_vidInit+0x142>
    4cba:	98 a7       	std	Y+40, r25	; 0x28
    4cbc:	8f a3       	std	Y+39, r24	; 0x27

	_delay_ms(15);
	LCD_vidCmd(0x03);
    4cbe:	83 e0       	ldi	r24, 0x03	; 3
    4cc0:	0e 94 36 28 	call	0x506c	; 0x506c <LCD_vidCmd>
    4cc4:	80 e0       	ldi	r24, 0x00	; 0
    4cc6:	90 e0       	ldi	r25, 0x00	; 0
    4cc8:	a0 ea       	ldi	r26, 0xA0	; 160
    4cca:	b0 e4       	ldi	r27, 0x40	; 64
    4ccc:	8b a3       	std	Y+35, r24	; 0x23
    4cce:	9c a3       	std	Y+36, r25	; 0x24
    4cd0:	ad a3       	std	Y+37, r26	; 0x25
    4cd2:	be a3       	std	Y+38, r27	; 0x26
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4cd4:	6b a1       	ldd	r22, Y+35	; 0x23
    4cd6:	7c a1       	ldd	r23, Y+36	; 0x24
    4cd8:	8d a1       	ldd	r24, Y+37	; 0x25
    4cda:	9e a1       	ldd	r25, Y+38	; 0x26
    4cdc:	20 e0       	ldi	r18, 0x00	; 0
    4cde:	30 e0       	ldi	r19, 0x00	; 0
    4ce0:	4a e7       	ldi	r20, 0x7A	; 122
    4ce2:	55 e4       	ldi	r21, 0x45	; 69
    4ce4:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4ce8:	dc 01       	movw	r26, r24
    4cea:	cb 01       	movw	r24, r22
    4cec:	8f 8f       	std	Y+31, r24	; 0x1f
    4cee:	98 a3       	std	Y+32, r25	; 0x20
    4cf0:	a9 a3       	std	Y+33, r26	; 0x21
    4cf2:	ba a3       	std	Y+34, r27	; 0x22
	if (__tmp < 1.0)
    4cf4:	6f 8d       	ldd	r22, Y+31	; 0x1f
    4cf6:	78 a1       	ldd	r23, Y+32	; 0x20
    4cf8:	89 a1       	ldd	r24, Y+33	; 0x21
    4cfa:	9a a1       	ldd	r25, Y+34	; 0x22
    4cfc:	20 e0       	ldi	r18, 0x00	; 0
    4cfe:	30 e0       	ldi	r19, 0x00	; 0
    4d00:	40 e8       	ldi	r20, 0x80	; 128
    4d02:	5f e3       	ldi	r21, 0x3F	; 63
    4d04:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4d08:	88 23       	and	r24, r24
    4d0a:	2c f4       	brge	.+10     	; 0x4d16 <LCD_vidInit+0x1a2>
		__ticks = 1;
    4d0c:	81 e0       	ldi	r24, 0x01	; 1
    4d0e:	90 e0       	ldi	r25, 0x00	; 0
    4d10:	9e 8f       	std	Y+30, r25	; 0x1e
    4d12:	8d 8f       	std	Y+29, r24	; 0x1d
    4d14:	3f c0       	rjmp	.+126    	; 0x4d94 <LCD_vidInit+0x220>
	else if (__tmp > 65535)
    4d16:	6f 8d       	ldd	r22, Y+31	; 0x1f
    4d18:	78 a1       	ldd	r23, Y+32	; 0x20
    4d1a:	89 a1       	ldd	r24, Y+33	; 0x21
    4d1c:	9a a1       	ldd	r25, Y+34	; 0x22
    4d1e:	20 e0       	ldi	r18, 0x00	; 0
    4d20:	3f ef       	ldi	r19, 0xFF	; 255
    4d22:	4f e7       	ldi	r20, 0x7F	; 127
    4d24:	57 e4       	ldi	r21, 0x47	; 71
    4d26:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4d2a:	18 16       	cp	r1, r24
    4d2c:	4c f5       	brge	.+82     	; 0x4d80 <LCD_vidInit+0x20c>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4d2e:	6b a1       	ldd	r22, Y+35	; 0x23
    4d30:	7c a1       	ldd	r23, Y+36	; 0x24
    4d32:	8d a1       	ldd	r24, Y+37	; 0x25
    4d34:	9e a1       	ldd	r25, Y+38	; 0x26
    4d36:	20 e0       	ldi	r18, 0x00	; 0
    4d38:	30 e0       	ldi	r19, 0x00	; 0
    4d3a:	40 e2       	ldi	r20, 0x20	; 32
    4d3c:	51 e4       	ldi	r21, 0x41	; 65
    4d3e:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4d42:	dc 01       	movw	r26, r24
    4d44:	cb 01       	movw	r24, r22
    4d46:	bc 01       	movw	r22, r24
    4d48:	cd 01       	movw	r24, r26
    4d4a:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4d4e:	dc 01       	movw	r26, r24
    4d50:	cb 01       	movw	r24, r22
    4d52:	9e 8f       	std	Y+30, r25	; 0x1e
    4d54:	8d 8f       	std	Y+29, r24	; 0x1d
    4d56:	0f c0       	rjmp	.+30     	; 0x4d76 <LCD_vidInit+0x202>
    4d58:	80 e9       	ldi	r24, 0x90	; 144
    4d5a:	91 e0       	ldi	r25, 0x01	; 1
    4d5c:	9c 8f       	std	Y+28, r25	; 0x1c
    4d5e:	8b 8f       	std	Y+27, r24	; 0x1b
    4d60:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4d62:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4d64:	01 97       	sbiw	r24, 0x01	; 1
    4d66:	f1 f7       	brne	.-4      	; 0x4d64 <LCD_vidInit+0x1f0>
    4d68:	9c 8f       	std	Y+28, r25	; 0x1c
    4d6a:	8b 8f       	std	Y+27, r24	; 0x1b
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4d6c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4d6e:	9e 8d       	ldd	r25, Y+30	; 0x1e
    4d70:	01 97       	sbiw	r24, 0x01	; 1
    4d72:	9e 8f       	std	Y+30, r25	; 0x1e
    4d74:	8d 8f       	std	Y+29, r24	; 0x1d
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4d76:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4d78:	9e 8d       	ldd	r25, Y+30	; 0x1e
    4d7a:	00 97       	sbiw	r24, 0x00	; 0
    4d7c:	69 f7       	brne	.-38     	; 0x4d58 <LCD_vidInit+0x1e4>
    4d7e:	14 c0       	rjmp	.+40     	; 0x4da8 <LCD_vidInit+0x234>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4d80:	6f 8d       	ldd	r22, Y+31	; 0x1f
    4d82:	78 a1       	ldd	r23, Y+32	; 0x20
    4d84:	89 a1       	ldd	r24, Y+33	; 0x21
    4d86:	9a a1       	ldd	r25, Y+34	; 0x22
    4d88:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4d8c:	dc 01       	movw	r26, r24
    4d8e:	cb 01       	movw	r24, r22
    4d90:	9e 8f       	std	Y+30, r25	; 0x1e
    4d92:	8d 8f       	std	Y+29, r24	; 0x1d
    4d94:	8d 8d       	ldd	r24, Y+29	; 0x1d
    4d96:	9e 8d       	ldd	r25, Y+30	; 0x1e
    4d98:	9a 8f       	std	Y+26, r25	; 0x1a
    4d9a:	89 8f       	std	Y+25, r24	; 0x19
    4d9c:	89 8d       	ldd	r24, Y+25	; 0x19
    4d9e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    4da0:	01 97       	sbiw	r24, 0x01	; 1
    4da2:	f1 f7       	brne	.-4      	; 0x4da0 <LCD_vidInit+0x22c>
    4da4:	9a 8f       	std	Y+26, r25	; 0x1a
    4da6:	89 8f       	std	Y+25, r24	; 0x19
	_delay_ms(5);
	LCD_vidCmd(0x03);
    4da8:	83 e0       	ldi	r24, 0x03	; 3
    4daa:	0e 94 36 28 	call	0x506c	; 0x506c <LCD_vidCmd>
    4dae:	80 e0       	ldi	r24, 0x00	; 0
    4db0:	90 e0       	ldi	r25, 0x00	; 0
    4db2:	a8 ec       	ldi	r26, 0xC8	; 200
    4db4:	b2 e4       	ldi	r27, 0x42	; 66
    4db6:	8d 8b       	std	Y+21, r24	; 0x15
    4db8:	9e 8b       	std	Y+22, r25	; 0x16
    4dba:	af 8b       	std	Y+23, r26	; 0x17
    4dbc:	b8 8f       	std	Y+24, r27	; 0x18
 */
void
_delay_us(double __us)
{
	uint8_t __ticks;
	double __tmp = ((F_CPU) / 3e6) * __us;
    4dbe:	6d 89       	ldd	r22, Y+21	; 0x15
    4dc0:	7e 89       	ldd	r23, Y+22	; 0x16
    4dc2:	8f 89       	ldd	r24, Y+23	; 0x17
    4dc4:	98 8d       	ldd	r25, Y+24	; 0x18
    4dc6:	2b ea       	ldi	r18, 0xAB	; 171
    4dc8:	3a ea       	ldi	r19, 0xAA	; 170
    4dca:	4a ea       	ldi	r20, 0xAA	; 170
    4dcc:	50 e4       	ldi	r21, 0x40	; 64
    4dce:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4dd2:	dc 01       	movw	r26, r24
    4dd4:	cb 01       	movw	r24, r22
    4dd6:	89 8b       	std	Y+17, r24	; 0x11
    4dd8:	9a 8b       	std	Y+18, r25	; 0x12
    4dda:	ab 8b       	std	Y+19, r26	; 0x13
    4ddc:	bc 8b       	std	Y+20, r27	; 0x14
	if (__tmp < 1.0)
    4dde:	69 89       	ldd	r22, Y+17	; 0x11
    4de0:	7a 89       	ldd	r23, Y+18	; 0x12
    4de2:	8b 89       	ldd	r24, Y+19	; 0x13
    4de4:	9c 89       	ldd	r25, Y+20	; 0x14
    4de6:	20 e0       	ldi	r18, 0x00	; 0
    4de8:	30 e0       	ldi	r19, 0x00	; 0
    4dea:	40 e8       	ldi	r20, 0x80	; 128
    4dec:	5f e3       	ldi	r21, 0x3F	; 63
    4dee:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4df2:	88 23       	and	r24, r24
    4df4:	1c f4       	brge	.+6      	; 0x4dfc <LCD_vidInit+0x288>
		__ticks = 1;
    4df6:	81 e0       	ldi	r24, 0x01	; 1
    4df8:	88 8b       	std	Y+16, r24	; 0x10
    4dfa:	91 c0       	rjmp	.+290    	; 0x4f1e <LCD_vidInit+0x3aa>
	else if (__tmp > 255)
    4dfc:	69 89       	ldd	r22, Y+17	; 0x11
    4dfe:	7a 89       	ldd	r23, Y+18	; 0x12
    4e00:	8b 89       	ldd	r24, Y+19	; 0x13
    4e02:	9c 89       	ldd	r25, Y+20	; 0x14
    4e04:	20 e0       	ldi	r18, 0x00	; 0
    4e06:	30 e0       	ldi	r19, 0x00	; 0
    4e08:	4f e7       	ldi	r20, 0x7F	; 127
    4e0a:	53 e4       	ldi	r21, 0x43	; 67
    4e0c:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4e10:	18 16       	cp	r1, r24
    4e12:	0c f0       	brlt	.+2      	; 0x4e16 <LCD_vidInit+0x2a2>
    4e14:	7b c0       	rjmp	.+246    	; 0x4f0c <LCD_vidInit+0x398>
	{
		_delay_ms(__us / 1000.0);
    4e16:	6d 89       	ldd	r22, Y+21	; 0x15
    4e18:	7e 89       	ldd	r23, Y+22	; 0x16
    4e1a:	8f 89       	ldd	r24, Y+23	; 0x17
    4e1c:	98 8d       	ldd	r25, Y+24	; 0x18
    4e1e:	20 e0       	ldi	r18, 0x00	; 0
    4e20:	30 e0       	ldi	r19, 0x00	; 0
    4e22:	4a e7       	ldi	r20, 0x7A	; 122
    4e24:	54 e4       	ldi	r21, 0x44	; 68
    4e26:	0e 94 19 03 	call	0x632	; 0x632 <__divsf3>
    4e2a:	dc 01       	movw	r26, r24
    4e2c:	cb 01       	movw	r24, r22
    4e2e:	8c 87       	std	Y+12, r24	; 0x0c
    4e30:	9d 87       	std	Y+13, r25	; 0x0d
    4e32:	ae 87       	std	Y+14, r26	; 0x0e
    4e34:	bf 87       	std	Y+15, r27	; 0x0f
 */
void
_delay_ms(double __ms)
{
	uint16_t __ticks;
	double __tmp = ((F_CPU) / 4e3) * __ms;
    4e36:	6c 85       	ldd	r22, Y+12	; 0x0c
    4e38:	7d 85       	ldd	r23, Y+13	; 0x0d
    4e3a:	8e 85       	ldd	r24, Y+14	; 0x0e
    4e3c:	9f 85       	ldd	r25, Y+15	; 0x0f
    4e3e:	20 e0       	ldi	r18, 0x00	; 0
    4e40:	30 e0       	ldi	r19, 0x00	; 0
    4e42:	4a e7       	ldi	r20, 0x7A	; 122
    4e44:	55 e4       	ldi	r21, 0x45	; 69
    4e46:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4e4a:	dc 01       	movw	r26, r24
    4e4c:	cb 01       	movw	r24, r22
    4e4e:	88 87       	std	Y+8, r24	; 0x08
    4e50:	99 87       	std	Y+9, r25	; 0x09
    4e52:	aa 87       	std	Y+10, r26	; 0x0a
    4e54:	bb 87       	std	Y+11, r27	; 0x0b
	if (__tmp < 1.0)
    4e56:	68 85       	ldd	r22, Y+8	; 0x08
    4e58:	79 85       	ldd	r23, Y+9	; 0x09
    4e5a:	8a 85       	ldd	r24, Y+10	; 0x0a
    4e5c:	9b 85       	ldd	r25, Y+11	; 0x0b
    4e5e:	20 e0       	ldi	r18, 0x00	; 0
    4e60:	30 e0       	ldi	r19, 0x00	; 0
    4e62:	40 e8       	ldi	r20, 0x80	; 128
    4e64:	5f e3       	ldi	r21, 0x3F	; 63
    4e66:	0e 94 25 04 	call	0x84a	; 0x84a <__ltsf2>
    4e6a:	88 23       	and	r24, r24
    4e6c:	2c f4       	brge	.+10     	; 0x4e78 <LCD_vidInit+0x304>
		__ticks = 1;
    4e6e:	81 e0       	ldi	r24, 0x01	; 1
    4e70:	90 e0       	ldi	r25, 0x00	; 0
    4e72:	9f 83       	std	Y+7, r25	; 0x07
    4e74:	8e 83       	std	Y+6, r24	; 0x06
    4e76:	3f c0       	rjmp	.+126    	; 0x4ef6 <LCD_vidInit+0x382>
	else if (__tmp > 65535)
    4e78:	68 85       	ldd	r22, Y+8	; 0x08
    4e7a:	79 85       	ldd	r23, Y+9	; 0x09
    4e7c:	8a 85       	ldd	r24, Y+10	; 0x0a
    4e7e:	9b 85       	ldd	r25, Y+11	; 0x0b
    4e80:	20 e0       	ldi	r18, 0x00	; 0
    4e82:	3f ef       	ldi	r19, 0xFF	; 255
    4e84:	4f e7       	ldi	r20, 0x7F	; 127
    4e86:	57 e4       	ldi	r21, 0x47	; 71
    4e88:	0e 94 c5 03 	call	0x78a	; 0x78a <__gtsf2>
    4e8c:	18 16       	cp	r1, r24
    4e8e:	4c f5       	brge	.+82     	; 0x4ee2 <LCD_vidInit+0x36e>
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
    4e90:	6c 85       	ldd	r22, Y+12	; 0x0c
    4e92:	7d 85       	ldd	r23, Y+13	; 0x0d
    4e94:	8e 85       	ldd	r24, Y+14	; 0x0e
    4e96:	9f 85       	ldd	r25, Y+15	; 0x0f
    4e98:	20 e0       	ldi	r18, 0x00	; 0
    4e9a:	30 e0       	ldi	r19, 0x00	; 0
    4e9c:	40 e2       	ldi	r20, 0x20	; 32
    4e9e:	51 e4       	ldi	r21, 0x41	; 65
    4ea0:	0e 94 1f 02 	call	0x43e	; 0x43e <__mulsf3>
    4ea4:	dc 01       	movw	r26, r24
    4ea6:	cb 01       	movw	r24, r22
    4ea8:	bc 01       	movw	r22, r24
    4eaa:	cd 01       	movw	r24, r26
    4eac:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4eb0:	dc 01       	movw	r26, r24
    4eb2:	cb 01       	movw	r24, r22
    4eb4:	9f 83       	std	Y+7, r25	; 0x07
    4eb6:	8e 83       	std	Y+6, r24	; 0x06
    4eb8:	0f c0       	rjmp	.+30     	; 0x4ed8 <LCD_vidInit+0x364>
    4eba:	80 e9       	ldi	r24, 0x90	; 144
    4ebc:	91 e0       	ldi	r25, 0x01	; 1
    4ebe:	9d 83       	std	Y+5, r25	; 0x05
    4ec0:	8c 83       	std	Y+4, r24	; 0x04
    4ec2:	8c 81       	ldd	r24, Y+4	; 0x04
    4ec4:	9d 81       	ldd	r25, Y+5	; 0x05
    4ec6:	01 97       	sbiw	r24, 0x01	; 1
    4ec8:	f1 f7       	brne	.-4      	; 0x4ec6 <LCD_vidInit+0x352>
    4eca:	9d 83       	std	Y+5, r25	; 0x05
    4ecc:	8c 83       	std	Y+4, r24	; 0x04
		while(__ticks)
		{
			// wait 1/10 ms
			_delay_loop_2(((F_CPU) / 4e3) / 10);
			__ticks --;
    4ece:	8e 81       	ldd	r24, Y+6	; 0x06
    4ed0:	9f 81       	ldd	r25, Y+7	; 0x07
    4ed2:	01 97       	sbiw	r24, 0x01	; 1
    4ed4:	9f 83       	std	Y+7, r25	; 0x07
    4ed6:	8e 83       	std	Y+6, r24	; 0x06
		__ticks = 1;
	else if (__tmp > 65535)
	{
		//	__ticks = requested delay in 1/10 ms
		__ticks = (uint16_t) (__ms * 10.0);
		while(__ticks)
    4ed8:	8e 81       	ldd	r24, Y+6	; 0x06
    4eda:	9f 81       	ldd	r25, Y+7	; 0x07
    4edc:	00 97       	sbiw	r24, 0x00	; 0
    4ede:	69 f7       	brne	.-38     	; 0x4eba <LCD_vidInit+0x346>
    4ee0:	24 c0       	rjmp	.+72     	; 0x4f2a <LCD_vidInit+0x3b6>
			__ticks --;
		}
		return;
	}
	else
		__ticks = (uint16_t)__tmp;
    4ee2:	68 85       	ldd	r22, Y+8	; 0x08
    4ee4:	79 85       	ldd	r23, Y+9	; 0x09
    4ee6:	8a 85       	ldd	r24, Y+10	; 0x0a
    4ee8:	9b 85       	ldd	r25, Y+11	; 0x0b
    4eea:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4eee:	dc 01       	movw	r26, r24
    4ef0:	cb 01       	movw	r24, r22
    4ef2:	9f 83       	std	Y+7, r25	; 0x07
    4ef4:	8e 83       	std	Y+6, r24	; 0x06
    4ef6:	8e 81       	ldd	r24, Y+6	; 0x06
    4ef8:	9f 81       	ldd	r25, Y+7	; 0x07
    4efa:	9b 83       	std	Y+3, r25	; 0x03
    4efc:	8a 83       	std	Y+2, r24	; 0x02
    4efe:	8a 81       	ldd	r24, Y+2	; 0x02
    4f00:	9b 81       	ldd	r25, Y+3	; 0x03
    4f02:	01 97       	sbiw	r24, 0x01	; 1
    4f04:	f1 f7       	brne	.-4      	; 0x4f02 <LCD_vidInit+0x38e>
    4f06:	9b 83       	std	Y+3, r25	; 0x03
    4f08:	8a 83       	std	Y+2, r24	; 0x02
    4f0a:	0f c0       	rjmp	.+30     	; 0x4f2a <LCD_vidInit+0x3b6>
	{
		_delay_ms(__us / 1000.0);
		return;
	}
	else
		__ticks = (uint8_t)__tmp;
    4f0c:	69 89       	ldd	r22, Y+17	; 0x11
    4f0e:	7a 89       	ldd	r23, Y+18	; 0x12
    4f10:	8b 89       	ldd	r24, Y+19	; 0x13
    4f12:	9c 89       	ldd	r25, Y+20	; 0x14
    4f14:	0e 94 49 00 	call	0x92	; 0x92 <__fixunssfsi>
    4f18:	dc 01       	movw	r26, r24
    4f1a:	cb 01       	movw	r24, r22
    4f1c:	88 8b       	std	Y+16, r24	; 0x10
    4f1e:	88 89       	ldd	r24, Y+16	; 0x10
    4f20:	89 83       	std	Y+1, r24	; 0x01
    can be achieved.
*/
void
_delay_loop_1(uint8_t __count)
{
	__asm__ volatile (
    4f22:	89 81       	ldd	r24, Y+1	; 0x01
    4f24:	8a 95       	dec	r24
    4f26:	f1 f7       	brne	.-4      	; 0x4f24 <LCD_vidInit+0x3b0>
    4f28:	89 83       	std	Y+1, r24	; 0x01
	_delay_us(100);
	LCD_vidCmd(0x03);
    4f2a:	83 e0       	ldi	r24, 0x03	; 3
    4f2c:	0e 94 36 28 	call	0x506c	; 0x506c <LCD_vidCmd>
	LCD_vidCmd(0x02);
    4f30:	82 e0       	ldi	r24, 0x02	; 2
    4f32:	0e 94 36 28 	call	0x506c	; 0x506c <LCD_vidCmd>
	LCD_vidCmd(LCD_4BIT_MODE);
    4f36:	88 e2       	ldi	r24, 0x28	; 40
    4f38:	0e 94 36 28 	call	0x506c	; 0x506c <LCD_vidCmd>
	  0b11111,
	  0b10001,
	  0b11111,
	  0b10101,
	  0b11011
	};
    4f3c:	ce 01       	movw	r24, r28
    4f3e:	c6 96       	adiw	r24, 0x36	; 54
    4f40:	9f af       	std	Y+63, r25	; 0x3f
    4f42:	8e af       	std	Y+62, r24	; 0x3e
    4f44:	e3 eb       	ldi	r30, 0xB3	; 179
    4f46:	f1 e0       	ldi	r31, 0x01	; 1
    4f48:	22 96       	adiw	r28, 0x02	; 2
    4f4a:	ff af       	std	Y+63, r31	; 0x3f
    4f4c:	ee af       	std	Y+62, r30	; 0x3e
    4f4e:	22 97       	sbiw	r28, 0x02	; 2
    4f50:	f8 e0       	ldi	r31, 0x08	; 8
    4f52:	23 96       	adiw	r28, 0x03	; 3
    4f54:	ff af       	std	Y+63, r31	; 0x3f
    4f56:	23 97       	sbiw	r28, 0x03	; 3
    4f58:	22 96       	adiw	r28, 0x02	; 2
    4f5a:	ee ad       	ldd	r30, Y+62	; 0x3e
    4f5c:	ff ad       	ldd	r31, Y+63	; 0x3f
    4f5e:	22 97       	sbiw	r28, 0x02	; 2
    4f60:	00 80       	ld	r0, Z
    4f62:	22 96       	adiw	r28, 0x02	; 2
    4f64:	8e ad       	ldd	r24, Y+62	; 0x3e
    4f66:	9f ad       	ldd	r25, Y+63	; 0x3f
    4f68:	22 97       	sbiw	r28, 0x02	; 2
    4f6a:	01 96       	adiw	r24, 0x01	; 1
    4f6c:	22 96       	adiw	r28, 0x02	; 2
    4f6e:	9f af       	std	Y+63, r25	; 0x3f
    4f70:	8e af       	std	Y+62, r24	; 0x3e
    4f72:	22 97       	sbiw	r28, 0x02	; 2
    4f74:	ee ad       	ldd	r30, Y+62	; 0x3e
    4f76:	ff ad       	ldd	r31, Y+63	; 0x3f
    4f78:	00 82       	st	Z, r0
    4f7a:	8e ad       	ldd	r24, Y+62	; 0x3e
    4f7c:	9f ad       	ldd	r25, Y+63	; 0x3f
    4f7e:	01 96       	adiw	r24, 0x01	; 1
    4f80:	9f af       	std	Y+63, r25	; 0x3f
    4f82:	8e af       	std	Y+62, r24	; 0x3e
    4f84:	23 96       	adiw	r28, 0x03	; 3
    4f86:	9f ad       	ldd	r25, Y+63	; 0x3f
    4f88:	23 97       	sbiw	r28, 0x03	; 3
    4f8a:	91 50       	subi	r25, 0x01	; 1
    4f8c:	23 96       	adiw	r28, 0x03	; 3
    4f8e:	9f af       	std	Y+63, r25	; 0x3f
    4f90:	23 97       	sbiw	r28, 0x03	; 3
    4f92:	23 96       	adiw	r28, 0x03	; 3
    4f94:	ef ad       	ldd	r30, Y+63	; 0x3f
    4f96:	23 97       	sbiw	r28, 0x03	; 3
    4f98:	ee 23       	and	r30, r30
    4f9a:	f1 f6       	brne	.-68     	; 0x4f58 <LCD_vidInit+0x3e4>

	u8 counter;

	for (counter = 0; counter<8;counter++)
    4f9c:	1d aa       	std	Y+53, r1	; 0x35
    4f9e:	12 c0       	rjmp	.+36     	; 0x4fc4 <LCD_vidInit+0x450>
	{

		LCD_vidCmd(LCD_CGRAM_START_ADDRESS + counter);
    4fa0:	8d a9       	ldd	r24, Y+53	; 0x35
    4fa2:	80 5c       	subi	r24, 0xC0	; 192
    4fa4:	0e 94 36 28 	call	0x506c	; 0x506c <LCD_vidCmd>
		LCD_vidDisplayChar(customChar[counter]);
    4fa8:	8d a9       	ldd	r24, Y+53	; 0x35
    4faa:	28 2f       	mov	r18, r24
    4fac:	30 e0       	ldi	r19, 0x00	; 0
    4fae:	ce 01       	movw	r24, r28
    4fb0:	c6 96       	adiw	r24, 0x36	; 54
    4fb2:	fc 01       	movw	r30, r24
    4fb4:	e2 0f       	add	r30, r18
    4fb6:	f3 1f       	adc	r31, r19
    4fb8:	80 81       	ld	r24, Z
    4fba:	0e 94 f3 27 	call	0x4fe6	; 0x4fe6 <LCD_vidDisplayChar>
	  0b11011
	};

	u8 counter;

	for (counter = 0; counter<8;counter++)
    4fbe:	8d a9       	ldd	r24, Y+53	; 0x35
    4fc0:	8f 5f       	subi	r24, 0xFF	; 255
    4fc2:	8d ab       	std	Y+53, r24	; 0x35
    4fc4:	8d a9       	ldd	r24, Y+53	; 0x35
    4fc6:	88 30       	cpi	r24, 0x08	; 8
    4fc8:	58 f3       	brcs	.-42     	; 0x4fa0 <LCD_vidInit+0x42c>
	{

		LCD_vidCmd(LCD_CGRAM_START_ADDRESS + counter);
		LCD_vidDisplayChar(customChar[counter]);
	}
	LCD_vidRowColumn(0,0);
    4fca:	80 e0       	ldi	r24, 0x00	; 0
    4fcc:	60 e0       	ldi	r22, 0x00	; 0
    4fce:	0e 94 5d 28 	call	0x50ba	; 0x50ba <LCD_vidRowColumn>
}
    4fd2:	ce 5b       	subi	r28, 0xBE	; 190
    4fd4:	df 4f       	sbci	r29, 0xFF	; 255
    4fd6:	0f b6       	in	r0, 0x3f	; 63
    4fd8:	f8 94       	cli
    4fda:	de bf       	out	0x3e, r29	; 62
    4fdc:	0f be       	out	0x3f, r0	; 63
    4fde:	cd bf       	out	0x3d, r28	; 61
    4fe0:	cf 91       	pop	r28
    4fe2:	df 91       	pop	r29
    4fe4:	08 95       	ret

00004fe6 <LCD_vidDisplayChar>:

void LCD_vidDisplayChar(u8 chr)
{
    4fe6:	df 93       	push	r29
    4fe8:	cf 93       	push	r28
    4fea:	00 d0       	rcall	.+0      	; 0x4fec <LCD_vidDisplayChar+0x6>
    4fec:	0f 92       	push	r0
    4fee:	cd b7       	in	r28, 0x3d	; 61
    4ff0:	de b7       	in	r29, 0x3e	; 62
    4ff2:	8b 83       	std	Y+3, r24	; 0x03
	u8 loc_MSB = (chr & ~LCD_MASK);
    4ff4:	8b 81       	ldd	r24, Y+3	; 0x03
    4ff6:	80 7f       	andi	r24, 0xF0	; 240
    4ff8:	8a 83       	std	Y+2, r24	; 0x02
	u8 loc_LSB = (chr << 4);
    4ffa:	8b 81       	ldd	r24, Y+3	; 0x03
    4ffc:	82 95       	swap	r24
    4ffe:	80 7f       	andi	r24, 0xF0	; 240
    5000:	89 83       	std	Y+1, r24	; 0x01

	/* RS = 1 */
	Dio_vidwriteChannel(DIO_PORTB,DIO_PIN1,DIO_HIGH);
    5002:	81 e0       	ldi	r24, 0x01	; 1
    5004:	61 e0       	ldi	r22, 0x01	; 1
    5006:	41 e0       	ldi	r20, 0x01	; 1
    5008:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
	/* Write MSB to LCD */
	Dio_vidwriteChannelGroup(DIO_PORTA,loc_MSB,LCD_MASK);
    500c:	80 e0       	ldi	r24, 0x00	; 0
    500e:	6a 81       	ldd	r22, Y+2	; 0x02
    5010:	4f e0       	ldi	r20, 0x0F	; 15
    5012:	0e 94 be 30 	call	0x617c	; 0x617c <Dio_vidwriteChannelGroup>
	/* Send Enable Pulse */
	LCD_vidEnablePulse();
    5016:	0e 94 6d 24 	call	0x48da	; 0x48da <LCD_vidEnablePulse>


	/* Write LSB to LCD */
	Dio_vidwriteChannelGroup(DIO_PORTA,loc_LSB,LCD_MASK);
    501a:	80 e0       	ldi	r24, 0x00	; 0
    501c:	69 81       	ldd	r22, Y+1	; 0x01
    501e:	4f e0       	ldi	r20, 0x0F	; 15
    5020:	0e 94 be 30 	call	0x617c	; 0x617c <Dio_vidwriteChannelGroup>
	/* Send Enable Pulse */
	LCD_vidEnablePulse();
    5024:	0e 94 6d 24 	call	0x48da	; 0x48da <LCD_vidEnablePulse>
}
    5028:	0f 90       	pop	r0
    502a:	0f 90       	pop	r0
    502c:	0f 90       	pop	r0
    502e:	cf 91       	pop	r28
    5030:	df 91       	pop	r29
    5032:	08 95       	ret

00005034 <LCD_vidDisplayWord>:

void LCD_vidDisplayWord(u8 *word)
{
    5034:	df 93       	push	r29
    5036:	cf 93       	push	r28
    5038:	00 d0       	rcall	.+0      	; 0x503a <LCD_vidDisplayWord+0x6>
    503a:	cd b7       	in	r28, 0x3d	; 61
    503c:	de b7       	in	r29, 0x3e	; 62
    503e:	9a 83       	std	Y+2, r25	; 0x02
    5040:	89 83       	std	Y+1, r24	; 0x01
    5042:	0a c0       	rjmp	.+20     	; 0x5058 <LCD_vidDisplayWord+0x24>
	while (*word != '\0')
	{
		LCD_vidDisplayChar(*word);
    5044:	e9 81       	ldd	r30, Y+1	; 0x01
    5046:	fa 81       	ldd	r31, Y+2	; 0x02
    5048:	80 81       	ld	r24, Z
    504a:	0e 94 f3 27 	call	0x4fe6	; 0x4fe6 <LCD_vidDisplayChar>
		word++;
    504e:	89 81       	ldd	r24, Y+1	; 0x01
    5050:	9a 81       	ldd	r25, Y+2	; 0x02
    5052:	01 96       	adiw	r24, 0x01	; 1
    5054:	9a 83       	std	Y+2, r25	; 0x02
    5056:	89 83       	std	Y+1, r24	; 0x01
	LCD_vidEnablePulse();
}

void LCD_vidDisplayWord(u8 *word)
{
	while (*word != '\0')
    5058:	e9 81       	ldd	r30, Y+1	; 0x01
    505a:	fa 81       	ldd	r31, Y+2	; 0x02
    505c:	80 81       	ld	r24, Z
    505e:	88 23       	and	r24, r24
    5060:	89 f7       	brne	.-30     	; 0x5044 <LCD_vidDisplayWord+0x10>
	{
		LCD_vidDisplayChar(*word);
		word++;
	}
}
    5062:	0f 90       	pop	r0
    5064:	0f 90       	pop	r0
    5066:	cf 91       	pop	r28
    5068:	df 91       	pop	r29
    506a:	08 95       	ret

0000506c <LCD_vidCmd>:

void LCD_vidCmd(lcd_Cmd_t cmd)
{
    506c:	df 93       	push	r29
    506e:	cf 93       	push	r28
    5070:	00 d0       	rcall	.+0      	; 0x5072 <LCD_vidCmd+0x6>
    5072:	0f 92       	push	r0
    5074:	cd b7       	in	r28, 0x3d	; 61
    5076:	de b7       	in	r29, 0x3e	; 62
    5078:	8b 83       	std	Y+3, r24	; 0x03
	u8 loc_MSB = (cmd & ~LCD_MASK);
    507a:	8b 81       	ldd	r24, Y+3	; 0x03
    507c:	80 7f       	andi	r24, 0xF0	; 240
    507e:	8a 83       	std	Y+2, r24	; 0x02
	u8 loc_LSB = (cmd << 4);
    5080:	8b 81       	ldd	r24, Y+3	; 0x03
    5082:	82 95       	swap	r24
    5084:	80 7f       	andi	r24, 0xF0	; 240
    5086:	89 83       	std	Y+1, r24	; 0x01

	Dio_vidwriteChannel(DIO_PORTB,DIO_PIN1,DIO_LOW);
    5088:	81 e0       	ldi	r24, 0x01	; 1
    508a:	61 e0       	ldi	r22, 0x01	; 1
    508c:	40 e0       	ldi	r20, 0x00	; 0
    508e:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>

	/* Write MSB to LCD */
	Dio_vidwriteChannelGroup(DIO_PORTA,loc_MSB,LCD_MASK);
    5092:	80 e0       	ldi	r24, 0x00	; 0
    5094:	6a 81       	ldd	r22, Y+2	; 0x02
    5096:	4f e0       	ldi	r20, 0x0F	; 15
    5098:	0e 94 be 30 	call	0x617c	; 0x617c <Dio_vidwriteChannelGroup>
	/* Send Enable Pulse */
	LCD_vidEnablePulse();
    509c:	0e 94 6d 24 	call	0x48da	; 0x48da <LCD_vidEnablePulse>


	/* Write LSB to LCD */
	Dio_vidwriteChannelGroup(DIO_PORTA,loc_LSB,LCD_MASK);
    50a0:	80 e0       	ldi	r24, 0x00	; 0
    50a2:	69 81       	ldd	r22, Y+1	; 0x01
    50a4:	4f e0       	ldi	r20, 0x0F	; 15
    50a6:	0e 94 be 30 	call	0x617c	; 0x617c <Dio_vidwriteChannelGroup>
	/* Send Enable Pulse */
	LCD_vidEnablePulse();
    50aa:	0e 94 6d 24 	call	0x48da	; 0x48da <LCD_vidEnablePulse>
}
    50ae:	0f 90       	pop	r0
    50b0:	0f 90       	pop	r0
    50b2:	0f 90       	pop	r0
    50b4:	cf 91       	pop	r28
    50b6:	df 91       	pop	r29
    50b8:	08 95       	ret

000050ba <LCD_vidRowColumn>:

void LCD_vidRowColumn(u8 row,u8 column)
{
    50ba:	df 93       	push	r29
    50bc:	cf 93       	push	r28
    50be:	00 d0       	rcall	.+0      	; 0x50c0 <LCD_vidRowColumn+0x6>
    50c0:	00 d0       	rcall	.+0      	; 0x50c2 <LCD_vidRowColumn+0x8>
    50c2:	cd b7       	in	r28, 0x3d	; 61
    50c4:	de b7       	in	r29, 0x3e	; 62
    50c6:	89 83       	std	Y+1, r24	; 0x01
    50c8:	6a 83       	std	Y+2, r22	; 0x02
	switch (row)
    50ca:	89 81       	ldd	r24, Y+1	; 0x01
    50cc:	28 2f       	mov	r18, r24
    50ce:	30 e0       	ldi	r19, 0x00	; 0
    50d0:	3c 83       	std	Y+4, r19	; 0x04
    50d2:	2b 83       	std	Y+3, r18	; 0x03
    50d4:	8b 81       	ldd	r24, Y+3	; 0x03
    50d6:	9c 81       	ldd	r25, Y+4	; 0x04
    50d8:	00 97       	sbiw	r24, 0x00	; 0
    50da:	31 f0       	breq	.+12     	; 0x50e8 <LCD_vidRowColumn+0x2e>
    50dc:	2b 81       	ldd	r18, Y+3	; 0x03
    50de:	3c 81       	ldd	r19, Y+4	; 0x04
    50e0:	21 30       	cpi	r18, 0x01	; 1
    50e2:	31 05       	cpc	r19, r1
    50e4:	31 f0       	breq	.+12     	; 0x50f2 <LCD_vidRowColumn+0x38>
    50e6:	09 c0       	rjmp	.+18     	; 0x50fa <LCD_vidRowColumn+0x40>
	{
	case 0:
	{
		LCD_vidCmd(0x80 + column);
    50e8:	8a 81       	ldd	r24, Y+2	; 0x02
    50ea:	80 58       	subi	r24, 0x80	; 128
    50ec:	0e 94 36 28 	call	0x506c	; 0x506c <LCD_vidCmd>
    50f0:	04 c0       	rjmp	.+8      	; 0x50fa <LCD_vidRowColumn+0x40>
		break;
	}
	case 1:
	{
		LCD_vidCmd(0xC0 + column);
    50f2:	8a 81       	ldd	r24, Y+2	; 0x02
    50f4:	80 54       	subi	r24, 0x40	; 64
    50f6:	0e 94 36 28 	call	0x506c	; 0x506c <LCD_vidCmd>
		break;
	}
	}
}
    50fa:	0f 90       	pop	r0
    50fc:	0f 90       	pop	r0
    50fe:	0f 90       	pop	r0
    5100:	0f 90       	pop	r0
    5102:	cf 91       	pop	r28
    5104:	df 91       	pop	r29
    5106:	08 95       	ret

00005108 <LCD_vidDisplayInt>:

void LCD_vidDisplayInt(u32 num)
{
    5108:	df 93       	push	r29
    510a:	cf 93       	push	r28
    510c:	cd b7       	in	r28, 0x3d	; 61
    510e:	de b7       	in	r29, 0x3e	; 62
    5110:	2e 97       	sbiw	r28, 0x0e	; 14
    5112:	0f b6       	in	r0, 0x3f	; 63
    5114:	f8 94       	cli
    5116:	de bf       	out	0x3e, r29	; 62
    5118:	0f be       	out	0x3f, r0	; 63
    511a:	cd bf       	out	0x3d, r28	; 61
    511c:	6b 87       	std	Y+11, r22	; 0x0b
    511e:	7c 87       	std	Y+12, r23	; 0x0c
    5120:	8d 87       	std	Y+13, r24	; 0x0d
    5122:	9e 87       	std	Y+14, r25	; 0x0e
	u8 buffer[10];
	sprintf(buffer,"%d",num);
    5124:	8d b7       	in	r24, 0x3d	; 61
    5126:	9e b7       	in	r25, 0x3e	; 62
    5128:	08 97       	sbiw	r24, 0x08	; 8
    512a:	0f b6       	in	r0, 0x3f	; 63
    512c:	f8 94       	cli
    512e:	9e bf       	out	0x3e, r25	; 62
    5130:	0f be       	out	0x3f, r0	; 63
    5132:	8d bf       	out	0x3d, r24	; 61
    5134:	ed b7       	in	r30, 0x3d	; 61
    5136:	fe b7       	in	r31, 0x3e	; 62
    5138:	31 96       	adiw	r30, 0x01	; 1
    513a:	ce 01       	movw	r24, r28
    513c:	01 96       	adiw	r24, 0x01	; 1
    513e:	91 83       	std	Z+1, r25	; 0x01
    5140:	80 83       	st	Z, r24
    5142:	81 e9       	ldi	r24, 0x91	; 145
    5144:	90 e0       	ldi	r25, 0x00	; 0
    5146:	93 83       	std	Z+3, r25	; 0x03
    5148:	82 83       	std	Z+2, r24	; 0x02
    514a:	8b 85       	ldd	r24, Y+11	; 0x0b
    514c:	9c 85       	ldd	r25, Y+12	; 0x0c
    514e:	ad 85       	ldd	r26, Y+13	; 0x0d
    5150:	be 85       	ldd	r27, Y+14	; 0x0e
    5152:	84 83       	std	Z+4, r24	; 0x04
    5154:	95 83       	std	Z+5, r25	; 0x05
    5156:	a6 83       	std	Z+6, r26	; 0x06
    5158:	b7 83       	std	Z+7, r27	; 0x07
    515a:	0e 94 25 32 	call	0x644a	; 0x644a <sprintf>
    515e:	8d b7       	in	r24, 0x3d	; 61
    5160:	9e b7       	in	r25, 0x3e	; 62
    5162:	08 96       	adiw	r24, 0x08	; 8
    5164:	0f b6       	in	r0, 0x3f	; 63
    5166:	f8 94       	cli
    5168:	9e bf       	out	0x3e, r25	; 62
    516a:	0f be       	out	0x3f, r0	; 63
    516c:	8d bf       	out	0x3d, r24	; 61
	LCD_vidDisplayWord(buffer);
    516e:	ce 01       	movw	r24, r28
    5170:	01 96       	adiw	r24, 0x01	; 1
    5172:	0e 94 1a 28 	call	0x5034	; 0x5034 <LCD_vidDisplayWord>
}
    5176:	2e 96       	adiw	r28, 0x0e	; 14
    5178:	0f b6       	in	r0, 0x3f	; 63
    517a:	f8 94       	cli
    517c:	de bf       	out	0x3e, r29	; 62
    517e:	0f be       	out	0x3f, r0	; 63
    5180:	cd bf       	out	0x3d, r28	; 61
    5182:	cf 91       	pop	r28
    5184:	df 91       	pop	r29
    5186:	08 95       	ret

00005188 <LCD_vidDisplayFloat>:

void LCD_vidDisplayFloat(f64 num)
{
    5188:	df 93       	push	r29
    518a:	cf 93       	push	r28
    518c:	cd b7       	in	r28, 0x3d	; 61
    518e:	de b7       	in	r29, 0x3e	; 62
    5190:	ac 97       	sbiw	r28, 0x2c	; 44
    5192:	0f b6       	in	r0, 0x3f	; 63
    5194:	f8 94       	cli
    5196:	de bf       	out	0x3e, r29	; 62
    5198:	0f be       	out	0x3f, r0	; 63
    519a:	cd bf       	out	0x3d, r28	; 61
    519c:	69 a7       	std	Y+41, r22	; 0x29
    519e:	7a a7       	std	Y+42, r23	; 0x2a
    51a0:	8b a7       	std	Y+43, r24	; 0x2b
    51a2:	9c a7       	std	Y+44, r25	; 0x2c
	f64 buffer[10];
	sprintf(buffer,"%f",num);
    51a4:	ce 01       	movw	r24, r28
    51a6:	01 96       	adiw	r24, 0x01	; 1
    51a8:	2d b7       	in	r18, 0x3d	; 61
    51aa:	3e b7       	in	r19, 0x3e	; 62
    51ac:	28 50       	subi	r18, 0x08	; 8
    51ae:	30 40       	sbci	r19, 0x00	; 0
    51b0:	0f b6       	in	r0, 0x3f	; 63
    51b2:	f8 94       	cli
    51b4:	3e bf       	out	0x3e, r19	; 62
    51b6:	0f be       	out	0x3f, r0	; 63
    51b8:	2d bf       	out	0x3d, r18	; 61
    51ba:	ed b7       	in	r30, 0x3d	; 61
    51bc:	fe b7       	in	r31, 0x3e	; 62
    51be:	31 96       	adiw	r30, 0x01	; 1
    51c0:	91 83       	std	Z+1, r25	; 0x01
    51c2:	80 83       	st	Z, r24
    51c4:	84 e9       	ldi	r24, 0x94	; 148
    51c6:	90 e0       	ldi	r25, 0x00	; 0
    51c8:	93 83       	std	Z+3, r25	; 0x03
    51ca:	82 83       	std	Z+2, r24	; 0x02
    51cc:	89 a5       	ldd	r24, Y+41	; 0x29
    51ce:	9a a5       	ldd	r25, Y+42	; 0x2a
    51d0:	ab a5       	ldd	r26, Y+43	; 0x2b
    51d2:	bc a5       	ldd	r27, Y+44	; 0x2c
    51d4:	84 83       	std	Z+4, r24	; 0x04
    51d6:	95 83       	std	Z+5, r25	; 0x05
    51d8:	a6 83       	std	Z+6, r26	; 0x06
    51da:	b7 83       	std	Z+7, r27	; 0x07
    51dc:	0e 94 25 32 	call	0x644a	; 0x644a <sprintf>
    51e0:	8d b7       	in	r24, 0x3d	; 61
    51e2:	9e b7       	in	r25, 0x3e	; 62
    51e4:	08 96       	adiw	r24, 0x08	; 8
    51e6:	0f b6       	in	r0, 0x3f	; 63
    51e8:	f8 94       	cli
    51ea:	9e bf       	out	0x3e, r25	; 62
    51ec:	0f be       	out	0x3f, r0	; 63
    51ee:	8d bf       	out	0x3d, r24	; 61
	LCD_vidDisplayWord(buffer);
    51f0:	ce 01       	movw	r24, r28
    51f2:	01 96       	adiw	r24, 0x01	; 1
    51f4:	0e 94 1a 28 	call	0x5034	; 0x5034 <LCD_vidDisplayWord>
}
    51f8:	ac 96       	adiw	r28, 0x2c	; 44
    51fa:	0f b6       	in	r0, 0x3f	; 63
    51fc:	f8 94       	cli
    51fe:	de bf       	out	0x3e, r29	; 62
    5200:	0f be       	out	0x3f, r0	; 63
    5202:	cd bf       	out	0x3d, r28	; 61
    5204:	cf 91       	pop	r28
    5206:	df 91       	pop	r29
    5208:	08 95       	ret

0000520a <KEYPAD_vidInit>:
		{'7','8','9','C'},
	    {'*','0','#','D'}
};

void KEYPAD_vidInit(void)
{
    520a:	df 93       	push	r29
    520c:	cf 93       	push	r28
    520e:	cd b7       	in	r28, 0x3d	; 61
    5210:	de b7       	in	r29, 0x3e	; 62
	/* Configure Rows Pins as input */
	Dio_vidconfigChannel(DIO_PORTD,DIO_PIN6,DIO_INPUT);
    5212:	83 e0       	ldi	r24, 0x03	; 3
    5214:	66 e0       	ldi	r22, 0x06	; 6
    5216:	40 e0       	ldi	r20, 0x00	; 0
    5218:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTD,DIO_PIN3,DIO_INPUT);
    521c:	83 e0       	ldi	r24, 0x03	; 3
    521e:	63 e0       	ldi	r22, 0x03	; 3
    5220:	40 e0       	ldi	r20, 0x00	; 0
    5222:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTC,DIO_PIN2,DIO_INPUT);
    5226:	82 e0       	ldi	r24, 0x02	; 2
    5228:	62 e0       	ldi	r22, 0x02	; 2
    522a:	40 e0       	ldi	r20, 0x00	; 0
    522c:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTC,DIO_PIN3,DIO_INPUT);
    5230:	82 e0       	ldi	r24, 0x02	; 2
    5232:	63 e0       	ldi	r22, 0x03	; 3
    5234:	40 e0       	ldi	r20, 0x00	; 0
    5236:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>


	/* Configure Columns pins as output */
	Dio_vidconfigChannel(DIO_PORTC,DIO_PIN4,DIO_OUTPUT);
    523a:	82 e0       	ldi	r24, 0x02	; 2
    523c:	64 e0       	ldi	r22, 0x04	; 4
    523e:	41 e0       	ldi	r20, 0x01	; 1
    5240:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTC,DIO_PIN5,DIO_OUTPUT);
    5244:	82 e0       	ldi	r24, 0x02	; 2
    5246:	65 e0       	ldi	r22, 0x05	; 5
    5248:	41 e0       	ldi	r20, 0x01	; 1
    524a:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTC,DIO_PIN6,DIO_OUTPUT);
    524e:	82 e0       	ldi	r24, 0x02	; 2
    5250:	66 e0       	ldi	r22, 0x06	; 6
    5252:	41 e0       	ldi	r20, 0x01	; 1
    5254:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTC,DIO_PIN7,DIO_OUTPUT);
    5258:	82 e0       	ldi	r24, 0x02	; 2
    525a:	67 e0       	ldi	r22, 0x07	; 7
    525c:	41 e0       	ldi	r20, 0x01	; 1
    525e:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>


	/* Initialize output Columns as High */
	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN4,DIO_HIGH);
    5262:	82 e0       	ldi	r24, 0x02	; 2
    5264:	64 e0       	ldi	r22, 0x04	; 4
    5266:	41 e0       	ldi	r20, 0x01	; 1
    5268:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN5,DIO_HIGH);
    526c:	82 e0       	ldi	r24, 0x02	; 2
    526e:	65 e0       	ldi	r22, 0x05	; 5
    5270:	41 e0       	ldi	r20, 0x01	; 1
    5272:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN6,DIO_HIGH);
    5276:	82 e0       	ldi	r24, 0x02	; 2
    5278:	66 e0       	ldi	r22, 0x06	; 6
    527a:	41 e0       	ldi	r20, 0x01	; 1
    527c:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN7,DIO_HIGH);
    5280:	82 e0       	ldi	r24, 0x02	; 2
    5282:	67 e0       	ldi	r22, 0x07	; 7
    5284:	41 e0       	ldi	r20, 0x01	; 1
    5286:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
}
    528a:	cf 91       	pop	r28
    528c:	df 91       	pop	r29
    528e:	08 95       	ret

00005290 <KEYPAD_udtGetRow>:

kp_row_t KEYPAD_udtGetRow(void)
{
    5290:	df 93       	push	r29
    5292:	cf 93       	push	r28
    5294:	0f 92       	push	r0
    5296:	cd b7       	in	r28, 0x3d	; 61
    5298:	de b7       	in	r29, 0x3e	; 62
	kp_row_t loc_row = KP_NOROW;
    529a:	84 e0       	ldi	r24, 0x04	; 4
    529c:	89 83       	std	Y+1, r24	; 0x01

	if (Dio_udtreadChannel(DIO_PORTD,DIO_PIN6) == DIO_HIGH)
    529e:	83 e0       	ldi	r24, 0x03	; 3
    52a0:	66 e0       	ldi	r22, 0x06	; 6
    52a2:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <Dio_udtreadChannel>
    52a6:	81 30       	cpi	r24, 0x01	; 1
    52a8:	11 f4       	brne	.+4      	; 0x52ae <KEYPAD_udtGetRow+0x1e>
	{
		loc_row = KP_ROW0;
    52aa:	19 82       	std	Y+1, r1	; 0x01
    52ac:	1a c0       	rjmp	.+52     	; 0x52e2 <KEYPAD_udtGetRow+0x52>
	}
	else if (Dio_udtreadChannel(DIO_PORTD,DIO_PIN3) == DIO_HIGH)
    52ae:	83 e0       	ldi	r24, 0x03	; 3
    52b0:	63 e0       	ldi	r22, 0x03	; 3
    52b2:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <Dio_udtreadChannel>
    52b6:	81 30       	cpi	r24, 0x01	; 1
    52b8:	19 f4       	brne	.+6      	; 0x52c0 <KEYPAD_udtGetRow+0x30>
	{
		loc_row = KP_ROW1;
    52ba:	81 e0       	ldi	r24, 0x01	; 1
    52bc:	89 83       	std	Y+1, r24	; 0x01
    52be:	11 c0       	rjmp	.+34     	; 0x52e2 <KEYPAD_udtGetRow+0x52>
	}
	else if (Dio_udtreadChannel(DIO_PORTC,DIO_PIN2) == DIO_HIGH)
    52c0:	82 e0       	ldi	r24, 0x02	; 2
    52c2:	62 e0       	ldi	r22, 0x02	; 2
    52c4:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <Dio_udtreadChannel>
    52c8:	81 30       	cpi	r24, 0x01	; 1
    52ca:	19 f4       	brne	.+6      	; 0x52d2 <KEYPAD_udtGetRow+0x42>
	{
		loc_row = KP_ROW2;
    52cc:	82 e0       	ldi	r24, 0x02	; 2
    52ce:	89 83       	std	Y+1, r24	; 0x01
    52d0:	08 c0       	rjmp	.+16     	; 0x52e2 <KEYPAD_udtGetRow+0x52>
	}
	else if (Dio_udtreadChannel(DIO_PORTC,DIO_PIN3) == DIO_HIGH)
    52d2:	82 e0       	ldi	r24, 0x02	; 2
    52d4:	63 e0       	ldi	r22, 0x03	; 3
    52d6:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <Dio_udtreadChannel>
    52da:	81 30       	cpi	r24, 0x01	; 1
    52dc:	11 f4       	brne	.+4      	; 0x52e2 <KEYPAD_udtGetRow+0x52>
	{
		loc_row = KP_ROW3;
    52de:	83 e0       	ldi	r24, 0x03	; 3
    52e0:	89 83       	std	Y+1, r24	; 0x01
	}
	return loc_row;
    52e2:	89 81       	ldd	r24, Y+1	; 0x01
}
    52e4:	0f 90       	pop	r0
    52e6:	cf 91       	pop	r28
    52e8:	df 91       	pop	r29
    52ea:	08 95       	ret

000052ec <KEYPAD_udtGetColumn>:

kp_col_t KEYPAD_udtGetColumn(kp_row_t current_row)
{
    52ec:	df 93       	push	r29
    52ee:	cf 93       	push	r28
    52f0:	00 d0       	rcall	.+0      	; 0x52f2 <KEYPAD_udtGetColumn+0x6>
    52f2:	cd b7       	in	r28, 0x3d	; 61
    52f4:	de b7       	in	r29, 0x3e	; 62
    52f6:	89 83       	std	Y+1, r24	; 0x01
	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN4,DIO_HIGH);
    52f8:	82 e0       	ldi	r24, 0x02	; 2
    52fa:	64 e0       	ldi	r22, 0x04	; 4
    52fc:	41 e0       	ldi	r20, 0x01	; 1
    52fe:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN5,DIO_LOW);
    5302:	82 e0       	ldi	r24, 0x02	; 2
    5304:	65 e0       	ldi	r22, 0x05	; 5
    5306:	40 e0       	ldi	r20, 0x00	; 0
    5308:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN6,DIO_LOW);
    530c:	82 e0       	ldi	r24, 0x02	; 2
    530e:	66 e0       	ldi	r22, 0x06	; 6
    5310:	40 e0       	ldi	r20, 0x00	; 0
    5312:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN7,DIO_LOW);
    5316:	82 e0       	ldi	r24, 0x02	; 2
    5318:	67 e0       	ldi	r22, 0x07	; 7
    531a:	40 e0       	ldi	r20, 0x00	; 0
    531c:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>


	if (KEYPAD_udtGetRow() == current_row)
    5320:	0e 94 48 29 	call	0x5290	; 0x5290 <KEYPAD_udtGetRow>
    5324:	98 2f       	mov	r25, r24
    5326:	89 81       	ldd	r24, Y+1	; 0x01
    5328:	98 17       	cp	r25, r24
    532a:	11 f4       	brne	.+4      	; 0x5330 <KEYPAD_udtGetColumn+0x44>
	{
		return KP_COLUMN0;
    532c:	1a 82       	std	Y+2, r1	; 0x02
    532e:	59 c0       	rjmp	.+178    	; 0x53e2 <KEYPAD_udtGetColumn+0xf6>
	}

	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN4,DIO_LOW);
    5330:	82 e0       	ldi	r24, 0x02	; 2
    5332:	64 e0       	ldi	r22, 0x04	; 4
    5334:	40 e0       	ldi	r20, 0x00	; 0
    5336:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN5,DIO_HIGH);
    533a:	82 e0       	ldi	r24, 0x02	; 2
    533c:	65 e0       	ldi	r22, 0x05	; 5
    533e:	41 e0       	ldi	r20, 0x01	; 1
    5340:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN6,DIO_LOW);
    5344:	82 e0       	ldi	r24, 0x02	; 2
    5346:	66 e0       	ldi	r22, 0x06	; 6
    5348:	40 e0       	ldi	r20, 0x00	; 0
    534a:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN7,DIO_LOW);
    534e:	82 e0       	ldi	r24, 0x02	; 2
    5350:	67 e0       	ldi	r22, 0x07	; 7
    5352:	40 e0       	ldi	r20, 0x00	; 0
    5354:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>


	if (KEYPAD_udtGetRow() == current_row)
    5358:	0e 94 48 29 	call	0x5290	; 0x5290 <KEYPAD_udtGetRow>
    535c:	98 2f       	mov	r25, r24
    535e:	89 81       	ldd	r24, Y+1	; 0x01
    5360:	98 17       	cp	r25, r24
    5362:	19 f4       	brne	.+6      	; 0x536a <KEYPAD_udtGetColumn+0x7e>
	{
		return KP_COLUMN1;
    5364:	81 e0       	ldi	r24, 0x01	; 1
    5366:	8a 83       	std	Y+2, r24	; 0x02
    5368:	3c c0       	rjmp	.+120    	; 0x53e2 <KEYPAD_udtGetColumn+0xf6>
	}

	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN4,DIO_LOW);
    536a:	82 e0       	ldi	r24, 0x02	; 2
    536c:	64 e0       	ldi	r22, 0x04	; 4
    536e:	40 e0       	ldi	r20, 0x00	; 0
    5370:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN5,DIO_LOW);
    5374:	82 e0       	ldi	r24, 0x02	; 2
    5376:	65 e0       	ldi	r22, 0x05	; 5
    5378:	40 e0       	ldi	r20, 0x00	; 0
    537a:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN6,DIO_HIGH);
    537e:	82 e0       	ldi	r24, 0x02	; 2
    5380:	66 e0       	ldi	r22, 0x06	; 6
    5382:	41 e0       	ldi	r20, 0x01	; 1
    5384:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN7,DIO_LOW);
    5388:	82 e0       	ldi	r24, 0x02	; 2
    538a:	67 e0       	ldi	r22, 0x07	; 7
    538c:	40 e0       	ldi	r20, 0x00	; 0
    538e:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>


	if (KEYPAD_udtGetRow() == current_row)
    5392:	0e 94 48 29 	call	0x5290	; 0x5290 <KEYPAD_udtGetRow>
    5396:	98 2f       	mov	r25, r24
    5398:	89 81       	ldd	r24, Y+1	; 0x01
    539a:	98 17       	cp	r25, r24
    539c:	19 f4       	brne	.+6      	; 0x53a4 <KEYPAD_udtGetColumn+0xb8>
	{
		return KP_COLUMN2;
    539e:	82 e0       	ldi	r24, 0x02	; 2
    53a0:	8a 83       	std	Y+2, r24	; 0x02
    53a2:	1f c0       	rjmp	.+62     	; 0x53e2 <KEYPAD_udtGetColumn+0xf6>
	}

	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN4,DIO_LOW);
    53a4:	82 e0       	ldi	r24, 0x02	; 2
    53a6:	64 e0       	ldi	r22, 0x04	; 4
    53a8:	40 e0       	ldi	r20, 0x00	; 0
    53aa:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN5,DIO_LOW);
    53ae:	82 e0       	ldi	r24, 0x02	; 2
    53b0:	65 e0       	ldi	r22, 0x05	; 5
    53b2:	40 e0       	ldi	r20, 0x00	; 0
    53b4:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN6,DIO_LOW);
    53b8:	82 e0       	ldi	r24, 0x02	; 2
    53ba:	66 e0       	ldi	r22, 0x06	; 6
    53bc:	40 e0       	ldi	r20, 0x00	; 0
    53be:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
	Dio_vidwriteChannel(DIO_PORTC,DIO_PIN7,DIO_HIGH);
    53c2:	82 e0       	ldi	r24, 0x02	; 2
    53c4:	67 e0       	ldi	r22, 0x07	; 7
    53c6:	41 e0       	ldi	r20, 0x01	; 1
    53c8:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>


	if (KEYPAD_udtGetRow() == current_row)
    53cc:	0e 94 48 29 	call	0x5290	; 0x5290 <KEYPAD_udtGetRow>
    53d0:	98 2f       	mov	r25, r24
    53d2:	89 81       	ldd	r24, Y+1	; 0x01
    53d4:	98 17       	cp	r25, r24
    53d6:	19 f4       	brne	.+6      	; 0x53de <KEYPAD_udtGetColumn+0xf2>
	{
		return KP_COLUMN3;
    53d8:	83 e0       	ldi	r24, 0x03	; 3
    53da:	8a 83       	std	Y+2, r24	; 0x02
    53dc:	02 c0       	rjmp	.+4      	; 0x53e2 <KEYPAD_udtGetColumn+0xf6>
	}
	return KP_NOCOLUMN;
    53de:	84 e0       	ldi	r24, 0x04	; 4
    53e0:	8a 83       	std	Y+2, r24	; 0x02
    53e2:	8a 81       	ldd	r24, Y+2	; 0x02
}
    53e4:	0f 90       	pop	r0
    53e6:	0f 90       	pop	r0
    53e8:	cf 91       	pop	r28
    53ea:	df 91       	pop	r29
    53ec:	08 95       	ret

000053ee <KEYPAD_udtIsPressed>:

boolean KEYPAD_udtIsPressed()
{
    53ee:	df 93       	push	r29
    53f0:	cf 93       	push	r28
    53f2:	0f 92       	push	r0
    53f4:	cd b7       	in	r28, 0x3d	; 61
    53f6:	de b7       	in	r29, 0x3e	; 62
	if (
    53f8:	83 e0       	ldi	r24, 0x03	; 3
    53fa:	66 e0       	ldi	r22, 0x06	; 6
    53fc:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <Dio_udtreadChannel>
    5400:	81 30       	cpi	r24, 0x01	; 1
    5402:	91 f0       	breq	.+36     	; 0x5428 <KEYPAD_udtIsPressed+0x3a>
    5404:	83 e0       	ldi	r24, 0x03	; 3
    5406:	63 e0       	ldi	r22, 0x03	; 3
    5408:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <Dio_udtreadChannel>
    540c:	81 30       	cpi	r24, 0x01	; 1
    540e:	61 f0       	breq	.+24     	; 0x5428 <KEYPAD_udtIsPressed+0x3a>
    5410:	82 e0       	ldi	r24, 0x02	; 2
    5412:	62 e0       	ldi	r22, 0x02	; 2
    5414:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <Dio_udtreadChannel>
    5418:	81 30       	cpi	r24, 0x01	; 1
    541a:	31 f0       	breq	.+12     	; 0x5428 <KEYPAD_udtIsPressed+0x3a>
    541c:	82 e0       	ldi	r24, 0x02	; 2
    541e:	63 e0       	ldi	r22, 0x03	; 3
    5420:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <Dio_udtreadChannel>
    5424:	81 30       	cpi	r24, 0x01	; 1
    5426:	19 f4       	brne	.+6      	; 0x542e <KEYPAD_udtIsPressed+0x40>
			(Dio_udtreadChannel(DIO_PORTC,DIO_PIN2) == DIO_HIGH) ||
			(Dio_udtreadChannel(DIO_PORTC,DIO_PIN3) == DIO_HIGH)
		)

	{
		return TRUE;
    5428:	81 e0       	ldi	r24, 0x01	; 1
    542a:	89 83       	std	Y+1, r24	; 0x01
    542c:	01 c0       	rjmp	.+2      	; 0x5430 <KEYPAD_udtIsPressed+0x42>
	}
	else
	{
		return FALSE;
    542e:	19 82       	std	Y+1, r1	; 0x01
    5430:	89 81       	ldd	r24, Y+1	; 0x01
	}
}
    5432:	0f 90       	pop	r0
    5434:	cf 91       	pop	r28
    5436:	df 91       	pop	r29
    5438:	08 95       	ret

0000543a <KEYPAD_u8GetKeyPressed>:

u8 KEYPAD_u8GetKeyPressed(void)
{
    543a:	df 93       	push	r29
    543c:	cf 93       	push	r28
    543e:	00 d0       	rcall	.+0      	; 0x5440 <KEYPAD_u8GetKeyPressed+0x6>
    5440:	0f 92       	push	r0
    5442:	cd b7       	in	r28, 0x3d	; 61
    5444:	de b7       	in	r29, 0x3e	; 62
	kp_row_t loc_row = KP_NOROW;
    5446:	84 e0       	ldi	r24, 0x04	; 4
    5448:	8b 83       	std	Y+3, r24	; 0x03
	kp_col_t loc_column = KP_NOCOLUMN;
    544a:	84 e0       	ldi	r24, 0x04	; 4
    544c:	8a 83       	std	Y+2, r24	; 0x02
	u8 loc_button = 0xFF;
    544e:	8f ef       	ldi	r24, 0xFF	; 255
    5450:	89 83       	std	Y+1, r24	; 0x01

	KEYPAD_vidInit();
    5452:	0e 94 05 29 	call	0x520a	; 0x520a <KEYPAD_vidInit>

	if (KEYPAD_udtIsPressed() == TRUE)
    5456:	0e 94 f7 29 	call	0x53ee	; 0x53ee <KEYPAD_udtIsPressed>
    545a:	81 30       	cpi	r24, 0x01	; 1
    545c:	c9 f4       	brne	.+50     	; 0x5490 <KEYPAD_u8GetKeyPressed+0x56>
	{
		loc_row = KEYPAD_udtGetRow();
    545e:	0e 94 48 29 	call	0x5290	; 0x5290 <KEYPAD_udtGetRow>
    5462:	8b 83       	std	Y+3, r24	; 0x03
		loc_column = KEYPAD_udtGetColumn(loc_row);
    5464:	8b 81       	ldd	r24, Y+3	; 0x03
    5466:	0e 94 76 29 	call	0x52ec	; 0x52ec <KEYPAD_udtGetColumn>
    546a:	8a 83       	std	Y+2, r24	; 0x02
		loc_button = Keypad_Layout[loc_row][loc_column];
    546c:	8b 81       	ldd	r24, Y+3	; 0x03
    546e:	48 2f       	mov	r20, r24
    5470:	50 e0       	ldi	r21, 0x00	; 0
    5472:	8a 81       	ldd	r24, Y+2	; 0x02
    5474:	28 2f       	mov	r18, r24
    5476:	30 e0       	ldi	r19, 0x00	; 0
    5478:	ca 01       	movw	r24, r20
    547a:	88 0f       	add	r24, r24
    547c:	99 1f       	adc	r25, r25
    547e:	88 0f       	add	r24, r24
    5480:	99 1f       	adc	r25, r25
    5482:	82 0f       	add	r24, r18
    5484:	93 1f       	adc	r25, r19
    5486:	fc 01       	movw	r30, r24
    5488:	ed 55       	subi	r30, 0x5D	; 93
    548a:	fe 4f       	sbci	r31, 0xFE	; 254
    548c:	80 81       	ld	r24, Z
    548e:	89 83       	std	Y+1, r24	; 0x01
	}
	return loc_button;
    5490:	89 81       	ldd	r24, Y+1	; 0x01
}
    5492:	0f 90       	pop	r0
    5494:	0f 90       	pop	r0
    5496:	0f 90       	pop	r0
    5498:	cf 91       	pop	r28
    549a:	df 91       	pop	r29
    549c:	08 95       	ret

0000549e <BUZZER_vidbuzzerInit>:
 */

#include "BUZZER.h"

void BUZZER_vidbuzzerInit(void)
{
    549e:	df 93       	push	r29
    54a0:	cf 93       	push	r28
    54a2:	cd b7       	in	r28, 0x3d	; 61
    54a4:	de b7       	in	r29, 0x3e	; 62
	Dio_vidconfigChannel(DIO_PORTA,DIO_PIN3,DIO_OUTPUT);
    54a6:	80 e0       	ldi	r24, 0x00	; 0
    54a8:	63 e0       	ldi	r22, 0x03	; 3
    54aa:	41 e0       	ldi	r20, 0x01	; 1
    54ac:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>
}
    54b0:	cf 91       	pop	r28
    54b2:	df 91       	pop	r29
    54b4:	08 95       	ret

000054b6 <BUZZER_vidbuzzerOn>:

void BUZZER_vidbuzzerOn(void)
{
    54b6:	df 93       	push	r29
    54b8:	cf 93       	push	r28
    54ba:	cd b7       	in	r28, 0x3d	; 61
    54bc:	de b7       	in	r29, 0x3e	; 62
	Dio_vidwriteChannel(DIO_PORTA,DIO_PIN3,DIO_HIGH);
    54be:	80 e0       	ldi	r24, 0x00	; 0
    54c0:	63 e0       	ldi	r22, 0x03	; 3
    54c2:	41 e0       	ldi	r20, 0x01	; 1
    54c4:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
}
    54c8:	cf 91       	pop	r28
    54ca:	df 91       	pop	r29
    54cc:	08 95       	ret

000054ce <BUZZER_vidbuzzerOff>:

void BUZZER_vidbuzzerOff(void)
{
    54ce:	df 93       	push	r29
    54d0:	cf 93       	push	r28
    54d2:	cd b7       	in	r28, 0x3d	; 61
    54d4:	de b7       	in	r29, 0x3e	; 62
	Dio_vidwriteChannel(DIO_PORTA,DIO_PIN3,DIO_LOW);
    54d6:	80 e0       	ldi	r24, 0x00	; 0
    54d8:	63 e0       	ldi	r22, 0x03	; 3
    54da:	40 e0       	ldi	r20, 0x00	; 0
    54dc:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
}
    54e0:	cf 91       	pop	r28
    54e2:	df 91       	pop	r29
    54e4:	08 95       	ret

000054e6 <BUZZER_vidbuzzerToggle>:

void BUZZER_vidbuzzerToggle(void)
{
    54e6:	df 93       	push	r29
    54e8:	cf 93       	push	r28
    54ea:	cd b7       	in	r28, 0x3d	; 61
    54ec:	de b7       	in	r29, 0x3e	; 62
	Dio_vidflipChannel(DIO_PORTA,DIO_PIN3);
    54ee:	80 e0       	ldi	r24, 0x00	; 0
    54f0:	63 e0       	ldi	r22, 0x03	; 3
    54f2:	0e 94 41 30 	call	0x6082	; 0x6082 <Dio_vidflipChannel>
}
    54f6:	cf 91       	pop	r28
    54f8:	df 91       	pop	r29
    54fa:	08 95       	ret

000054fc <BUTTON_vidbuttonInit>:
 *      Author: Khaled
 */
#include "BUTTON.h"

void BUTTON_vidbuttonInit(void)
{
    54fc:	df 93       	push	r29
    54fe:	cf 93       	push	r28
    5500:	cd b7       	in	r28, 0x3d	; 61
    5502:	de b7       	in	r29, 0x3e	; 62
	Dio_vidconfigChannel(DIO_PORTB,DIO_PIN0,DIO_INPUT);
    5504:	81 e0       	ldi	r24, 0x01	; 1
    5506:	60 e0       	ldi	r22, 0x00	; 0
    5508:	40 e0       	ldi	r20, 0x00	; 0
    550a:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTD,DIO_PIN6,DIO_INPUT);
    550e:	83 e0       	ldi	r24, 0x03	; 3
    5510:	66 e0       	ldi	r22, 0x06	; 6
    5512:	40 e0       	ldi	r20, 0x00	; 0
    5514:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>
	Dio_vidconfigChannel(DIO_PORTD,DIO_PIN2,DIO_INPUT);
    5518:	83 e0       	ldi	r24, 0x03	; 3
    551a:	62 e0       	ldi	r22, 0x02	; 2
    551c:	40 e0       	ldi	r20, 0x00	; 0
    551e:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>
}
    5522:	cf 91       	pop	r28
    5524:	df 91       	pop	r29
    5526:	08 95       	ret

00005528 <BUTTON_udtbuttonStatus>:

button_butStatus_t BUTTON_udtbuttonStatus(button_buttonId_t button)
{
    5528:	df 93       	push	r29
    552a:	cf 93       	push	r28
    552c:	00 d0       	rcall	.+0      	; 0x552e <BUTTON_udtbuttonStatus+0x6>
    552e:	00 d0       	rcall	.+0      	; 0x5530 <BUTTON_udtbuttonStatus+0x8>
    5530:	cd b7       	in	r28, 0x3d	; 61
    5532:	de b7       	in	r29, 0x3e	; 62
    5534:	89 83       	std	Y+1, r24	; 0x01
	switch(button)
    5536:	89 81       	ldd	r24, Y+1	; 0x01
    5538:	28 2f       	mov	r18, r24
    553a:	30 e0       	ldi	r19, 0x00	; 0
    553c:	3c 83       	std	Y+4, r19	; 0x04
    553e:	2b 83       	std	Y+3, r18	; 0x03
    5540:	8b 81       	ldd	r24, Y+3	; 0x03
    5542:	9c 81       	ldd	r25, Y+4	; 0x04
    5544:	81 30       	cpi	r24, 0x01	; 1
    5546:	91 05       	cpc	r25, r1
    5548:	a1 f0       	breq	.+40     	; 0x5572 <BUTTON_udtbuttonStatus+0x4a>
    554a:	2b 81       	ldd	r18, Y+3	; 0x03
    554c:	3c 81       	ldd	r19, Y+4	; 0x04
    554e:	22 30       	cpi	r18, 0x02	; 2
    5550:	31 05       	cpc	r19, r1
    5552:	d1 f0       	breq	.+52     	; 0x5588 <BUTTON_udtbuttonStatus+0x60>
    5554:	8b 81       	ldd	r24, Y+3	; 0x03
    5556:	9c 81       	ldd	r25, Y+4	; 0x04
    5558:	00 97       	sbiw	r24, 0x00	; 0
    555a:	09 f5       	brne	.+66     	; 0x559e <BUTTON_udtbuttonStatus+0x76>
	{
	case BUTTON0:
	{
		if (Dio_udtreadChannel(DIO_PORTB,DIO_PIN0) == 1)
    555c:	81 e0       	ldi	r24, 0x01	; 1
    555e:	60 e0       	ldi	r22, 0x00	; 0
    5560:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <Dio_udtreadChannel>
    5564:	81 30       	cpi	r24, 0x01	; 1
    5566:	19 f4       	brne	.+6      	; 0x556e <BUTTON_udtbuttonStatus+0x46>
		{
			return PRESSED;
    5568:	91 e0       	ldi	r25, 0x01	; 1
    556a:	9a 83       	std	Y+2, r25	; 0x02
    556c:	19 c0       	rjmp	.+50     	; 0x55a0 <BUTTON_udtbuttonStatus+0x78>
		}
		else
		{
			return RELEASED;
    556e:	1a 82       	std	Y+2, r1	; 0x02
    5570:	17 c0       	rjmp	.+46     	; 0x55a0 <BUTTON_udtbuttonStatus+0x78>
		}
	}
	case BUTTON1:
	{
		if (Dio_udtreadChannel(DIO_PORTD,DIO_PIN6) == 1)
    5572:	83 e0       	ldi	r24, 0x03	; 3
    5574:	66 e0       	ldi	r22, 0x06	; 6
    5576:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <Dio_udtreadChannel>
    557a:	81 30       	cpi	r24, 0x01	; 1
    557c:	19 f4       	brne	.+6      	; 0x5584 <BUTTON_udtbuttonStatus+0x5c>
		{
			return PRESSED;
    557e:	21 e0       	ldi	r18, 0x01	; 1
    5580:	2a 83       	std	Y+2, r18	; 0x02
    5582:	0e c0       	rjmp	.+28     	; 0x55a0 <BUTTON_udtbuttonStatus+0x78>
		}
		else
		{
			return RELEASED;
    5584:	1a 82       	std	Y+2, r1	; 0x02
    5586:	0c c0       	rjmp	.+24     	; 0x55a0 <BUTTON_udtbuttonStatus+0x78>
		}
	}
	case BUTTON2:
	{
		if (Dio_udtreadChannel(DIO_PORTD,DIO_PIN2)== 1)
    5588:	83 e0       	ldi	r24, 0x03	; 3
    558a:	62 e0       	ldi	r22, 0x02	; 2
    558c:	0e 94 ad 2f 	call	0x5f5a	; 0x5f5a <Dio_udtreadChannel>
    5590:	81 30       	cpi	r24, 0x01	; 1
    5592:	19 f4       	brne	.+6      	; 0x559a <BUTTON_udtbuttonStatus+0x72>
		{
			return PRESSED;
    5594:	31 e0       	ldi	r19, 0x01	; 1
    5596:	3a 83       	std	Y+2, r19	; 0x02
    5598:	03 c0       	rjmp	.+6      	; 0x55a0 <BUTTON_udtbuttonStatus+0x78>
		}
		else
		{
			return RELEASED;
    559a:	1a 82       	std	Y+2, r1	; 0x02
    559c:	01 c0       	rjmp	.+2      	; 0x55a0 <BUTTON_udtbuttonStatus+0x78>
		}
	}
	}
	return RELEASED;
    559e:	1a 82       	std	Y+2, r1	; 0x02
    55a0:	8a 81       	ldd	r24, Y+2	; 0x02
}
    55a2:	0f 90       	pop	r0
    55a4:	0f 90       	pop	r0
    55a6:	0f 90       	pop	r0
    55a8:	0f 90       	pop	r0
    55aa:	cf 91       	pop	r28
    55ac:	df 91       	pop	r29
    55ae:	08 95       	ret

000055b0 <USART_Init>:
 *      Author: Khaled
 */
#include "UART.h"

void USART_Init(u32 baud)
{
    55b0:	df 93       	push	r29
    55b2:	cf 93       	push	r28
    55b4:	cd b7       	in	r28, 0x3d	; 61
    55b6:	de b7       	in	r29, 0x3e	; 62
    55b8:	28 97       	sbiw	r28, 0x08	; 8
    55ba:	0f b6       	in	r0, 0x3f	; 63
    55bc:	f8 94       	cli
    55be:	de bf       	out	0x3e, r29	; 62
    55c0:	0f be       	out	0x3f, r0	; 63
    55c2:	cd bf       	out	0x3d, r28	; 61
    55c4:	6d 83       	std	Y+5, r22	; 0x05
    55c6:	7e 83       	std	Y+6, r23	; 0x06
    55c8:	8f 83       	std	Y+7, r24	; 0x07
    55ca:	98 87       	std	Y+8, r25	; 0x08
	u32 loc_UBBR_val = ((F_OSC/(16*baud))-1);
    55cc:	8d 81       	ldd	r24, Y+5	; 0x05
    55ce:	9e 81       	ldd	r25, Y+6	; 0x06
    55d0:	af 81       	ldd	r26, Y+7	; 0x07
    55d2:	b8 85       	ldd	r27, Y+8	; 0x08
    55d4:	88 0f       	add	r24, r24
    55d6:	99 1f       	adc	r25, r25
    55d8:	aa 1f       	adc	r26, r26
    55da:	bb 1f       	adc	r27, r27
    55dc:	88 0f       	add	r24, r24
    55de:	99 1f       	adc	r25, r25
    55e0:	aa 1f       	adc	r26, r26
    55e2:	bb 1f       	adc	r27, r27
    55e4:	88 0f       	add	r24, r24
    55e6:	99 1f       	adc	r25, r25
    55e8:	aa 1f       	adc	r26, r26
    55ea:	bb 1f       	adc	r27, r27
    55ec:	88 0f       	add	r24, r24
    55ee:	99 1f       	adc	r25, r25
    55f0:	aa 1f       	adc	r26, r26
    55f2:	bb 1f       	adc	r27, r27
    55f4:	9c 01       	movw	r18, r24
    55f6:	ad 01       	movw	r20, r26
    55f8:	80 e0       	ldi	r24, 0x00	; 0
    55fa:	94 e2       	ldi	r25, 0x24	; 36
    55fc:	a4 ef       	ldi	r26, 0xF4	; 244
    55fe:	b0 e0       	ldi	r27, 0x00	; 0
    5600:	bc 01       	movw	r22, r24
    5602:	cd 01       	movw	r24, r26
    5604:	0e 94 ad 31 	call	0x635a	; 0x635a <__udivmodsi4>
    5608:	da 01       	movw	r26, r20
    560a:	c9 01       	movw	r24, r18
    560c:	01 97       	sbiw	r24, 0x01	; 1
    560e:	a1 09       	sbc	r26, r1
    5610:	b1 09       	sbc	r27, r1
    5612:	89 83       	std	Y+1, r24	; 0x01
    5614:	9a 83       	std	Y+2, r25	; 0x02
    5616:	ab 83       	std	Y+3, r26	; 0x03
    5618:	bc 83       	std	Y+4, r27	; 0x04
	/* Set baud rate */
	UART_UBRRH_REG = loc_UBBR_val>>8;
    561a:	e0 e4       	ldi	r30, 0x40	; 64
    561c:	f0 e0       	ldi	r31, 0x00	; 0
    561e:	89 81       	ldd	r24, Y+1	; 0x01
    5620:	9a 81       	ldd	r25, Y+2	; 0x02
    5622:	ab 81       	ldd	r26, Y+3	; 0x03
    5624:	bc 81       	ldd	r27, Y+4	; 0x04
    5626:	89 2f       	mov	r24, r25
    5628:	9a 2f       	mov	r25, r26
    562a:	ab 2f       	mov	r26, r27
    562c:	bb 27       	eor	r27, r27
    562e:	80 83       	st	Z, r24
	UART_UBRRL_REG = loc_UBBR_val;
    5630:	e9 e2       	ldi	r30, 0x29	; 41
    5632:	f0 e0       	ldi	r31, 0x00	; 0
    5634:	89 81       	ldd	r24, Y+1	; 0x01
    5636:	80 83       	st	Z, r24
	/* Enable receiver and transmitter */
	UART_UCSRB_REG = (1<<UART_RXEN_BIT)|(1<<UART_TXEN_BIT);
    5638:	ea e2       	ldi	r30, 0x2A	; 42
    563a:	f0 e0       	ldi	r31, 0x00	; 0
    563c:	88 e1       	ldi	r24, 0x18	; 24
    563e:	80 83       	st	Z, r24
	/* Set frame format: 8data, 2stop bit */
	UART_UCSRC_REG = (1<<UART_URSEL_BIT)|(1<<UART_USBS_BIT)|(3<<UART_UCSZ0_BIT);
    5640:	e0 e4       	ldi	r30, 0x40	; 64
    5642:	f0 e0       	ldi	r31, 0x00	; 0
    5644:	8e e8       	ldi	r24, 0x8E	; 142
    5646:	80 83       	st	Z, r24
}
    5648:	28 96       	adiw	r28, 0x08	; 8
    564a:	0f b6       	in	r0, 0x3f	; 63
    564c:	f8 94       	cli
    564e:	de bf       	out	0x3e, r29	; 62
    5650:	0f be       	out	0x3f, r0	; 63
    5652:	cd bf       	out	0x3d, r28	; 61
    5654:	cf 91       	pop	r28
    5656:	df 91       	pop	r29
    5658:	08 95       	ret

0000565a <USART_TransmitChr>:
void USART_TransmitChr(u8 data)
{
    565a:	df 93       	push	r29
    565c:	cf 93       	push	r28
    565e:	0f 92       	push	r0
    5660:	cd b7       	in	r28, 0x3d	; 61
    5662:	de b7       	in	r29, 0x3e	; 62
    5664:	89 83       	std	Y+1, r24	; 0x01
	while(CHECK_BIT(UART_UCSRA_REG,UART_UDRE_BIT) == 0)
    5666:	eb e2       	ldi	r30, 0x2B	; 43
    5668:	f0 e0       	ldi	r31, 0x00	; 0
    566a:	80 81       	ld	r24, Z
    566c:	82 95       	swap	r24
    566e:	86 95       	lsr	r24
    5670:	87 70       	andi	r24, 0x07	; 7
    5672:	88 2f       	mov	r24, r24
    5674:	90 e0       	ldi	r25, 0x00	; 0
    5676:	81 70       	andi	r24, 0x01	; 1
    5678:	90 70       	andi	r25, 0x00	; 0
    567a:	00 97       	sbiw	r24, 0x00	; 0
    567c:	a1 f3       	breq	.-24     	; 0x5666 <USART_TransmitChr+0xc>
	{
		;
	}
	UART_UDR_REG = data;
    567e:	ec e2       	ldi	r30, 0x2C	; 44
    5680:	f0 e0       	ldi	r31, 0x00	; 0
    5682:	89 81       	ldd	r24, Y+1	; 0x01
    5684:	80 83       	st	Z, r24
}
    5686:	0f 90       	pop	r0
    5688:	cf 91       	pop	r28
    568a:	df 91       	pop	r29
    568c:	08 95       	ret

0000568e <USART_TransmitStr>:
void USART_TransmitStr(u8 *str)
{
    568e:	df 93       	push	r29
    5690:	cf 93       	push	r28
    5692:	00 d0       	rcall	.+0      	; 0x5694 <USART_TransmitStr+0x6>
    5694:	cd b7       	in	r28, 0x3d	; 61
    5696:	de b7       	in	r29, 0x3e	; 62
    5698:	9a 83       	std	Y+2, r25	; 0x02
    569a:	89 83       	std	Y+1, r24	; 0x01
    569c:	0a c0       	rjmp	.+20     	; 0x56b2 <USART_TransmitStr+0x24>
	while (*str != '\0')
	{
		USART_TransmitChr(*str);
    569e:	e9 81       	ldd	r30, Y+1	; 0x01
    56a0:	fa 81       	ldd	r31, Y+2	; 0x02
    56a2:	80 81       	ld	r24, Z
    56a4:	0e 94 2d 2b 	call	0x565a	; 0x565a <USART_TransmitChr>
		str++;
    56a8:	89 81       	ldd	r24, Y+1	; 0x01
    56aa:	9a 81       	ldd	r25, Y+2	; 0x02
    56ac:	01 96       	adiw	r24, 0x01	; 1
    56ae:	9a 83       	std	Y+2, r25	; 0x02
    56b0:	89 83       	std	Y+1, r24	; 0x01
	}
	UART_UDR_REG = data;
}
void USART_TransmitStr(u8 *str)
{
	while (*str != '\0')
    56b2:	e9 81       	ldd	r30, Y+1	; 0x01
    56b4:	fa 81       	ldd	r31, Y+2	; 0x02
    56b6:	80 81       	ld	r24, Z
    56b8:	88 23       	and	r24, r24
    56ba:	89 f7       	brne	.-30     	; 0x569e <USART_TransmitStr+0x10>
	{
		USART_TransmitChr(*str);
		str++;
	}
}
    56bc:	0f 90       	pop	r0
    56be:	0f 90       	pop	r0
    56c0:	cf 91       	pop	r28
    56c2:	df 91       	pop	r29
    56c4:	08 95       	ret

000056c6 <USART_Recieve_Block>:
u8 USART_Recieve_Block(void)
{
    56c6:	df 93       	push	r29
    56c8:	cf 93       	push	r28
    56ca:	cd b7       	in	r28, 0x3d	; 61
    56cc:	de b7       	in	r29, 0x3e	; 62
	while (CHECK_BIT(UART_UCSRA_REG,UART_RXC_BIT) == 0)
    56ce:	eb e2       	ldi	r30, 0x2B	; 43
    56d0:	f0 e0       	ldi	r31, 0x00	; 0
    56d2:	80 81       	ld	r24, Z
    56d4:	88 23       	and	r24, r24
    56d6:	dc f7       	brge	.-10     	; 0x56ce <USART_Recieve_Block+0x8>
	{
		;
	}
	return UART_UDR_REG;
    56d8:	ec e2       	ldi	r30, 0x2C	; 44
    56da:	f0 e0       	ldi	r31, 0x00	; 0
    56dc:	80 81       	ld	r24, Z
}
    56de:	cf 91       	pop	r28
    56e0:	df 91       	pop	r29
    56e2:	08 95       	ret

000056e4 <USART_Recieve_NonBlock>:
u8 USART_Recieve_NonBlock(void)
{
    56e4:	df 93       	push	r29
    56e6:	cf 93       	push	r28
    56e8:	0f 92       	push	r0
    56ea:	cd b7       	in	r28, 0x3d	; 61
    56ec:	de b7       	in	r29, 0x3e	; 62
	if (CHECK_BIT(UART_UCSRA_REG,UART_RXC_BIT) == 1)
    56ee:	eb e2       	ldi	r30, 0x2B	; 43
    56f0:	f0 e0       	ldi	r31, 0x00	; 0
    56f2:	80 81       	ld	r24, Z
    56f4:	88 1f       	adc	r24, r24
    56f6:	88 27       	eor	r24, r24
    56f8:	88 1f       	adc	r24, r24
    56fa:	81 30       	cpi	r24, 0x01	; 1
    56fc:	29 f4       	brne	.+10     	; 0x5708 <USART_Recieve_NonBlock+0x24>
	{
		return UART_UDR_REG;
    56fe:	ec e2       	ldi	r30, 0x2C	; 44
    5700:	f0 e0       	ldi	r31, 0x00	; 0
    5702:	80 81       	ld	r24, Z
    5704:	89 83       	std	Y+1, r24	; 0x01
    5706:	01 c0       	rjmp	.+2      	; 0x570a <USART_Recieve_NonBlock+0x26>
	}
	else
	{
		return 0;
    5708:	19 82       	std	Y+1, r1	; 0x01
    570a:	89 81       	ldd	r24, Y+1	; 0x01
	}
}
    570c:	0f 90       	pop	r0
    570e:	cf 91       	pop	r28
    5710:	df 91       	pop	r29
    5712:	08 95       	ret

00005714 <USART_RecieveInterruptEnable>:
void USART_RecieveInterruptEnable(void)
{
    5714:	df 93       	push	r29
    5716:	cf 93       	push	r28
    5718:	cd b7       	in	r28, 0x3d	; 61
    571a:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(UART_UCSRB_REG,UART_RXC_INT_BIT);
    571c:	aa e2       	ldi	r26, 0x2A	; 42
    571e:	b0 e0       	ldi	r27, 0x00	; 0
    5720:	ea e2       	ldi	r30, 0x2A	; 42
    5722:	f0 e0       	ldi	r31, 0x00	; 0
    5724:	80 81       	ld	r24, Z
    5726:	80 68       	ori	r24, 0x80	; 128
    5728:	8c 93       	st	X, r24
}
    572a:	cf 91       	pop	r28
    572c:	df 91       	pop	r29
    572e:	08 95       	ret

00005730 <SPI_vidMasterInit>:
 *      Author: Khaled
 */
#include "SPI.h"

void SPI_vidMasterInit(void)
{
    5730:	df 93       	push	r29
    5732:	cf 93       	push	r28
    5734:	cd b7       	in	r28, 0x3d	; 61
    5736:	de b7       	in	r29, 0x3e	; 62
	/*	configure SPI MOSI Pin as output	*/
	Dio_vidconfigChannel(DIO_PORTB, DIO_PIN5, DIO_OUTPUT);
    5738:	81 e0       	ldi	r24, 0x01	; 1
    573a:	65 e0       	ldi	r22, 0x05	; 5
    573c:	41 e0       	ldi	r20, 0x01	; 1
    573e:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>
	/*	configure SPI SS Pin as output	*/
	Dio_vidconfigChannel(DIO_PORTB, DIO_PIN4, DIO_OUTPUT);
    5742:	81 e0       	ldi	r24, 0x01	; 1
    5744:	64 e0       	ldi	r22, 0x04	; 4
    5746:	41 e0       	ldi	r20, 0x01	; 1
    5748:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>
	/*	configure SPI SCK Pin as output	*/
	Dio_vidconfigChannel(DIO_PORTB, DIO_PIN7, DIO_OUTPUT);
    574c:	81 e0       	ldi	r24, 0x01	; 1
    574e:	67 e0       	ldi	r22, 0x07	; 7
    5750:	41 e0       	ldi	r20, 0x01	; 1
    5752:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>
	/*	configure SPI MISO Pin as input	*/
	Dio_vidconfigChannel(DIO_PORTB, DIO_PIN6, DIO_INPUT);
    5756:	81 e0       	ldi	r24, 0x01	; 1
    5758:	66 e0       	ldi	r22, 0x06	; 6
    575a:	40 e0       	ldi	r20, 0x00	; 0
    575c:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>
	/*	initialize SPI SS pin with HIGH (No slave selected) */
	Dio_vidwriteChannel(DIO_PORTB, DIO_PIN4, DIO_HIGH);
    5760:	81 e0       	ldi	r24, 0x01	; 1
    5762:	64 e0       	ldi	r22, 0x04	; 4
    5764:	41 e0       	ldi	r20, 0x01	; 1
    5766:	0e 94 ca 2e 	call	0x5d94	; 0x5d94 <Dio_vidwriteChannel>
	/*	enable SPI Module	*/
	SET_BIT(SPI_SPCR_REG,SPI_SPE_BIT);
    576a:	ad e2       	ldi	r26, 0x2D	; 45
    576c:	b0 e0       	ldi	r27, 0x00	; 0
    576e:	ed e2       	ldi	r30, 0x2D	; 45
    5770:	f0 e0       	ldi	r31, 0x00	; 0
    5772:	80 81       	ld	r24, Z
    5774:	80 64       	ori	r24, 0x40	; 64
    5776:	8c 93       	st	X, r24
	/*	enable SPI Module in Master mode	*/
	SET_BIT(SPI_SPCR_REG,SPI_MSTR_BIT);
    5778:	ad e2       	ldi	r26, 0x2D	; 45
    577a:	b0 e0       	ldi	r27, 0x00	; 0
    577c:	ed e2       	ldi	r30, 0x2D	; 45
    577e:	f0 e0       	ldi	r31, 0x00	; 0
    5780:	80 81       	ld	r24, Z
    5782:	80 61       	ori	r24, 0x10	; 16
    5784:	8c 93       	st	X, r24
	/*	set SCK frequency by F_CPU/16	*/
	/*	Set SPI Speed	1MHZ*/
	SPI_SPCR_REG |= SPI_SCK_FREQ_FCPU_DIV_16;
    5786:	ad e2       	ldi	r26, 0x2D	; 45
    5788:	b0 e0       	ldi	r27, 0x00	; 0
    578a:	ed e2       	ldi	r30, 0x2D	; 45
    578c:	f0 e0       	ldi	r31, 0x00	; 0
    578e:	80 81       	ld	r24, Z
    5790:	81 60       	ori	r24, 0x01	; 1
    5792:	8c 93       	st	X, r24
}
    5794:	cf 91       	pop	r28
    5796:	df 91       	pop	r29
    5798:	08 95       	ret

0000579a <SPI_vidSlaveInit>:

void SPI_vidSlaveInit(void)
{
    579a:	df 93       	push	r29
    579c:	cf 93       	push	r28
    579e:	cd b7       	in	r28, 0x3d	; 61
    57a0:	de b7       	in	r29, 0x3e	; 62
	/*	configure SPI MOSI Pin as input	*/
	Dio_vidconfigChannel(DIO_PORTB, DIO_PIN5, DIO_INPUT);
    57a2:	81 e0       	ldi	r24, 0x01	; 1
    57a4:	65 e0       	ldi	r22, 0x05	; 5
    57a6:	40 e0       	ldi	r20, 0x00	; 0
    57a8:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>
	/*	configure SPI SS Pin as input	*/
	Dio_vidconfigChannel(DIO_PORTB, DIO_PIN4, DIO_INPUT);
    57ac:	81 e0       	ldi	r24, 0x01	; 1
    57ae:	64 e0       	ldi	r22, 0x04	; 4
    57b0:	40 e0       	ldi	r20, 0x00	; 0
    57b2:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>
	/*	configure SPI SCK Pin as input	*/
	Dio_vidconfigChannel(DIO_PORTB, DIO_PIN7, DIO_INPUT);
    57b6:	81 e0       	ldi	r24, 0x01	; 1
    57b8:	67 e0       	ldi	r22, 0x07	; 7
    57ba:	40 e0       	ldi	r20, 0x00	; 0
    57bc:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>
	/*	configure SPI MISO Pin as output	*/
	Dio_vidconfigChannel(DIO_PORTB, DIO_PIN6, DIO_OUTPUT);
    57c0:	81 e0       	ldi	r24, 0x01	; 1
    57c2:	66 e0       	ldi	r22, 0x06	; 6
    57c4:	41 e0       	ldi	r20, 0x01	; 1
    57c6:	0e 94 e7 2d 	call	0x5bce	; 0x5bce <Dio_vidconfigChannel>
	/*	enable SPI Module	*/
	SET_BIT(SPI_SPCR_REG,SPI_SPE_BIT);
    57ca:	ad e2       	ldi	r26, 0x2D	; 45
    57cc:	b0 e0       	ldi	r27, 0x00	; 0
    57ce:	ed e2       	ldi	r30, 0x2D	; 45
    57d0:	f0 e0       	ldi	r31, 0x00	; 0
    57d2:	80 81       	ld	r24, Z
    57d4:	80 64       	ori	r24, 0x40	; 64
    57d6:	8c 93       	st	X, r24
	/*	enable SPI Module in Slave mode	*/
	CLEAR_BIT(SPI_SPCR_REG,SPI_MSTR_BIT);
    57d8:	ad e2       	ldi	r26, 0x2D	; 45
    57da:	b0 e0       	ldi	r27, 0x00	; 0
    57dc:	ed e2       	ldi	r30, 0x2D	; 45
    57de:	f0 e0       	ldi	r31, 0x00	; 0
    57e0:	80 81       	ld	r24, Z
    57e2:	8f 7e       	andi	r24, 0xEF	; 239
    57e4:	8c 93       	st	X, r24
}
    57e6:	cf 91       	pop	r28
    57e8:	df 91       	pop	r29
    57ea:	08 95       	ret

000057ec <SPI_MasterWrite>:

void SPI_MasterWrite(u8 data)
{
    57ec:	df 93       	push	r29
    57ee:	cf 93       	push	r28
    57f0:	00 d0       	rcall	.+0      	; 0x57f2 <SPI_MasterWrite+0x6>
    57f2:	cd b7       	in	r28, 0x3d	; 61
    57f4:	de b7       	in	r29, 0x3e	; 62
    57f6:	8a 83       	std	Y+2, r24	; 0x02
	u8 loc_flush_byte;
	/*	load SPI data register with a byte to send	*/
	SPI_SPDR_REG = data;
    57f8:	ef e2       	ldi	r30, 0x2F	; 47
    57fa:	f0 e0       	ldi	r31, 0x00	; 0
    57fc:	8a 81       	ldd	r24, Y+2	; 0x02
    57fe:	80 83       	st	Z, r24
	/*	wait until byte sent	*/
	while(CHECK_BIT(SPI_SPSR_REG,SPI_SPIF_BIT) == 0)
    5800:	ee e2       	ldi	r30, 0x2E	; 46
    5802:	f0 e0       	ldi	r31, 0x00	; 0
    5804:	80 81       	ld	r24, Z
    5806:	88 23       	and	r24, r24
    5808:	dc f7       	brge	.-10     	; 0x5800 <SPI_MasterWrite+0x14>
	{
		;
	}
		/*	flush the data register	*/
	loc_flush_byte = SPI_SPDR_REG;
    580a:	ef e2       	ldi	r30, 0x2F	; 47
    580c:	f0 e0       	ldi	r31, 0x00	; 0
    580e:	80 81       	ld	r24, Z
    5810:	89 83       	std	Y+1, r24	; 0x01
}
    5812:	0f 90       	pop	r0
    5814:	0f 90       	pop	r0
    5816:	cf 91       	pop	r28
    5818:	df 91       	pop	r29
    581a:	08 95       	ret

0000581c <SPI_u8MasterRead>:

u8 SPI_u8MasterRead(void)
{
    581c:	df 93       	push	r29
    581e:	cf 93       	push	r28
    5820:	0f 92       	push	r0
    5822:	cd b7       	in	r28, 0x3d	; 61
    5824:	de b7       	in	r29, 0x3e	; 62
	u8 loc_dummy_byte=0xFF;
    5826:	8f ef       	ldi	r24, 0xFF	; 255
    5828:	89 83       	std	Y+1, r24	; 0x01
	/*	load SPI data register with a byte to send	*/
	SPI_SPDR_REG = loc_dummy_byte;
    582a:	ef e2       	ldi	r30, 0x2F	; 47
    582c:	f0 e0       	ldi	r31, 0x00	; 0
    582e:	89 81       	ldd	r24, Y+1	; 0x01
    5830:	80 83       	st	Z, r24
	/*	wait until byte received	*/
	while(CHECK_BIT(SPI_SPSR_REG,SPI_SPIF_BIT) == 0)
    5832:	ee e2       	ldi	r30, 0x2E	; 46
    5834:	f0 e0       	ldi	r31, 0x00	; 0
    5836:	80 81       	ld	r24, Z
    5838:	88 23       	and	r24, r24
    583a:	dc f7       	brge	.-10     	; 0x5832 <SPI_u8MasterRead+0x16>
	{
		;
	}
		/*	read the data register	*/
	return SPI_SPDR_REG;
    583c:	ef e2       	ldi	r30, 0x2F	; 47
    583e:	f0 e0       	ldi	r31, 0x00	; 0
    5840:	80 81       	ld	r24, Z
}
    5842:	0f 90       	pop	r0
    5844:	cf 91       	pop	r28
    5846:	df 91       	pop	r29
    5848:	08 95       	ret

0000584a <SPI_u8MasterTranseve>:

u8 SPI_u8MasterTranseve(u8 data)
{
    584a:	df 93       	push	r29
    584c:	cf 93       	push	r28
    584e:	0f 92       	push	r0
    5850:	cd b7       	in	r28, 0x3d	; 61
    5852:	de b7       	in	r29, 0x3e	; 62
    5854:	89 83       	std	Y+1, r24	; 0x01
	/*	load SPI data register with a byte to send	*/
	SPI_SPDR_REG = data;
    5856:	ef e2       	ldi	r30, 0x2F	; 47
    5858:	f0 e0       	ldi	r31, 0x00	; 0
    585a:	89 81       	ldd	r24, Y+1	; 0x01
    585c:	80 83       	st	Z, r24
	/*	wait until byte sent	*/
	while(CHECK_BIT(SPI_SPSR_REG,SPI_SPIF_BIT) == 0)
    585e:	ee e2       	ldi	r30, 0x2E	; 46
    5860:	f0 e0       	ldi	r31, 0x00	; 0
    5862:	80 81       	ld	r24, Z
    5864:	88 23       	and	r24, r24
    5866:	dc f7       	brge	.-10     	; 0x585e <SPI_u8MasterTranseve+0x14>
	{
		;
	}
	/*	flush the data register	*/
	return SPI_SPDR_REG;
    5868:	ef e2       	ldi	r30, 0x2F	; 47
    586a:	f0 e0       	ldi	r31, 0x00	; 0
    586c:	80 81       	ld	r24, Z
}
    586e:	0f 90       	pop	r0
    5870:	cf 91       	pop	r28
    5872:	df 91       	pop	r29
    5874:	08 95       	ret

00005876 <SPI_u8SlaveRead>:

u8 SPI_u8SlaveRead(void)
{
    5876:	df 93       	push	r29
    5878:	cf 93       	push	r28
    587a:	cd b7       	in	r28, 0x3d	; 61
    587c:	de b7       	in	r29, 0x3e	; 62
	/*	wait until byte received	*/
	while(CHECK_BIT(SPI_SPSR_REG,SPI_SPIF_BIT) == 0)
    587e:	ee e2       	ldi	r30, 0x2E	; 46
    5880:	f0 e0       	ldi	r31, 0x00	; 0
    5882:	80 81       	ld	r24, Z
    5884:	88 23       	and	r24, r24
    5886:	dc f7       	brge	.-10     	; 0x587e <SPI_u8SlaveRead+0x8>
	{
		;
	}
		/*	read the data register	*/
	return SPI_SPDR_REG;
    5888:	ef e2       	ldi	r30, 0x2F	; 47
    588a:	f0 e0       	ldi	r31, 0x00	; 0
    588c:	80 81       	ld	r24, Z
}
    588e:	cf 91       	pop	r28
    5890:	df 91       	pop	r29
    5892:	08 95       	ret

00005894 <SPI_vidSlaveWrite>:

void SPI_vidSlaveWrite(u8 data)
{
    5894:	df 93       	push	r29
    5896:	cf 93       	push	r28
    5898:	0f 92       	push	r0
    589a:	cd b7       	in	r28, 0x3d	; 61
    589c:	de b7       	in	r29, 0x3e	; 62
    589e:	89 83       	std	Y+1, r24	; 0x01
	SPI_SPDR_REG = data;
    58a0:	ef e2       	ldi	r30, 0x2F	; 47
    58a2:	f0 e0       	ldi	r31, 0x00	; 0
    58a4:	89 81       	ldd	r24, Y+1	; 0x01
    58a6:	80 83       	st	Z, r24
}
    58a8:	0f 90       	pop	r0
    58aa:	cf 91       	pop	r28
    58ac:	df 91       	pop	r29
    58ae:	08 95       	ret

000058b0 <GINT_vidEnableAllInterrupt>:
 */
#include "Gint.h"
#include "Bit_Math.h"

void GINT_vidEnableAllInterrupt(void)
{
    58b0:	df 93       	push	r29
    58b2:	cf 93       	push	r28
    58b4:	cd b7       	in	r28, 0x3d	; 61
    58b6:	de b7       	in	r29, 0x3e	; 62
	SET_BIT(GINT_SREG_REG,7);
    58b8:	af e5       	ldi	r26, 0x5F	; 95
    58ba:	b0 e0       	ldi	r27, 0x00	; 0
    58bc:	ef e5       	ldi	r30, 0x5F	; 95
    58be:	f0 e0       	ldi	r31, 0x00	; 0
    58c0:	80 81       	ld	r24, Z
    58c2:	80 68       	ori	r24, 0x80	; 128
    58c4:	8c 93       	st	X, r24
}
    58c6:	cf 91       	pop	r28
    58c8:	df 91       	pop	r29
    58ca:	08 95       	ret

000058cc <GINT_vidDisableAllInterrupt>:
void GINT_vidDisableAllInterrupt(void)
{
    58cc:	df 93       	push	r29
    58ce:	cf 93       	push	r28
    58d0:	cd b7       	in	r28, 0x3d	; 61
    58d2:	de b7       	in	r29, 0x3e	; 62
	CLEAR_BIT(GINT_SREG_REG,7);
    58d4:	af e5       	ldi	r26, 0x5F	; 95
    58d6:	b0 e0       	ldi	r27, 0x00	; 0
    58d8:	ef e5       	ldi	r30, 0x5F	; 95
    58da:	f0 e0       	ldi	r31, 0x00	; 0
    58dc:	80 81       	ld	r24, Z
    58de:	8f 77       	andi	r24, 0x7F	; 127
    58e0:	8c 93       	st	X, r24
}
    58e2:	cf 91       	pop	r28
    58e4:	df 91       	pop	r29
    58e6:	08 95       	ret

000058e8 <EXTINT_vidEnableExtInterrupt>:
 */
#include "Extint.h"
#include "Bit_Math.h"

void EXTINT_vidEnableExtInterrupt(extint_interrupt_t interrupt,extint_edge_t edge)
{
    58e8:	df 93       	push	r29
    58ea:	cf 93       	push	r28
    58ec:	cd b7       	in	r28, 0x3d	; 61
    58ee:	de b7       	in	r29, 0x3e	; 62
    58f0:	2a 97       	sbiw	r28, 0x0a	; 10
    58f2:	0f b6       	in	r0, 0x3f	; 63
    58f4:	f8 94       	cli
    58f6:	de bf       	out	0x3e, r29	; 62
    58f8:	0f be       	out	0x3f, r0	; 63
    58fa:	cd bf       	out	0x3d, r28	; 61
    58fc:	89 83       	std	Y+1, r24	; 0x01
    58fe:	6a 83       	std	Y+2, r22	; 0x02
	switch (interrupt)
    5900:	89 81       	ldd	r24, Y+1	; 0x01
    5902:	28 2f       	mov	r18, r24
    5904:	30 e0       	ldi	r19, 0x00	; 0
    5906:	3a 87       	std	Y+10, r19	; 0x0a
    5908:	29 87       	std	Y+9, r18	; 0x09
    590a:	89 85       	ldd	r24, Y+9	; 0x09
    590c:	9a 85       	ldd	r25, Y+10	; 0x0a
    590e:	81 30       	cpi	r24, 0x01	; 1
    5910:	91 05       	cpc	r25, r1
    5912:	09 f4       	brne	.+2      	; 0x5916 <EXTINT_vidEnableExtInterrupt+0x2e>
    5914:	6d c0       	rjmp	.+218    	; 0x59f0 <EXTINT_vidEnableExtInterrupt+0x108>
    5916:	29 85       	ldd	r18, Y+9	; 0x09
    5918:	3a 85       	ldd	r19, Y+10	; 0x0a
    591a:	22 30       	cpi	r18, 0x02	; 2
    591c:	31 05       	cpc	r19, r1
    591e:	09 f4       	brne	.+2      	; 0x5922 <EXTINT_vidEnableExtInterrupt+0x3a>
    5920:	c9 c0       	rjmp	.+402    	; 0x5ab4 <EXTINT_vidEnableExtInterrupt+0x1cc>
    5922:	89 85       	ldd	r24, Y+9	; 0x09
    5924:	9a 85       	ldd	r25, Y+10	; 0x0a
    5926:	00 97       	sbiw	r24, 0x00	; 0
    5928:	09 f0       	breq	.+2      	; 0x592c <EXTINT_vidEnableExtInterrupt+0x44>
    592a:	e9 c0       	rjmp	.+466    	; 0x5afe <EXTINT_vidEnableExtInterrupt+0x216>
	{
	case EXT_INT0:
	{
		switch (edge)
    592c:	8a 81       	ldd	r24, Y+2	; 0x02
    592e:	28 2f       	mov	r18, r24
    5930:	30 e0       	ldi	r19, 0x00	; 0
    5932:	38 87       	std	Y+8, r19	; 0x08
    5934:	2f 83       	std	Y+7, r18	; 0x07
    5936:	8f 81       	ldd	r24, Y+7	; 0x07
    5938:	98 85       	ldd	r25, Y+8	; 0x08
    593a:	81 30       	cpi	r24, 0x01	; 1
    593c:	91 05       	cpc	r25, r1
    593e:	21 f1       	breq	.+72     	; 0x5988 <EXTINT_vidEnableExtInterrupt+0xa0>
    5940:	2f 81       	ldd	r18, Y+7	; 0x07
    5942:	38 85       	ldd	r19, Y+8	; 0x08
    5944:	22 30       	cpi	r18, 0x02	; 2
    5946:	31 05       	cpc	r19, r1
    5948:	2c f4       	brge	.+10     	; 0x5954 <EXTINT_vidEnableExtInterrupt+0x6c>
    594a:	8f 81       	ldd	r24, Y+7	; 0x07
    594c:	98 85       	ldd	r25, Y+8	; 0x08
    594e:	00 97       	sbiw	r24, 0x00	; 0
    5950:	61 f0       	breq	.+24     	; 0x596a <EXTINT_vidEnableExtInterrupt+0x82>
    5952:	46 c0       	rjmp	.+140    	; 0x59e0 <EXTINT_vidEnableExtInterrupt+0xf8>
    5954:	2f 81       	ldd	r18, Y+7	; 0x07
    5956:	38 85       	ldd	r19, Y+8	; 0x08
    5958:	22 30       	cpi	r18, 0x02	; 2
    595a:	31 05       	cpc	r19, r1
    595c:	21 f1       	breq	.+72     	; 0x59a6 <EXTINT_vidEnableExtInterrupt+0xbe>
    595e:	8f 81       	ldd	r24, Y+7	; 0x07
    5960:	98 85       	ldd	r25, Y+8	; 0x08
    5962:	83 30       	cpi	r24, 0x03	; 3
    5964:	91 05       	cpc	r25, r1
    5966:	71 f1       	breq	.+92     	; 0x59c4 <EXTINT_vidEnableExtInterrupt+0xdc>
    5968:	3b c0       	rjmp	.+118    	; 0x59e0 <EXTINT_vidEnableExtInterrupt+0xf8>
		{
		case RISING_EDGE:
		{
			SET_BIT(EXTINT_MCUCR_REG,1);
    596a:	a5 e5       	ldi	r26, 0x55	; 85
    596c:	b0 e0       	ldi	r27, 0x00	; 0
    596e:	e5 e5       	ldi	r30, 0x55	; 85
    5970:	f0 e0       	ldi	r31, 0x00	; 0
    5972:	80 81       	ld	r24, Z
    5974:	82 60       	ori	r24, 0x02	; 2
    5976:	8c 93       	st	X, r24
			SET_BIT(EXTINT_MCUCR_REG,0);
    5978:	a5 e5       	ldi	r26, 0x55	; 85
    597a:	b0 e0       	ldi	r27, 0x00	; 0
    597c:	e5 e5       	ldi	r30, 0x55	; 85
    597e:	f0 e0       	ldi	r31, 0x00	; 0
    5980:	80 81       	ld	r24, Z
    5982:	81 60       	ori	r24, 0x01	; 1
    5984:	8c 93       	st	X, r24
    5986:	2c c0       	rjmp	.+88     	; 0x59e0 <EXTINT_vidEnableExtInterrupt+0xf8>
			break;
		}
		case FALLING_EDGE:
		{
			SET_BIT(EXTINT_MCUCR_REG,1);
    5988:	a5 e5       	ldi	r26, 0x55	; 85
    598a:	b0 e0       	ldi	r27, 0x00	; 0
    598c:	e5 e5       	ldi	r30, 0x55	; 85
    598e:	f0 e0       	ldi	r31, 0x00	; 0
    5990:	80 81       	ld	r24, Z
    5992:	82 60       	ori	r24, 0x02	; 2
    5994:	8c 93       	st	X, r24
			CLEAR_BIT(EXTINT_MCUCR_REG,0);
    5996:	a5 e5       	ldi	r26, 0x55	; 85
    5998:	b0 e0       	ldi	r27, 0x00	; 0
    599a:	e5 e5       	ldi	r30, 0x55	; 85
    599c:	f0 e0       	ldi	r31, 0x00	; 0
    599e:	80 81       	ld	r24, Z
    59a0:	8e 7f       	andi	r24, 0xFE	; 254
    59a2:	8c 93       	st	X, r24
    59a4:	1d c0       	rjmp	.+58     	; 0x59e0 <EXTINT_vidEnableExtInterrupt+0xf8>
			break;
		}
		case LOW_VALUE:
		{
			CLEAR_BIT(EXTINT_MCUCR_REG,1);
    59a6:	a5 e5       	ldi	r26, 0x55	; 85
    59a8:	b0 e0       	ldi	r27, 0x00	; 0
    59aa:	e5 e5       	ldi	r30, 0x55	; 85
    59ac:	f0 e0       	ldi	r31, 0x00	; 0
    59ae:	80 81       	ld	r24, Z
    59b0:	8d 7f       	andi	r24, 0xFD	; 253
    59b2:	8c 93       	st	X, r24
			CLEAR_BIT(EXTINT_MCUCR_REG,0);
    59b4:	a5 e5       	ldi	r26, 0x55	; 85
    59b6:	b0 e0       	ldi	r27, 0x00	; 0
    59b8:	e5 e5       	ldi	r30, 0x55	; 85
    59ba:	f0 e0       	ldi	r31, 0x00	; 0
    59bc:	80 81       	ld	r24, Z
    59be:	8e 7f       	andi	r24, 0xFE	; 254
    59c0:	8c 93       	st	X, r24
    59c2:	0e c0       	rjmp	.+28     	; 0x59e0 <EXTINT_vidEnableExtInterrupt+0xf8>
			break;
		}
		case BOTH_EDGES:
		{
			CLEAR_BIT(EXTINT_MCUCR_REG,1);
    59c4:	a5 e5       	ldi	r26, 0x55	; 85
    59c6:	b0 e0       	ldi	r27, 0x00	; 0
    59c8:	e5 e5       	ldi	r30, 0x55	; 85
    59ca:	f0 e0       	ldi	r31, 0x00	; 0
    59cc:	80 81       	ld	r24, Z
    59ce:	8d 7f       	andi	r24, 0xFD	; 253
    59d0:	8c 93       	st	X, r24
			SET_BIT(EXTINT_MCUCR_REG,0);
    59d2:	a5 e5       	ldi	r26, 0x55	; 85
    59d4:	b0 e0       	ldi	r27, 0x00	; 0
    59d6:	e5 e5       	ldi	r30, 0x55	; 85
    59d8:	f0 e0       	ldi	r31, 0x00	; 0
    59da:	80 81       	ld	r24, Z
    59dc:	81 60       	ori	r24, 0x01	; 1
    59de:	8c 93       	st	X, r24
			break;
		}
		}
		SET_BIT(EXTINT_GICR_REG,6);
    59e0:	ab e5       	ldi	r26, 0x5B	; 91
    59e2:	b0 e0       	ldi	r27, 0x00	; 0
    59e4:	eb e5       	ldi	r30, 0x5B	; 91
    59e6:	f0 e0       	ldi	r31, 0x00	; 0
    59e8:	80 81       	ld	r24, Z
    59ea:	80 64       	ori	r24, 0x40	; 64
    59ec:	8c 93       	st	X, r24
    59ee:	87 c0       	rjmp	.+270    	; 0x5afe <EXTINT_vidEnableExtInterrupt+0x216>
		break;
	}
	case EXT_INT1:
	{
		switch (edge)
    59f0:	8a 81       	ldd	r24, Y+2	; 0x02
    59f2:	28 2f       	mov	r18, r24
    59f4:	30 e0       	ldi	r19, 0x00	; 0
    59f6:	3e 83       	std	Y+6, r19	; 0x06
    59f8:	2d 83       	std	Y+5, r18	; 0x05
    59fa:	8d 81       	ldd	r24, Y+5	; 0x05
    59fc:	9e 81       	ldd	r25, Y+6	; 0x06
    59fe:	81 30       	cpi	r24, 0x01	; 1
    5a00:	91 05       	cpc	r25, r1
    5a02:	21 f1       	breq	.+72     	; 0x5a4c <EXTINT_vidEnableExtInterrupt+0x164>
    5a04:	2d 81       	ldd	r18, Y+5	; 0x05
    5a06:	3e 81       	ldd	r19, Y+6	; 0x06
    5a08:	22 30       	cpi	r18, 0x02	; 2
    5a0a:	31 05       	cpc	r19, r1
    5a0c:	2c f4       	brge	.+10     	; 0x5a18 <EXTINT_vidEnableExtInterrupt+0x130>
    5a0e:	8d 81       	ldd	r24, Y+5	; 0x05
    5a10:	9e 81       	ldd	r25, Y+6	; 0x06
    5a12:	00 97       	sbiw	r24, 0x00	; 0
    5a14:	61 f0       	breq	.+24     	; 0x5a2e <EXTINT_vidEnableExtInterrupt+0x146>
    5a16:	46 c0       	rjmp	.+140    	; 0x5aa4 <EXTINT_vidEnableExtInterrupt+0x1bc>
    5a18:	2d 81       	ldd	r18, Y+5	; 0x05
    5a1a:	3e 81       	ldd	r19, Y+6	; 0x06
    5a1c:	22 30       	cpi	r18, 0x02	; 2
    5a1e:	31 05       	cpc	r19, r1
    5a20:	21 f1       	breq	.+72     	; 0x5a6a <EXTINT_vidEnableExtInterrupt+0x182>
    5a22:	8d 81       	ldd	r24, Y+5	; 0x05
    5a24:	9e 81       	ldd	r25, Y+6	; 0x06
    5a26:	83 30       	cpi	r24, 0x03	; 3
    5a28:	91 05       	cpc	r25, r1
    5a2a:	71 f1       	breq	.+92     	; 0x5a88 <EXTINT_vidEnableExtInterrupt+0x1a0>
    5a2c:	3b c0       	rjmp	.+118    	; 0x5aa4 <EXTINT_vidEnableExtInterrupt+0x1bc>
		{
		case RISING_EDGE:
		{
			SET_BIT(EXTINT_MCUCR_REG,1);
    5a2e:	a5 e5       	ldi	r26, 0x55	; 85
    5a30:	b0 e0       	ldi	r27, 0x00	; 0
    5a32:	e5 e5       	ldi	r30, 0x55	; 85
    5a34:	f0 e0       	ldi	r31, 0x00	; 0
    5a36:	80 81       	ld	r24, Z
    5a38:	82 60       	ori	r24, 0x02	; 2
    5a3a:	8c 93       	st	X, r24
			SET_BIT(EXTINT_MCUCR_REG,0);
    5a3c:	a5 e5       	ldi	r26, 0x55	; 85
    5a3e:	b0 e0       	ldi	r27, 0x00	; 0
    5a40:	e5 e5       	ldi	r30, 0x55	; 85
    5a42:	f0 e0       	ldi	r31, 0x00	; 0
    5a44:	80 81       	ld	r24, Z
    5a46:	81 60       	ori	r24, 0x01	; 1
    5a48:	8c 93       	st	X, r24
    5a4a:	2c c0       	rjmp	.+88     	; 0x5aa4 <EXTINT_vidEnableExtInterrupt+0x1bc>
			break;
		}
		case FALLING_EDGE:
		{
			SET_BIT(EXTINT_MCUCR_REG,1);
    5a4c:	a5 e5       	ldi	r26, 0x55	; 85
    5a4e:	b0 e0       	ldi	r27, 0x00	; 0
    5a50:	e5 e5       	ldi	r30, 0x55	; 85
    5a52:	f0 e0       	ldi	r31, 0x00	; 0
    5a54:	80 81       	ld	r24, Z
    5a56:	82 60       	ori	r24, 0x02	; 2
    5a58:	8c 93       	st	X, r24
			CLEAR_BIT(EXTINT_MCUCR_REG,0);
    5a5a:	a5 e5       	ldi	r26, 0x55	; 85
    5a5c:	b0 e0       	ldi	r27, 0x00	; 0
    5a5e:	e5 e5       	ldi	r30, 0x55	; 85
    5a60:	f0 e0       	ldi	r31, 0x00	; 0
    5a62:	80 81       	ld	r24, Z
    5a64:	8e 7f       	andi	r24, 0xFE	; 254
    5a66:	8c 93       	st	X, r24
    5a68:	1d c0       	rjmp	.+58     	; 0x5aa4 <EXTINT_vidEnableExtInterrupt+0x1bc>
			break;
		}
		case LOW_VALUE:
		{
			CLEAR_BIT(EXTINT_MCUCR_REG,0);
    5a6a:	a5 e5       	ldi	r26, 0x55	; 85
    5a6c:	b0 e0       	ldi	r27, 0x00	; 0
    5a6e:	e5 e5       	ldi	r30, 0x55	; 85
    5a70:	f0 e0       	ldi	r31, 0x00	; 0
    5a72:	80 81       	ld	r24, Z
    5a74:	8e 7f       	andi	r24, 0xFE	; 254
    5a76:	8c 93       	st	X, r24
			CLEAR_BIT(EXTINT_MCUCR_REG,1);
    5a78:	a5 e5       	ldi	r26, 0x55	; 85
    5a7a:	b0 e0       	ldi	r27, 0x00	; 0
    5a7c:	e5 e5       	ldi	r30, 0x55	; 85
    5a7e:	f0 e0       	ldi	r31, 0x00	; 0
    5a80:	80 81       	ld	r24, Z
    5a82:	8d 7f       	andi	r24, 0xFD	; 253
    5a84:	8c 93       	st	X, r24
    5a86:	0e c0       	rjmp	.+28     	; 0x5aa4 <EXTINT_vidEnableExtInterrupt+0x1bc>
			break;
		}
		case BOTH_EDGES:
		{
			CLEAR_BIT(EXTINT_MCUCR_REG,1);
    5a88:	a5 e5       	ldi	r26, 0x55	; 85
    5a8a:	b0 e0       	ldi	r27, 0x00	; 0
    5a8c:	e5 e5       	ldi	r30, 0x55	; 85
    5a8e:	f0 e0       	ldi	r31, 0x00	; 0
    5a90:	80 81       	ld	r24, Z
    5a92:	8d 7f       	andi	r24, 0xFD	; 253
    5a94:	8c 93       	st	X, r24
			SET_BIT(EXTINT_MCUCR_REG,0);
    5a96:	a5 e5       	ldi	r26, 0x55	; 85
    5a98:	b0 e0       	ldi	r27, 0x00	; 0
    5a9a:	e5 e5       	ldi	r30, 0x55	; 85
    5a9c:	f0 e0       	ldi	r31, 0x00	; 0
    5a9e:	80 81       	ld	r24, Z
    5aa0:	81 60       	ori	r24, 0x01	; 1
    5aa2:	8c 93       	st	X, r24
			break;
		}
		}
		SET_BIT(EXTINT_GICR_REG,7);
    5aa4:	ab e5       	ldi	r26, 0x5B	; 91
    5aa6:	b0 e0       	ldi	r27, 0x00	; 0
    5aa8:	eb e5       	ldi	r30, 0x5B	; 91
    5aaa:	f0 e0       	ldi	r31, 0x00	; 0
    5aac:	80 81       	ld	r24, Z
    5aae:	80 68       	ori	r24, 0x80	; 128
    5ab0:	8c 93       	st	X, r24
    5ab2:	25 c0       	rjmp	.+74     	; 0x5afe <EXTINT_vidEnableExtInterrupt+0x216>
		break;
	}
	case EXT_INT2:
	{
		switch(edge)
    5ab4:	8a 81       	ldd	r24, Y+2	; 0x02
    5ab6:	28 2f       	mov	r18, r24
    5ab8:	30 e0       	ldi	r19, 0x00	; 0
    5aba:	3c 83       	std	Y+4, r19	; 0x04
    5abc:	2b 83       	std	Y+3, r18	; 0x03
    5abe:	8b 81       	ldd	r24, Y+3	; 0x03
    5ac0:	9c 81       	ldd	r25, Y+4	; 0x04
    5ac2:	00 97       	sbiw	r24, 0x00	; 0
    5ac4:	31 f0       	breq	.+12     	; 0x5ad2 <EXTINT_vidEnableExtInterrupt+0x1ea>
    5ac6:	2b 81       	ldd	r18, Y+3	; 0x03
    5ac8:	3c 81       	ldd	r19, Y+4	; 0x04
    5aca:	21 30       	cpi	r18, 0x01	; 1
    5acc:	31 05       	cpc	r19, r1
    5ace:	49 f0       	breq	.+18     	; 0x5ae2 <EXTINT_vidEnableExtInterrupt+0x1fa>
    5ad0:	0f c0       	rjmp	.+30     	; 0x5af0 <EXTINT_vidEnableExtInterrupt+0x208>
		{
		case RISING_EDGE:
		{
			SET_BIT(EXTINT_MCUCSR_REG,6);
    5ad2:	a4 e5       	ldi	r26, 0x54	; 84
    5ad4:	b0 e0       	ldi	r27, 0x00	; 0
    5ad6:	e4 e5       	ldi	r30, 0x54	; 84
    5ad8:	f0 e0       	ldi	r31, 0x00	; 0
    5ada:	80 81       	ld	r24, Z
    5adc:	80 64       	ori	r24, 0x40	; 64
    5ade:	8c 93       	st	X, r24
    5ae0:	07 c0       	rjmp	.+14     	; 0x5af0 <EXTINT_vidEnableExtInterrupt+0x208>
			break;
		}
		case FALLING_EDGE:
		{
			CLEAR_BIT(EXTINT_MCUCSR_REG,6);
    5ae2:	a4 e5       	ldi	r26, 0x54	; 84
    5ae4:	b0 e0       	ldi	r27, 0x00	; 0
    5ae6:	e4 e5       	ldi	r30, 0x54	; 84
    5ae8:	f0 e0       	ldi	r31, 0x00	; 0
    5aea:	80 81       	ld	r24, Z
    5aec:	8f 7b       	andi	r24, 0xBF	; 191
    5aee:	8c 93       	st	X, r24
		case LOW_VALUE:
		{
			break;
		}
		}
		SET_BIT(EXTINT_GICR_REG,5);
    5af0:	ab e5       	ldi	r26, 0x5B	; 91
    5af2:	b0 e0       	ldi	r27, 0x00	; 0
    5af4:	eb e5       	ldi	r30, 0x5B	; 91
    5af6:	f0 e0       	ldi	r31, 0x00	; 0
    5af8:	80 81       	ld	r24, Z
    5afa:	80 62       	ori	r24, 0x20	; 32
    5afc:	8c 93       	st	X, r24
		break;
	}
	}
}
    5afe:	2a 96       	adiw	r28, 0x0a	; 10
    5b00:	0f b6       	in	r0, 0x3f	; 63
    5b02:	f8 94       	cli
    5b04:	de bf       	out	0x3e, r29	; 62
    5b06:	0f be       	out	0x3f, r0	; 63
    5b08:	cd bf       	out	0x3d, r28	; 61
    5b0a:	cf 91       	pop	r28
    5b0c:	df 91       	pop	r29
    5b0e:	08 95       	ret

00005b10 <EEPROM_vidWrite>:
 *      Author: Khaled
 */
#include "EEPROM.h"

void EEPROM_vidWrite(u16 address, u8 data)
{
    5b10:	df 93       	push	r29
    5b12:	cf 93       	push	r28
    5b14:	00 d0       	rcall	.+0      	; 0x5b16 <EEPROM_vidWrite+0x6>
    5b16:	0f 92       	push	r0
    5b18:	cd b7       	in	r28, 0x3d	; 61
    5b1a:	de b7       	in	r29, 0x3e	; 62
    5b1c:	9a 83       	std	Y+2, r25	; 0x02
    5b1e:	89 83       	std	Y+1, r24	; 0x01
    5b20:	6b 83       	std	Y+3, r22	; 0x03
	/* Wait for completion of previous write */
	while(EEPROM_CR_REG & (1<<EEWE))
    5b22:	ec e3       	ldi	r30, 0x3C	; 60
    5b24:	f0 e0       	ldi	r31, 0x00	; 0
    5b26:	80 81       	ld	r24, Z
    5b28:	88 2f       	mov	r24, r24
    5b2a:	90 e0       	ldi	r25, 0x00	; 0
    5b2c:	82 70       	andi	r24, 0x02	; 2
    5b2e:	90 70       	andi	r25, 0x00	; 0
    5b30:	00 97       	sbiw	r24, 0x00	; 0
    5b32:	b9 f7       	brne	.-18     	; 0x5b22 <EEPROM_vidWrite+0x12>
		/*	Do Nothing	*/		;
	/* Set up address and data registers */
	EEPROM_ARL_REG=address;
    5b34:	ee e3       	ldi	r30, 0x3E	; 62
    5b36:	f0 e0       	ldi	r31, 0x00	; 0
    5b38:	89 81       	ldd	r24, Y+1	; 0x01
    5b3a:	80 83       	st	Z, r24
	EEPROM_ARH_REG = address>>8;
    5b3c:	ef e3       	ldi	r30, 0x3F	; 63
    5b3e:	f0 e0       	ldi	r31, 0x00	; 0
    5b40:	89 81       	ldd	r24, Y+1	; 0x01
    5b42:	9a 81       	ldd	r25, Y+2	; 0x02
    5b44:	89 2f       	mov	r24, r25
    5b46:	99 27       	eor	r25, r25
    5b48:	80 83       	st	Z, r24
	EEPROM_DR_REG = data;
    5b4a:	ed e3       	ldi	r30, 0x3D	; 61
    5b4c:	f0 e0       	ldi	r31, 0x00	; 0
    5b4e:	8b 81       	ldd	r24, Y+3	; 0x03
    5b50:	80 83       	st	Z, r24
	/* Write logical one to EEMWE */
	EEPROM_CR_REG |= (1<<EEMWE);
    5b52:	ac e3       	ldi	r26, 0x3C	; 60
    5b54:	b0 e0       	ldi	r27, 0x00	; 0
    5b56:	ec e3       	ldi	r30, 0x3C	; 60
    5b58:	f0 e0       	ldi	r31, 0x00	; 0
    5b5a:	80 81       	ld	r24, Z
    5b5c:	84 60       	ori	r24, 0x04	; 4
    5b5e:	8c 93       	st	X, r24
	/* Start eeprom write by setting EEWE */
	EEPROM_CR_REG |= (1<<EEWE);
    5b60:	ac e3       	ldi	r26, 0x3C	; 60
    5b62:	b0 e0       	ldi	r27, 0x00	; 0
    5b64:	ec e3       	ldi	r30, 0x3C	; 60
    5b66:	f0 e0       	ldi	r31, 0x00	; 0
    5b68:	80 81       	ld	r24, Z
    5b6a:	82 60       	ori	r24, 0x02	; 2
    5b6c:	8c 93       	st	X, r24
}
    5b6e:	0f 90       	pop	r0
    5b70:	0f 90       	pop	r0
    5b72:	0f 90       	pop	r0
    5b74:	cf 91       	pop	r28
    5b76:	df 91       	pop	r29
    5b78:	08 95       	ret

00005b7a <EEPROM_u8Read>:
u8 EEPROM_u8Read(u16 address)
{
    5b7a:	df 93       	push	r29
    5b7c:	cf 93       	push	r28
    5b7e:	00 d0       	rcall	.+0      	; 0x5b80 <EEPROM_u8Read+0x6>
    5b80:	cd b7       	in	r28, 0x3d	; 61
    5b82:	de b7       	in	r29, 0x3e	; 62
    5b84:	9a 83       	std	Y+2, r25	; 0x02
    5b86:	89 83       	std	Y+1, r24	; 0x01
	/* Wait for completion of previous write */
	while(EEPROM_CR_REG & (1<<EEWE))
    5b88:	ec e3       	ldi	r30, 0x3C	; 60
    5b8a:	f0 e0       	ldi	r31, 0x00	; 0
    5b8c:	80 81       	ld	r24, Z
    5b8e:	88 2f       	mov	r24, r24
    5b90:	90 e0       	ldi	r25, 0x00	; 0
    5b92:	82 70       	andi	r24, 0x02	; 2
    5b94:	90 70       	andi	r25, 0x00	; 0
    5b96:	00 97       	sbiw	r24, 0x00	; 0
    5b98:	b9 f7       	brne	.-18     	; 0x5b88 <EEPROM_u8Read+0xe>
			;
	/* Set up address register */
	EEPROM_ARL_REG	=address;
    5b9a:	ee e3       	ldi	r30, 0x3E	; 62
    5b9c:	f0 e0       	ldi	r31, 0x00	; 0
    5b9e:	89 81       	ldd	r24, Y+1	; 0x01
    5ba0:	80 83       	st	Z, r24
	EEPROM_ARH_REG = address>>8;
    5ba2:	ef e3       	ldi	r30, 0x3F	; 63
    5ba4:	f0 e0       	ldi	r31, 0x00	; 0
    5ba6:	89 81       	ldd	r24, Y+1	; 0x01
    5ba8:	9a 81       	ldd	r25, Y+2	; 0x02
    5baa:	89 2f       	mov	r24, r25
    5bac:	99 27       	eor	r25, r25
    5bae:	80 83       	st	Z, r24
	/* Start eeprom read by writing EERE */
	EEPROM_CR_REG |= (1<<EERE);
    5bb0:	ac e3       	ldi	r26, 0x3C	; 60
    5bb2:	b0 e0       	ldi	r27, 0x00	; 0
    5bb4:	ec e3       	ldi	r30, 0x3C	; 60
    5bb6:	f0 e0       	ldi	r31, 0x00	; 0
    5bb8:	80 81       	ld	r24, Z
    5bba:	81 60       	ori	r24, 0x01	; 1
    5bbc:	8c 93       	st	X, r24
	/* Return data from data register */
	return EEPROM_DR_REG;
    5bbe:	ed e3       	ldi	r30, 0x3D	; 61
    5bc0:	f0 e0       	ldi	r31, 0x00	; 0
    5bc2:	80 81       	ld	r24, Z
}
    5bc4:	0f 90       	pop	r0
    5bc6:	0f 90       	pop	r0
    5bc8:	cf 91       	pop	r28
    5bca:	df 91       	pop	r29
    5bcc:	08 95       	ret

00005bce <Dio_vidconfigChannel>:
 */
#include "Dio.h"
#include "Bit_Math.h"

void Dio_vidconfigChannel(dio_port_t port,dio_pin_t pin,dio_dir_t dir)
{
    5bce:	df 93       	push	r29
    5bd0:	cf 93       	push	r28
    5bd2:	00 d0       	rcall	.+0      	; 0x5bd4 <Dio_vidconfigChannel+0x6>
    5bd4:	00 d0       	rcall	.+0      	; 0x5bd6 <Dio_vidconfigChannel+0x8>
    5bd6:	0f 92       	push	r0
    5bd8:	cd b7       	in	r28, 0x3d	; 61
    5bda:	de b7       	in	r29, 0x3e	; 62
    5bdc:	89 83       	std	Y+1, r24	; 0x01
    5bde:	6a 83       	std	Y+2, r22	; 0x02
    5be0:	4b 83       	std	Y+3, r20	; 0x03
	switch (port)
    5be2:	89 81       	ldd	r24, Y+1	; 0x01
    5be4:	28 2f       	mov	r18, r24
    5be6:	30 e0       	ldi	r19, 0x00	; 0
    5be8:	3d 83       	std	Y+5, r19	; 0x05
    5bea:	2c 83       	std	Y+4, r18	; 0x04
    5bec:	8c 81       	ldd	r24, Y+4	; 0x04
    5bee:	9d 81       	ldd	r25, Y+5	; 0x05
    5bf0:	81 30       	cpi	r24, 0x01	; 1
    5bf2:	91 05       	cpc	r25, r1
    5bf4:	09 f4       	brne	.+2      	; 0x5bf8 <Dio_vidconfigChannel+0x2a>
    5bf6:	43 c0       	rjmp	.+134    	; 0x5c7e <Dio_vidconfigChannel+0xb0>
    5bf8:	2c 81       	ldd	r18, Y+4	; 0x04
    5bfa:	3d 81       	ldd	r19, Y+5	; 0x05
    5bfc:	22 30       	cpi	r18, 0x02	; 2
    5bfe:	31 05       	cpc	r19, r1
    5c00:	2c f4       	brge	.+10     	; 0x5c0c <Dio_vidconfigChannel+0x3e>
    5c02:	8c 81       	ldd	r24, Y+4	; 0x04
    5c04:	9d 81       	ldd	r25, Y+5	; 0x05
    5c06:	00 97       	sbiw	r24, 0x00	; 0
    5c08:	71 f0       	breq	.+28     	; 0x5c26 <Dio_vidconfigChannel+0x58>
    5c0a:	bc c0       	rjmp	.+376    	; 0x5d84 <Dio_vidconfigChannel+0x1b6>
    5c0c:	2c 81       	ldd	r18, Y+4	; 0x04
    5c0e:	3d 81       	ldd	r19, Y+5	; 0x05
    5c10:	22 30       	cpi	r18, 0x02	; 2
    5c12:	31 05       	cpc	r19, r1
    5c14:	09 f4       	brne	.+2      	; 0x5c18 <Dio_vidconfigChannel+0x4a>
    5c16:	5f c0       	rjmp	.+190    	; 0x5cd6 <Dio_vidconfigChannel+0x108>
    5c18:	8c 81       	ldd	r24, Y+4	; 0x04
    5c1a:	9d 81       	ldd	r25, Y+5	; 0x05
    5c1c:	83 30       	cpi	r24, 0x03	; 3
    5c1e:	91 05       	cpc	r25, r1
    5c20:	09 f4       	brne	.+2      	; 0x5c24 <Dio_vidconfigChannel+0x56>
    5c22:	85 c0       	rjmp	.+266    	; 0x5d2e <Dio_vidconfigChannel+0x160>
    5c24:	af c0       	rjmp	.+350    	; 0x5d84 <Dio_vidconfigChannel+0x1b6>
	{
	case DIO_PORTA:
	{
		if(dir == DIO_INPUT)
    5c26:	8b 81       	ldd	r24, Y+3	; 0x03
    5c28:	88 23       	and	r24, r24
    5c2a:	a9 f4       	brne	.+42     	; 0x5c56 <Dio_vidconfigChannel+0x88>
		{
			CLEAR_BIT(DIO_DDRA_REG,pin);
    5c2c:	aa e3       	ldi	r26, 0x3A	; 58
    5c2e:	b0 e0       	ldi	r27, 0x00	; 0
    5c30:	ea e3       	ldi	r30, 0x3A	; 58
    5c32:	f0 e0       	ldi	r31, 0x00	; 0
    5c34:	80 81       	ld	r24, Z
    5c36:	48 2f       	mov	r20, r24
    5c38:	8a 81       	ldd	r24, Y+2	; 0x02
    5c3a:	28 2f       	mov	r18, r24
    5c3c:	30 e0       	ldi	r19, 0x00	; 0
    5c3e:	81 e0       	ldi	r24, 0x01	; 1
    5c40:	90 e0       	ldi	r25, 0x00	; 0
    5c42:	02 2e       	mov	r0, r18
    5c44:	02 c0       	rjmp	.+4      	; 0x5c4a <Dio_vidconfigChannel+0x7c>
    5c46:	88 0f       	add	r24, r24
    5c48:	99 1f       	adc	r25, r25
    5c4a:	0a 94       	dec	r0
    5c4c:	e2 f7       	brpl	.-8      	; 0x5c46 <Dio_vidconfigChannel+0x78>
    5c4e:	80 95       	com	r24
    5c50:	84 23       	and	r24, r20
    5c52:	8c 93       	st	X, r24
    5c54:	97 c0       	rjmp	.+302    	; 0x5d84 <Dio_vidconfigChannel+0x1b6>
		}
		else
		{
			SET_BIT(DIO_DDRA_REG,pin);
    5c56:	aa e3       	ldi	r26, 0x3A	; 58
    5c58:	b0 e0       	ldi	r27, 0x00	; 0
    5c5a:	ea e3       	ldi	r30, 0x3A	; 58
    5c5c:	f0 e0       	ldi	r31, 0x00	; 0
    5c5e:	80 81       	ld	r24, Z
    5c60:	48 2f       	mov	r20, r24
    5c62:	8a 81       	ldd	r24, Y+2	; 0x02
    5c64:	28 2f       	mov	r18, r24
    5c66:	30 e0       	ldi	r19, 0x00	; 0
    5c68:	81 e0       	ldi	r24, 0x01	; 1
    5c6a:	90 e0       	ldi	r25, 0x00	; 0
    5c6c:	02 2e       	mov	r0, r18
    5c6e:	02 c0       	rjmp	.+4      	; 0x5c74 <Dio_vidconfigChannel+0xa6>
    5c70:	88 0f       	add	r24, r24
    5c72:	99 1f       	adc	r25, r25
    5c74:	0a 94       	dec	r0
    5c76:	e2 f7       	brpl	.-8      	; 0x5c70 <Dio_vidconfigChannel+0xa2>
    5c78:	84 2b       	or	r24, r20
    5c7a:	8c 93       	st	X, r24
    5c7c:	83 c0       	rjmp	.+262    	; 0x5d84 <Dio_vidconfigChannel+0x1b6>
		}
		break;
	}
	case DIO_PORTB:
	{
		if(dir == DIO_INPUT)
    5c7e:	8b 81       	ldd	r24, Y+3	; 0x03
    5c80:	88 23       	and	r24, r24
    5c82:	a9 f4       	brne	.+42     	; 0x5cae <Dio_vidconfigChannel+0xe0>
		{
			CLEAR_BIT(DIO_DDRB_REG,pin);
    5c84:	a7 e3       	ldi	r26, 0x37	; 55
    5c86:	b0 e0       	ldi	r27, 0x00	; 0
    5c88:	e7 e3       	ldi	r30, 0x37	; 55
    5c8a:	f0 e0       	ldi	r31, 0x00	; 0
    5c8c:	80 81       	ld	r24, Z
    5c8e:	48 2f       	mov	r20, r24
    5c90:	8a 81       	ldd	r24, Y+2	; 0x02
    5c92:	28 2f       	mov	r18, r24
    5c94:	30 e0       	ldi	r19, 0x00	; 0
    5c96:	81 e0       	ldi	r24, 0x01	; 1
    5c98:	90 e0       	ldi	r25, 0x00	; 0
    5c9a:	02 2e       	mov	r0, r18
    5c9c:	02 c0       	rjmp	.+4      	; 0x5ca2 <Dio_vidconfigChannel+0xd4>
    5c9e:	88 0f       	add	r24, r24
    5ca0:	99 1f       	adc	r25, r25
    5ca2:	0a 94       	dec	r0
    5ca4:	e2 f7       	brpl	.-8      	; 0x5c9e <Dio_vidconfigChannel+0xd0>
    5ca6:	80 95       	com	r24
    5ca8:	84 23       	and	r24, r20
    5caa:	8c 93       	st	X, r24
    5cac:	6b c0       	rjmp	.+214    	; 0x5d84 <Dio_vidconfigChannel+0x1b6>
		}
		else
		{
			SET_BIT(DIO_DDRB_REG,pin);
    5cae:	a7 e3       	ldi	r26, 0x37	; 55
    5cb0:	b0 e0       	ldi	r27, 0x00	; 0
    5cb2:	e7 e3       	ldi	r30, 0x37	; 55
    5cb4:	f0 e0       	ldi	r31, 0x00	; 0
    5cb6:	80 81       	ld	r24, Z
    5cb8:	48 2f       	mov	r20, r24
    5cba:	8a 81       	ldd	r24, Y+2	; 0x02
    5cbc:	28 2f       	mov	r18, r24
    5cbe:	30 e0       	ldi	r19, 0x00	; 0
    5cc0:	81 e0       	ldi	r24, 0x01	; 1
    5cc2:	90 e0       	ldi	r25, 0x00	; 0
    5cc4:	02 2e       	mov	r0, r18
    5cc6:	02 c0       	rjmp	.+4      	; 0x5ccc <Dio_vidconfigChannel+0xfe>
    5cc8:	88 0f       	add	r24, r24
    5cca:	99 1f       	adc	r25, r25
    5ccc:	0a 94       	dec	r0
    5cce:	e2 f7       	brpl	.-8      	; 0x5cc8 <Dio_vidconfigChannel+0xfa>
    5cd0:	84 2b       	or	r24, r20
    5cd2:	8c 93       	st	X, r24
    5cd4:	57 c0       	rjmp	.+174    	; 0x5d84 <Dio_vidconfigChannel+0x1b6>
		}
		break;
	}
	case DIO_PORTC:
	{
		if(dir == DIO_INPUT)
    5cd6:	8b 81       	ldd	r24, Y+3	; 0x03
    5cd8:	88 23       	and	r24, r24
    5cda:	a9 f4       	brne	.+42     	; 0x5d06 <Dio_vidconfigChannel+0x138>
		{
			CLEAR_BIT(DIO_DDRC_REG,pin);
    5cdc:	a4 e3       	ldi	r26, 0x34	; 52
    5cde:	b0 e0       	ldi	r27, 0x00	; 0
    5ce0:	e4 e3       	ldi	r30, 0x34	; 52
    5ce2:	f0 e0       	ldi	r31, 0x00	; 0
    5ce4:	80 81       	ld	r24, Z
    5ce6:	48 2f       	mov	r20, r24
    5ce8:	8a 81       	ldd	r24, Y+2	; 0x02
    5cea:	28 2f       	mov	r18, r24
    5cec:	30 e0       	ldi	r19, 0x00	; 0
    5cee:	81 e0       	ldi	r24, 0x01	; 1
    5cf0:	90 e0       	ldi	r25, 0x00	; 0
    5cf2:	02 2e       	mov	r0, r18
    5cf4:	02 c0       	rjmp	.+4      	; 0x5cfa <Dio_vidconfigChannel+0x12c>
    5cf6:	88 0f       	add	r24, r24
    5cf8:	99 1f       	adc	r25, r25
    5cfa:	0a 94       	dec	r0
    5cfc:	e2 f7       	brpl	.-8      	; 0x5cf6 <Dio_vidconfigChannel+0x128>
    5cfe:	80 95       	com	r24
    5d00:	84 23       	and	r24, r20
    5d02:	8c 93       	st	X, r24
    5d04:	3f c0       	rjmp	.+126    	; 0x5d84 <Dio_vidconfigChannel+0x1b6>
		}
		else
		{
			SET_BIT(DIO_DDRC_REG,pin);
    5d06:	a4 e3       	ldi	r26, 0x34	; 52
    5d08:	b0 e0       	ldi	r27, 0x00	; 0
    5d0a:	e4 e3       	ldi	r30, 0x34	; 52
    5d0c:	f0 e0       	ldi	r31, 0x00	; 0
    5d0e:	80 81       	ld	r24, Z
    5d10:	48 2f       	mov	r20, r24
    5d12:	8a 81       	ldd	r24, Y+2	; 0x02
    5d14:	28 2f       	mov	r18, r24
    5d16:	30 e0       	ldi	r19, 0x00	; 0
    5d18:	81 e0       	ldi	r24, 0x01	; 1
    5d1a:	90 e0       	ldi	r25, 0x00	; 0
    5d1c:	02 2e       	mov	r0, r18
    5d1e:	02 c0       	rjmp	.+4      	; 0x5d24 <Dio_vidconfigChannel+0x156>
    5d20:	88 0f       	add	r24, r24
    5d22:	99 1f       	adc	r25, r25
    5d24:	0a 94       	dec	r0
    5d26:	e2 f7       	brpl	.-8      	; 0x5d20 <Dio_vidconfigChannel+0x152>
    5d28:	84 2b       	or	r24, r20
    5d2a:	8c 93       	st	X, r24
    5d2c:	2b c0       	rjmp	.+86     	; 0x5d84 <Dio_vidconfigChannel+0x1b6>
		}
		break;
	}
	case DIO_PORTD:
	{
		if(dir == DIO_INPUT)
    5d2e:	8b 81       	ldd	r24, Y+3	; 0x03
    5d30:	88 23       	and	r24, r24
    5d32:	a9 f4       	brne	.+42     	; 0x5d5e <Dio_vidconfigChannel+0x190>
		{
			CLEAR_BIT(DIO_DDRD_REG,pin);
    5d34:	a1 e3       	ldi	r26, 0x31	; 49
    5d36:	b0 e0       	ldi	r27, 0x00	; 0
    5d38:	e1 e3       	ldi	r30, 0x31	; 49
    5d3a:	f0 e0       	ldi	r31, 0x00	; 0
    5d3c:	80 81       	ld	r24, Z
    5d3e:	48 2f       	mov	r20, r24
    5d40:	8a 81       	ldd	r24, Y+2	; 0x02
    5d42:	28 2f       	mov	r18, r24
    5d44:	30 e0       	ldi	r19, 0x00	; 0
    5d46:	81 e0       	ldi	r24, 0x01	; 1
    5d48:	90 e0       	ldi	r25, 0x00	; 0
    5d4a:	02 2e       	mov	r0, r18
    5d4c:	02 c0       	rjmp	.+4      	; 0x5d52 <Dio_vidconfigChannel+0x184>
    5d4e:	88 0f       	add	r24, r24
    5d50:	99 1f       	adc	r25, r25
    5d52:	0a 94       	dec	r0
    5d54:	e2 f7       	brpl	.-8      	; 0x5d4e <Dio_vidconfigChannel+0x180>
    5d56:	80 95       	com	r24
    5d58:	84 23       	and	r24, r20
    5d5a:	8c 93       	st	X, r24
    5d5c:	13 c0       	rjmp	.+38     	; 0x5d84 <Dio_vidconfigChannel+0x1b6>
		}
		else
		{
			SET_BIT(DIO_DDRD_REG,pin);
    5d5e:	a1 e3       	ldi	r26, 0x31	; 49
    5d60:	b0 e0       	ldi	r27, 0x00	; 0
    5d62:	e1 e3       	ldi	r30, 0x31	; 49
    5d64:	f0 e0       	ldi	r31, 0x00	; 0
    5d66:	80 81       	ld	r24, Z
    5d68:	48 2f       	mov	r20, r24
    5d6a:	8a 81       	ldd	r24, Y+2	; 0x02
    5d6c:	28 2f       	mov	r18, r24
    5d6e:	30 e0       	ldi	r19, 0x00	; 0
    5d70:	81 e0       	ldi	r24, 0x01	; 1
    5d72:	90 e0       	ldi	r25, 0x00	; 0
    5d74:	02 2e       	mov	r0, r18
    5d76:	02 c0       	rjmp	.+4      	; 0x5d7c <Dio_vidconfigChannel+0x1ae>
    5d78:	88 0f       	add	r24, r24
    5d7a:	99 1f       	adc	r25, r25
    5d7c:	0a 94       	dec	r0
    5d7e:	e2 f7       	brpl	.-8      	; 0x5d78 <Dio_vidconfigChannel+0x1aa>
    5d80:	84 2b       	or	r24, r20
    5d82:	8c 93       	st	X, r24
		}
		break;
	}
  }
}
    5d84:	0f 90       	pop	r0
    5d86:	0f 90       	pop	r0
    5d88:	0f 90       	pop	r0
    5d8a:	0f 90       	pop	r0
    5d8c:	0f 90       	pop	r0
    5d8e:	cf 91       	pop	r28
    5d90:	df 91       	pop	r29
    5d92:	08 95       	ret

00005d94 <Dio_vidwriteChannel>:

void Dio_vidwriteChannel(dio_port_t port,dio_pin_t pin,dio_level_t level)
{
    5d94:	df 93       	push	r29
    5d96:	cf 93       	push	r28
    5d98:	00 d0       	rcall	.+0      	; 0x5d9a <Dio_vidwriteChannel+0x6>
    5d9a:	00 d0       	rcall	.+0      	; 0x5d9c <Dio_vidwriteChannel+0x8>
    5d9c:	0f 92       	push	r0
    5d9e:	cd b7       	in	r28, 0x3d	; 61
    5da0:	de b7       	in	r29, 0x3e	; 62
    5da2:	89 83       	std	Y+1, r24	; 0x01
    5da4:	6a 83       	std	Y+2, r22	; 0x02
    5da6:	4b 83       	std	Y+3, r20	; 0x03
	switch(port)
    5da8:	89 81       	ldd	r24, Y+1	; 0x01
    5daa:	28 2f       	mov	r18, r24
    5dac:	30 e0       	ldi	r19, 0x00	; 0
    5dae:	3d 83       	std	Y+5, r19	; 0x05
    5db0:	2c 83       	std	Y+4, r18	; 0x04
    5db2:	8c 81       	ldd	r24, Y+4	; 0x04
    5db4:	9d 81       	ldd	r25, Y+5	; 0x05
    5db6:	81 30       	cpi	r24, 0x01	; 1
    5db8:	91 05       	cpc	r25, r1
    5dba:	09 f4       	brne	.+2      	; 0x5dbe <Dio_vidwriteChannel+0x2a>
    5dbc:	43 c0       	rjmp	.+134    	; 0x5e44 <Dio_vidwriteChannel+0xb0>
    5dbe:	2c 81       	ldd	r18, Y+4	; 0x04
    5dc0:	3d 81       	ldd	r19, Y+5	; 0x05
    5dc2:	22 30       	cpi	r18, 0x02	; 2
    5dc4:	31 05       	cpc	r19, r1
    5dc6:	2c f4       	brge	.+10     	; 0x5dd2 <Dio_vidwriteChannel+0x3e>
    5dc8:	8c 81       	ldd	r24, Y+4	; 0x04
    5dca:	9d 81       	ldd	r25, Y+5	; 0x05
    5dcc:	00 97       	sbiw	r24, 0x00	; 0
    5dce:	71 f0       	breq	.+28     	; 0x5dec <Dio_vidwriteChannel+0x58>
    5dd0:	bc c0       	rjmp	.+376    	; 0x5f4a <Dio_vidwriteChannel+0x1b6>
    5dd2:	2c 81       	ldd	r18, Y+4	; 0x04
    5dd4:	3d 81       	ldd	r19, Y+5	; 0x05
    5dd6:	22 30       	cpi	r18, 0x02	; 2
    5dd8:	31 05       	cpc	r19, r1
    5dda:	09 f4       	brne	.+2      	; 0x5dde <Dio_vidwriteChannel+0x4a>
    5ddc:	5f c0       	rjmp	.+190    	; 0x5e9c <Dio_vidwriteChannel+0x108>
    5dde:	8c 81       	ldd	r24, Y+4	; 0x04
    5de0:	9d 81       	ldd	r25, Y+5	; 0x05
    5de2:	83 30       	cpi	r24, 0x03	; 3
    5de4:	91 05       	cpc	r25, r1
    5de6:	09 f4       	brne	.+2      	; 0x5dea <Dio_vidwriteChannel+0x56>
    5de8:	85 c0       	rjmp	.+266    	; 0x5ef4 <Dio_vidwriteChannel+0x160>
    5dea:	af c0       	rjmp	.+350    	; 0x5f4a <Dio_vidwriteChannel+0x1b6>
	{
	case DIO_PORTA:
	{
		if (level == DIO_HIGH)
    5dec:	8b 81       	ldd	r24, Y+3	; 0x03
    5dee:	81 30       	cpi	r24, 0x01	; 1
    5df0:	a1 f4       	brne	.+40     	; 0x5e1a <Dio_vidwriteChannel+0x86>
		{
			SET_BIT(DIO_PORTA_REG,pin);
    5df2:	ab e3       	ldi	r26, 0x3B	; 59
    5df4:	b0 e0       	ldi	r27, 0x00	; 0
    5df6:	eb e3       	ldi	r30, 0x3B	; 59
    5df8:	f0 e0       	ldi	r31, 0x00	; 0
    5dfa:	80 81       	ld	r24, Z
    5dfc:	48 2f       	mov	r20, r24
    5dfe:	8a 81       	ldd	r24, Y+2	; 0x02
    5e00:	28 2f       	mov	r18, r24
    5e02:	30 e0       	ldi	r19, 0x00	; 0
    5e04:	81 e0       	ldi	r24, 0x01	; 1
    5e06:	90 e0       	ldi	r25, 0x00	; 0
    5e08:	02 2e       	mov	r0, r18
    5e0a:	02 c0       	rjmp	.+4      	; 0x5e10 <Dio_vidwriteChannel+0x7c>
    5e0c:	88 0f       	add	r24, r24
    5e0e:	99 1f       	adc	r25, r25
    5e10:	0a 94       	dec	r0
    5e12:	e2 f7       	brpl	.-8      	; 0x5e0c <Dio_vidwriteChannel+0x78>
    5e14:	84 2b       	or	r24, r20
    5e16:	8c 93       	st	X, r24
    5e18:	98 c0       	rjmp	.+304    	; 0x5f4a <Dio_vidwriteChannel+0x1b6>
		}
		else
		{
			CLEAR_BIT(DIO_PORTA_REG,pin);
    5e1a:	ab e3       	ldi	r26, 0x3B	; 59
    5e1c:	b0 e0       	ldi	r27, 0x00	; 0
    5e1e:	eb e3       	ldi	r30, 0x3B	; 59
    5e20:	f0 e0       	ldi	r31, 0x00	; 0
    5e22:	80 81       	ld	r24, Z
    5e24:	48 2f       	mov	r20, r24
    5e26:	8a 81       	ldd	r24, Y+2	; 0x02
    5e28:	28 2f       	mov	r18, r24
    5e2a:	30 e0       	ldi	r19, 0x00	; 0
    5e2c:	81 e0       	ldi	r24, 0x01	; 1
    5e2e:	90 e0       	ldi	r25, 0x00	; 0
    5e30:	02 2e       	mov	r0, r18
    5e32:	02 c0       	rjmp	.+4      	; 0x5e38 <Dio_vidwriteChannel+0xa4>
    5e34:	88 0f       	add	r24, r24
    5e36:	99 1f       	adc	r25, r25
    5e38:	0a 94       	dec	r0
    5e3a:	e2 f7       	brpl	.-8      	; 0x5e34 <Dio_vidwriteChannel+0xa0>
    5e3c:	80 95       	com	r24
    5e3e:	84 23       	and	r24, r20
    5e40:	8c 93       	st	X, r24
    5e42:	83 c0       	rjmp	.+262    	; 0x5f4a <Dio_vidwriteChannel+0x1b6>
		}
		break;
	}
	case DIO_PORTB:
	{
		if (level == DIO_HIGH)
    5e44:	8b 81       	ldd	r24, Y+3	; 0x03
    5e46:	81 30       	cpi	r24, 0x01	; 1
    5e48:	a1 f4       	brne	.+40     	; 0x5e72 <Dio_vidwriteChannel+0xde>
		{
			SET_BIT(DIO_PORTB_REG,pin);
    5e4a:	a8 e3       	ldi	r26, 0x38	; 56
    5e4c:	b0 e0       	ldi	r27, 0x00	; 0
    5e4e:	e8 e3       	ldi	r30, 0x38	; 56
    5e50:	f0 e0       	ldi	r31, 0x00	; 0
    5e52:	80 81       	ld	r24, Z
    5e54:	48 2f       	mov	r20, r24
    5e56:	8a 81       	ldd	r24, Y+2	; 0x02
    5e58:	28 2f       	mov	r18, r24
    5e5a:	30 e0       	ldi	r19, 0x00	; 0
    5e5c:	81 e0       	ldi	r24, 0x01	; 1
    5e5e:	90 e0       	ldi	r25, 0x00	; 0
    5e60:	02 2e       	mov	r0, r18
    5e62:	02 c0       	rjmp	.+4      	; 0x5e68 <Dio_vidwriteChannel+0xd4>
    5e64:	88 0f       	add	r24, r24
    5e66:	99 1f       	adc	r25, r25
    5e68:	0a 94       	dec	r0
    5e6a:	e2 f7       	brpl	.-8      	; 0x5e64 <Dio_vidwriteChannel+0xd0>
    5e6c:	84 2b       	or	r24, r20
    5e6e:	8c 93       	st	X, r24
    5e70:	6c c0       	rjmp	.+216    	; 0x5f4a <Dio_vidwriteChannel+0x1b6>
		}
		else
		{
			CLEAR_BIT(DIO_PORTB_REG,pin);
    5e72:	a8 e3       	ldi	r26, 0x38	; 56
    5e74:	b0 e0       	ldi	r27, 0x00	; 0
    5e76:	e8 e3       	ldi	r30, 0x38	; 56
    5e78:	f0 e0       	ldi	r31, 0x00	; 0
    5e7a:	80 81       	ld	r24, Z
    5e7c:	48 2f       	mov	r20, r24
    5e7e:	8a 81       	ldd	r24, Y+2	; 0x02
    5e80:	28 2f       	mov	r18, r24
    5e82:	30 e0       	ldi	r19, 0x00	; 0
    5e84:	81 e0       	ldi	r24, 0x01	; 1
    5e86:	90 e0       	ldi	r25, 0x00	; 0
    5e88:	02 2e       	mov	r0, r18
    5e8a:	02 c0       	rjmp	.+4      	; 0x5e90 <Dio_vidwriteChannel+0xfc>
    5e8c:	88 0f       	add	r24, r24
    5e8e:	99 1f       	adc	r25, r25
    5e90:	0a 94       	dec	r0
    5e92:	e2 f7       	brpl	.-8      	; 0x5e8c <Dio_vidwriteChannel+0xf8>
    5e94:	80 95       	com	r24
    5e96:	84 23       	and	r24, r20
    5e98:	8c 93       	st	X, r24
    5e9a:	57 c0       	rjmp	.+174    	; 0x5f4a <Dio_vidwriteChannel+0x1b6>
		}
		break;
	}
	case DIO_PORTC:
	{
		if (level == DIO_HIGH)
    5e9c:	8b 81       	ldd	r24, Y+3	; 0x03
    5e9e:	81 30       	cpi	r24, 0x01	; 1
    5ea0:	a1 f4       	brne	.+40     	; 0x5eca <Dio_vidwriteChannel+0x136>
		{
			SET_BIT(DIO_PORTC_REG,pin);
    5ea2:	a5 e3       	ldi	r26, 0x35	; 53
    5ea4:	b0 e0       	ldi	r27, 0x00	; 0
    5ea6:	e5 e3       	ldi	r30, 0x35	; 53
    5ea8:	f0 e0       	ldi	r31, 0x00	; 0
    5eaa:	80 81       	ld	r24, Z
    5eac:	48 2f       	mov	r20, r24
    5eae:	8a 81       	ldd	r24, Y+2	; 0x02
    5eb0:	28 2f       	mov	r18, r24
    5eb2:	30 e0       	ldi	r19, 0x00	; 0
    5eb4:	81 e0       	ldi	r24, 0x01	; 1
    5eb6:	90 e0       	ldi	r25, 0x00	; 0
    5eb8:	02 2e       	mov	r0, r18
    5eba:	02 c0       	rjmp	.+4      	; 0x5ec0 <Dio_vidwriteChannel+0x12c>
    5ebc:	88 0f       	add	r24, r24
    5ebe:	99 1f       	adc	r25, r25
    5ec0:	0a 94       	dec	r0
    5ec2:	e2 f7       	brpl	.-8      	; 0x5ebc <Dio_vidwriteChannel+0x128>
    5ec4:	84 2b       	or	r24, r20
    5ec6:	8c 93       	st	X, r24
    5ec8:	40 c0       	rjmp	.+128    	; 0x5f4a <Dio_vidwriteChannel+0x1b6>
		}
		else
		{
			CLEAR_BIT(DIO_PORTC_REG,pin);
    5eca:	a5 e3       	ldi	r26, 0x35	; 53
    5ecc:	b0 e0       	ldi	r27, 0x00	; 0
    5ece:	e5 e3       	ldi	r30, 0x35	; 53
    5ed0:	f0 e0       	ldi	r31, 0x00	; 0
    5ed2:	80 81       	ld	r24, Z
    5ed4:	48 2f       	mov	r20, r24
    5ed6:	8a 81       	ldd	r24, Y+2	; 0x02
    5ed8:	28 2f       	mov	r18, r24
    5eda:	30 e0       	ldi	r19, 0x00	; 0
    5edc:	81 e0       	ldi	r24, 0x01	; 1
    5ede:	90 e0       	ldi	r25, 0x00	; 0
    5ee0:	02 2e       	mov	r0, r18
    5ee2:	02 c0       	rjmp	.+4      	; 0x5ee8 <Dio_vidwriteChannel+0x154>
    5ee4:	88 0f       	add	r24, r24
    5ee6:	99 1f       	adc	r25, r25
    5ee8:	0a 94       	dec	r0
    5eea:	e2 f7       	brpl	.-8      	; 0x5ee4 <Dio_vidwriteChannel+0x150>
    5eec:	80 95       	com	r24
    5eee:	84 23       	and	r24, r20
    5ef0:	8c 93       	st	X, r24
    5ef2:	2b c0       	rjmp	.+86     	; 0x5f4a <Dio_vidwriteChannel+0x1b6>
		}
		break;
	}
	case DIO_PORTD:
	{
		if (level == DIO_HIGH)
    5ef4:	8b 81       	ldd	r24, Y+3	; 0x03
    5ef6:	81 30       	cpi	r24, 0x01	; 1
    5ef8:	a1 f4       	brne	.+40     	; 0x5f22 <Dio_vidwriteChannel+0x18e>
		{
			SET_BIT(DIO_PORTD_REG,pin);
    5efa:	a2 e3       	ldi	r26, 0x32	; 50
    5efc:	b0 e0       	ldi	r27, 0x00	; 0
    5efe:	e2 e3       	ldi	r30, 0x32	; 50
    5f00:	f0 e0       	ldi	r31, 0x00	; 0
    5f02:	80 81       	ld	r24, Z
    5f04:	48 2f       	mov	r20, r24
    5f06:	8a 81       	ldd	r24, Y+2	; 0x02
    5f08:	28 2f       	mov	r18, r24
    5f0a:	30 e0       	ldi	r19, 0x00	; 0
    5f0c:	81 e0       	ldi	r24, 0x01	; 1
    5f0e:	90 e0       	ldi	r25, 0x00	; 0
    5f10:	02 2e       	mov	r0, r18
    5f12:	02 c0       	rjmp	.+4      	; 0x5f18 <Dio_vidwriteChannel+0x184>
    5f14:	88 0f       	add	r24, r24
    5f16:	99 1f       	adc	r25, r25
    5f18:	0a 94       	dec	r0
    5f1a:	e2 f7       	brpl	.-8      	; 0x5f14 <Dio_vidwriteChannel+0x180>
    5f1c:	84 2b       	or	r24, r20
    5f1e:	8c 93       	st	X, r24
    5f20:	14 c0       	rjmp	.+40     	; 0x5f4a <Dio_vidwriteChannel+0x1b6>
		}
		else
		{
			CLEAR_BIT(DIO_PORTD_REG,pin);
    5f22:	a2 e3       	ldi	r26, 0x32	; 50
    5f24:	b0 e0       	ldi	r27, 0x00	; 0
    5f26:	e2 e3       	ldi	r30, 0x32	; 50
    5f28:	f0 e0       	ldi	r31, 0x00	; 0
    5f2a:	80 81       	ld	r24, Z
    5f2c:	48 2f       	mov	r20, r24
    5f2e:	8a 81       	ldd	r24, Y+2	; 0x02
    5f30:	28 2f       	mov	r18, r24
    5f32:	30 e0       	ldi	r19, 0x00	; 0
    5f34:	81 e0       	ldi	r24, 0x01	; 1
    5f36:	90 e0       	ldi	r25, 0x00	; 0
    5f38:	02 2e       	mov	r0, r18
    5f3a:	02 c0       	rjmp	.+4      	; 0x5f40 <Dio_vidwriteChannel+0x1ac>
    5f3c:	88 0f       	add	r24, r24
    5f3e:	99 1f       	adc	r25, r25
    5f40:	0a 94       	dec	r0
    5f42:	e2 f7       	brpl	.-8      	; 0x5f3c <Dio_vidwriteChannel+0x1a8>
    5f44:	80 95       	com	r24
    5f46:	84 23       	and	r24, r20
    5f48:	8c 93       	st	X, r24
		}
		break;
	}
	}
}
    5f4a:	0f 90       	pop	r0
    5f4c:	0f 90       	pop	r0
    5f4e:	0f 90       	pop	r0
    5f50:	0f 90       	pop	r0
    5f52:	0f 90       	pop	r0
    5f54:	cf 91       	pop	r28
    5f56:	df 91       	pop	r29
    5f58:	08 95       	ret

00005f5a <Dio_udtreadChannel>:

dio_level_t Dio_udtreadChannel(dio_port_t port,dio_pin_t pin)
{
    5f5a:	df 93       	push	r29
    5f5c:	cf 93       	push	r28
    5f5e:	00 d0       	rcall	.+0      	; 0x5f60 <Dio_udtreadChannel+0x6>
    5f60:	00 d0       	rcall	.+0      	; 0x5f62 <Dio_udtreadChannel+0x8>
    5f62:	0f 92       	push	r0
    5f64:	cd b7       	in	r28, 0x3d	; 61
    5f66:	de b7       	in	r29, 0x3e	; 62
    5f68:	89 83       	std	Y+1, r24	; 0x01
    5f6a:	6a 83       	std	Y+2, r22	; 0x02
	switch(port)
    5f6c:	89 81       	ldd	r24, Y+1	; 0x01
    5f6e:	28 2f       	mov	r18, r24
    5f70:	30 e0       	ldi	r19, 0x00	; 0
    5f72:	3d 83       	std	Y+5, r19	; 0x05
    5f74:	2c 83       	std	Y+4, r18	; 0x04
    5f76:	4c 81       	ldd	r20, Y+4	; 0x04
    5f78:	5d 81       	ldd	r21, Y+5	; 0x05
    5f7a:	41 30       	cpi	r20, 0x01	; 1
    5f7c:	51 05       	cpc	r21, r1
    5f7e:	79 f1       	breq	.+94     	; 0x5fde <Dio_udtreadChannel+0x84>
    5f80:	8c 81       	ldd	r24, Y+4	; 0x04
    5f82:	9d 81       	ldd	r25, Y+5	; 0x05
    5f84:	82 30       	cpi	r24, 0x02	; 2
    5f86:	91 05       	cpc	r25, r1
    5f88:	34 f4       	brge	.+12     	; 0x5f96 <Dio_udtreadChannel+0x3c>
    5f8a:	2c 81       	ldd	r18, Y+4	; 0x04
    5f8c:	3d 81       	ldd	r19, Y+5	; 0x05
    5f8e:	21 15       	cp	r18, r1
    5f90:	31 05       	cpc	r19, r1
    5f92:	69 f0       	breq	.+26     	; 0x5fae <Dio_udtreadChannel+0x54>
    5f94:	6c c0       	rjmp	.+216    	; 0x606e <Dio_udtreadChannel+0x114>
    5f96:	4c 81       	ldd	r20, Y+4	; 0x04
    5f98:	5d 81       	ldd	r21, Y+5	; 0x05
    5f9a:	42 30       	cpi	r20, 0x02	; 2
    5f9c:	51 05       	cpc	r21, r1
    5f9e:	b9 f1       	breq	.+110    	; 0x600e <Dio_udtreadChannel+0xb4>
    5fa0:	8c 81       	ldd	r24, Y+4	; 0x04
    5fa2:	9d 81       	ldd	r25, Y+5	; 0x05
    5fa4:	83 30       	cpi	r24, 0x03	; 3
    5fa6:	91 05       	cpc	r25, r1
    5fa8:	09 f4       	brne	.+2      	; 0x5fac <Dio_udtreadChannel+0x52>
    5faa:	49 c0       	rjmp	.+146    	; 0x603e <Dio_udtreadChannel+0xe4>
    5fac:	60 c0       	rjmp	.+192    	; 0x606e <Dio_udtreadChannel+0x114>
	{
	case DIO_PORTA:
	{
		if(CHECK_BIT(DIO_PINA_REG,pin) == 1)
    5fae:	e9 e3       	ldi	r30, 0x39	; 57
    5fb0:	f0 e0       	ldi	r31, 0x00	; 0
    5fb2:	80 81       	ld	r24, Z
    5fb4:	28 2f       	mov	r18, r24
    5fb6:	30 e0       	ldi	r19, 0x00	; 0
    5fb8:	8a 81       	ldd	r24, Y+2	; 0x02
    5fba:	88 2f       	mov	r24, r24
    5fbc:	90 e0       	ldi	r25, 0x00	; 0
    5fbe:	a9 01       	movw	r20, r18
    5fc0:	02 c0       	rjmp	.+4      	; 0x5fc6 <Dio_udtreadChannel+0x6c>
    5fc2:	55 95       	asr	r21
    5fc4:	47 95       	ror	r20
    5fc6:	8a 95       	dec	r24
    5fc8:	e2 f7       	brpl	.-8      	; 0x5fc2 <Dio_udtreadChannel+0x68>
    5fca:	ca 01       	movw	r24, r20
    5fcc:	81 70       	andi	r24, 0x01	; 1
    5fce:	90 70       	andi	r25, 0x00	; 0
    5fd0:	88 23       	and	r24, r24
    5fd2:	19 f0       	breq	.+6      	; 0x5fda <Dio_udtreadChannel+0x80>
		{
			return DIO_HIGH;
    5fd4:	51 e0       	ldi	r21, 0x01	; 1
    5fd6:	5b 83       	std	Y+3, r21	; 0x03
    5fd8:	4b c0       	rjmp	.+150    	; 0x6070 <Dio_udtreadChannel+0x116>
		}
		else
		{
			return DIO_LOW;
    5fda:	1b 82       	std	Y+3, r1	; 0x03
    5fdc:	49 c0       	rjmp	.+146    	; 0x6070 <Dio_udtreadChannel+0x116>
		}
	}
	case DIO_PORTB:
	{
		if(CHECK_BIT(DIO_PINB_REG,pin) == 1)
    5fde:	e6 e3       	ldi	r30, 0x36	; 54
    5fe0:	f0 e0       	ldi	r31, 0x00	; 0
    5fe2:	80 81       	ld	r24, Z
    5fe4:	28 2f       	mov	r18, r24
    5fe6:	30 e0       	ldi	r19, 0x00	; 0
    5fe8:	8a 81       	ldd	r24, Y+2	; 0x02
    5fea:	88 2f       	mov	r24, r24
    5fec:	90 e0       	ldi	r25, 0x00	; 0
    5fee:	a9 01       	movw	r20, r18
    5ff0:	02 c0       	rjmp	.+4      	; 0x5ff6 <Dio_udtreadChannel+0x9c>
    5ff2:	55 95       	asr	r21
    5ff4:	47 95       	ror	r20
    5ff6:	8a 95       	dec	r24
    5ff8:	e2 f7       	brpl	.-8      	; 0x5ff2 <Dio_udtreadChannel+0x98>
    5ffa:	ca 01       	movw	r24, r20
    5ffc:	81 70       	andi	r24, 0x01	; 1
    5ffe:	90 70       	andi	r25, 0x00	; 0
    6000:	88 23       	and	r24, r24
    6002:	19 f0       	breq	.+6      	; 0x600a <Dio_udtreadChannel+0xb0>
		{
			return DIO_HIGH;
    6004:	51 e0       	ldi	r21, 0x01	; 1
    6006:	5b 83       	std	Y+3, r21	; 0x03
    6008:	33 c0       	rjmp	.+102    	; 0x6070 <Dio_udtreadChannel+0x116>
		}
		else
		{
			return DIO_LOW;
    600a:	1b 82       	std	Y+3, r1	; 0x03
    600c:	31 c0       	rjmp	.+98     	; 0x6070 <Dio_udtreadChannel+0x116>
		}
	}
	case DIO_PORTC:
	{
		if(CHECK_BIT(DIO_PINC_REG,pin) == 1)
    600e:	e3 e3       	ldi	r30, 0x33	; 51
    6010:	f0 e0       	ldi	r31, 0x00	; 0
    6012:	80 81       	ld	r24, Z
    6014:	28 2f       	mov	r18, r24
    6016:	30 e0       	ldi	r19, 0x00	; 0
    6018:	8a 81       	ldd	r24, Y+2	; 0x02
    601a:	88 2f       	mov	r24, r24
    601c:	90 e0       	ldi	r25, 0x00	; 0
    601e:	a9 01       	movw	r20, r18
    6020:	02 c0       	rjmp	.+4      	; 0x6026 <Dio_udtreadChannel+0xcc>
    6022:	55 95       	asr	r21
    6024:	47 95       	ror	r20
    6026:	8a 95       	dec	r24
    6028:	e2 f7       	brpl	.-8      	; 0x6022 <Dio_udtreadChannel+0xc8>
    602a:	ca 01       	movw	r24, r20
    602c:	81 70       	andi	r24, 0x01	; 1
    602e:	90 70       	andi	r25, 0x00	; 0
    6030:	88 23       	and	r24, r24
    6032:	19 f0       	breq	.+6      	; 0x603a <Dio_udtreadChannel+0xe0>
		{
			return DIO_HIGH;
    6034:	51 e0       	ldi	r21, 0x01	; 1
    6036:	5b 83       	std	Y+3, r21	; 0x03
    6038:	1b c0       	rjmp	.+54     	; 0x6070 <Dio_udtreadChannel+0x116>
		}
		else
		{
			return DIO_LOW;
    603a:	1b 82       	std	Y+3, r1	; 0x03
    603c:	19 c0       	rjmp	.+50     	; 0x6070 <Dio_udtreadChannel+0x116>
		}
	}
	case DIO_PORTD:
	{
		if(CHECK_BIT(DIO_PIND_REG,pin) == 1)
    603e:	e0 e3       	ldi	r30, 0x30	; 48
    6040:	f0 e0       	ldi	r31, 0x00	; 0
    6042:	80 81       	ld	r24, Z
    6044:	28 2f       	mov	r18, r24
    6046:	30 e0       	ldi	r19, 0x00	; 0
    6048:	8a 81       	ldd	r24, Y+2	; 0x02
    604a:	88 2f       	mov	r24, r24
    604c:	90 e0       	ldi	r25, 0x00	; 0
    604e:	a9 01       	movw	r20, r18
    6050:	02 c0       	rjmp	.+4      	; 0x6056 <Dio_udtreadChannel+0xfc>
    6052:	55 95       	asr	r21
    6054:	47 95       	ror	r20
    6056:	8a 95       	dec	r24
    6058:	e2 f7       	brpl	.-8      	; 0x6052 <Dio_udtreadChannel+0xf8>
    605a:	ca 01       	movw	r24, r20
    605c:	81 70       	andi	r24, 0x01	; 1
    605e:	90 70       	andi	r25, 0x00	; 0
    6060:	88 23       	and	r24, r24
    6062:	19 f0       	breq	.+6      	; 0x606a <Dio_udtreadChannel+0x110>
		{
			return DIO_HIGH;
    6064:	51 e0       	ldi	r21, 0x01	; 1
    6066:	5b 83       	std	Y+3, r21	; 0x03
    6068:	03 c0       	rjmp	.+6      	; 0x6070 <Dio_udtreadChannel+0x116>
		}
		else
		{
			return DIO_LOW;
    606a:	1b 82       	std	Y+3, r1	; 0x03
    606c:	01 c0       	rjmp	.+2      	; 0x6070 <Dio_udtreadChannel+0x116>
		}
	}

	}
	return DIO_LOW;
    606e:	1b 82       	std	Y+3, r1	; 0x03
    6070:	8b 81       	ldd	r24, Y+3	; 0x03
}
    6072:	0f 90       	pop	r0
    6074:	0f 90       	pop	r0
    6076:	0f 90       	pop	r0
    6078:	0f 90       	pop	r0
    607a:	0f 90       	pop	r0
    607c:	cf 91       	pop	r28
    607e:	df 91       	pop	r29
    6080:	08 95       	ret

00006082 <Dio_vidflipChannel>:

void Dio_vidflipChannel(dio_port_t port,dio_pin_t pin)
{
    6082:	df 93       	push	r29
    6084:	cf 93       	push	r28
    6086:	00 d0       	rcall	.+0      	; 0x6088 <Dio_vidflipChannel+0x6>
    6088:	00 d0       	rcall	.+0      	; 0x608a <Dio_vidflipChannel+0x8>
    608a:	cd b7       	in	r28, 0x3d	; 61
    608c:	de b7       	in	r29, 0x3e	; 62
    608e:	89 83       	std	Y+1, r24	; 0x01
    6090:	6a 83       	std	Y+2, r22	; 0x02
	switch(port)
    6092:	89 81       	ldd	r24, Y+1	; 0x01
    6094:	28 2f       	mov	r18, r24
    6096:	30 e0       	ldi	r19, 0x00	; 0
    6098:	3c 83       	std	Y+4, r19	; 0x04
    609a:	2b 83       	std	Y+3, r18	; 0x03
    609c:	8b 81       	ldd	r24, Y+3	; 0x03
    609e:	9c 81       	ldd	r25, Y+4	; 0x04
    60a0:	81 30       	cpi	r24, 0x01	; 1
    60a2:	91 05       	cpc	r25, r1
    60a4:	49 f1       	breq	.+82     	; 0x60f8 <Dio_vidflipChannel+0x76>
    60a6:	2b 81       	ldd	r18, Y+3	; 0x03
    60a8:	3c 81       	ldd	r19, Y+4	; 0x04
    60aa:	22 30       	cpi	r18, 0x02	; 2
    60ac:	31 05       	cpc	r19, r1
    60ae:	2c f4       	brge	.+10     	; 0x60ba <Dio_vidflipChannel+0x38>
    60b0:	8b 81       	ldd	r24, Y+3	; 0x03
    60b2:	9c 81       	ldd	r25, Y+4	; 0x04
    60b4:	00 97       	sbiw	r24, 0x00	; 0
    60b6:	61 f0       	breq	.+24     	; 0x60d0 <Dio_vidflipChannel+0x4e>
    60b8:	5a c0       	rjmp	.+180    	; 0x616e <Dio_vidflipChannel+0xec>
    60ba:	2b 81       	ldd	r18, Y+3	; 0x03
    60bc:	3c 81       	ldd	r19, Y+4	; 0x04
    60be:	22 30       	cpi	r18, 0x02	; 2
    60c0:	31 05       	cpc	r19, r1
    60c2:	71 f1       	breq	.+92     	; 0x6120 <Dio_vidflipChannel+0x9e>
    60c4:	8b 81       	ldd	r24, Y+3	; 0x03
    60c6:	9c 81       	ldd	r25, Y+4	; 0x04
    60c8:	83 30       	cpi	r24, 0x03	; 3
    60ca:	91 05       	cpc	r25, r1
    60cc:	e9 f1       	breq	.+122    	; 0x6148 <Dio_vidflipChannel+0xc6>
    60ce:	4f c0       	rjmp	.+158    	; 0x616e <Dio_vidflipChannel+0xec>
	{
	case DIO_PORTA:
	{
		FLIP_BIT(DIO_PORTA_REG,pin);
    60d0:	ab e3       	ldi	r26, 0x3B	; 59
    60d2:	b0 e0       	ldi	r27, 0x00	; 0
    60d4:	eb e3       	ldi	r30, 0x3B	; 59
    60d6:	f0 e0       	ldi	r31, 0x00	; 0
    60d8:	80 81       	ld	r24, Z
    60da:	48 2f       	mov	r20, r24
    60dc:	8a 81       	ldd	r24, Y+2	; 0x02
    60de:	28 2f       	mov	r18, r24
    60e0:	30 e0       	ldi	r19, 0x00	; 0
    60e2:	81 e0       	ldi	r24, 0x01	; 1
    60e4:	90 e0       	ldi	r25, 0x00	; 0
    60e6:	02 2e       	mov	r0, r18
    60e8:	02 c0       	rjmp	.+4      	; 0x60ee <Dio_vidflipChannel+0x6c>
    60ea:	88 0f       	add	r24, r24
    60ec:	99 1f       	adc	r25, r25
    60ee:	0a 94       	dec	r0
    60f0:	e2 f7       	brpl	.-8      	; 0x60ea <Dio_vidflipChannel+0x68>
    60f2:	84 27       	eor	r24, r20
    60f4:	8c 93       	st	X, r24
    60f6:	3b c0       	rjmp	.+118    	; 0x616e <Dio_vidflipChannel+0xec>
		break;
	}
	case DIO_PORTB:
	{
		FLIP_BIT(DIO_PORTB_REG,pin);
    60f8:	a8 e3       	ldi	r26, 0x38	; 56
    60fa:	b0 e0       	ldi	r27, 0x00	; 0
    60fc:	e8 e3       	ldi	r30, 0x38	; 56
    60fe:	f0 e0       	ldi	r31, 0x00	; 0
    6100:	80 81       	ld	r24, Z
    6102:	48 2f       	mov	r20, r24
    6104:	8a 81       	ldd	r24, Y+2	; 0x02
    6106:	28 2f       	mov	r18, r24
    6108:	30 e0       	ldi	r19, 0x00	; 0
    610a:	81 e0       	ldi	r24, 0x01	; 1
    610c:	90 e0       	ldi	r25, 0x00	; 0
    610e:	02 2e       	mov	r0, r18
    6110:	02 c0       	rjmp	.+4      	; 0x6116 <Dio_vidflipChannel+0x94>
    6112:	88 0f       	add	r24, r24
    6114:	99 1f       	adc	r25, r25
    6116:	0a 94       	dec	r0
    6118:	e2 f7       	brpl	.-8      	; 0x6112 <Dio_vidflipChannel+0x90>
    611a:	84 27       	eor	r24, r20
    611c:	8c 93       	st	X, r24
    611e:	27 c0       	rjmp	.+78     	; 0x616e <Dio_vidflipChannel+0xec>
		break;
	}
	case DIO_PORTC:
	{
		FLIP_BIT(DIO_PORTC_REG,pin);
    6120:	a5 e3       	ldi	r26, 0x35	; 53
    6122:	b0 e0       	ldi	r27, 0x00	; 0
    6124:	e5 e3       	ldi	r30, 0x35	; 53
    6126:	f0 e0       	ldi	r31, 0x00	; 0
    6128:	80 81       	ld	r24, Z
    612a:	48 2f       	mov	r20, r24
    612c:	8a 81       	ldd	r24, Y+2	; 0x02
    612e:	28 2f       	mov	r18, r24
    6130:	30 e0       	ldi	r19, 0x00	; 0
    6132:	81 e0       	ldi	r24, 0x01	; 1
    6134:	90 e0       	ldi	r25, 0x00	; 0
    6136:	02 2e       	mov	r0, r18
    6138:	02 c0       	rjmp	.+4      	; 0x613e <Dio_vidflipChannel+0xbc>
    613a:	88 0f       	add	r24, r24
    613c:	99 1f       	adc	r25, r25
    613e:	0a 94       	dec	r0
    6140:	e2 f7       	brpl	.-8      	; 0x613a <Dio_vidflipChannel+0xb8>
    6142:	84 27       	eor	r24, r20
    6144:	8c 93       	st	X, r24
    6146:	13 c0       	rjmp	.+38     	; 0x616e <Dio_vidflipChannel+0xec>
		break;
	}
	case DIO_PORTD:
	{
		FLIP_BIT(DIO_PORTD_REG,pin);
    6148:	a2 e3       	ldi	r26, 0x32	; 50
    614a:	b0 e0       	ldi	r27, 0x00	; 0
    614c:	e2 e3       	ldi	r30, 0x32	; 50
    614e:	f0 e0       	ldi	r31, 0x00	; 0
    6150:	80 81       	ld	r24, Z
    6152:	48 2f       	mov	r20, r24
    6154:	8a 81       	ldd	r24, Y+2	; 0x02
    6156:	28 2f       	mov	r18, r24
    6158:	30 e0       	ldi	r19, 0x00	; 0
    615a:	81 e0       	ldi	r24, 0x01	; 1
    615c:	90 e0       	ldi	r25, 0x00	; 0
    615e:	02 2e       	mov	r0, r18
    6160:	02 c0       	rjmp	.+4      	; 0x6166 <Dio_vidflipChannel+0xe4>
    6162:	88 0f       	add	r24, r24
    6164:	99 1f       	adc	r25, r25
    6166:	0a 94       	dec	r0
    6168:	e2 f7       	brpl	.-8      	; 0x6162 <Dio_vidflipChannel+0xe0>
    616a:	84 27       	eor	r24, r20
    616c:	8c 93       	st	X, r24
		break;
	}
	}
}
    616e:	0f 90       	pop	r0
    6170:	0f 90       	pop	r0
    6172:	0f 90       	pop	r0
    6174:	0f 90       	pop	r0
    6176:	cf 91       	pop	r28
    6178:	df 91       	pop	r29
    617a:	08 95       	ret

0000617c <Dio_vidwriteChannelGroup>:

void Dio_vidwriteChannelGroup(dio_port_t port,u8 data,u8 mask)
{
    617c:	df 93       	push	r29
    617e:	cf 93       	push	r28
    6180:	00 d0       	rcall	.+0      	; 0x6182 <Dio_vidwriteChannelGroup+0x6>
    6182:	00 d0       	rcall	.+0      	; 0x6184 <Dio_vidwriteChannelGroup+0x8>
    6184:	0f 92       	push	r0
    6186:	cd b7       	in	r28, 0x3d	; 61
    6188:	de b7       	in	r29, 0x3e	; 62
    618a:	89 83       	std	Y+1, r24	; 0x01
    618c:	6a 83       	std	Y+2, r22	; 0x02
    618e:	4b 83       	std	Y+3, r20	; 0x03
	switch(port)
    6190:	89 81       	ldd	r24, Y+1	; 0x01
    6192:	28 2f       	mov	r18, r24
    6194:	30 e0       	ldi	r19, 0x00	; 0
    6196:	3d 83       	std	Y+5, r19	; 0x05
    6198:	2c 83       	std	Y+4, r18	; 0x04
    619a:	8c 81       	ldd	r24, Y+4	; 0x04
    619c:	9d 81       	ldd	r25, Y+5	; 0x05
    619e:	81 30       	cpi	r24, 0x01	; 1
    61a0:	91 05       	cpc	r25, r1
    61a2:	01 f1       	breq	.+64     	; 0x61e4 <Dio_vidwriteChannelGroup+0x68>
    61a4:	2c 81       	ldd	r18, Y+4	; 0x04
    61a6:	3d 81       	ldd	r19, Y+5	; 0x05
    61a8:	22 30       	cpi	r18, 0x02	; 2
    61aa:	31 05       	cpc	r19, r1
    61ac:	2c f4       	brge	.+10     	; 0x61b8 <Dio_vidwriteChannelGroup+0x3c>
    61ae:	8c 81       	ldd	r24, Y+4	; 0x04
    61b0:	9d 81       	ldd	r25, Y+5	; 0x05
    61b2:	00 97       	sbiw	r24, 0x00	; 0
    61b4:	61 f0       	breq	.+24     	; 0x61ce <Dio_vidwriteChannelGroup+0x52>
    61b6:	36 c0       	rjmp	.+108    	; 0x6224 <Dio_vidwriteChannelGroup+0xa8>
    61b8:	2c 81       	ldd	r18, Y+4	; 0x04
    61ba:	3d 81       	ldd	r19, Y+5	; 0x05
    61bc:	22 30       	cpi	r18, 0x02	; 2
    61be:	31 05       	cpc	r19, r1
    61c0:	e1 f0       	breq	.+56     	; 0x61fa <Dio_vidwriteChannelGroup+0x7e>
    61c2:	8c 81       	ldd	r24, Y+4	; 0x04
    61c4:	9d 81       	ldd	r25, Y+5	; 0x05
    61c6:	83 30       	cpi	r24, 0x03	; 3
    61c8:	91 05       	cpc	r25, r1
    61ca:	11 f1       	breq	.+68     	; 0x6210 <Dio_vidwriteChannelGroup+0x94>
    61cc:	2b c0       	rjmp	.+86     	; 0x6224 <Dio_vidwriteChannelGroup+0xa8>
	{
	case DIO_PORTA:
	{
		DIO_PORTA_REG = (DIO_PORTA_REG & mask) | (data);
    61ce:	ab e3       	ldi	r26, 0x3B	; 59
    61d0:	b0 e0       	ldi	r27, 0x00	; 0
    61d2:	eb e3       	ldi	r30, 0x3B	; 59
    61d4:	f0 e0       	ldi	r31, 0x00	; 0
    61d6:	90 81       	ld	r25, Z
    61d8:	8b 81       	ldd	r24, Y+3	; 0x03
    61da:	98 23       	and	r25, r24
    61dc:	8a 81       	ldd	r24, Y+2	; 0x02
    61de:	89 2b       	or	r24, r25
    61e0:	8c 93       	st	X, r24
    61e2:	20 c0       	rjmp	.+64     	; 0x6224 <Dio_vidwriteChannelGroup+0xa8>
		break;
	}
	case DIO_PORTB:
	{
		DIO_PORTB_REG = (DIO_PORTB_REG & mask) | (data);
    61e4:	a8 e3       	ldi	r26, 0x38	; 56
    61e6:	b0 e0       	ldi	r27, 0x00	; 0
    61e8:	e8 e3       	ldi	r30, 0x38	; 56
    61ea:	f0 e0       	ldi	r31, 0x00	; 0
    61ec:	90 81       	ld	r25, Z
    61ee:	8b 81       	ldd	r24, Y+3	; 0x03
    61f0:	98 23       	and	r25, r24
    61f2:	8a 81       	ldd	r24, Y+2	; 0x02
    61f4:	89 2b       	or	r24, r25
    61f6:	8c 93       	st	X, r24
    61f8:	15 c0       	rjmp	.+42     	; 0x6224 <Dio_vidwriteChannelGroup+0xa8>
		break;
	}
	case DIO_PORTC:
	{
		DIO_PORTC_REG = (DIO_PORTC_REG & mask) | (data);
    61fa:	a5 e3       	ldi	r26, 0x35	; 53
    61fc:	b0 e0       	ldi	r27, 0x00	; 0
    61fe:	e5 e3       	ldi	r30, 0x35	; 53
    6200:	f0 e0       	ldi	r31, 0x00	; 0
    6202:	90 81       	ld	r25, Z
    6204:	8b 81       	ldd	r24, Y+3	; 0x03
    6206:	98 23       	and	r25, r24
    6208:	8a 81       	ldd	r24, Y+2	; 0x02
    620a:	89 2b       	or	r24, r25
    620c:	8c 93       	st	X, r24
    620e:	0a c0       	rjmp	.+20     	; 0x6224 <Dio_vidwriteChannelGroup+0xa8>
		break;
	}
	case DIO_PORTD:
	{
		DIO_PORTD_REG = (DIO_PORTD_REG & mask) | (data);
    6210:	a2 e3       	ldi	r26, 0x32	; 50
    6212:	b0 e0       	ldi	r27, 0x00	; 0
    6214:	e2 e3       	ldi	r30, 0x32	; 50
    6216:	f0 e0       	ldi	r31, 0x00	; 0
    6218:	90 81       	ld	r25, Z
    621a:	8b 81       	ldd	r24, Y+3	; 0x03
    621c:	98 23       	and	r25, r24
    621e:	8a 81       	ldd	r24, Y+2	; 0x02
    6220:	89 2b       	or	r24, r25
    6222:	8c 93       	st	X, r24
		break;
	}
	}
}
    6224:	0f 90       	pop	r0
    6226:	0f 90       	pop	r0
    6228:	0f 90       	pop	r0
    622a:	0f 90       	pop	r0
    622c:	0f 90       	pop	r0
    622e:	cf 91       	pop	r28
    6230:	df 91       	pop	r29
    6232:	08 95       	ret

00006234 <ADC_Init>:


#include "ADC.h"

void ADC_Init(void)
{
    6234:	df 93       	push	r29
    6236:	cf 93       	push	r28
    6238:	cd b7       	in	r28, 0x3d	; 61
    623a:	de b7       	in	r29, 0x3e	; 62
	/* 	Vref = AVCC	*/
	ADC_ADMUX_REG|=(AVCC5V_REF<<6);
    623c:	a7 e2       	ldi	r26, 0x27	; 39
    623e:	b0 e0       	ldi	r27, 0x00	; 0
    6240:	e7 e2       	ldi	r30, 0x27	; 39
    6242:	f0 e0       	ldi	r31, 0x00	; 0
    6244:	80 81       	ld	r24, Z
    6246:	80 64       	ori	r24, 0x40	; 64
    6248:	8c 93       	st	X, r24
	/*	Enable ADC, Prescaler = /128	*/
	ADC_ADCSRA_REG=(ADC_ENABLE)|(ADCPS_128);
    624a:	e6 e2       	ldi	r30, 0x26	; 38
    624c:	f0 e0       	ldi	r31, 0x00	; 0
    624e:	87 e8       	ldi	r24, 0x87	; 135
    6250:	80 83       	st	Z, r24
}
    6252:	cf 91       	pop	r28
    6254:	df 91       	pop	r29
    6256:	08 95       	ret

00006258 <ADC_Read>:

u16 ADC_Read(adc_Channel_t chnlNo)
{
    6258:	df 93       	push	r29
    625a:	cf 93       	push	r28
    625c:	00 d0       	rcall	.+0      	; 0x625e <ADC_Read+0x6>
    625e:	0f 92       	push	r0
    6260:	cd b7       	in	r28, 0x3d	; 61
    6262:	de b7       	in	r29, 0x3e	; 62
    6264:	8b 83       	std	Y+3, r24	; 0x03
	u16 result;
	/*	Select Channel	*/
	ADC_ADMUX_REG = (ADC_ADMUX_REG & 0xF8)|(chnlNo);
    6266:	a7 e2       	ldi	r26, 0x27	; 39
    6268:	b0 e0       	ldi	r27, 0x00	; 0
    626a:	e7 e2       	ldi	r30, 0x27	; 39
    626c:	f0 e0       	ldi	r31, 0x00	; 0
    626e:	80 81       	ld	r24, Z
    6270:	98 2f       	mov	r25, r24
    6272:	98 7f       	andi	r25, 0xF8	; 248
    6274:	8b 81       	ldd	r24, Y+3	; 0x03
    6276:	89 2b       	or	r24, r25
    6278:	8c 93       	st	X, r24
	/*	Start ADC Conversion	*/
	SET_BIT(ADC_ADCSRA_REG,ADC_START_CONVERSION_BIT_NO);
    627a:	a6 e2       	ldi	r26, 0x26	; 38
    627c:	b0 e0       	ldi	r27, 0x00	; 0
    627e:	e6 e2       	ldi	r30, 0x26	; 38
    6280:	f0 e0       	ldi	r31, 0x00	; 0
    6282:	80 81       	ld	r24, Z
    6284:	80 64       	ori	r24, 0x40	; 64
    6286:	8c 93       	st	X, r24
	/*	Wait Until ADC Conversion Finished	*/
	while(CHECK_BIT(ADC_ADCSRA_REG,ADIF_BIT_NO) != 1)
    6288:	e6 e2       	ldi	r30, 0x26	; 38
    628a:	f0 e0       	ldi	r31, 0x00	; 0
    628c:	80 81       	ld	r24, Z
    628e:	82 95       	swap	r24
    6290:	8f 70       	andi	r24, 0x0F	; 15
    6292:	88 2f       	mov	r24, r24
    6294:	90 e0       	ldi	r25, 0x00	; 0
    6296:	81 70       	andi	r24, 0x01	; 1
    6298:	90 70       	andi	r25, 0x00	; 0
    629a:	00 97       	sbiw	r24, 0x00	; 0
    629c:	a9 f3       	breq	.-22     	; 0x6288 <ADC_Read+0x30>
	{
		/*	Do Nothing	*/
	}
	/*	Clear Interrupt Flag To Be Ready For Another Conversion	*/
	SET_BIT(ADC_ADCSRA_REG,ADIF_BIT_NO);
    629e:	a6 e2       	ldi	r26, 0x26	; 38
    62a0:	b0 e0       	ldi	r27, 0x00	; 0
    62a2:	e6 e2       	ldi	r30, 0x26	; 38
    62a4:	f0 e0       	ldi	r31, 0x00	; 0
    62a6:	80 81       	ld	r24, Z
    62a8:	80 61       	ori	r24, 0x10	; 16
    62aa:	8c 93       	st	X, r24
	/*	Read ADC Result	*/
	result=(ADC_ADCL_REG|(ADC_ADCH_REG<<8));
    62ac:	e4 e2       	ldi	r30, 0x24	; 36
    62ae:	f0 e0       	ldi	r31, 0x00	; 0
    62b0:	80 81       	ld	r24, Z
    62b2:	28 2f       	mov	r18, r24
    62b4:	30 e0       	ldi	r19, 0x00	; 0
    62b6:	e5 e2       	ldi	r30, 0x25	; 37
    62b8:	f0 e0       	ldi	r31, 0x00	; 0
    62ba:	80 81       	ld	r24, Z
    62bc:	88 2f       	mov	r24, r24
    62be:	90 e0       	ldi	r25, 0x00	; 0
    62c0:	98 2f       	mov	r25, r24
    62c2:	88 27       	eor	r24, r24
    62c4:	82 2b       	or	r24, r18
    62c6:	93 2b       	or	r25, r19
    62c8:	9a 83       	std	Y+2, r25	; 0x02
    62ca:	89 83       	std	Y+1, r24	; 0x01
	return result;
    62cc:	89 81       	ldd	r24, Y+1	; 0x01
    62ce:	9a 81       	ldd	r25, Y+2	; 0x02
}
    62d0:	0f 90       	pop	r0
    62d2:	0f 90       	pop	r0
    62d4:	0f 90       	pop	r0
    62d6:	cf 91       	pop	r28
    62d8:	df 91       	pop	r29
    62da:	08 95       	ret

000062dc <__mulsi3>:
    62dc:	62 9f       	mul	r22, r18
    62de:	d0 01       	movw	r26, r0
    62e0:	73 9f       	mul	r23, r19
    62e2:	f0 01       	movw	r30, r0
    62e4:	82 9f       	mul	r24, r18
    62e6:	e0 0d       	add	r30, r0
    62e8:	f1 1d       	adc	r31, r1
    62ea:	64 9f       	mul	r22, r20
    62ec:	e0 0d       	add	r30, r0
    62ee:	f1 1d       	adc	r31, r1
    62f0:	92 9f       	mul	r25, r18
    62f2:	f0 0d       	add	r31, r0
    62f4:	83 9f       	mul	r24, r19
    62f6:	f0 0d       	add	r31, r0
    62f8:	74 9f       	mul	r23, r20
    62fa:	f0 0d       	add	r31, r0
    62fc:	65 9f       	mul	r22, r21
    62fe:	f0 0d       	add	r31, r0
    6300:	99 27       	eor	r25, r25
    6302:	72 9f       	mul	r23, r18
    6304:	b0 0d       	add	r27, r0
    6306:	e1 1d       	adc	r30, r1
    6308:	f9 1f       	adc	r31, r25
    630a:	63 9f       	mul	r22, r19
    630c:	b0 0d       	add	r27, r0
    630e:	e1 1d       	adc	r30, r1
    6310:	f9 1f       	adc	r31, r25
    6312:	bd 01       	movw	r22, r26
    6314:	cf 01       	movw	r24, r30
    6316:	11 24       	eor	r1, r1
    6318:	08 95       	ret

0000631a <__udivmodqi4>:
    631a:	99 1b       	sub	r25, r25
    631c:	79 e0       	ldi	r23, 0x09	; 9
    631e:	04 c0       	rjmp	.+8      	; 0x6328 <__udivmodqi4_ep>

00006320 <__udivmodqi4_loop>:
    6320:	99 1f       	adc	r25, r25
    6322:	96 17       	cp	r25, r22
    6324:	08 f0       	brcs	.+2      	; 0x6328 <__udivmodqi4_ep>
    6326:	96 1b       	sub	r25, r22

00006328 <__udivmodqi4_ep>:
    6328:	88 1f       	adc	r24, r24
    632a:	7a 95       	dec	r23
    632c:	c9 f7       	brne	.-14     	; 0x6320 <__udivmodqi4_loop>
    632e:	80 95       	com	r24
    6330:	08 95       	ret

00006332 <__udivmodhi4>:
    6332:	aa 1b       	sub	r26, r26
    6334:	bb 1b       	sub	r27, r27
    6336:	51 e1       	ldi	r21, 0x11	; 17
    6338:	07 c0       	rjmp	.+14     	; 0x6348 <__udivmodhi4_ep>

0000633a <__udivmodhi4_loop>:
    633a:	aa 1f       	adc	r26, r26
    633c:	bb 1f       	adc	r27, r27
    633e:	a6 17       	cp	r26, r22
    6340:	b7 07       	cpc	r27, r23
    6342:	10 f0       	brcs	.+4      	; 0x6348 <__udivmodhi4_ep>
    6344:	a6 1b       	sub	r26, r22
    6346:	b7 0b       	sbc	r27, r23

00006348 <__udivmodhi4_ep>:
    6348:	88 1f       	adc	r24, r24
    634a:	99 1f       	adc	r25, r25
    634c:	5a 95       	dec	r21
    634e:	a9 f7       	brne	.-22     	; 0x633a <__udivmodhi4_loop>
    6350:	80 95       	com	r24
    6352:	90 95       	com	r25
    6354:	bc 01       	movw	r22, r24
    6356:	cd 01       	movw	r24, r26
    6358:	08 95       	ret

0000635a <__udivmodsi4>:
    635a:	a1 e2       	ldi	r26, 0x21	; 33
    635c:	1a 2e       	mov	r1, r26
    635e:	aa 1b       	sub	r26, r26
    6360:	bb 1b       	sub	r27, r27
    6362:	fd 01       	movw	r30, r26
    6364:	0d c0       	rjmp	.+26     	; 0x6380 <__udivmodsi4_ep>

00006366 <__udivmodsi4_loop>:
    6366:	aa 1f       	adc	r26, r26
    6368:	bb 1f       	adc	r27, r27
    636a:	ee 1f       	adc	r30, r30
    636c:	ff 1f       	adc	r31, r31
    636e:	a2 17       	cp	r26, r18
    6370:	b3 07       	cpc	r27, r19
    6372:	e4 07       	cpc	r30, r20
    6374:	f5 07       	cpc	r31, r21
    6376:	20 f0       	brcs	.+8      	; 0x6380 <__udivmodsi4_ep>
    6378:	a2 1b       	sub	r26, r18
    637a:	b3 0b       	sbc	r27, r19
    637c:	e4 0b       	sbc	r30, r20
    637e:	f5 0b       	sbc	r31, r21

00006380 <__udivmodsi4_ep>:
    6380:	66 1f       	adc	r22, r22
    6382:	77 1f       	adc	r23, r23
    6384:	88 1f       	adc	r24, r24
    6386:	99 1f       	adc	r25, r25
    6388:	1a 94       	dec	r1
    638a:	69 f7       	brne	.-38     	; 0x6366 <__udivmodsi4_loop>
    638c:	60 95       	com	r22
    638e:	70 95       	com	r23
    6390:	80 95       	com	r24
    6392:	90 95       	com	r25
    6394:	9b 01       	movw	r18, r22
    6396:	ac 01       	movw	r20, r24
    6398:	bd 01       	movw	r22, r26
    639a:	cf 01       	movw	r24, r30
    639c:	08 95       	ret

0000639e <__prologue_saves__>:
    639e:	2f 92       	push	r2
    63a0:	3f 92       	push	r3
    63a2:	4f 92       	push	r4
    63a4:	5f 92       	push	r5
    63a6:	6f 92       	push	r6
    63a8:	7f 92       	push	r7
    63aa:	8f 92       	push	r8
    63ac:	9f 92       	push	r9
    63ae:	af 92       	push	r10
    63b0:	bf 92       	push	r11
    63b2:	cf 92       	push	r12
    63b4:	df 92       	push	r13
    63b6:	ef 92       	push	r14
    63b8:	ff 92       	push	r15
    63ba:	0f 93       	push	r16
    63bc:	1f 93       	push	r17
    63be:	cf 93       	push	r28
    63c0:	df 93       	push	r29
    63c2:	cd b7       	in	r28, 0x3d	; 61
    63c4:	de b7       	in	r29, 0x3e	; 62
    63c6:	ca 1b       	sub	r28, r26
    63c8:	db 0b       	sbc	r29, r27
    63ca:	0f b6       	in	r0, 0x3f	; 63
    63cc:	f8 94       	cli
    63ce:	de bf       	out	0x3e, r29	; 62
    63d0:	0f be       	out	0x3f, r0	; 63
    63d2:	cd bf       	out	0x3d, r28	; 61
    63d4:	09 94       	ijmp

000063d6 <__epilogue_restores__>:
    63d6:	2a 88       	ldd	r2, Y+18	; 0x12
    63d8:	39 88       	ldd	r3, Y+17	; 0x11
    63da:	48 88       	ldd	r4, Y+16	; 0x10
    63dc:	5f 84       	ldd	r5, Y+15	; 0x0f
    63de:	6e 84       	ldd	r6, Y+14	; 0x0e
    63e0:	7d 84       	ldd	r7, Y+13	; 0x0d
    63e2:	8c 84       	ldd	r8, Y+12	; 0x0c
    63e4:	9b 84       	ldd	r9, Y+11	; 0x0b
    63e6:	aa 84       	ldd	r10, Y+10	; 0x0a
    63e8:	b9 84       	ldd	r11, Y+9	; 0x09
    63ea:	c8 84       	ldd	r12, Y+8	; 0x08
    63ec:	df 80       	ldd	r13, Y+7	; 0x07
    63ee:	ee 80       	ldd	r14, Y+6	; 0x06
    63f0:	fd 80       	ldd	r15, Y+5	; 0x05
    63f2:	0c 81       	ldd	r16, Y+4	; 0x04
    63f4:	1b 81       	ldd	r17, Y+3	; 0x03
    63f6:	aa 81       	ldd	r26, Y+2	; 0x02
    63f8:	b9 81       	ldd	r27, Y+1	; 0x01
    63fa:	ce 0f       	add	r28, r30
    63fc:	d1 1d       	adc	r29, r1
    63fe:	0f b6       	in	r0, 0x3f	; 63
    6400:	f8 94       	cli
    6402:	de bf       	out	0x3e, r29	; 62
    6404:	0f be       	out	0x3f, r0	; 63
    6406:	cd bf       	out	0x3d, r28	; 61
    6408:	ed 01       	movw	r28, r26
    640a:	08 95       	ret

0000640c <memcpy>:
    640c:	fb 01       	movw	r30, r22
    640e:	dc 01       	movw	r26, r24
    6410:	02 c0       	rjmp	.+4      	; 0x6416 <memcpy+0xa>
    6412:	01 90       	ld	r0, Z+
    6414:	0d 92       	st	X+, r0
    6416:	41 50       	subi	r20, 0x01	; 1
    6418:	50 40       	sbci	r21, 0x00	; 0
    641a:	d8 f7       	brcc	.-10     	; 0x6412 <memcpy+0x6>
    641c:	08 95       	ret

0000641e <memset>:
    641e:	dc 01       	movw	r26, r24
    6420:	01 c0       	rjmp	.+2      	; 0x6424 <memset+0x6>
    6422:	6d 93       	st	X+, r22
    6424:	41 50       	subi	r20, 0x01	; 1
    6426:	50 40       	sbci	r21, 0x00	; 0
    6428:	e0 f7       	brcc	.-8      	; 0x6422 <memset+0x4>
    642a:	08 95       	ret

0000642c <strncpy>:
    642c:	fb 01       	movw	r30, r22
    642e:	dc 01       	movw	r26, r24
    6430:	41 50       	subi	r20, 0x01	; 1
    6432:	50 40       	sbci	r21, 0x00	; 0
    6434:	48 f0       	brcs	.+18     	; 0x6448 <strncpy+0x1c>
    6436:	01 90       	ld	r0, Z+
    6438:	0d 92       	st	X+, r0
    643a:	00 20       	and	r0, r0
    643c:	c9 f7       	brne	.-14     	; 0x6430 <strncpy+0x4>
    643e:	01 c0       	rjmp	.+2      	; 0x6442 <strncpy+0x16>
    6440:	1d 92       	st	X+, r1
    6442:	41 50       	subi	r20, 0x01	; 1
    6444:	50 40       	sbci	r21, 0x00	; 0
    6446:	e0 f7       	brcc	.-8      	; 0x6440 <strncpy+0x14>
    6448:	08 95       	ret

0000644a <sprintf>:
    644a:	ae e0       	ldi	r26, 0x0E	; 14
    644c:	b0 e0       	ldi	r27, 0x00	; 0
    644e:	eb e2       	ldi	r30, 0x2B	; 43
    6450:	f2 e3       	ldi	r31, 0x32	; 50
    6452:	0c 94 dd 31 	jmp	0x63ba	; 0x63ba <__prologue_saves__+0x1c>
    6456:	0d 89       	ldd	r16, Y+21	; 0x15
    6458:	1e 89       	ldd	r17, Y+22	; 0x16
    645a:	86 e0       	ldi	r24, 0x06	; 6
    645c:	8c 83       	std	Y+4, r24	; 0x04
    645e:	1a 83       	std	Y+2, r17	; 0x02
    6460:	09 83       	std	Y+1, r16	; 0x01
    6462:	8f ef       	ldi	r24, 0xFF	; 255
    6464:	9f e7       	ldi	r25, 0x7F	; 127
    6466:	9e 83       	std	Y+6, r25	; 0x06
    6468:	8d 83       	std	Y+5, r24	; 0x05
    646a:	9e 01       	movw	r18, r28
    646c:	27 5e       	subi	r18, 0xE7	; 231
    646e:	3f 4f       	sbci	r19, 0xFF	; 255
    6470:	ce 01       	movw	r24, r28
    6472:	01 96       	adiw	r24, 0x01	; 1
    6474:	6f 89       	ldd	r22, Y+23	; 0x17
    6476:	78 8d       	ldd	r23, Y+24	; 0x18
    6478:	a9 01       	movw	r20, r18
    647a:	0e 94 49 32 	call	0x6492	; 0x6492 <vfprintf>
    647e:	2f 81       	ldd	r18, Y+7	; 0x07
    6480:	38 85       	ldd	r19, Y+8	; 0x08
    6482:	02 0f       	add	r16, r18
    6484:	13 1f       	adc	r17, r19
    6486:	f8 01       	movw	r30, r16
    6488:	10 82       	st	Z, r1
    648a:	2e 96       	adiw	r28, 0x0e	; 14
    648c:	e4 e0       	ldi	r30, 0x04	; 4
    648e:	0c 94 f9 31 	jmp	0x63f2	; 0x63f2 <__epilogue_restores__+0x1c>

00006492 <vfprintf>:
    6492:	ab e0       	ldi	r26, 0x0B	; 11
    6494:	b0 e0       	ldi	r27, 0x00	; 0
    6496:	ef e4       	ldi	r30, 0x4F	; 79
    6498:	f2 e3       	ldi	r31, 0x32	; 50
    649a:	0c 94 cf 31 	jmp	0x639e	; 0x639e <__prologue_saves__>
    649e:	3c 01       	movw	r6, r24
    64a0:	2b 01       	movw	r4, r22
    64a2:	5a 01       	movw	r10, r20
    64a4:	fc 01       	movw	r30, r24
    64a6:	17 82       	std	Z+7, r1	; 0x07
    64a8:	16 82       	std	Z+6, r1	; 0x06
    64aa:	83 81       	ldd	r24, Z+3	; 0x03
    64ac:	81 fd       	sbrc	r24, 1
    64ae:	03 c0       	rjmp	.+6      	; 0x64b6 <vfprintf+0x24>
    64b0:	6f ef       	ldi	r22, 0xFF	; 255
    64b2:	7f ef       	ldi	r23, 0xFF	; 255
    64b4:	c6 c1       	rjmp	.+908    	; 0x6842 <vfprintf+0x3b0>
    64b6:	9a e0       	ldi	r25, 0x0A	; 10
    64b8:	89 2e       	mov	r8, r25
    64ba:	1e 01       	movw	r2, r28
    64bc:	08 94       	sec
    64be:	21 1c       	adc	r2, r1
    64c0:	31 1c       	adc	r3, r1
    64c2:	f3 01       	movw	r30, r6
    64c4:	23 81       	ldd	r18, Z+3	; 0x03
    64c6:	f2 01       	movw	r30, r4
    64c8:	23 fd       	sbrc	r18, 3
    64ca:	85 91       	lpm	r24, Z+
    64cc:	23 ff       	sbrs	r18, 3
    64ce:	81 91       	ld	r24, Z+
    64d0:	2f 01       	movw	r4, r30
    64d2:	88 23       	and	r24, r24
    64d4:	09 f4       	brne	.+2      	; 0x64d8 <vfprintf+0x46>
    64d6:	b2 c1       	rjmp	.+868    	; 0x683c <vfprintf+0x3aa>
    64d8:	85 32       	cpi	r24, 0x25	; 37
    64da:	39 f4       	brne	.+14     	; 0x64ea <vfprintf+0x58>
    64dc:	23 fd       	sbrc	r18, 3
    64de:	85 91       	lpm	r24, Z+
    64e0:	23 ff       	sbrs	r18, 3
    64e2:	81 91       	ld	r24, Z+
    64e4:	2f 01       	movw	r4, r30
    64e6:	85 32       	cpi	r24, 0x25	; 37
    64e8:	29 f4       	brne	.+10     	; 0x64f4 <vfprintf+0x62>
    64ea:	90 e0       	ldi	r25, 0x00	; 0
    64ec:	b3 01       	movw	r22, r6
    64ee:	0e 94 3c 34 	call	0x6878	; 0x6878 <fputc>
    64f2:	e7 cf       	rjmp	.-50     	; 0x64c2 <vfprintf+0x30>
    64f4:	98 2f       	mov	r25, r24
    64f6:	ff 24       	eor	r15, r15
    64f8:	ee 24       	eor	r14, r14
    64fa:	99 24       	eor	r9, r9
    64fc:	ff e1       	ldi	r31, 0x1F	; 31
    64fe:	ff 15       	cp	r31, r15
    6500:	d0 f0       	brcs	.+52     	; 0x6536 <vfprintf+0xa4>
    6502:	9b 32       	cpi	r25, 0x2B	; 43
    6504:	69 f0       	breq	.+26     	; 0x6520 <vfprintf+0x8e>
    6506:	9c 32       	cpi	r25, 0x2C	; 44
    6508:	28 f4       	brcc	.+10     	; 0x6514 <vfprintf+0x82>
    650a:	90 32       	cpi	r25, 0x20	; 32
    650c:	59 f0       	breq	.+22     	; 0x6524 <vfprintf+0x92>
    650e:	93 32       	cpi	r25, 0x23	; 35
    6510:	91 f4       	brne	.+36     	; 0x6536 <vfprintf+0xa4>
    6512:	0e c0       	rjmp	.+28     	; 0x6530 <vfprintf+0x9e>
    6514:	9d 32       	cpi	r25, 0x2D	; 45
    6516:	49 f0       	breq	.+18     	; 0x652a <vfprintf+0x98>
    6518:	90 33       	cpi	r25, 0x30	; 48
    651a:	69 f4       	brne	.+26     	; 0x6536 <vfprintf+0xa4>
    651c:	41 e0       	ldi	r20, 0x01	; 1
    651e:	24 c0       	rjmp	.+72     	; 0x6568 <vfprintf+0xd6>
    6520:	52 e0       	ldi	r21, 0x02	; 2
    6522:	f5 2a       	or	r15, r21
    6524:	84 e0       	ldi	r24, 0x04	; 4
    6526:	f8 2a       	or	r15, r24
    6528:	28 c0       	rjmp	.+80     	; 0x657a <vfprintf+0xe8>
    652a:	98 e0       	ldi	r25, 0x08	; 8
    652c:	f9 2a       	or	r15, r25
    652e:	25 c0       	rjmp	.+74     	; 0x657a <vfprintf+0xe8>
    6530:	e0 e1       	ldi	r30, 0x10	; 16
    6532:	fe 2a       	or	r15, r30
    6534:	22 c0       	rjmp	.+68     	; 0x657a <vfprintf+0xe8>
    6536:	f7 fc       	sbrc	r15, 7
    6538:	29 c0       	rjmp	.+82     	; 0x658c <vfprintf+0xfa>
    653a:	89 2f       	mov	r24, r25
    653c:	80 53       	subi	r24, 0x30	; 48
    653e:	8a 30       	cpi	r24, 0x0A	; 10
    6540:	70 f4       	brcc	.+28     	; 0x655e <vfprintf+0xcc>
    6542:	f6 fe       	sbrs	r15, 6
    6544:	05 c0       	rjmp	.+10     	; 0x6550 <vfprintf+0xbe>
    6546:	98 9c       	mul	r9, r8
    6548:	90 2c       	mov	r9, r0
    654a:	11 24       	eor	r1, r1
    654c:	98 0e       	add	r9, r24
    654e:	15 c0       	rjmp	.+42     	; 0x657a <vfprintf+0xe8>
    6550:	e8 9c       	mul	r14, r8
    6552:	e0 2c       	mov	r14, r0
    6554:	11 24       	eor	r1, r1
    6556:	e8 0e       	add	r14, r24
    6558:	f0 e2       	ldi	r31, 0x20	; 32
    655a:	ff 2a       	or	r15, r31
    655c:	0e c0       	rjmp	.+28     	; 0x657a <vfprintf+0xe8>
    655e:	9e 32       	cpi	r25, 0x2E	; 46
    6560:	29 f4       	brne	.+10     	; 0x656c <vfprintf+0xda>
    6562:	f6 fc       	sbrc	r15, 6
    6564:	6b c1       	rjmp	.+726    	; 0x683c <vfprintf+0x3aa>
    6566:	40 e4       	ldi	r20, 0x40	; 64
    6568:	f4 2a       	or	r15, r20
    656a:	07 c0       	rjmp	.+14     	; 0x657a <vfprintf+0xe8>
    656c:	9c 36       	cpi	r25, 0x6C	; 108
    656e:	19 f4       	brne	.+6      	; 0x6576 <vfprintf+0xe4>
    6570:	50 e8       	ldi	r21, 0x80	; 128
    6572:	f5 2a       	or	r15, r21
    6574:	02 c0       	rjmp	.+4      	; 0x657a <vfprintf+0xe8>
    6576:	98 36       	cpi	r25, 0x68	; 104
    6578:	49 f4       	brne	.+18     	; 0x658c <vfprintf+0xfa>
    657a:	f2 01       	movw	r30, r4
    657c:	23 fd       	sbrc	r18, 3
    657e:	95 91       	lpm	r25, Z+
    6580:	23 ff       	sbrs	r18, 3
    6582:	91 91       	ld	r25, Z+
    6584:	2f 01       	movw	r4, r30
    6586:	99 23       	and	r25, r25
    6588:	09 f0       	breq	.+2      	; 0x658c <vfprintf+0xfa>
    658a:	b8 cf       	rjmp	.-144    	; 0x64fc <vfprintf+0x6a>
    658c:	89 2f       	mov	r24, r25
    658e:	85 54       	subi	r24, 0x45	; 69
    6590:	83 30       	cpi	r24, 0x03	; 3
    6592:	18 f0       	brcs	.+6      	; 0x659a <vfprintf+0x108>
    6594:	80 52       	subi	r24, 0x20	; 32
    6596:	83 30       	cpi	r24, 0x03	; 3
    6598:	38 f4       	brcc	.+14     	; 0x65a8 <vfprintf+0x116>
    659a:	44 e0       	ldi	r20, 0x04	; 4
    659c:	50 e0       	ldi	r21, 0x00	; 0
    659e:	a4 0e       	add	r10, r20
    65a0:	b5 1e       	adc	r11, r21
    65a2:	5f e3       	ldi	r21, 0x3F	; 63
    65a4:	59 83       	std	Y+1, r21	; 0x01
    65a6:	0f c0       	rjmp	.+30     	; 0x65c6 <vfprintf+0x134>
    65a8:	93 36       	cpi	r25, 0x63	; 99
    65aa:	31 f0       	breq	.+12     	; 0x65b8 <vfprintf+0x126>
    65ac:	93 37       	cpi	r25, 0x73	; 115
    65ae:	79 f0       	breq	.+30     	; 0x65ce <vfprintf+0x13c>
    65b0:	93 35       	cpi	r25, 0x53	; 83
    65b2:	09 f0       	breq	.+2      	; 0x65b6 <vfprintf+0x124>
    65b4:	56 c0       	rjmp	.+172    	; 0x6662 <vfprintf+0x1d0>
    65b6:	20 c0       	rjmp	.+64     	; 0x65f8 <vfprintf+0x166>
    65b8:	f5 01       	movw	r30, r10
    65ba:	80 81       	ld	r24, Z
    65bc:	89 83       	std	Y+1, r24	; 0x01
    65be:	42 e0       	ldi	r20, 0x02	; 2
    65c0:	50 e0       	ldi	r21, 0x00	; 0
    65c2:	a4 0e       	add	r10, r20
    65c4:	b5 1e       	adc	r11, r21
    65c6:	61 01       	movw	r12, r2
    65c8:	01 e0       	ldi	r16, 0x01	; 1
    65ca:	10 e0       	ldi	r17, 0x00	; 0
    65cc:	12 c0       	rjmp	.+36     	; 0x65f2 <vfprintf+0x160>
    65ce:	f5 01       	movw	r30, r10
    65d0:	c0 80       	ld	r12, Z
    65d2:	d1 80       	ldd	r13, Z+1	; 0x01
    65d4:	f6 fc       	sbrc	r15, 6
    65d6:	03 c0       	rjmp	.+6      	; 0x65de <vfprintf+0x14c>
    65d8:	6f ef       	ldi	r22, 0xFF	; 255
    65da:	7f ef       	ldi	r23, 0xFF	; 255
    65dc:	02 c0       	rjmp	.+4      	; 0x65e2 <vfprintf+0x150>
    65de:	69 2d       	mov	r22, r9
    65e0:	70 e0       	ldi	r23, 0x00	; 0
    65e2:	42 e0       	ldi	r20, 0x02	; 2
    65e4:	50 e0       	ldi	r21, 0x00	; 0
    65e6:	a4 0e       	add	r10, r20
    65e8:	b5 1e       	adc	r11, r21
    65ea:	c6 01       	movw	r24, r12
    65ec:	0e 94 31 34 	call	0x6862	; 0x6862 <strnlen>
    65f0:	8c 01       	movw	r16, r24
    65f2:	5f e7       	ldi	r21, 0x7F	; 127
    65f4:	f5 22       	and	r15, r21
    65f6:	14 c0       	rjmp	.+40     	; 0x6620 <vfprintf+0x18e>
    65f8:	f5 01       	movw	r30, r10
    65fa:	c0 80       	ld	r12, Z
    65fc:	d1 80       	ldd	r13, Z+1	; 0x01
    65fe:	f6 fc       	sbrc	r15, 6
    6600:	03 c0       	rjmp	.+6      	; 0x6608 <vfprintf+0x176>
    6602:	6f ef       	ldi	r22, 0xFF	; 255
    6604:	7f ef       	ldi	r23, 0xFF	; 255
    6606:	02 c0       	rjmp	.+4      	; 0x660c <vfprintf+0x17a>
    6608:	69 2d       	mov	r22, r9
    660a:	70 e0       	ldi	r23, 0x00	; 0
    660c:	42 e0       	ldi	r20, 0x02	; 2
    660e:	50 e0       	ldi	r21, 0x00	; 0
    6610:	a4 0e       	add	r10, r20
    6612:	b5 1e       	adc	r11, r21
    6614:	c6 01       	movw	r24, r12
    6616:	0e 94 26 34 	call	0x684c	; 0x684c <strnlen_P>
    661a:	8c 01       	movw	r16, r24
    661c:	50 e8       	ldi	r21, 0x80	; 128
    661e:	f5 2a       	or	r15, r21
    6620:	f3 fe       	sbrs	r15, 3
    6622:	07 c0       	rjmp	.+14     	; 0x6632 <vfprintf+0x1a0>
    6624:	1a c0       	rjmp	.+52     	; 0x665a <vfprintf+0x1c8>
    6626:	80 e2       	ldi	r24, 0x20	; 32
    6628:	90 e0       	ldi	r25, 0x00	; 0
    662a:	b3 01       	movw	r22, r6
    662c:	0e 94 3c 34 	call	0x6878	; 0x6878 <fputc>
    6630:	ea 94       	dec	r14
    6632:	8e 2d       	mov	r24, r14
    6634:	90 e0       	ldi	r25, 0x00	; 0
    6636:	08 17       	cp	r16, r24
    6638:	19 07       	cpc	r17, r25
    663a:	a8 f3       	brcs	.-22     	; 0x6626 <vfprintf+0x194>
    663c:	0e c0       	rjmp	.+28     	; 0x665a <vfprintf+0x1c8>
    663e:	f6 01       	movw	r30, r12
    6640:	f7 fc       	sbrc	r15, 7
    6642:	85 91       	lpm	r24, Z+
    6644:	f7 fe       	sbrs	r15, 7
    6646:	81 91       	ld	r24, Z+
    6648:	6f 01       	movw	r12, r30
    664a:	90 e0       	ldi	r25, 0x00	; 0
    664c:	b3 01       	movw	r22, r6
    664e:	0e 94 3c 34 	call	0x6878	; 0x6878 <fputc>
    6652:	e1 10       	cpse	r14, r1
    6654:	ea 94       	dec	r14
    6656:	01 50       	subi	r16, 0x01	; 1
    6658:	10 40       	sbci	r17, 0x00	; 0
    665a:	01 15       	cp	r16, r1
    665c:	11 05       	cpc	r17, r1
    665e:	79 f7       	brne	.-34     	; 0x663e <vfprintf+0x1ac>
    6660:	ea c0       	rjmp	.+468    	; 0x6836 <vfprintf+0x3a4>
    6662:	94 36       	cpi	r25, 0x64	; 100
    6664:	11 f0       	breq	.+4      	; 0x666a <vfprintf+0x1d8>
    6666:	99 36       	cpi	r25, 0x69	; 105
    6668:	69 f5       	brne	.+90     	; 0x66c4 <vfprintf+0x232>
    666a:	f7 fe       	sbrs	r15, 7
    666c:	08 c0       	rjmp	.+16     	; 0x667e <vfprintf+0x1ec>
    666e:	f5 01       	movw	r30, r10
    6670:	20 81       	ld	r18, Z
    6672:	31 81       	ldd	r19, Z+1	; 0x01
    6674:	42 81       	ldd	r20, Z+2	; 0x02
    6676:	53 81       	ldd	r21, Z+3	; 0x03
    6678:	84 e0       	ldi	r24, 0x04	; 4
    667a:	90 e0       	ldi	r25, 0x00	; 0
    667c:	0a c0       	rjmp	.+20     	; 0x6692 <vfprintf+0x200>
    667e:	f5 01       	movw	r30, r10
    6680:	80 81       	ld	r24, Z
    6682:	91 81       	ldd	r25, Z+1	; 0x01
    6684:	9c 01       	movw	r18, r24
    6686:	44 27       	eor	r20, r20
    6688:	37 fd       	sbrc	r19, 7
    668a:	40 95       	com	r20
    668c:	54 2f       	mov	r21, r20
    668e:	82 e0       	ldi	r24, 0x02	; 2
    6690:	90 e0       	ldi	r25, 0x00	; 0
    6692:	a8 0e       	add	r10, r24
    6694:	b9 1e       	adc	r11, r25
    6696:	9f e6       	ldi	r25, 0x6F	; 111
    6698:	f9 22       	and	r15, r25
    669a:	57 ff       	sbrs	r21, 7
    669c:	09 c0       	rjmp	.+18     	; 0x66b0 <vfprintf+0x21e>
    669e:	50 95       	com	r21
    66a0:	40 95       	com	r20
    66a2:	30 95       	com	r19
    66a4:	21 95       	neg	r18
    66a6:	3f 4f       	sbci	r19, 0xFF	; 255
    66a8:	4f 4f       	sbci	r20, 0xFF	; 255
    66aa:	5f 4f       	sbci	r21, 0xFF	; 255
    66ac:	e0 e8       	ldi	r30, 0x80	; 128
    66ae:	fe 2a       	or	r15, r30
    66b0:	ca 01       	movw	r24, r20
    66b2:	b9 01       	movw	r22, r18
    66b4:	a1 01       	movw	r20, r2
    66b6:	2a e0       	ldi	r18, 0x0A	; 10
    66b8:	30 e0       	ldi	r19, 0x00	; 0
    66ba:	0e 94 68 34 	call	0x68d0	; 0x68d0 <__ultoa_invert>
    66be:	d8 2e       	mov	r13, r24
    66c0:	d2 18       	sub	r13, r2
    66c2:	40 c0       	rjmp	.+128    	; 0x6744 <vfprintf+0x2b2>
    66c4:	95 37       	cpi	r25, 0x75	; 117
    66c6:	29 f4       	brne	.+10     	; 0x66d2 <vfprintf+0x240>
    66c8:	1f 2d       	mov	r17, r15
    66ca:	1f 7e       	andi	r17, 0xEF	; 239
    66cc:	2a e0       	ldi	r18, 0x0A	; 10
    66ce:	30 e0       	ldi	r19, 0x00	; 0
    66d0:	1d c0       	rjmp	.+58     	; 0x670c <vfprintf+0x27a>
    66d2:	1f 2d       	mov	r17, r15
    66d4:	19 7f       	andi	r17, 0xF9	; 249
    66d6:	9f 36       	cpi	r25, 0x6F	; 111
    66d8:	61 f0       	breq	.+24     	; 0x66f2 <vfprintf+0x260>
    66da:	90 37       	cpi	r25, 0x70	; 112
    66dc:	20 f4       	brcc	.+8      	; 0x66e6 <vfprintf+0x254>
    66de:	98 35       	cpi	r25, 0x58	; 88
    66e0:	09 f0       	breq	.+2      	; 0x66e4 <vfprintf+0x252>
    66e2:	ac c0       	rjmp	.+344    	; 0x683c <vfprintf+0x3aa>
    66e4:	0f c0       	rjmp	.+30     	; 0x6704 <vfprintf+0x272>
    66e6:	90 37       	cpi	r25, 0x70	; 112
    66e8:	39 f0       	breq	.+14     	; 0x66f8 <vfprintf+0x266>
    66ea:	98 37       	cpi	r25, 0x78	; 120
    66ec:	09 f0       	breq	.+2      	; 0x66f0 <vfprintf+0x25e>
    66ee:	a6 c0       	rjmp	.+332    	; 0x683c <vfprintf+0x3aa>
    66f0:	04 c0       	rjmp	.+8      	; 0x66fa <vfprintf+0x268>
    66f2:	28 e0       	ldi	r18, 0x08	; 8
    66f4:	30 e0       	ldi	r19, 0x00	; 0
    66f6:	0a c0       	rjmp	.+20     	; 0x670c <vfprintf+0x27a>
    66f8:	10 61       	ori	r17, 0x10	; 16
    66fa:	14 fd       	sbrc	r17, 4
    66fc:	14 60       	ori	r17, 0x04	; 4
    66fe:	20 e1       	ldi	r18, 0x10	; 16
    6700:	30 e0       	ldi	r19, 0x00	; 0
    6702:	04 c0       	rjmp	.+8      	; 0x670c <vfprintf+0x27a>
    6704:	14 fd       	sbrc	r17, 4
    6706:	16 60       	ori	r17, 0x06	; 6
    6708:	20 e1       	ldi	r18, 0x10	; 16
    670a:	32 e0       	ldi	r19, 0x02	; 2
    670c:	17 ff       	sbrs	r17, 7
    670e:	08 c0       	rjmp	.+16     	; 0x6720 <vfprintf+0x28e>
    6710:	f5 01       	movw	r30, r10
    6712:	60 81       	ld	r22, Z
    6714:	71 81       	ldd	r23, Z+1	; 0x01
    6716:	82 81       	ldd	r24, Z+2	; 0x02
    6718:	93 81       	ldd	r25, Z+3	; 0x03
    671a:	44 e0       	ldi	r20, 0x04	; 4
    671c:	50 e0       	ldi	r21, 0x00	; 0
    671e:	08 c0       	rjmp	.+16     	; 0x6730 <vfprintf+0x29e>
    6720:	f5 01       	movw	r30, r10
    6722:	80 81       	ld	r24, Z
    6724:	91 81       	ldd	r25, Z+1	; 0x01
    6726:	bc 01       	movw	r22, r24
    6728:	80 e0       	ldi	r24, 0x00	; 0
    672a:	90 e0       	ldi	r25, 0x00	; 0
    672c:	42 e0       	ldi	r20, 0x02	; 2
    672e:	50 e0       	ldi	r21, 0x00	; 0
    6730:	a4 0e       	add	r10, r20
    6732:	b5 1e       	adc	r11, r21
    6734:	a1 01       	movw	r20, r2
    6736:	0e 94 68 34 	call	0x68d0	; 0x68d0 <__ultoa_invert>
    673a:	d8 2e       	mov	r13, r24
    673c:	d2 18       	sub	r13, r2
    673e:	8f e7       	ldi	r24, 0x7F	; 127
    6740:	f8 2e       	mov	r15, r24
    6742:	f1 22       	and	r15, r17
    6744:	f6 fe       	sbrs	r15, 6
    6746:	0b c0       	rjmp	.+22     	; 0x675e <vfprintf+0x2cc>
    6748:	5e ef       	ldi	r21, 0xFE	; 254
    674a:	f5 22       	and	r15, r21
    674c:	d9 14       	cp	r13, r9
    674e:	38 f4       	brcc	.+14     	; 0x675e <vfprintf+0x2cc>
    6750:	f4 fe       	sbrs	r15, 4
    6752:	07 c0       	rjmp	.+14     	; 0x6762 <vfprintf+0x2d0>
    6754:	f2 fc       	sbrc	r15, 2
    6756:	05 c0       	rjmp	.+10     	; 0x6762 <vfprintf+0x2d0>
    6758:	8f ee       	ldi	r24, 0xEF	; 239
    675a:	f8 22       	and	r15, r24
    675c:	02 c0       	rjmp	.+4      	; 0x6762 <vfprintf+0x2d0>
    675e:	1d 2d       	mov	r17, r13
    6760:	01 c0       	rjmp	.+2      	; 0x6764 <vfprintf+0x2d2>
    6762:	19 2d       	mov	r17, r9
    6764:	f4 fe       	sbrs	r15, 4
    6766:	0d c0       	rjmp	.+26     	; 0x6782 <vfprintf+0x2f0>
    6768:	fe 01       	movw	r30, r28
    676a:	ed 0d       	add	r30, r13
    676c:	f1 1d       	adc	r31, r1
    676e:	80 81       	ld	r24, Z
    6770:	80 33       	cpi	r24, 0x30	; 48
    6772:	19 f4       	brne	.+6      	; 0x677a <vfprintf+0x2e8>
    6774:	99 ee       	ldi	r25, 0xE9	; 233
    6776:	f9 22       	and	r15, r25
    6778:	08 c0       	rjmp	.+16     	; 0x678a <vfprintf+0x2f8>
    677a:	1f 5f       	subi	r17, 0xFF	; 255
    677c:	f2 fe       	sbrs	r15, 2
    677e:	05 c0       	rjmp	.+10     	; 0x678a <vfprintf+0x2f8>
    6780:	03 c0       	rjmp	.+6      	; 0x6788 <vfprintf+0x2f6>
    6782:	8f 2d       	mov	r24, r15
    6784:	86 78       	andi	r24, 0x86	; 134
    6786:	09 f0       	breq	.+2      	; 0x678a <vfprintf+0x2f8>
    6788:	1f 5f       	subi	r17, 0xFF	; 255
    678a:	0f 2d       	mov	r16, r15
    678c:	f3 fc       	sbrc	r15, 3
    678e:	14 c0       	rjmp	.+40     	; 0x67b8 <vfprintf+0x326>
    6790:	f0 fe       	sbrs	r15, 0
    6792:	0f c0       	rjmp	.+30     	; 0x67b2 <vfprintf+0x320>
    6794:	1e 15       	cp	r17, r14
    6796:	10 f0       	brcs	.+4      	; 0x679c <vfprintf+0x30a>
    6798:	9d 2c       	mov	r9, r13
    679a:	0b c0       	rjmp	.+22     	; 0x67b2 <vfprintf+0x320>
    679c:	9d 2c       	mov	r9, r13
    679e:	9e 0c       	add	r9, r14
    67a0:	91 1a       	sub	r9, r17
    67a2:	1e 2d       	mov	r17, r14
    67a4:	06 c0       	rjmp	.+12     	; 0x67b2 <vfprintf+0x320>
    67a6:	80 e2       	ldi	r24, 0x20	; 32
    67a8:	90 e0       	ldi	r25, 0x00	; 0
    67aa:	b3 01       	movw	r22, r6
    67ac:	0e 94 3c 34 	call	0x6878	; 0x6878 <fputc>
    67b0:	1f 5f       	subi	r17, 0xFF	; 255
    67b2:	1e 15       	cp	r17, r14
    67b4:	c0 f3       	brcs	.-16     	; 0x67a6 <vfprintf+0x314>
    67b6:	04 c0       	rjmp	.+8      	; 0x67c0 <vfprintf+0x32e>
    67b8:	1e 15       	cp	r17, r14
    67ba:	10 f4       	brcc	.+4      	; 0x67c0 <vfprintf+0x32e>
    67bc:	e1 1a       	sub	r14, r17
    67be:	01 c0       	rjmp	.+2      	; 0x67c2 <vfprintf+0x330>
    67c0:	ee 24       	eor	r14, r14
    67c2:	04 ff       	sbrs	r16, 4
    67c4:	0f c0       	rjmp	.+30     	; 0x67e4 <vfprintf+0x352>
    67c6:	80 e3       	ldi	r24, 0x30	; 48
    67c8:	90 e0       	ldi	r25, 0x00	; 0
    67ca:	b3 01       	movw	r22, r6
    67cc:	0e 94 3c 34 	call	0x6878	; 0x6878 <fputc>
    67d0:	02 ff       	sbrs	r16, 2
    67d2:	1d c0       	rjmp	.+58     	; 0x680e <vfprintf+0x37c>
    67d4:	01 fd       	sbrc	r16, 1
    67d6:	03 c0       	rjmp	.+6      	; 0x67de <vfprintf+0x34c>
    67d8:	88 e7       	ldi	r24, 0x78	; 120
    67da:	90 e0       	ldi	r25, 0x00	; 0
    67dc:	0e c0       	rjmp	.+28     	; 0x67fa <vfprintf+0x368>
    67de:	88 e5       	ldi	r24, 0x58	; 88
    67e0:	90 e0       	ldi	r25, 0x00	; 0
    67e2:	0b c0       	rjmp	.+22     	; 0x67fa <vfprintf+0x368>
    67e4:	80 2f       	mov	r24, r16
    67e6:	86 78       	andi	r24, 0x86	; 134
    67e8:	91 f0       	breq	.+36     	; 0x680e <vfprintf+0x37c>
    67ea:	01 ff       	sbrs	r16, 1
    67ec:	02 c0       	rjmp	.+4      	; 0x67f2 <vfprintf+0x360>
    67ee:	8b e2       	ldi	r24, 0x2B	; 43
    67f0:	01 c0       	rjmp	.+2      	; 0x67f4 <vfprintf+0x362>
    67f2:	80 e2       	ldi	r24, 0x20	; 32
    67f4:	f7 fc       	sbrc	r15, 7
    67f6:	8d e2       	ldi	r24, 0x2D	; 45
    67f8:	90 e0       	ldi	r25, 0x00	; 0
    67fa:	b3 01       	movw	r22, r6
    67fc:	0e 94 3c 34 	call	0x6878	; 0x6878 <fputc>
    6800:	06 c0       	rjmp	.+12     	; 0x680e <vfprintf+0x37c>
    6802:	80 e3       	ldi	r24, 0x30	; 48
    6804:	90 e0       	ldi	r25, 0x00	; 0
    6806:	b3 01       	movw	r22, r6
    6808:	0e 94 3c 34 	call	0x6878	; 0x6878 <fputc>
    680c:	9a 94       	dec	r9
    680e:	d9 14       	cp	r13, r9
    6810:	c0 f3       	brcs	.-16     	; 0x6802 <vfprintf+0x370>
    6812:	da 94       	dec	r13
    6814:	f1 01       	movw	r30, r2
    6816:	ed 0d       	add	r30, r13
    6818:	f1 1d       	adc	r31, r1
    681a:	80 81       	ld	r24, Z
    681c:	90 e0       	ldi	r25, 0x00	; 0
    681e:	b3 01       	movw	r22, r6
    6820:	0e 94 3c 34 	call	0x6878	; 0x6878 <fputc>
    6824:	dd 20       	and	r13, r13
    6826:	a9 f7       	brne	.-22     	; 0x6812 <vfprintf+0x380>
    6828:	06 c0       	rjmp	.+12     	; 0x6836 <vfprintf+0x3a4>
    682a:	80 e2       	ldi	r24, 0x20	; 32
    682c:	90 e0       	ldi	r25, 0x00	; 0
    682e:	b3 01       	movw	r22, r6
    6830:	0e 94 3c 34 	call	0x6878	; 0x6878 <fputc>
    6834:	ea 94       	dec	r14
    6836:	ee 20       	and	r14, r14
    6838:	c1 f7       	brne	.-16     	; 0x682a <vfprintf+0x398>
    683a:	43 ce       	rjmp	.-890    	; 0x64c2 <vfprintf+0x30>
    683c:	f3 01       	movw	r30, r6
    683e:	66 81       	ldd	r22, Z+6	; 0x06
    6840:	77 81       	ldd	r23, Z+7	; 0x07
    6842:	cb 01       	movw	r24, r22
    6844:	2b 96       	adiw	r28, 0x0b	; 11
    6846:	e2 e1       	ldi	r30, 0x12	; 18
    6848:	0c 94 eb 31 	jmp	0x63d6	; 0x63d6 <__epilogue_restores__>

0000684c <strnlen_P>:
    684c:	fc 01       	movw	r30, r24
    684e:	05 90       	lpm	r0, Z+
    6850:	61 50       	subi	r22, 0x01	; 1
    6852:	70 40       	sbci	r23, 0x00	; 0
    6854:	01 10       	cpse	r0, r1
    6856:	d8 f7       	brcc	.-10     	; 0x684e <strnlen_P+0x2>
    6858:	80 95       	com	r24
    685a:	90 95       	com	r25
    685c:	8e 0f       	add	r24, r30
    685e:	9f 1f       	adc	r25, r31
    6860:	08 95       	ret

00006862 <strnlen>:
    6862:	fc 01       	movw	r30, r24
    6864:	61 50       	subi	r22, 0x01	; 1
    6866:	70 40       	sbci	r23, 0x00	; 0
    6868:	01 90       	ld	r0, Z+
    686a:	01 10       	cpse	r0, r1
    686c:	d8 f7       	brcc	.-10     	; 0x6864 <strnlen+0x2>
    686e:	80 95       	com	r24
    6870:	90 95       	com	r25
    6872:	8e 0f       	add	r24, r30
    6874:	9f 1f       	adc	r25, r31
    6876:	08 95       	ret

00006878 <fputc>:
    6878:	0f 93       	push	r16
    687a:	1f 93       	push	r17
    687c:	cf 93       	push	r28
    687e:	df 93       	push	r29
    6880:	8c 01       	movw	r16, r24
    6882:	eb 01       	movw	r28, r22
    6884:	8b 81       	ldd	r24, Y+3	; 0x03
    6886:	81 ff       	sbrs	r24, 1
    6888:	1b c0       	rjmp	.+54     	; 0x68c0 <fputc+0x48>
    688a:	82 ff       	sbrs	r24, 2
    688c:	0d c0       	rjmp	.+26     	; 0x68a8 <fputc+0x30>
    688e:	2e 81       	ldd	r18, Y+6	; 0x06
    6890:	3f 81       	ldd	r19, Y+7	; 0x07
    6892:	8c 81       	ldd	r24, Y+4	; 0x04
    6894:	9d 81       	ldd	r25, Y+5	; 0x05
    6896:	28 17       	cp	r18, r24
    6898:	39 07       	cpc	r19, r25
    689a:	64 f4       	brge	.+24     	; 0x68b4 <fputc+0x3c>
    689c:	e8 81       	ld	r30, Y
    689e:	f9 81       	ldd	r31, Y+1	; 0x01
    68a0:	01 93       	st	Z+, r16
    68a2:	f9 83       	std	Y+1, r31	; 0x01
    68a4:	e8 83       	st	Y, r30
    68a6:	06 c0       	rjmp	.+12     	; 0x68b4 <fputc+0x3c>
    68a8:	e8 85       	ldd	r30, Y+8	; 0x08
    68aa:	f9 85       	ldd	r31, Y+9	; 0x09
    68ac:	80 2f       	mov	r24, r16
    68ae:	09 95       	icall
    68b0:	89 2b       	or	r24, r25
    68b2:	31 f4       	brne	.+12     	; 0x68c0 <fputc+0x48>
    68b4:	8e 81       	ldd	r24, Y+6	; 0x06
    68b6:	9f 81       	ldd	r25, Y+7	; 0x07
    68b8:	01 96       	adiw	r24, 0x01	; 1
    68ba:	9f 83       	std	Y+7, r25	; 0x07
    68bc:	8e 83       	std	Y+6, r24	; 0x06
    68be:	02 c0       	rjmp	.+4      	; 0x68c4 <fputc+0x4c>
    68c0:	0f ef       	ldi	r16, 0xFF	; 255
    68c2:	1f ef       	ldi	r17, 0xFF	; 255
    68c4:	c8 01       	movw	r24, r16
    68c6:	df 91       	pop	r29
    68c8:	cf 91       	pop	r28
    68ca:	1f 91       	pop	r17
    68cc:	0f 91       	pop	r16
    68ce:	08 95       	ret

000068d0 <__ultoa_invert>:
    68d0:	fa 01       	movw	r30, r20
    68d2:	aa 27       	eor	r26, r26
    68d4:	28 30       	cpi	r18, 0x08	; 8
    68d6:	51 f1       	breq	.+84     	; 0x692c <__ultoa_invert+0x5c>
    68d8:	20 31       	cpi	r18, 0x10	; 16
    68da:	81 f1       	breq	.+96     	; 0x693c <__ultoa_invert+0x6c>
    68dc:	e8 94       	clt
    68de:	6f 93       	push	r22
    68e0:	6e 7f       	andi	r22, 0xFE	; 254
    68e2:	6e 5f       	subi	r22, 0xFE	; 254
    68e4:	7f 4f       	sbci	r23, 0xFF	; 255
    68e6:	8f 4f       	sbci	r24, 0xFF	; 255
    68e8:	9f 4f       	sbci	r25, 0xFF	; 255
    68ea:	af 4f       	sbci	r26, 0xFF	; 255
    68ec:	b1 e0       	ldi	r27, 0x01	; 1
    68ee:	3e d0       	rcall	.+124    	; 0x696c <__ultoa_invert+0x9c>
    68f0:	b4 e0       	ldi	r27, 0x04	; 4
    68f2:	3c d0       	rcall	.+120    	; 0x696c <__ultoa_invert+0x9c>
    68f4:	67 0f       	add	r22, r23
    68f6:	78 1f       	adc	r23, r24
    68f8:	89 1f       	adc	r24, r25
    68fa:	9a 1f       	adc	r25, r26
    68fc:	a1 1d       	adc	r26, r1
    68fe:	68 0f       	add	r22, r24
    6900:	79 1f       	adc	r23, r25
    6902:	8a 1f       	adc	r24, r26
    6904:	91 1d       	adc	r25, r1
    6906:	a1 1d       	adc	r26, r1
    6908:	6a 0f       	add	r22, r26
    690a:	71 1d       	adc	r23, r1
    690c:	81 1d       	adc	r24, r1
    690e:	91 1d       	adc	r25, r1
    6910:	a1 1d       	adc	r26, r1
    6912:	20 d0       	rcall	.+64     	; 0x6954 <__ultoa_invert+0x84>
    6914:	09 f4       	brne	.+2      	; 0x6918 <__ultoa_invert+0x48>
    6916:	68 94       	set
    6918:	3f 91       	pop	r19
    691a:	2a e0       	ldi	r18, 0x0A	; 10
    691c:	26 9f       	mul	r18, r22
    691e:	11 24       	eor	r1, r1
    6920:	30 19       	sub	r19, r0
    6922:	30 5d       	subi	r19, 0xD0	; 208
    6924:	31 93       	st	Z+, r19
    6926:	de f6       	brtc	.-74     	; 0x68de <__ultoa_invert+0xe>
    6928:	cf 01       	movw	r24, r30
    692a:	08 95       	ret
    692c:	46 2f       	mov	r20, r22
    692e:	47 70       	andi	r20, 0x07	; 7
    6930:	40 5d       	subi	r20, 0xD0	; 208
    6932:	41 93       	st	Z+, r20
    6934:	b3 e0       	ldi	r27, 0x03	; 3
    6936:	0f d0       	rcall	.+30     	; 0x6956 <__ultoa_invert+0x86>
    6938:	c9 f7       	brne	.-14     	; 0x692c <__ultoa_invert+0x5c>
    693a:	f6 cf       	rjmp	.-20     	; 0x6928 <__ultoa_invert+0x58>
    693c:	46 2f       	mov	r20, r22
    693e:	4f 70       	andi	r20, 0x0F	; 15
    6940:	40 5d       	subi	r20, 0xD0	; 208
    6942:	4a 33       	cpi	r20, 0x3A	; 58
    6944:	18 f0       	brcs	.+6      	; 0x694c <__ultoa_invert+0x7c>
    6946:	49 5d       	subi	r20, 0xD9	; 217
    6948:	31 fd       	sbrc	r19, 1
    694a:	40 52       	subi	r20, 0x20	; 32
    694c:	41 93       	st	Z+, r20
    694e:	02 d0       	rcall	.+4      	; 0x6954 <__ultoa_invert+0x84>
    6950:	a9 f7       	brne	.-22     	; 0x693c <__ultoa_invert+0x6c>
    6952:	ea cf       	rjmp	.-44     	; 0x6928 <__ultoa_invert+0x58>
    6954:	b4 e0       	ldi	r27, 0x04	; 4
    6956:	a6 95       	lsr	r26
    6958:	97 95       	ror	r25
    695a:	87 95       	ror	r24
    695c:	77 95       	ror	r23
    695e:	67 95       	ror	r22
    6960:	ba 95       	dec	r27
    6962:	c9 f7       	brne	.-14     	; 0x6956 <__ultoa_invert+0x86>
    6964:	00 97       	sbiw	r24, 0x00	; 0
    6966:	61 05       	cpc	r22, r1
    6968:	71 05       	cpc	r23, r1
    696a:	08 95       	ret
    696c:	9b 01       	movw	r18, r22
    696e:	ac 01       	movw	r20, r24
    6970:	0a 2e       	mov	r0, r26
    6972:	06 94       	lsr	r0
    6974:	57 95       	ror	r21
    6976:	47 95       	ror	r20
    6978:	37 95       	ror	r19
    697a:	27 95       	ror	r18
    697c:	ba 95       	dec	r27
    697e:	c9 f7       	brne	.-14     	; 0x6972 <__ultoa_invert+0xa2>
    6980:	62 0f       	add	r22, r18
    6982:	73 1f       	adc	r23, r19
    6984:	84 1f       	adc	r24, r20
    6986:	95 1f       	adc	r25, r21
    6988:	a0 1d       	adc	r26, r0
    698a:	08 95       	ret

0000698c <_exit>:
    698c:	f8 94       	cli

0000698e <__stop_program>:
    698e:	ff cf       	rjmp	.-2      	; 0x698e <__stop_program>
